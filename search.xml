<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DokuWiKi</title>
      <link href="/2019/03/12/Dokuwiki/"/>
      <url>/2019/03/12/Dokuwiki/</url>
      
        <content type="html"><![CDATA[<h2 id="DokuWIKI"><a href="#DokuWIKI" class="headerlink" title="DokuWIKI"></a>DokuWIKI</h2><pre><code>DokuWIKI是一个用途多样的开源WIKI软件，并且不需要数据库。</code></pre><h3 id="一、DokuWIKI配置文件"><a href="#一、DokuWIKI配置文件" class="headerlink" title="一、DokuWIKI配置文件"></a>一、DokuWIKI配置文件</h3><pre><code>acl.auth.php.dist acl.auth.php的默认发布acronyms.conf  用于定义首字母缩写词dokuwiki.php  DokuWiKi主配置文件entities.conf    用于定义实体字符interwiki.conf    用于定义interwiki，以便使用简单方式书写URLlocal.php.dist    local.php的默认发布mediameta.php    定义media manager的metadata配置mime.conf    定义mimetypes配置文件msg    一个标志文件，用于判断当前版本是否为最新mysql.conf.php.example    mysql.conf.php默认发布smileys.conf 用于定义笑脸配置文件user.auth.php.dist users.auth.php的默认文件wordblock.conf  用于配置不允许书写URLwords.aspell.dist 拼写检查配置文件</code></pre><h3 id="二、DokuWIKI安装"><a href="#二、DokuWIKI安装" class="headerlink" title="二、DokuWIKI安装"></a>二、DokuWIKI安装</h3><blockquote><p>解压dokuwiki</p></blockquote><p><code>~]# tar xf dokuwiki-8a269cc015a64b40e4c918699f1e1142.tgz</code></p><p><code>chown -R nginx.nginx .</code>    #修改权限</p><blockquote><p>nginx 配置</p></blockquote><pre><code>server {    listen 80;    server_name www.testdokuwiki.com;    root /data/dokuwiki;    index index.html index.php;    location ~ \.php$ {        root /data/dokuwiki;        fastcgi_pass 127.0.0.1:9000;        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        include fastcgi_params;    }    location ~ /(conf/bin/inc)/ {        deny all;    }}</code></pre><p><strong>注意，这里可能会与php-fpm版本不兼容，需要使用更高版本。</strong></p><h3 id="三、authPDO插件使用"><a href="#三、authPDO插件使用" class="headerlink" title="三、authPDO插件使用"></a>三、authPDO插件使用</h3><pre><code>由于在生产环境中不想把密码相关的配置存储在文件中，把文件存储在mysql数据库中，好方便管理，更新等操作。</code></pre><p><a href="https://www.dokuwiki.org/plugin:authpdo" target="_blank" rel="noopener"><br>authPDO插件使用说明<br></a></p><h4 id="（1）准备数据库"><a href="#（1）准备数据库" class="headerlink" title="（1）准备数据库"></a>（1）准备数据库</h4><blockquote><p>创建user表</p></blockquote><pre><code>create table user(uid int auto_increment not null primary key,username varchar(20) not null ,realname varchar(30) not null, password varchar(128) not null, mail varchar(256) not null);</code></pre><blockquote><p>创建group表</p></blockquote><pre><code>create table group(gid int auto_increment not null primary key,gname varchar(30) not null);</code></pre><blockquote><p>创建成员表</p></blockquote><pre><code>create table member(mid int auto_increment not null primary key, gid int, foreign key(gid) references organize(gid),uid int,foreign key(uid) references user(uid));</code></pre><blockquote><p>创建用户</p></blockquote><pre><code>insert into user(username,realname,password,mail) values (&quot;admin&quot;,&quot;admin&quot;,password(&quot;123456&quot;), &quot;473823554@qq.com&quot;)</code></pre><blockquote><p>创建组</p></blockquote><pre><code>insert into organize(gname) values (&quot;admin&quot;);</code></pre><blockquote><p>创建成员</p></blockquote><pre><code>insert into member (gid,uid) vaules (1,1);</code></pre><h4 id="（2）authPDO插件配置"><a href="#（2）authPDO插件配置" class="headerlink" title="（2）authPDO插件配置"></a>（2）authPDO插件配置</h4><p><img src="https://blog-1258711185.cos.ap-guangzhou.myqcloud.com/dokuwiki01.png?q-sign-algorithm=sha1&amp;q-ak=AKIDyfCPgRhy9kmKxvHOXryoSKE3T91w4ot4&amp;q-sign-time=1552379614;1552381414&amp;q-key-time=1552379614;1552381414&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=6a9d6d365cae3f0ddadf748575ce8a17eca2c08b&amp;x-cos-security-token=0efc7b9f773a4726c67e9110e173b349e31d4ec610001" alt=""></p><p><img src="https://blog-1258711185.cos.ap-guangzhou.myqcloud.com/dokuwiki02.png?q-sign-algorithm=sha1&amp;q-ak=AKIDtYtNDhpVrqxu6Gbd4gTz67vzvpCHX8qH&amp;q-sign-time=1552379627;1552381427&amp;q-key-time=1552379627;1552381427&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=9970a4dc0f9b6b6b6197150c8be701a724d268fb&amp;x-cos-security-token=5381772790470aa62c062903bba1ad5ce368119410001" alt=""></p><p><img src="https://blog-1258711185.cos.ap-guangzhou.myqcloud.com/dokuwiki03.png?q-sign-algorithm=sha1&amp;q-ak=AKIDrqM1NqW10ajVDPAz5A7b1KRkQ54qRMy4&amp;q-sign-time=1552379640;1552381440&amp;q-key-time=1552379640;1552381440&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=7beb616f0b387b721882a5567fa2d2a1e3502a01&amp;x-cos-security-token=aed8ff93d9c3272c673259b96326fcbf77cdf11310001" alt=""></p><p><img src="https://blog-1258711185.cos.ap-guangzhou.myqcloud.com/dokuwiki04.png?q-sign-algorithm=sha1&amp;q-ak=AKID2PnXmSUvgBMdbX3mszbPXJe8kdDsg8Gz&amp;q-sign-time=1552379654;1552381454&amp;q-key-time=1552379654;1552381454&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=2ad9b62cf0c5221f5244d889948d44814cbc3414&amp;x-cos-security-token=929e5b004e0b633a931b5c8277ef49fa1f71596710001" alt=""></p><blockquote><p>dsn (data source name)</p></blockquote><pre><code>mysql:host=127.0.0.1;dbname=dokuwiki</code></pre><blockquote><p>user和pass</p></blockquote><pre><code>root   123456</code></pre><blockquote><p>select-user</p></blockquote><pre><code>select uid,username as user,realname as name,mail,password as hash from user where username = :user</code></pre><p><em>强制段</em></p><pre><code>user     登录名hash    密码mail    邮件地址name    用户全名</code></pre><blockquote><p>select-user-groups</p></blockquote><pre><code>select gname as `group` from group as g , member as m where g.gid = m.gid and m.uid = :uid </code></pre><blockquote><p>select-groups</p></blockquote><pre><code>select gid ,gname as `group` from group</code></pre><blockquote><p>insert-user</p></blockquote><pre><code>insert into user(username,realname,password,mail) values(:user,:name,:hash,:mail)</code></pre><blockquote><p>delete-user</p></blockquote><pre><code>delete from username where id = :uid</code></pre><blockquote><p>list-users</p></blockquote><pre><code>select username as user from user as u , member as m , group as g where u.uid = m.uid and g.gid = m.gid and g.gname like :group and u.username like :user and u.realname like :name and u.mail like :mail </code></pre><blockquote><p>count-users</p></blockquote><pre><code>select count(username) as count from user as u,member as m , group as g where u.uid = m.uid and g.gid = m.gid and g.group like :group and u.lusername like :user and u.realname like :name and u.mail like :mail</code></pre><blockquote><p>update-user-info</p></blockquote><pre><code>update user set realname = :name ,mail = :mail where uid = :uid</code></pre><blockquote><p>update-user-login</p></blockquote><pre><code>update user set username = :newlogin where uid = :uid</code></pre><blockquote><p>update-user-pass</p></blockquote><pre><code>update user set password = :hash where uid = :uid</code></pre><blockquote><p>insert-group</p></blockquote><pre><code>insert into organize (gname) values (:group)</code></pre><blockquote><p>join-group</p></blockquote><pre><code>insert into member (uid, gid) values (:uid,:gid)</code></pre><blockquote><p>leave-group</p></blockquote><pre><code>delete from member where uid = :uid and gid = :gid</code></pre><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>(1) 外观</p><p>wrap：几乎涵盖大多数外观、排版上的要求</p><p>(2) 标签</p><p>tag：用标签来组织内容<br>tagentry：在编辑栏下提供所有标签列表<br>cloud：标签云</p><p>EditTable：表哥编辑</p><hr><p><a href="https://blog.csdn.net/wszll_alex/article/category/7650010" target="_blank" rel="noopener">参考地址</a></p>]]></content>
      
      
      <categories>
          
          <category> wiki </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wiki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rsyslog</title>
      <link href="/2019/03/11/rsyslog/"/>
      <url>/2019/03/11/rsyslog/</url>
      
        <content type="html"><![CDATA[<p>在日常生活中如果您是一个生活有条理的人，一定会记录一下每天发生的事情，方便自己回看。CentOS系统中也是这样工作的，当我们在某时发生了错误时，这时日志就给我们起到了举足轻重的作用；我们可以查看日志并分析错误产生的原因等等。</p><h1 id="一、rsyslog基本介绍"><a href="#一、rsyslog基本介绍" class="headerlink" title="一、rsyslog基本介绍"></a>一、rsyslog基本介绍</h1><h2 id="1、rsyslog基本概念"><a href="#1、rsyslog基本概念" class="headerlink" title="1、rsyslog基本概念"></a>1、rsyslog基本概念</h2><p>Rsyslog是用于UNIX和类Unix的计算机系统上用于转发IP 网络中的日志消息的开源软件实用程序。它实现了基本的syslog协议，扩展了基于内容的过滤，丰富的过滤功能，灵活的配置选项，并添加了使用TCP进行传输的功能</p><h2 id="2、rsyslog构成"><a href="#2、rsyslog构成" class="headerlink" title="2、rsyslog构成"></a>2、rsyslog构成</h2><p>CentOS 5之前版本：sysklogd</p><p>CentOS 5之后版本：</p><pre><code>syslogd：记录系统日志klogd：记录内核日志</code></pre><p>事件记录格式：</p><pre><code>日期时间  主机   进程[PID]: 事件内容</code></pre><p>示例：</p><pre><code>Sep 18 11:10:33 localhost rz[3487]: [root] xcache-3.2.0.tar.bz2/ZMODEM: 148392 Bytes, 1037300 BPS</code></pre><h2 id="3、rsyslog工作模式"><a href="#3、rsyslog工作模式" class="headerlink" title="3、rsyslog工作模式"></a>3、rsyslog工作模式</h2><p>基于C/S架构：通过TCP或UDP协议的服务完成日志记录传送，将分布在不同主机的日志实现集中管理。</p><h2 id="4、rsyslog特性"><a href="#4、rsyslog特性" class="headerlink" title="4、rsyslog特性"></a>4、rsyslog特性</h2><p>（1）支持多协议；UDP,TCP,SSL,TLS,RELP等<br>（2）实现日志存储；MySQL，gpsql，oracle等<br>（3）强大的过滤器，可实现过滤日志信息中任何部分<br>（4）自定义输出格式</p><h2 id="5、rsyslog配置文件"><a href="#5、rsyslog配置文件" class="headerlink" title="5、rsyslog配置文件"></a>5、rsyslog配置文件</h2><p>主程序：</p><pre><code>/usr/sbin/rsyslogd</code></pre><p>库文件</p><pre><code>/lib64/rsyslog/*.so</code></pre><p>主配置文件</p><pre><code>/etc/rsyslog.conf和/etc/rsyslog.d/*.conf</code></pre><p><code>[root@localhost~]#grep &quot;^###&quot; /etc/rsyslog.conf</code> </p><pre><code>#### MODULES ####   相关模块配置#### GLOBAL DIRECTIVES #### 全局配置#### RULES #### 日志记录相关的规则配置</code></pre><p>（1）MODULES格式</p><pre><code>$ModLoad ModulesName</code></pre><p>（2）GLOBAL DIRECTIVES格式</p><pre><code>$WorkDirectory /var/lib/rsyslog 定义工作目录$ActionFileDefaultTemplate  使用时间戳格式 RSYSLOG_TraditionalFileFormat   $ActionFileEnableSync on  $IncludeConfig /etc/rsyslog.d/*.conf      其他配置文件位置$OmitLocalLogging on       $IMJournalStateFile imjournal.state</code></pre><p>（3）RULES格式</p><p>facility.priority   target</p><p><strong>facility</strong>    设施，从功能或程序上对日志进行分类</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>auth</td><td>授权日志信息</td></tr><tr><td>authpriv</td><td>认证日志信息</td></tr><tr><td>cron</td><td>任务计划日志信息</td></tr><tr><td>daemon</td><td>进程日志信息</td></tr><tr><td>kern</td><td>内核日志信息</td></tr><tr><td>lpr</td><td>打印机日志信息</td></tr><tr><td>mail</td><td>邮件日志信息</td></tr><tr><td>mark</td><td>标签日志信息</td></tr><tr><td>news</td><td>新闻日志信息</td></tr><tr><td>security</td><td>安全日志信息</td></tr><tr><td>user</td><td>用户日志信息</td></tr><tr><td>uucp</td><td>uucp日志信息</td></tr><tr><td>syslog</td><td>系统日志信息</td></tr><tr><td>local0-local7</td><td>自定义日志信息</td></tr></tbody></table><p><strong>priority</strong> 优先级</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>debug</td><td>只要发生就记录下来</td></tr><tr><td>info</td><td>一些基本的信息说明，无任何严重性</td></tr><tr><td>notice</td><td>系统进程，但有发生要注意的事项</td></tr><tr><td>warn（warning）</td><td>系统发生警告信息，但还不至于影响Daemon的正常工作</td></tr><tr><td>err（error）</td><td>发生重大的错误信息，这些信息通畅可以是说明无法启动的原因</td></tr><tr><td>crit（critical）</td><td>系统发生比err还严重的错误信息，通畅表示到达系统临界点</td></tr><tr><td>emerg（panic）</td><td>最严重的等级，通畅表示系统已经瘫痪</td></tr></tbody></table><p>如何指定级别？</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>指定所有级别</td></tr><tr><td>none</td><td>没有级别</td></tr><tr><td>PRIORITY</td><td>此级别及更高的级别日志信息</td></tr><tr><td>=PRIORITY</td><td>只指定此级别</td></tr></tbody></table><p><strong>target</strong></p><pre><code>文件路径：通常在/var/log目录下定义，文件路径前的“-”表示异步写入，可以提升系统性能用户：将日志事件通知给指定的用户，*表示登录的所有用户日志服务器：@HOST,把日志发送至指定的远程服务器中记录；这些可以将日志集中管理。默认监听在TCP/UDP的514端口上。管道：|COMMAND,转发给其他命令处理</code></pre><h2 id="6、其他日志文件"><a href="#6、其他日志文件" class="headerlink" title="6、其他日志文件"></a>6、其他日志文件</h2><p><code>/var/log/secure</code>:系统安装日志，文本格式，应周期性分析此日志文件<br><code>/var/log/btmp</code>：当前系统上，用户的失败尝试登陆相关的日志信息，二进制格式。可以使用lastb命令查看，再日常工作中可以查看是否有人尝试破解密码登录，然后截取除IP地址丢进防火墙中即可。</p><p><strong>注意：如果想清楚文件中的内容不能直接把文件删除可以使用<code>&gt;/var/log/wtmp</code>进行清楚。</strong></p><p><code>[root@localhost~]#lastb</code></p><pre><code>root     :0           :0               Wed Sep 20 11:45 - 11:45  (00:00)    btmp begins Wed Sep 20 11:45:14 2017</code></pre><p><code>/var/log/wtmp</code>:当前系统上，用户正常登录系统的相关日志信息，二进制格式，可以使用last命令查看</p><p><code>[root@localhost~]#last</code></p><pre><code>root     pts/1        192.168.4.1      Thu Oct 12 08:43   still logged in   root     pts/0        192.168.4.1      Thu Oct 12 08:20   still logged in   root     :0           :0               Thu Oct 12 08:20   still logged in </code></pre><p><code>/var/log/lastlog</code>:每一个用户最近一次的登陆信息，二进格式，可以使用lastlog命令查看。</p><p><code>[root@localhost~]#lastlog</code></p><pre><code>Username         Port     From             Latestroot             pts/1    192.168.4.1      Thu Oct 12 08:43:58 +0800 2017bin                                        **Never logged in**daemon                                     **Never logged in**</code></pre><p><code>/var/log/dmesg</code>:系统引导过程中的日志信息，文本格式，可以使用专用命令dmesg命令查看，如果系统出错可以查看是否启动过程哪里出错</p><p><code>/var/log/anaconda</code>:存放anaconda的日志目录</p><h1 id="二、日志服务器"><a href="#二、日志服务器" class="headerlink" title="二、日志服务器"></a>二、日志服务器</h1><blockquote><p>环境准备</p></blockquote><p>|<br>|主机|主机名|角色<br>|192.168.31.205|master|日志服务器<br>|192.168.31.139|node2|client</p><p>(1) master上修改配置文件</p><pre><code># Provides UDP syslog reception$ModLoad imudp$UDPServerRun 514# Provides TCP syslog reception#$ModLoad imtcp#$InputTCPServerRun 514</code></pre><p><em>可以启动tcp或者udp，这个看网络的问题</em></p><p><code>~]# systemctl restart rsyslog</code></p><p><code>~]# ss -unlp |grep 514</code></p><pre><code>UNCONN     0      0            *:514                      *:*                   users:((&quot;rsyslogd&quot;,pid=120004,fd=3))UNCONN     0      0           :::514                     :::*                   users:((&quot;rsyslogd&quot;,pid=120004,fd=4))</code></pre><p>(2) 客户端进行配置</p><p><code>~]# vim /etc/rsyslog.conf</code></p><pre><code>*.info;mail.none;authpriv.none;cron.none                @192.168.31.205</code></pre><p><code>~]# service rsyslog restart</code>   </p><p>（3）测试</p><p><code>~]# ~]# logger &quot;这是一条测试日志&quot;</code> 在node2上测试</p><p>看看master 上查看是否能收到</p><p><code>~]#tail -f /var/log/messages</code></p><pre><code>Mar 11 10:45:31 node2 root: 这是一条测试日志</code></pre><h1 id="三、如何将日志存储到mysql服务器上"><a href="#三、如何将日志存储到mysql服务器上" class="headerlink" title="三、如何将日志存储到mysql服务器上"></a>三、如何将日志存储到mysql服务器上</h1><pre><code>将日志存储到日志服务器上这样的好处是集中管理日志，但是当我们某天遇到问题时，不可能一个一个的去查询，这样显然增加了我们的工作量，如果可以直接搜索查询多好，mysql就为我们解决了这个问题。</code></pre><p>（1）在node2安装mysql模块相关的程序包</p><p><code>~]#yum install -y rsyslog-mysql</code></p><p><code>~]#rpm -ql rsyslog-mysql</code>   #查看文件</p><pre><code>/usr/lib64/rsyslog/ommysql.so    #模块/usr/share/doc/rsyslog-8.24.0/mysql-createDB.sql    #表结构</code></pre><p><code>~]# scp /usr/share/doc/rsyslog-8.24.0/mysql-createDB.sql master:/root/</code></p><p>（2）master创建表结构</p><p><code>~]# mysql -uroot -p &lt; mysql-createDB.sql</code>  #为rsyslog创建数据库及表</p><p>（3）授权</p><pre><code>grant all privileges on Syslog.* to &#39;syslog&#39;@&#39;192.168.31.%&#39; identified by &#39;123456&#39;;</code></pre><p>（4）在node2修改配置文件</p><pre><code>   $ModLoad ommysql*.info;mail.none;authpriv.none;cron.none                :ommysql:192.168.31.205,Syslog,syslog,123456</code></pre><p><code>~]# systemctl restart rsyslog</code>   #重启服务</p><p>（4）node2测试</p><p><code>~]# logger &quot;这是一个测试日志&quot;</code></p><p><code>~]#mysql -u root -p</code>    #登陆mysql日志服务器查看</p><pre><code>MariaDB [(none)]&gt; use SyslogMariaDB [Syslog]&gt; SELECT count(*)  FROM SystemEvents;+----------+| count(*) |+----------+|        10 |+----------+10 row in set (0.00 sec)</code></pre><h1 id="四、模块imfile"><a href="#四、模块imfile" class="headerlink" title="四、模块imfile"></a>四、模块imfile</h1><pre><code>该模块提供将任何标准文本文件转换为系统日志消息的功能。逐行读取，并将任何读取的行传递给rsyslog规则引擎。规则殷勤应用过滤条件并选择需要执行的操作。</code></pre><h3 id="1-参数"><a href="#1-参数" class="headerlink" title="(1) 参数"></a>(1) 参数</h3><p>$InputFileName   待监控的文件路径<br>$InputFileTag    文件唯一表示tag，最好保持唯一，用于接受端区分原始log文件<br>$InputFileStateFile 需要保证发送端唯一，记录读取到哪，状态文件保存在$WorkDirectory，默认为/var/lib/rsyslog；如果某个要监控的文件名变化了，一定要重新设置该值<br>$InputFileFacility log类型，默认为local0<br>$InputFileSeverity    log级别<br>$InputRunFileMonitor    启动监控当前的文件<br>$InputFilePollInterval  全局设置，默认轮询10s<br>$InputFilePersistStateInterval 没多少行更新state文件状态</p><blockquote><p>示例</p></blockquote><p>$InputFileName     /var/log/nginx/access.log<br>$InputFilePollInterval 5<br>$InputFileTag nginx<br>$InputFileStateFile /var/lib/rsyslog/nginx.access-test.log<br>$InputFileSeverity info<br>$InputFileFacility local5<br>$InputRunFileMonitor  </p><p>local5.*     ommysql:192.168.31.205,Rsyslog,syslog,123456</p><h1 id="五、日志图形化管理工具"><a href="#五、日志图形化管理工具" class="headerlink" title="五、日志图形化管理工具"></a>五、日志图形化管理工具</h1><p>（1）解压缩</p><p><code>~]#tar xf loganalyzer-4.1.7.tar.gz</code></p><p>（2）配置nginx</p><p><code>conf.d]# cat loganalyzer.conf</code></p><pre><code>server {    listen 80;    server_name www.testloganalyzer.com;    location /log {        fastcgi_pass 127.0.0.1:9000;        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME /data/php/$fastcgi_script_name;        include fastcgi_params;    }}</code></pre><p><code>~ #] cp -r src/* /data/php/</code></p><p><code>~ #] cp contrib/* /data/php/</code></p><p><code>~]# chmod +x secure.sh</code></p><p><code>~]# chmod +x configure.sh</code></p><p><code>~]#./configure.sh</code></p><p><code>~]#./secure.sh</code></p><p><code>~ ]# chown -R nginx.nginx ./*</code></p><p>（3）启动nginx</p><blockquote><p>修改配置文件</p></blockquote><pre><code>server {        server_name www.testloganalyzer.com;        root /data/;        location /php {                index index.php index.html;        }        location ~ \.php$ {                fastcgi_pass 127.0.0.1:9000;                fastcgi_index index.php;                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;                include fastcgi_params;        }}</code></pre><p><code>~]# systemctl start nginx php-fpm</code></p><p><strong>注意，在刚开始我使用php5.4的时候，出现版本不兼容问题。换一个高版本就解决了。</strong></p><p>（4）测试是否成功</p><p><img src="https://blog-1258711185.cos.ap-guangzhou.myqcloud.com/loganalyzer01.png?q-sign-algorithm=sha1&amp;q-ak=AKIDD1mHLbWHLkl9WDv36hDuoduber0egMvw&amp;q-sign-time=1552361748;1552363548&amp;q-key-time=1552361748;1552363548&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=032d02b450cd7ce321b1c2b292537ee6d1b6c3fb&amp;x-cos-security-token=57732fdf54b25794b82aea641aeac8e54958a1f510001" alt=""></p><p><img src="https://blog-1258711185.cos.ap-guangzhou.myqcloud.com/loganalyzer02.png?q-sign-algorithm=sha1&amp;q-ak=AKIDowehgxgJgBIAAgSbAwVlMKIWLNOMk7xu&amp;q-sign-time=1552361770;1552363570&amp;q-key-time=1552361770;1552363570&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=69d19d7ac02c06fdee96611618dbbd1000e56449&amp;x-cos-security-token=16d6e432eb955c2cbf058eb06ca8d19d1551c33910001" alt=""></p><p><img src="https://blog-1258711185.cos.ap-guangzhou.myqcloud.com/loganalyzer03.png?q-sign-algorithm=sha1&amp;q-ak=AKIDwu8fWEcxO7st1DR4LM4BiKiRR4vM6IQQ&amp;q-sign-time=1552361787;1552363587&amp;q-key-time=1552361787;1552363587&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=23d601d8e981d586f19dc249fc3028af7f74cdaf&amp;x-cos-security-token=c0064661202db32a00ee1ba16d6f5a59fd620c8e10001" alt=""></p><p><img src="https://blog-1258711185.cos.ap-guangzhou.myqcloud.com/loganalyzer04.png?q-sign-algorithm=sha1&amp;q-ak=AKIDwrAWIcB7tDJFi4Wy22zyi9M8p9Kn0Irm&amp;q-sign-time=1552361801;1552363601&amp;q-key-time=1552361801;1552363601&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=bd951d690f0fb63f3b2b11f56cfd89c5121d9c63&amp;x-cos-security-token=a99201e1b8a6b5a39bcddedac4883872b8dc4cff10001" alt=""></p><p><img src="https://blog-1258711185.cos.ap-guangzhou.myqcloud.com/loganalyzer05.png?q-sign-algorithm=sha1&amp;q-ak=AKIDdA6dz2oA0qC70812BHBQvzs8GRUjQDHB&amp;q-sign-time=1552361813;1552363613&amp;q-key-time=1552361813;1552363613&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=857315c1e3993527a0afed1a6c982da97bc71330&amp;x-cos-security-token=b19a5b73180df009f4826d3cd22d563708c03c8510001" alt=""></p><p><img src="https://blog-1258711185.cos.ap-guangzhou.myqcloud.com/loganalyzer06.png?q-sign-algorithm=sha1&amp;q-ak=AKIDevl33wr452ZXm0IePyJMsQn1DesDGA96&amp;q-sign-time=1552361828;1552363628&amp;q-key-time=1552361828;1552363628&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=9c3754c849f8a030f02cd434cf1dae1ce5a71efc&amp;x-cos-security-token=08c99f0c5d3d8109fac7fda63da2135b3eec130910001" alt=""></p><p><strong>如果想生成图表可以安装<code>yum install -y php-gd</code>,然后重新启动httpd服务即可。</strong></p><hr><h1 id="logrotate"><a href="#logrotate" class="headerlink" title="logrotate"></a>logrotate</h1><h3 id="1-logrotate配置项"><a href="#1-logrotate配置项" class="headerlink" title="(1)logrotate配置项"></a>(1)logrotate配置项</h3><pre><code>daily 指定转储周期为每天weekly 指定转储周期为每周monthly 指定转储周期为每月compress 通过gzip压缩nocompress 不需要压缩copytruncate 用于还在打开中的日志文件，把当前日志备份并截断nocopytruncate 备份但不截断missingok 如果文件不存在，继续下一个文件，不报异常nomissingok 如果文件不存在，报异常create mode owner group 转储文件，使用指定的文件模式创建新的日志文件delaycompress 和compress一起使用时，转储日志文件到下一次转储时才压缩errors address 转储时错误信息发送到指定的email地址ifempty 即使是空文件也转储mail address 把转储日志文件发送到指定email地址olddir directory 转储后的日志文件放入指定的目录prerotate postrotate 转储前或者后执行的脚本rotate count 指定日志文件删除之前转储的次数 size SIZE 当日志文件到达指定大小时才转储</code></pre><h3 id="（2）示例"><a href="#（2）示例" class="headerlink" title="（2）示例"></a>（2）示例</h3><pre><code>/var/log/nginx/access.log{    daily    create 0644 root root    rotate 5    missingok    compress    noifempty    postrotate         systemctl restart rsyslog &gt; /dev/null    endscript}</code></pre><p>#<br>        postrotate<br>            systemctl restart rsyslog &gt; /dev/null<br>        endscript</p><p><em>必须加上上面三句，因为在logrotate中，在rsyslog中还是持有这个文件句柄，会继续往原文件中写，即使已经被重命名了。</em></p>]]></content>
      
      
      <categories>
          
          <category> 日志系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rsyslog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openvpn</title>
      <link href="/2019/02/20/openvpn/"/>
      <url>/2019/02/20/openvpn/</url>
      
        <content type="html"><![CDATA[<h2 id="一、OpenVPN"><a href="#一、OpenVPN" class="headerlink" title="一、OpenVPN"></a>一、OpenVPN</h2><pre><code>OpenVPN的技术核心是虚拟网卡，它是由一个底层编程技术实现的一个驱动软件，安装之后多出一块网卡。OpenVPN提供了tun和tap两种工作模式。tap模式是桥接模式，通过软件在系统中模拟一个tap设备，一个二层设备，同时支持链路层协议。 tun模式是路由模式，ip层点对点协议。</code></pre><h3 id="1、server端配置文件"><a href="#1、server端配置文件" class="headerlink" title="1、server端配置文件"></a>1、server端配置文件</h3><pre><code>  local 10.2.11.237                 #外网口ip地址  port 1194                         #VPN端口  proto tcp                         #VPN使用的协议  dev tun                           #使用的模式  ca /etc/openvpn/ca.crt  cert /etc/openvpn/server.crt  key /etc/openvpn/server.key       # This file should be kept secret  dh /etc/openvpn/dh.pem            #定义迪菲.赫尔曼 秘钥  server 172.16.10.0 255.255.255.0  #vpn分配给客户端的网段  ifconfig-pool-persist ipp.txt     #定义客户端和虚拟IP地址的关系，在openvpn重启时，再次连接的客户端将依然被分配和断开之前的IP地址  ;server-bridge 10.8.0.4 255.255.255.0 10.8.0.50 10.8.0.100 #定义tap桥接模式时，分配给客户端的IP地址段  push &quot;route 192.168.109.0 255.255.255.0&quot; #推送一个默认路由，使vpn访问内网IP网络通过VPN访问  keepalive 30 120                  #设定保活参数，每10秒通过ping来确定Client是否存活，当然这个ping的进行是在虚拟通道中而不是在真是外部链路上的，超过120无反馈  push “redirect-gateway def1 bypass-dhcp”  #可以重定向客户端的网关，进行科学上网时用到  client-to-client                     # vpn客户端之间可以互相访问  duplicate-cn                         # 多人使用相同的证书和密钥连接VPN，否则只能一人使用  tls-auth /etc/openvpn/ta.key 0       # This file is secret  comp-lzo                          #允许数据压缩  max-clients 100                   #最大客户端你并发连接数量  persist-key                       #通过keepalive检测超时后，重新启动VPN，不重新读取keys保留第一次使用的keys  persist-tun                       #通过keepalive检测超时后，重新启动VPN，一直保持tun或者tap设备是linkupde  status /var/log/openvpn-status.log  #把openvpn的一些状态信息写到文件中，比如客户端获取的IP地址  log  /var/log/openvpn.log         #记录日志  log-append openvpn.log            #记录日志，每次重新启动openvpn后追加原有的log信息  verb 3                            #设置日志记录冗长级别  ;mute 20                          #重复日志记录限额</code></pre><h3 id="2、client配置文件"><a href="#2、client配置文件" class="headerlink" title="2、client配置文件"></a>2、client配置文件</h3><pre><code>  client  dev tun  proto tcp  remote 10.2.11.237 1194           # 此为公网IP，也可以是域名  ;remote-random                    # 随机选择一个server连接，否则按照顺序从上到下依次连接  resolv-retry infinite             # 始终重新解析Server的IP地址，保证server IP地址是动态的使用DDNS动态更新DNS后，Client在自动重新连接时重新解析server的IP地址。  nobind                            #定义本机不绑定任何端口监听incoming数据  persist-key  persist-tun  ca ca.crt  cert alsvpn.crt                    # 创建的用户证书  key alsvpn.key                     # 创建的用户秘钥  remote-cert-tls server  tls-auth ta.key 1  comp-lzo  verb 3</code></pre><h2 id="二、OpenVPN认证方式"><a href="#二、OpenVPN认证方式" class="headerlink" title="二、OpenVPN认证方式"></a>二、OpenVPN认证方式</h2><h4 id="1、环境前提"><a href="#1、环境前提" class="headerlink" title="1、环境前提"></a>1、环境前提</h4><blockquote><p>在openvpn服务器上配置时间同步</p></blockquote><p><code>~]# vim /etc/chrony.conf</code></p><pre><code>server time1.aliyun.com iburst</code></pre><p><code>~]# systemctl start chronyd.service</code></p><blockquote><p>软件安装前提</p></blockquote><p><code>~]#yum  -y install gcc gcc-c++ openssl openssl-devl lzrsz pam-devel cmake</code></p><h4 id="2、编译安装"><a href="#2、编译安装" class="headerlink" title="2、编译安装"></a>2、编译安装</h4><h5 id="（1）编译安装lzo-压缩算法"><a href="#（1）编译安装lzo-压缩算法" class="headerlink" title="（1）编译安装lzo  压缩算法"></a>（1）编译安装lzo  压缩算法</h5><p><code>~]# tar xf lzo-2.10.tar.gz</code></p><p><code>~]# ./configure &amp;&amp; make &amp;&amp; make install</code></p><h5 id="（2）编译安装openvpn"><a href="#（2）编译安装openvpn" class="headerlink" title="（2）编译安装openvpn"></a>（2）编译安装openvpn</h5><p><code>~]# tar xf openvpn-2.4.6.tar.gz</code></p><p><code>~]# ./configure --prefix=/usr/local/openvpn</code></p><p><code>~]# make &amp;&amp; make install</code></p><p><code>~]# mkdir /etc/openvpn/conf.d</code></p><p><code>~]# vim /etc/profile.d/openvpn.sh</code></p><pre><code>  export PATH=//etc/openvpn/sbin:$PATH</code></pre><p><code>~]# source openvpn.sh</code></p><p><code>~]# cp sample/sample-config-files/server.conf /etc/openvpn/conf.d/</code></p><h5 id="（3）证书生成"><a href="#（3）证书生成" class="headerlink" title="（3）证书生成"></a>（3）证书生成</h5><p><code>~]# tar xf EasyRSA-unix-v3.0.6.tgz</code></p><p><code>~]# mv EasyRSA-v3.0.6/ easy-rsa</code></p><p><code>~]# tree</code></p><pre><code>.├── easyrsa├── openssl-easyrsa.cnf├── vars├── vars.example└── x509-types    ├── ca    ├── client    ├── code-signing    ├── COMMON    ├── server    └── serverClient</code></pre><p><strong>将不需要的文件删除</strong></p><p><code>~]# cp vars.example vars</code>  </p><p><code>~]# vim vars</code></p><pre><code>  set_var EASYRSA_REQ_COUNTRY     &quot;CN&quot;  set_var EASYRSA_REQ_PROVINCE    &quot;Guangdong&quot;  set_var EASYRSA_REQ_CITY        &quot;Guangzhou&quot;  set_var EASYRSA_REQ_ORG         &quot;xingxing&quot;  set_var EASYRSA_REQ_EMAIL       &quot;473@qq.com&quot;  set_var EASYRSA_REQ_OU          &quot;Ops&quot;</code></pre><blockquote><p>初始化CA</p></blockquote><p><code>~]# ./easyrsa init-pki</code>  </p><h6 id="生成ca证书"><a href="#生成ca证书" class="headerlink" title="生成ca证书"></a>生成ca证书</h6><p><code>~]# ./easyrsa build-ca</code>  </p><pre><code>Note: using Easy-RSA configuration from: ./varsUsing SSL: openssl OpenSSL 1.0.2k-fips  26 Jan 2017Enter New CA Key Passphrase:  #输入密码Re-Enter New CA Key Passphrase:   #再次输入密码Common Name (eg: your user, host, or server name) [Easy-RSA CA]:ca  输入证书名Your new CA certificate file for publishing is at:/etc/openvpn/easy-rsa/pki/ca.crt  #ca证书存放的位置</code></pre><blockquote><p>生成服务端证书</p><h6 id="生成证书请求"><a href="#生成证书请求" class="headerlink" title="生成证书请求"></a>生成证书请求</h6><p><code>~]# ./easyrsa gen-req server nopass</code>   </p></blockquote><h6 id="对证书进行签证，前一个server指定类型，-后一个为证书名称"><a href="#对证书进行签证，前一个server指定类型，-后一个为证书名称" class="headerlink" title="对证书进行签证，前一个server指定类型， 后一个为证书名称"></a>对证书进行签证，前一个server指定类型， 后一个为证书名称</h6><p><code>~]# ./easyrsa sign-req server server</code></p><p><code>~]# ./easyrsa gen-dh</code></p><p><code>~]# openvpn --genkey --secret ta.key</code></p><blockquote><p>生成客户端证书</p></blockquote><p><code>~]# mkdir /mnt/easy-rsa</code></p><p><code>~]# ./easyrsa init-pki</code></p><p><code>~]# ./easyrsa gen-req client nopass</code></p><h6 id="导入证书文件"><a href="#导入证书文件" class="headerlink" title="导入证书文件"></a>导入证书文件</h6><p><code>~]# ./easyrsa import-req /mnt/easy-rsa/pki/reqs/client.req client</code> </p><p><code>~]# ./easyrsa sign-req client client</code></p><h3 id="方式一：证书认证登录"><a href="#方式一：证书认证登录" class="headerlink" title="方式一：证书认证登录"></a>方式一：证书认证登录</h3><blockquote><p>(1)服务端文件配置</p></blockquote><p><code>~]# vim server.conf</code></p><pre><code>  port 1194  proto tcp  dev tun  ca ssl/ca.crt  cert ssl/server.crt  key ssl/server.key  # This file should be kept secret  dh ssl/dh.pem  server 172.16.0.0 255.255.255.0  ifconfig-pool-persist ipp.txt  push &quot;route 192.168.0.0 255.255.255.0&quot;  client-to-client  duplicate-cn  keepalive 10 120  tls-auth ssl/ta.key  # This file is secret  cipher AES-256-CBC  comp-lzo  max-clients 100  persist-key  persist-tun  status openvpn-status.log  log         openvpn.log  log-append openvpn.log  verb 3</code></pre><blockquote><p>(2)客户端文件配置</p></blockquote><pre><code>  client  dev tun  proto tcp  remote 192.168.31.205 1194  resolv-retry infinite  nobind  persist-key  persist-tun  &lt;ca&gt;  -----BEGIN CERTIFICATE-----  ...  -----END CERTIFICATE-----  &lt;/ca&gt;  &lt;cert&gt;  -----BEGIN CERTIFICATE-----  ...  -----END CERTIFICATE-----  &lt;/cert&gt;   &lt;key&gt;  -----BEGIN PRIVATE KEY-----  ...  -----END PRIVATE KEY-----  &lt;/key&gt;  &lt;tls-auth&gt;  ...  &lt;/tls-auth&gt;  comp-lzo  verb 3</code></pre><blockquote><p>(3)修改防火墙规则</p></blockquote><p><code>~]# iptables -t nat -A POSTROUTING -s 172.18.1.0/24 -o ens37 -j SNAT --to-source 192.168.1.101</code></p><pre><code>此规则的作用是将来自172.18.1.0/24网段的请求伪装成192.168.1.10 通过ens37网卡发出去。  172.18.1.0/24  是openvpn给客户端分配的IP地址段  192.168.1.101  是内网通信的网关（简单这么理解）  ens37 内网网卡</code></pre><blockquote><p>(4)启动服务</p></blockquote><p><code>~]# openvpn --daemon --config server.conf &amp;</code></p><h3 id="方式二：-密码和证书双重认证"><a href="#方式二：-密码和证书双重认证" class="headerlink" title="方式二： 密码和证书双重认证"></a>方式二： 密码和证书双重认证</h3><blockquote><p>（1）编辑账户认证脚本</p></blockquote><p><code>~]# vim checkpsw.sh</code> </p><pre><code>  #!/bin/sh  ###########################################################  # checkpsw.sh (C) 2004 Mathias Sundman &lt;mathias@openvpn.se&gt;  #  # This script will authenticate OpenVPN users against  # a plain text file. The passfile should simply contain  # one row per user with the username first followed by  # one or more space(s) or tab(s) and then the password.  PASSFILE=&quot;/etc/openvpn/psw-file&quot;  LOG_FILE=&quot;/var/log/openvpn-password.log&quot;  TIME_STAMP=`date &quot;+%Y-%m-%d %T&quot;`  ###########################################################  if [ ! -r &quot;${PASSFILE}&quot; ]; then    echo &quot;${TIME_STAMP}: Could not open password file \&quot;${PASSFILE}\&quot; for reading.&quot; &gt;&gt; ${LOG_FILE}    exit 1  fi  CORRECT_PASSWORD=`awk &#39;!/^;/&amp;&amp;!/^#/&amp;&amp;$1==&quot;&#39;${username}&#39;&quot;{print $2;exit}&#39; ${PASSFILE}`  if [ &quot;${CORRECT_PASSWORD}&quot; = &quot;&quot; ]; then     echo &quot;${TIME_STAMP}: User does not exist: username=\&quot;${username}\&quot;, password=\&quot;${password}\&quot;.&quot; &gt;&gt; ${LOG_FILE}    exit 1  fi  if [ &quot;${password}&quot; = &quot;${CORRECT_PASSWORD}&quot; ]; then     echo &quot;${TIME_STAMP}: Successful authentication: username=\&quot;${username}\&quot;.&quot; &gt;&gt; ${LOG_FILE}    exit 0  fi  echo &quot;${TIME_STAMP}: Incorrect password: username=\&quot;${username}\&quot;, password=\&quot;${password}\&quot;.&quot; &gt;&gt; ${LOG_FILE}  exit 1</code></pre><p><code>~]# chmod +x checkpsw.sh</code></p><blockquote><p>（2）创建用户名密码文件</p></blockquote><p><code>~]# vim psw-file</code></p><pre><code>  joah 123456  test321 123456</code></pre><blockquote><p>（3）在文件末尾追加如下几行</p></blockquote><pre><code>  auth-user-pass-verify /etc/openvpn/conf.d/check.sh via-env  verify-client-cert  username-as-common-name  script-security 3  说明：        auth-user-pass-verify /etc/openvpn/conf.d/check.sh via-env #checkpsw.sh脚本文件认证username/password连接客户端        verify-client-cert  #证书和用户名密码双重认证        username-as-common-name #使用客户端提供的username作为common name        script-security 3    保存密码在环境变量中</code></pre><blockquote><p>（4）启动服务</p></blockquote><p><code>~]# openvpn --daemon --config server.conf &amp;</code></p><blockquote><p>（5）客户端配置文件</p></blockquote><p>在client.ovpn配置文件追加如下</p><pre><code>auth-user-pass   auth-nocache #可以在短线后防止内存中保存用户名和密码</code></pre><h3 id="方式三：-MySQL认证"><a href="#方式三：-MySQL认证" class="headerlink" title="方式三： MySQL认证"></a>方式三： MySQL认证</h3><blockquote><p>(1)安装pam_mysql</p></blockquote><p><code>~]# yum install -y mariadb-server mariadb-devel</code></p><blockquote><p>(2)创建数据库以及表</p></blockquote><p><code>create databases openvpn default charset utf8;</code></p><p><code>use openvpn;</code></p><ul><li><p>创建user表<br>#<br>  CREATE TABLE user (</p><pre><code>username varchar(24) NOT NULL,password varchar(128) DEFAULT NULL,active int(10) NOT NULL DEFAULT 1,creation timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,expired_time timestamp NOT NULL DEFAULT &#39;0000-00-00 00:00:00&#39;,name varchar(24) DEFAULT NULL,email char(128) DEFAULT NULL,note text,quota_cycle int(10) NOT NULL DEFAULT 30,quota_bytes bigint(20) NOT NULL DEFAULT &#39;10737418240&#39;,enabled int(10) NOT NULL DEFAULT 1,PRIMARY KEY (username),index idx_active (active),index idx_enabled (enabled)</code></pre><p>  ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p></li><li><p>创建log表<br>#<br>  CREATE TABLE log (</p><pre><code>username varchar(24) NOT NULL,start_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,end_time timestamp NOT NULL DEFAULT &#39;0000-00-00 00:00:00&#39;,trusted_ip varchar(64) DEFAULT NULL,trusted_port int(10) DEFAULT NULL,protocol varchar(16) DEFAULT NULL,remote_ip varchar(64) DEFAULT NULL,remote_netmask varchar(64) DEFAULT NULL,bytes_received bigint(20) DEFAULT 0,bytes_sent bigint(20) DEFAULT 0,status int(10) NOT NULL DEFAULT 1,index idx_username (username),index idx_start_time (start_time),index idx_end_time (end_time)</code></pre><p>  ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p></li><li><p>授权    </p></li></ul><p><code>grant all privileges on openvpn.* to &#39;openvpn&#39;@&#39;%&#39; identified by &#39;123456&#39;;</code></p><blockquote><p>(3)安装pam_mysql</p></blockquote><p><code>~]# yum install -y mariadb-devel pam-devel</code></p><p><code>~]# tar xf pam_mysql-0.7RC1.tar.gz</code></p><p><code>~]# ./configure --with-mysql=/usr --with-openssl=/usr --with-pam=/usr --with-pam-mods-dir=/lib64/security</code></p><p><code>~]# make &amp;&amp; make install</code></p><blockquote><p>(4)创建openvpn文件</p></blockquote><p><code>~]# vim /etc/pam.d/openvpn</code></p><pre><code>auth required /lib64/security/pam_mysql.so user=openvpn passwd=123456 host=localhost db=openvpn table=user usercolumn=username passwdcolumn=password where=active=1 sqllog=0 crypt=2account required /lib64/security/pam_mysql.so user=openvpn passwd=123456 host=localhost db=openvpn table=user usercolumn=username passwdcolumn=password where=active=1 sqllog=0 crypt=2</code></pre><p><strong>注意：</strong> </p><pre><code>  crypt=0 明文加密  crypt=1 使用crypt()加密  crypt=2 使用mysql中password()加密  crypt=3 使用md5加密</code></pre><blockquote><p>(5)修改openvpn服务端配置文件</p></blockquote><pre><code>  proto tcp  dev tun  port 1194  ca ssl/ca.crt  cert ssl/server.crt  key ssl/server.key  dh ssl/dh.pem  tls-auth ssl/ta.key 0  server 192.168.6.0 255.255.255.0  keepalive 20 120  persist-key  persist-tun  comp-lzo  push &quot;route 192.168.5.0 255.255.255.0&quot;  status /etc/openvpn/openvpn-status.log  max-clients 1000  verify-client-cert  username-as-common-name  script-security 3   plugin /etc/openvpn/conf.d/openvpn-auth-pam.so openvpn**注意：使用高版本的认证不成功的，不知道原因，需要下载低版本的进行编译即可**  ;如果需要设置设置连接和断开脚本，以便统计流量信息  ;client-connect /etc/openvpn/connect.sh  ;client-disconnect /etc/openvpn/disconnect.sh</code></pre><blockquote><p>(6)connect.sh脚本</p></blockquote><pre><code>  #!/bin/bash  #  DB=&#39;openvpn&#39;  LOGIN=&#39;openvpn&#39;  DBPASSWD=&#39;123456&#39;  mysql -u${LOGIN} -p${DBPASSWD} -h${HOST} -e &quot;INSERT INTO log(username,start_time,trusted_port,protocol,remote_ip,remote_netmask,status,trusted_ip) VALUES(&#39;$common_name&#39;,now(),$trusted_port,&#39;$proto_1&#39;,&#39;$ifconfig_pool_remote_ip&#39;,&#39;$route_netmask_1&#39;,1,&#39;${trusted_ip}&#39;)&quot; ${DATABASE}</code></pre><p><code>~]# chmod +x connect.sh</code></p><blockquote><p>(7)disconnect.sh脚本</p></blockquote><pre><code>#!/bin/bash#DATABASE=&#39;openvpn&#39;LOGIN=&#39;openvpn&#39;DBPASSWD=&#39;123456&#39;HOST=&#39;localhost&#39;#断开连接时，更新日志mysql -u${LOGIN} -h${HOST} -p${DBPASSWD} -e &quot;update log set end_time=now(),bytes_received=&#39;${bytes_received}&#39;,bytes_sent=&#39;${bytes_sent}&#39;,status=0 where trusted_ip=&#39;${trusted_ip}&#39; and trusted_port=&#39;${trusted_port}&#39; and remote_ip=&#39;${ifconfig_pool_remote_ip}&#39; and username=&#39;${common_name}&#39; and status=1&quot; ${DATABASE}#如果流量超出，则锁定用户mysql -u$DBADMIN -p$DBPASSWD -e &quot;UPDATE user SET active=0 WHERE user.username IN (SELECT username FROM (SELECT log.username AS username, quota_bytes FROM user, log WHERE log.username=user.username AND log.status=0 AND TO_DAYS(NOW())-TO_DAYS(start_time)&lt; =quota_cycle GROUP BY log.username HAVING SUM(bytes_received)+SUM(bytes_sent)&gt;=quota_bytes) AS u);&quot; $DB#如果过期时间超出，则锁定用户mysql -u${LOGIN} -h${HOST} -p${DBPASSWD} -e &quot;update user set active=0 where username=&#39;${common_name}&#39; and UNIX_TIMESTAMP(now()) &gt; UNIX_TIMESTAMP(expired_time)&quot; ${DATABASE}</code></pre><p><code>~]# chmod +x disconnect.sh</code></p><h3 id="四、windows客户端配置"><a href="#四、windows客户端配置" class="headerlink" title="四、windows客户端配置"></a>四、windows客户端配置</h3><ul><li><p>1）安装客户端软件省略（默认安装在C:\Program Files\OpenVPN）</p></li><li><p>2）配置客户端软件</p><p>  拷贝vpn服务器上/mnt/clinet/alsvpn目录下的ca.crt alsvpn.crt alsvpn.key ta.key client.opvn到C:\Program Files\OpenVPN\config中</p></li><li><p>3）以管理员运行</p></li><li><p>4）右击电脑右下角的图标，点击connect</p><p>  输入当时配置客户端证书，填写的密码，此处为clientopenvpn</p></li><li><p>5）拨号成功后，客户端会获取到ip地址 </p></li><li><p>6）查看客户端是否获取到内网网段的路由</p></li><li><p>7）测试是否可以ping通内网</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Openvpn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openvpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Glances</title>
      <link href="/2017/12/20/Glances/"/>
      <url>/2017/12/20/Glances/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Glances"><a href="#一、Glances" class="headerlink" title="一、Glances"></a>一、Glances</h1><p>Glances是一个由Python编写，使用psutil库来从系统抓取信息的基于curses开发的跨平台命令行监视工具。</p><h2 id="1、Glances功能"><a href="#1、Glances功能" class="headerlink" title="1、Glances功能"></a>1、Glances功能</h2><ul><li>CPU信息</li><li>总内存信息，包括了物理内存，交换空间和空闲内存等</li><li>网络链接的上下行速度</li><li>处理器总数机器状态信息</li><li>硬盘I/O相关信息</li><li>当前挂载设备使用情况</li><li>人性化显示</li></ul><h2 id="2、Glances颜色含义"><a href="#2、Glances颜色含义" class="headerlink" title="2、Glances颜色含义"></a>2、Glances颜色含义</h2><table><thead><tr><th>颜色</th><th>含义</th></tr></thead><tbody><tr><td>绿色</td><td>表示性能良好，无需做任何额外的工作</td></tr><tr><td>蓝色</td><td>表示系统性能有一些小问题，用户应当开始关注系统性能</td></tr><tr><td>品红</td><td>表示性能报警，应当采取措施，比如备份数据</td></tr><tr><td>红色</td><td>表示性能问题严重，可能宕机</td></tr></tbody></table><p><strong>阈值可以在配置文件中设置，一般阈值默认设置为（careful=50、warning=70、critical=90），一般在配置文件<code>/etc/glances.glances.conf</code>中配置。</strong></p><h1 id="二、Glances使用"><a href="#二、Glances使用" class="headerlink" title="二、Glances使用"></a>二、Glances使用</h1><h2 id="1、Glances安装"><a href="#1、Glances安装" class="headerlink" title="1、Glances安装"></a>1、Glances安装</h2><h3 id="（1）安装方式一"><a href="#（1）安装方式一" class="headerlink" title="（1）安装方式一"></a>（1）安装方式一</h3><pre><code>curl -L https://bit.ly/glances | /bin/bash</code></pre><h2 id="2、安装方式二"><a href="#2、安装方式二" class="headerlink" title="2、安装方式二"></a>2、安装方式二</h2><p>配置epel源安装即可</p><p><code>[root@node1~]#yum install -y glances</code></p><p><strong>不过我使用这种方法安装，不能启动。解决方法如下：</strong></p><p><code>[root@node1~]#pip install --upgrade glances</code></p><p><strong>我猜测可能版本不兼容导致的。</strong></p><h2 id="3、Glances命令"><a href="#3、Glances命令" class="headerlink" title="3、Glances命令"></a>3、Glances命令</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><pre><code>glances [OPTIONS]</code></pre><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-b</td><td>显示网络连接速度Byte/秒</td></tr><tr><td>-B @IP</td><td>绑定服务器端IP或主机名称</td></tr><tr><td>-c IP</td><td>连接glances服务器端</td></tr><tr><td>-C file</td><td>设置配置文件默认是<code>/etc/glances/glances.conf</code></td></tr><tr><td>-d</td><td>关闭磁盘IO模块</td></tr><tr><td>-e</td><td>显示传感器温度</td></tr><tr><td>-f file</td><td>设置输出文件，格式为HTML或CSV</td></tr><tr><td>-m</td><td>关闭挂载磁盘模块</td></tr><tr><td>-n</td><td>关闭网络模块</td></tr><tr><td>-p port</td><td>设置运行端口为61209</td></tr><tr><td>-P password</td><td>设置客户端/服务器密码</td></tr><tr><td>-s</td><td>设置glances运行模式为服务器</td></tr><tr><td>-t</td><td>设置屏幕刷新时间</td></tr></tbody></table><h3 id="Glances交互式方式的快捷键"><a href="#Glances交互式方式的快捷键" class="headerlink" title="Glances交互式方式的快捷键"></a>Glances交互式方式的快捷键</h3><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>h</td><td>显示帮助信息</td></tr><tr><td>q</td><td>离开程序退出</td></tr><tr><td>c</td><td>按照CPU实施负载对系统进程进行排序</td></tr><tr><td>m</td><td>按照内存状况对系统进行排序</td></tr><tr><td>i</td><td>按照IO使用情况对系统进行排序</td></tr><tr><td>p</td><td>安装进程名排序</td></tr><tr><td>w</td><td>删除日志文件</td></tr><tr><td>l</td><td>显示日志</td></tr><tr><td>s</td><td>显示传感器信息</td></tr><tr><td>f</td><td>显示系统信息</td></tr><tr><td>1</td><td>轮流显示每个CPU内核使用情况</td></tr></tbody></table><h2 id="4、运行glances"><a href="#4、运行glances" class="headerlink" title="4、运行glances"></a>4、运行glances</h2><p><code>[root@node1~]#glances</code><br><img src="http://owatlfstl.bkt.clouddn.com/2017-12-20_234911.jpg" alt=""></p><h1 id="三、Glances服务器-客户端工作方式"><a href="#三、Glances服务器-客户端工作方式" class="headerlink" title="三、Glances服务器/客户端工作方式"></a>三、Glances服务器/客户端工作方式</h1><p>glances支持服务器/客户端工作方式，可以实现远程监控。</p><h2 id="（1）在服务器端设置"><a href="#（1）在服务器端设置" class="headerlink" title="（1）在服务器端设置"></a>（1）在服务器端设置</h2><p><code>[root@node1~]#glances -s -B 192.168.4.61</code><br><strong>不过这样的工作方式，会占用终端，可以使用如下命令在后台运行。</strong><br><code>[root@node1~]#nohup glances -s -B 192.168.4.61 &amp;</code></p><h2 id="（2）在客户端上进行监控"><a href="#（2）在客户端上进行监控" class="headerlink" title="（2）在客户端上进行监控"></a>（2）在客户端上进行监控</h2><p><code>[root@node2~]#glances -c 192.168.4.61</code></p><p><strong>不过建议，设置成计划任务，隔一段时间检测下，以免命令被误删除。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> glances </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPM</title>
      <link href="/2017/12/19/RPM%E5%8C%85%E5%88%B6%E4%BD%9C/"/>
      <url>/2017/12/19/RPM%E5%8C%85%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="一、RPM制作"><a href="#一、RPM制作" class="headerlink" title="一、RPM制作"></a>一、RPM制作</h1><p>RPM Package Manager简称RPM。</p><h2 id="1、配置环境"><a href="#1、配置环境" class="headerlink" title="1、配置环境"></a>1、配置环境</h2><p>打包相关的配置保存在宏文件（macrofiles）中，默认使用<code>$home/rpmbuild</code>目录，用户配置文件保存在<code>$HOME/.rpmmacros</code>；而制作包的操作实际都在<code>topdir</code>指定的目录下。</p><h3 id="（1）查看所有配置文件顺序"><a href="#（1）查看所有配置文件顺序" class="headerlink" title="（1）查看所有配置文件顺序"></a>（1）查看所有配置文件顺序</h3><p><code>[root@node1~]#rpmbuild --showrc |grep macros</code></p><pre><code>Macro path: /usr/lib/rpm/macros:/usr/lib/rpm/macros.d/macros.*:/usr/lib/rpm/platform/%{_target}/macros:/usr/lib/rpm/fileattrs/*.attr:/usr/lib/rpm/redhat/macros:/etc/rpm/macros.*:/etc/rpm/macros:/etc/rpm/%{_target}/macros:~/.rpmmacros</code></pre><h3 id="（2）查看根工作目录"><a href="#（2）查看根工作目录" class="headerlink" title="（2）查看根工作目录"></a>（2）查看根工作目录</h3><p><code>[root@node1~]#rpmbuild --showrc |grep topdir</code></p><pre><code>-14: _builddir    %{_topdir}/BUILD-14: _buildrootdir    %{_topdir}/BUILDROOT-14: _rpmdir    %{_topdir}/RPMS-14: _sourcedir    %{_topdir}/SOURCES-14: _specdir    %{_topdir}/SPECS-14: _srcrpmdir    %{_topdir}/SRPMS-14: _topdir    %{getenv:HOME}/rpmbuild</code></pre><h3 id="（3）根目录介绍"><a href="#（3）根目录介绍" class="headerlink" title="（3）根目录介绍"></a>（3）根目录介绍</h3><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td>-14: _builddir    %{_topdir}/BUILD</td><td>编译rpm包的临时目录</td></tr><tr><td>-14: _buildrootdir    %{_topdir}/  BUILDROOT</td><td>编译后生成的软件临时安装目录</td></tr><tr><td>-14: _rpmdir    %{_topdir}/RPMS</td><td>最终生成的可安装rpm包的所在目录</td></tr><tr><td>-14: _sourcedir    %{_topdir}/SOURCES</td><td>所有源代码和补丁文件的存放目录</td></tr><tr><td>-14: _specdir    %{_topdir}/SPECS</td><td>存放SPEC文件的目录 <strong>重要</strong></td></tr><tr><td>-14: _srcrpmdir    %{_topdir}/SRPMS</td><td>软件最终的rpm源码格式存放路径</td></tr></tbody></table><h2 id="2、rpmbuild命令"><a href="#2、rpmbuild命令" class="headerlink" title="2、rpmbuild命令"></a>2、rpmbuild命令</h2><p>构建rpm包的命令</p><h3 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h3><pre><code>rpmbuild {-ba|-bb|-bp|-bc|-bi|-bl|-bs} [rpmbuild-options] SPECFILE ...</code></pre><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-bb</td><td>制作成二进制rpm包</td></tr><tr><td>-bs</td><td>制作源码的rpm包</td></tr><tr><td>-ba</td><td>源码和二进制两种形式的rpm包</td></tr><tr><td>-bl</td><td>检测BUILDROOT没有包含的rpm包中的文件</td></tr><tr><td>-bp</td><td>执行到pre段</td></tr><tr><td>-bc</td><td>执行到build段</td></tr><tr><td>-bi</td><td>执行到install段</td></tr><tr><td>–rebuild</td><td>重新编译</td></tr><tr><td>–define</td><td>编译时指定参数</td></tr></tbody></table><p><strong>一般来说，执行的顺序为<code>rpmbuild -bp</code> –&gt; <code>rpmbuild -bc</code> –&gt; <code>rpmbuild -bi</code> –&gt;<code>rpmbuild -bb</code>或<code>rpmbuild -ba</code></strong></p><h1 id="二、SPEC文件"><a href="#二、SPEC文件" class="headerlink" title="二、SPEC文件"></a>二、SPEC文件</h1><p>SPEC文件是整个包制作的核心，它的作用如同编译程序时的Makefile文件一样。</p><p><strong>注意：spec文件必须由普通用户创建。</strong></p><h2 id="1、SPEC结构"><a href="#1、SPEC结构" class="headerlink" title="1、SPEC结构"></a>1、SPEC结构</h2><h3 id="（1）自定义宏段，方便后续引用"><a href="#（1）自定义宏段，方便后续引用" class="headerlink" title="（1）自定义宏段，方便后续引用"></a>（1）自定义宏段，方便后续引用</h3><pre><code>%define VARIABLE_NAME value</code></pre><h3 id="（2）介绍区域段"><a href="#（2）介绍区域段" class="headerlink" title="（2）介绍区域段"></a>（2）介绍区域段</h3><pre><code>Name:    ##rpm包的名字Version:        ##rpm包的版本号，建议和源码包的名称保持一致Release:     1%{?dist }  ##rpm本身的版本号，使用默认值即可Summary:    ##rpm的一些介绍Group:      ##表示软件包所属类型License:        ##授权类型URL:        ##软件地址，一般为软件的地址Source0:    ##源码包名称，可以使用URL，可以使用sourceN指定多个，如配置文件等  。注意source0必须要填写，而且填写的名字必须和下载源码包名称要一致。而且源码包为tar.gz格式。BuildRoot： %_topdir /BUILDROOT  ##会打包该目录下文件，可查看安装后文件路径BuildRequires:  ##制作过程中用到的软件包Requires:    ##安装时所需软件包prefix:%{_prefix}这个主要为了解决今后安装rpm包时，并不一定把软件安装到rpm中打包的目录。因此，必须在这里定义该标识，并在编写%install脚本的时候引用，才能实现rpm安装时重新制定位置的功能prefix:%{_sysconfig}，由于%{_prefix}指/usr，而对于其他文件，例如/etc下的配置文件，则需要用%{_sysconfig}标识。%description    ##定义关于rpm包的描述信息</code></pre><h3 id="（3）准备阶段"><a href="#（3）准备阶段" class="headerlink" title="（3）准备阶段"></a>（3）准备阶段</h3><p>此阶段主要解压源码，并切换源码目录下</p><pre><code>%prep   安装前操作%setup -q   ##静默模式解压并切换到目录</code></pre><h3 id="（4）编译阶段"><a href="#（4）编译阶段" class="headerlink" title="（4）编译阶段"></a>（4）编译阶段</h3><pre><code>%build  ##定义编译软件包时的操作%configuremake %{?_smp_mflags}    ##多核则并行编译</code></pre><h3 id="（5）安装阶段"><a href="#（5）安装阶段" class="headerlink" title="（5）安装阶段"></a>（5）安装阶段</h3><pre><code>%install    ##定义安装软件包，使用默认即可make install DESTDIR=%{buildroot}        buildroot定义安装或编译时使用的虚拟目录，建议使用默认值。</code></pre><h3 id="（6）脚本端"><a href="#（6）脚本端" class="headerlink" title="（6）脚本端"></a>（6）脚本端</h3><pre><code>%pre    ##安装前执行脚本%post   ##安装后执行脚本%preun  ##rpm包卸载前执行脚本%postun ##rpm包卸载后执行脚本</code></pre><h3 id="（7）打包时包含的文件"><a href="#（7）打包时包含的文件" class="headerlink" title="（7）打包时包含的文件"></a>（7）打包时包含的文件</h3><pre><code>%files  ##定义rpm包安装时创建的相关目录及文件%defattr (-,root,root,0755) ##设置默认权限%doc    ##文档</code></pre><h3 id="（8）记录SPEC修改日志段"><a href="#（8）记录SPEC修改日志段" class="headerlink" title="（8）记录SPEC修改日志段"></a>（8）记录SPEC修改日志段</h3><pre><code>%changelog  ##记录SPEC修改日志段；一定要以“*”开头，以“-”结尾。星期和月一定使用英文，并且是简写，否则会报错。</code></pre><p><strong>rpm包信息中最重要的是name、version、release，最后生成rpm名称形式为name-version-release.rpm</strong></p><p><strong>%config(noreplace)表示配置文件，且不能覆盖，新安装时如果配置文件存在则会将原文件保存为<code>*.rpmsave</code>,升级时则不会覆盖原文件，直接将包中的文件命名为<code>*.rpmnew</code>。</strong></p><h1 id="三、补充"><a href="#三、补充" class="headerlink" title="三、补充"></a>三、补充</h1><h3 id="（1）补充说明"><a href="#（1）补充说明" class="headerlink" title="（1）补充说明"></a>（1）补充说明</h3><p>|引用|描述<br>|%setup |仅将软件包打开<br>|%setup -n newdir|将软件包解压在newdir目录下<br>|%setup -c|解压缩之前先产生目录<br>|%setup -b num|将第num个source文件解压缩<br>|%setup -T |不使用default解压缩操作<br>|%setup -T -b 0|将第0个源代码文件解压缩<br>|%setup -D |解压前不删除目录<br>|%path 0|使用第0个补丁文件<br>|%path -s|不显示打补丁时的信息<br>|%path -T |将所有打补丁产生的输出文件删除</p><h3 id="（2）systemd脚本配置"><a href="#（2）systemd脚本配置" class="headerlink" title="（2）systemd脚本配置"></a>（2）systemd脚本配置</h3><h4 id="安装结束后，实际执行systemctl-preset"><a href="#安装结束后，实际执行systemctl-preset" class="headerlink" title="安装结束后，实际执行systemctl preset"></a>安装结束后，实际执行systemctl preset</h4><pre><code>%systemd_post SERVER.service</code></pre><h4 id="执行卸载前-systemctl-disable"><a href="#执行卸载前-systemctl-disable" class="headerlink" title="执行卸载前 systemctl disable"></a>执行卸载前 systemctl disable</h4><pre><code>%systemd_preun SERVER.service</code></pre><h4 id="卸载后执行重启操作，daemon-reloaded-try-restart"><a href="#卸载后执行重启操作，daemon-reloaded-try-restart" class="headerlink" title="卸载后执行重启操作，daemon-reloaded+try-restart"></a>卸载后执行重启操作，daemon-reloaded+try-restart</h4><pre><code>%systemd_postun_with_restart SERVER.service</code></pre><h4 id="如果不需要启动，执行systemctl-daemon-reload"><a href="#如果不需要启动，执行systemctl-daemon-reload" class="headerlink" title="如果不需要启动，执行systemctl  daemon-reload"></a>如果不需要启动，执行systemctl  daemon-reload</h4><pre><code>%systemd_postun SERVER.service</code></pre><h3 id="（3）define和global区别"><a href="#（3）define和global区别" class="headerlink" title="（3）define和global区别"></a>（3）define和global区别</h3><ul><li>define用来定义宏，global用来定义变量</li><li>如果定义带参数的宏，必须使用define</li><li>在<code>%{}</code>内部，必须要使用global而非define</li><li>define在使用时计算其值，而global则在定义时就计算其值</li></ul><h3 id="（4）变量使用"><a href="#（4）变量使用" class="headerlink" title="（4）变量使用"></a>（4）变量使用</h3><p>define定义的变量类似于局部变量，只在<code>%{!?foo:...}</code>区间有效，不过SPEC并不会自动清除该变量，只有再次遇到<code>%{}</code>时才会清除。</p><p>如果在命令行汇总通过<code>--define &#39;with_ssl bundled&#39;</code>进行定义，在SPEC脚本中，使用<code>%{?with_ssl:}</code>处理上述参数，或者通过<code>%{!?with_ssl:}</code>处理未定义参数时的情况。</p><p>在RPM中，‘？’用于条件检测，默认如果对应的变量值不存在，那么RPM会原样保留字符串，如果不存在则删除。</p><h3 id="（5）初始宏定义"><a href="#（5）初始宏定义" class="headerlink" title="（5）初始宏定义"></a>（5）初始宏定义</h3><p>在定义文件的安装路径时，通常会使用类似<code>%_</code>的宏，这些宏一般会在<code>/usr/lib/rpm/macros</code>中定义。</p><p>很多的宏存放在<code>/etc/rpm</code>目录下定义的。</p><h3 id="（6）配置文件"><a href="#（6）配置文件" class="headerlink" title="（6）配置文件"></a>（6）配置文件</h3><table><thead><tr><th>配置文件</th><th>描述</th></tr></thead><tbody><tr><td>/usr/share/doc/rpm-VERSION/GROUPS</td><td>rpm软件包系统的标准分组</td></tr><tr><td>/usr/lib/rpm/macros</td><td>各种宏定义</td></tr><tr><td>/var/lib/rpm</td><td>已经安装rpm包数据库</td></tr></tbody></table><h1 id="四、示例"><a href="#四、示例" class="headerlink" title="四、示例"></a>四、示例</h1><h2 id="（1）使用普通用户"><a href="#（1）使用普通用户" class="headerlink" title="（1）使用普通用户"></a>（1）使用普通用户</h2><p><code>[root@node1~]#useradd rpmbuild</code><br><code>[root@node1~]#su - rpmbuild</code></p><h2 id="（2）创建所需目录"><a href="#（2）创建所需目录" class="headerlink" title="（2）创建所需目录"></a>（2）创建所需目录</h2><p><code>[rpmbuild@node1~/rpmbuild]$rpmbuild --showrc |grep topdir</code></p><pre><code>-14: _builddir    %{_topdir}/BUILD-14: _buildrootdir    %{_topdir}/BUILDROOT-14: _rpmdir    %{_topdir}/RPMS-14: _sourcedir    %{_topdir}/SOURCES-14: _specdir    %{_topdir}/SPECS-14: _srcrpmdir    %{_topdir}/SRPMS</code></pre><p><code>[rpmbuild@node1~]$mkdir rpmbuild/{SPECS,SOURCES,BUILD,RPMS,SRPMS} -pv</code></p><h2 id="（3）上传所要制作的包"><a href="#（3）上传所要制作的包" class="headerlink" title="（3）上传所要制作的包"></a>（3）上传所要制作的包</h2><p><code>[rpmbuild@node1~/rpmbuild]$tree</code></p><pre><code>.├── BUILD├── RPMS├── SOURCES│   └── nginx-1.12.2.tar.gz├── SPECS└── SRPMS</code></pre><h2 id="（4）构建SPEC文件"><a href="#（4）构建SPEC文件" class="headerlink" title="（4）构建SPEC文件"></a>（4）构建SPEC文件</h2><p><strong>注意：使用<code>.spec</code>后缀，编辑文件会自动生成模板文件。</strong></p><p><code>[rpmbuild@node1~/rpmbuild/SPECS]$vim nginx.spec</code></p><pre><code> %define realname nginx%define realver  1.4.2%define srcext   tar.gz%define page_speed_commit cd80e92%define psolver           1.6.29.3%if 0%{?suse_version}%define USER   wwwrun%define GROUP  www%define PREFIX /srv/www%define WEB_USER_HOME /var/lib/lighttpd%else%define USER   apache%define GROUP  apache%define PREFIX /var/www%define WEB_USER_HOME /var/www%endif%define CONF_FILE %{_sysconfdir}/%{name}/%{name}.conf# Common infoName:          %{realname}Version:       %{realver}Release:       16.1License:       BSD-2-ClauseGroup:         Productivity/Networking/Web/ServersURL:           http://nginx.org/Summary:       HTTP and reverse proxy server, as well as a mail proxy server# Install-time parametersProvides:      httpd http_daemon webserver %{?suse_version:suse_help_viewer}Requires:      logrotate# Build-time parametersBuildRequires: gcc-c++ libstdc++-develBuildRequires: dos2unixBuildRequires: zlib-devel openssl-devel pcre-develBuildRequires: libxml2-devel libxslt-devel gd-devel libGeoIP-devel%if 0%{?suse_version} || 0%{?fedora} || 0%{?rhel_version} || 0%{?centos_version} &gt;= 600BuildRequires: libaio-devel%endifBuildRoot:     %{_tmppath}/%{name}-rootSource0:       http://nginx.org/download/%{realname}-%{realver}%{?extraver}.%{srcext}Source1:       nginx.logrotateSource2:       nginx.initSource3:       nginx.sysconfigSource91:      https://github.com/pagespeed/ngx_pagespeed/tarball/%{page_speed_commit}/pagespeed-ngx_pagespeed-%{page_speed_commit}.tar.gzSource92:      https://dl.google.com/dl/page-speed/psol/%{psolver}.tar.gzPatch:         nginx-memset_zero.patch#!BuildIgnore: freetype2%descriptionnginx [engine x] is a HTTP and reverse proxy server, as well as a mail proxy serverThis nginx package built with Google PageSpeed# Preparation step (unpackung and patching if necessary)%prep%setup -q -n %{realname}-%{realver}%{?extraver} -a91%{__tar} -zxf %{S:92} -C pagespeed-ngx_pagespeed-%{page_speed_commit}%patch -p1%build./configure \ --prefix=%{PREFIX} \ --sbin-path=%{_sbindir}/%{name} \ --conf-path=%{CONF_FILE} \ --error-log-path=%{_localstatedir}/log/%{name}/error.log \ --http-log-path=%{_localstatedir}/log/%{name}/access.log \ --pid-path=%{_localstatedir}/run/%{name}.pid \ --lock-path=%{_localstatedir}/lock/%{name}.lock \ --user=%{USER} \ --group=%{GROUP} \ \ --http-client-body-temp-path=%{_localstatedir}/cache/%{name}/client_body_temp \ --http-proxy-temp-path=%{_localstatedir}/cache/%{name}/proxy_temp \ --http-fastcgi-temp-path=%{_localstatedir}/cache/%{name}/fastcgi_temp \ --http-uwsgi-temp-path=%{_localstatedir}/cache/%{name}/uwsgi_temp \ --http-scgi-temp-path=%{_localstatedir}/cache/%{name}/scgi_temp \%if 0%{?suse_version} || 0%{?fedora} || 0%{?rhel_version} || 0%{?centos_version} &gt;= 600 --with-file-aio \%endif --with-ipv6 \ \ --with-http_ssl_module \ --with-http_spdy_module \ --with-http_realip_module \ --with-http_addition_module \ --with-http_xslt_module \ --with-http_image_filter_module \ --with-http_geoip_module \ --with-http_sub_module \ --with-http_dav_module \ --with-http_flv_module \ --with-http_mp4_module \ --with-http_gzip_static_module \ --with-http_random_index_module \ --with-http_secure_link_module \ --with-http_degradation_module \ --with-http_stub_status_module \ \ --with-mail \ --with-mail_ssl_module \ \ --with-cc-opt=&quot;%{optflags}&quot; \ --with-ld-opt=&quot;-Wl,--as-needed -Wl,--strip-all&quot; \ \ --with-pcre \ --with-pcre-jit \ --add-module=%{_builddir}/%{realname}-%{realver}%{?extraver}/pagespeed-ngx_pagespeed-%{page_speed_commit}%__make %{?_smp_mflags}%install%__make install DESTDIR=%{buildroot}iconv -f koi8-r CHANGES.ru &gt; c &amp;&amp; %__mv -f c CHANGES.ru%__install -D -m644 man/nginx.8 %{buildroot}%{_mandir}/man8/nginx.8%__install -D -m644 %{S:1} %{buildroot}%{_sysconfdir}/logrotate.d/%{name}%__install -d -m755 %{buildroot}%{_initrddir}sed -r &#39;s|##PREFIX##|%{PREFIX}|; s|##CONF_FILE##|%{CONF_FILE}|&#39; %{S:2} &gt; %{buildroot}%{_initrddir}/%{name}%__rm -f %{buildroot}%{PREFIX}/html/index.html%if %{expand:%_vendor == &quot;suse&quot;}%__mv %{buildroot}%{PREFIX}/html %{buildroot}%{PREFIX}/htdocs%__install -d -m755 %{buildroot}/var/adm/fillup-templatessed -r &#39;s|##PREFIX##|%{PREFIX}|; s|##CONF_FILE##|%{CONF_FILE}|&#39; %{S:3} &gt; %{buildroot}/var/adm/fillup-templates/sysconfig.%{name}%__ln_s -f %{_initrddir}/%{name} %{buildroot}%{_sbindir}/rc%{name}dos2unix contrib/geo2nginx.pl%__install -D -m755 contrib/geo2nginx.pl %{buildroot}%{_bindir}/geo2nginx.pl%else%__install -d -m755 %{buildroot}/%{_sysconfdir}/sysconfigsed -r &#39;s|##PREFIX##|%{PREFIX}|; s|##CONF_FILE##|%{CONF_FILE}|&#39; %{S:3} &gt; %{buildroot}/%{_sysconfdir}/sysconfig/%{name}%endif%__install -d -m755 %{buildroot}%{_localstatedir}/cache/%{name}%clean[ &quot;%{buildroot}&quot; != &quot;/&quot; ] &amp;&amp; rm -rf %{buildroot}%files%defattr(-,root,root)%doc CHANGES CHANGES.ru LICENSE README%dir %{_sysconfdir}/%{name}%config(noreplace) %{_sysconfdir}/%{name}/*%config(noreplace) %{_sysconfdir}/logrotate.d/%{name}%{_sbindir}/nginx%attr(0755,root,root) %{_initrddir}/%{name}%dir %attr(0755,%{USER},%{GROUP}) %{_localstatedir}/log/%{name}%if %{expand:%_vendor == &quot;suse&quot;}%{_bindir}/geo2nginx.pl%{_sbindir}/rcnginx%{PREFIX}/htdocs/*/var/adm/fillup-templates/sysconfig.%{name}%else%{PREFIX}/html/*%config(noreplace) %{_sysconfdir}/sysconfig/%{name}%endif%doc %{_mandir}/man8/*%dir %attr(0755,%{USER},%{GROUP}) %{_localstatedir}/cache/%{name}%pre/usr/sbin/groupadd -r %{GROUP} &amp;&gt;/dev/null ||:/usr/sbin/useradd  -g %{GROUP} -s /bin/false -r -c &quot;Web-server&quot; -d %{WEB_USER_HOME} %{USER} &amp;&gt;/dev/null ||:%if 0%{?suse_version}%post%{fillup_and_insserv %{name}}%preun%{stop_on_removal %{name}}rm -rf %{_localstatedir}/cache/%{name}/*%postun%{restart_on_update %{name}}%{insserv_cleanup}%else%preunrm -rf %{_localstatedir}/cache/%{name}/*%endif%changelog</code></pre><h2 id="（5）生成rpm测试"><a href="#（5）生成rpm测试" class="headerlink" title="（5）生成rpm测试"></a>（5）生成rpm测试</h2><p><code>[rpmbuild@node1~/rpmbuild/SPECS]$rpmbuild -bb nginx.spec</code></p><p><strong>参考</strong>：<br><a href="https://jin-yang.github.io/post/linux-create-rpm-package.html" target="_blank" rel="noopener">https://jin-yang.github.io/post/linux-create-rpm-package.html</a></p><p><a href="http://blog.51cto.com/laoguang/1103628" target="_blank" rel="noopener">http://blog.51cto.com/laoguang/1103628</a></p><p><a href="http://hlee.iteye.com/blog/343499" target="_blank" rel="noopener">http://hlee.iteye.com/blog/343499</a></p>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rpm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jumpserver</title>
      <link href="/2017/12/17/Jumpserver/"/>
      <url>/2017/12/17/Jumpserver/</url>
      
        <content type="html"><![CDATA[<p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-17_181102.jpg" alt=""></p><h1 id="一、Jumpserver"><a href="#一、Jumpserver" class="headerlink" title="一、Jumpserver"></a>一、Jumpserver</h1><p>Jumpserver是一款实用Python，Django开发的开源跳板机系统，为互联网提供了认证、授权、审计、自动化运维等功能。基于ssh协议来管理，客户端无需安装agent。</p><h2 id="1、Jumpserver工作原理"><a href="#1、Jumpserver工作原理" class="headerlink" title="1、Jumpserver工作原理"></a>1、Jumpserver工作原理</h2><p><img src="http://owatlfstl.bkt.clouddn.com/jumpserver.png" alt=""></p><ul><li>（1）运维人员在操作过程中首先连接到堡垒机，然后向堡垒机提交操作请求</li><li>（2）请求通过堡垒机的授权检查后，堡垒机的应用代理模块将替代用户连接到目标主机完成操作，之后目标主机将操作结果返回给堡垒机，再将结果返回给运维人员。</li></ul><h2 id="2、Jumpserver特点"><a href="#2、Jumpserver特点" class="headerlink" title="2、Jumpserver特点"></a>2、Jumpserver特点</h2><ul><li>完全开源，GPL授权</li><li>实现了跳板机基本功能，认证、授权和审计</li><li>集成了Ansible，批量命令</li><li>自动收集硬件信息</li><li>录像回放</li><li>实时监控</li><li>批量上传和下载</li></ul><h2 id="3、Jumpserver名词解释"><a href="#3、Jumpserver名词解释" class="headerlink" title="3、Jumpserver名词解释"></a>3、Jumpserver名词解释</h2><ul><li><p>用户管理：</p><ul><li>用户组，多个用户可以组合成用户组，为了方便授权，可以将一个部门或几个部门几个用户组件成用户组，在授权中使用组授权，该组中的用户拥有所有授权的主机权限</li><li>用户，授权和登录的实体</li></ul></li><li><p>资产管理</p><ul><li>资产组，主机组、同用户组，是资产组成的集合，为了方便授权</li><li>资产，通常是服务器、网络设备</li><li>管理账号，添加资产时需要添加一个管理账户，该账户时该资产上已有的有管理权限的用户</li></ul></li></ul><h1 id="二、Jumpserver安装及文件详解"><a href="#二、Jumpserver安装及文件详解" class="headerlink" title="二、Jumpserver安装及文件详解"></a>二、Jumpserver安装及文件详解</h1><h2 id="1、Jumpserver安装"><a href="#1、Jumpserver安装" class="headerlink" title="1、Jumpserver安装"></a>1、Jumpserver安装</h2><p><code>[root@node1~]#yum install -y git</code>  #安装git工具</p><p><code>[root@node1~]#git clone https://github.com/jumpserver/jumpserver.git</code></p><p><strong>建议：不要安装在/root、/home目录下，以免权限问题。</strong></p><p><code>[root@node1~/jumpserver/install]#git checkout master</code></p><pre><code>Branch master set up to track remote branch master from origin.Switched to a new branch &#39;master&#39;</code></pre><p><strong>注意：执行完此条命令需退出重新切换进去。</strong></p><p><code>[root@node1~/jumpserver/install]#python install.py</code>   #安装<br><img src="http://owatlfstl.bkt.clouddn.com/2017-12-17_191426.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-21_101037.jpg" alt=""></p><h4 id="登录邮箱查看是否收到邮件"><a href="#登录邮箱查看是否收到邮件" class="headerlink" title="登录邮箱查看是否收到邮件"></a>登录邮箱查看是否收到邮件</h4><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-21_101204.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-17_202320.jpg" alt=""></p><h2 id="2、登录"><a href="#2、登录" class="headerlink" title="2、登录"></a>2、登录</h2><p>地址栏输入：<a href="http://192.168.4.61:8000" target="_blank" rel="noopener">http://192.168.4.61:8000</a></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-17_202453.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-17_202710.jpg" alt=""></p><h2 id="3、简单介绍"><a href="#3、简单介绍" class="headerlink" title="3、简单介绍"></a>3、简单介绍</h2><h3 id="（1）添加用户组"><a href="#（1）添加用户组" class="headerlink" title="（1）添加用户组"></a>（1）添加用户组</h3><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-17_202848.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-17_203007.jpg" alt=""></p><h3 id="（2）添加用户"><a href="#（2）添加用户" class="headerlink" title="（2）添加用户"></a>（2）添加用户</h3><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-17_203049.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-17_203206.jpg" alt=""></p><h3 id="（3）资产组"><a href="#（3）资产组" class="headerlink" title="（3）资产组"></a>（3）资产组</h3><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-18_090729.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-18_090937.jpg" alt=""></p><h3 id="（4）资产管理"><a href="#（4）资产管理" class="headerlink" title="（4）资产管理"></a>（4）资产管理</h3><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-18_091041.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-18_092611.jpg" alt=""></p><h3 id="（5）机房管理"><a href="#（5）机房管理" class="headerlink" title="（5）机房管理"></a>（5）机房管理</h3><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-18_091840.jpg" alt=""></p><h2 id="（6）系统用户"><a href="#（6）系统用户" class="headerlink" title="（6）系统用户"></a>（6）系统用户</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-18_094926.jpg" alt=""></p><h2 id="（7）授权规则"><a href="#（7）授权规则" class="headerlink" title="（7）授权规则"></a>（7）授权规则</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-21_101642.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 跳板机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jumpserver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MogileFS</title>
      <link href="/2017/12/16/MogileFS/"/>
      <url>/2017/12/16/MogileFS/</url>
      
        <content type="html"><![CDATA[<h1 id="一、分布式文件系统"><a href="#一、分布式文件系统" class="headerlink" title="一、分布式文件系统"></a>一、分布式文件系统</h1><p>分布式文件系统是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连，即集群文件系统，可以支持大量的节点以及PB级的数量存储。</p><h2 id="1、分布式文件系统类别"><a href="#1、分布式文件系统类别" class="headerlink" title="1、分布式文件系统类别"></a>1、分布式文件系统类别</h2><table><thead><tr><th>名称</th><th>特性</th></tr></thead><tbody><tr><td>MogileFS</td><td>适用于处理海量的小文件</td></tr><tr><td>Ceph</td><td>一个Linux PB级别的分布式文件系统</td></tr><tr><td>MooseFS</td><td>通用简便，适用于研发能力不强的公司</td></tr><tr><td>Taobao Filesystem</td><td>适用于处理海量小文件</td></tr><tr><td>ClusterFS</td><td>适用于处理单个大文件</td></tr><tr><td>Google Filesystem</td><td>GFS+MapReduce擅长处理单个大文件</td></tr><tr><td>Hadoop Distributed Filesytem</td><td>擅长处理单个大文件</td></tr></tbody></table><h2 id="2、分布式文件系统特点"><a href="#2、分布式文件系统特点" class="headerlink" title="2、分布式文件系统特点"></a>2、分布式文件系统特点</h2><ul><li>节点间能相互通信</li><li>同一数据存储在多个节点上</li><li>数据空间平衡</li><li>具有容错能力</li><li>文件系统支持</li></ul><h2 id="3、CAP理论"><a href="#3、CAP理论" class="headerlink" title="3、CAP理论"></a>3、CAP理论</h2><ul><li>C（Consistency）：任何一个读写操作总是能够读取之前完成写操作</li><li>A（Availability）：每一次操作总是能够在确定的时候返回，无论成功或失败都能够收到一个返回值</li><li>P（Tolerance of network Parition）：在出现网络分区的情况下，仍然能够满足一致性和可用性</li></ul><h1 id="二、MogileFS"><a href="#二、MogileFS" class="headerlink" title="二、MogileFS"></a>二、MogileFS</h1><p>MogileFS是一款开源的分布式文件存储系统，由LiveJournal旗下的Danga Interactive公司开发。</p><h2 id="1、MogileFS组成"><a href="#1、MogileFS组成" class="headerlink" title="1、MogileFS组成"></a>1、MogileFS组成</h2><ul><li><p>server：主要包括mogilefsd和mogstored两个应用程序。监听端口与7001</p><ul><li>mogilefsd实现的是tracker，它是一个调度器；主要用于Replication，Deletion，Query，Reaper，Moinitor等，这个是基于事件父进程/消息总线来管理所有来之于客户端应用的交互，包括将请求负载平衡到多个“query workers”中，然后让MogileFS的子进程去处理。</li><li>mogstored是存储节点，它其实是WebDAV服务，默认监听在7501端口，接受客户端的文件存储请求。一台存储主要都要启动一个mogstored服务，廓清就是增加这些机器，实际文件存放地方。</li></ul></li><li><p>MySQL：用来存放MogileFS的元数据，是Tracker来操作和管理它，可以用mogdbsetup程序来初始化数据库，因为数据保存了MogileFS的所有元数据，建议做成HA结构。</p></li></ul><p><strong>注意：在MogileFS安装完后，要运行mogadm工具将所有的存储节点注册到mogilefsd的数据库中，mogilefsd会对这些节点进行管理和监控。</strong></p><ul><li><p>utils（工具集）：主要是MogileFS的一些管理工具，如mogadm</p></li><li><p>客户端API：MogileFS的客户端API很多，例如Perl、PHP、Java等，用这些模块可以编写客户端程序，实现文件的备份管理功能等。</p></li></ul><h2 id="2、MogileFS特性"><a href="#2、MogileFS特性" class="headerlink" title="2、MogileFS特性"></a>2、MogileFS特性</h2><ul><li>支持多节点冗余</li><li>可实现自动文件复制</li><li>使用名称空间，每个文件通过key来确定</li><li>不需要RAID，应用层可以直接实现RAID，不共享任何东西，通过“集群”接口提供服务</li><li>工作于应用层，没有特殊的组件要求</li><li>不共享任何数据，MogileFS不需要依靠昂贵的SAN来共享磁盘，每个汲取只用于维护好自己的磁盘。</li></ul><h2 id="3、MogileFS管理几个概念"><a href="#3、MogileFS管理几个概念" class="headerlink" title="3、MogileFS管理几个概念"></a>3、MogileFS管理几个概念</h2><ul><li>Domain：一个MogileFS可以有多个Domain，用来存放不同文件，同一个Domain内key必须唯一，不同Domain内，key可以相同</li><li>每一个存储节点称为一个主机host，一个主机可以有多个存储设备dev，每个设备都有ID号，Domain+FID用来定位文件。设备不能删除的，只能将其设备的状态的值为dead，当一个设备dead之后，就真的dead了，里面的数据也无法恢复了，且这个dead了的设备ID也不能使用了。</li><li>Class：文件属性管理，定位文件存储在不同设备上的分数</li></ul><h2 id="4、MogileFS工作原理"><a href="#4、MogileFS工作原理" class="headerlink" title="4、MogileFS工作原理"></a>4、MogileFS工作原理</h2><p><img src="http://owatlfstl.bkt.clouddn.com/mogilefs.jpg" alt=""></p><ul><li>（1）应用程序请求打开一个文件，做一个“create_open”请求</li><li>（2）tracker做一些负载均衡处理，决定应该去哪儿，然后给应用程序一些可能用的位置信息</li><li>（3）应用程序写到其中一个位置上去</li><li>（4）应用程序通过“create_close”告诉tracker文件写到哪里</li><li>（5）tracker将名称和域的空间管理</li><li>（6）tracker在后台开始复制文件，知道他满足该文件类别设定的复制规则</li><li>（7）应用程序通过“get_path”请求domain+key文件，tracker基于每一位的I/O繁忙情况回复，该文件可用的完整URL地址列表</li><li>（8）应用程序然后按顺序尝试这些URL地址</li></ul><h1 id="三、MogileFS安装及文件介绍"><a href="#三、MogileFS安装及文件介绍" class="headerlink" title="三、MogileFS安装及文件介绍"></a>三、MogileFS安装及文件介绍</h1><h2 id="1、MogileFS安装"><a href="#1、MogileFS安装" class="headerlink" title="1、MogileFS安装"></a>1、MogileFS安装</h2><table><thead><tr><th>安装包</th><th>描述</th></tr></thead><tbody><tr><td>MogileFS-Server.noarch 0:2.46-2.el7.centos</td><td>核心服务                                                   </td></tr><tr><td>MogileFS-Server-mogilefsd.noarch 0:2.46-2.el7.centos</td><td>tracker节点                                        </td></tr><tr><td>MogileFS-Server-mogstored.noarch 0:2.46-2.el7.centos</td><td>存储节点                                      </td></tr><tr><td>MogileFS-Utils.noarch 0:2.19-1.el7.centos</td><td>MogileFS管理工具                                                    </td></tr><tr><td>perl-Danga-Socket.noarch 0:1.61-1.el6.rf</td><td>socket                                           </td></tr><tr><td>perl-MogileFS-Client.noarch 0:1.14-1.el7.centos</td><td>客户端                                      </td></tr><tr><td>perl-Perlbal.noarch 0:1.78-1.el6</td><td>库包</td></tr></tbody></table><p>将上述的包上传至本地安装</p><p><code>[root@node1~]#yum localinstall -y *.rpm</code>   </p><h2 id="2、MogileFS-Server-mogilefsd安装包文件"><a href="#2、MogileFS-Server-mogilefsd安装包文件" class="headerlink" title="2、MogileFS-Server-mogilefsd安装包文件"></a>2、MogileFS-Server-mogilefsd安装包文件</h2><table><thead><tr><th>文件</th><th>描述</th></tr></thead><tbody><tr><td><code>/etc/mogilefs/mogilefsd.conf</code></td><td>主配置文件</td></tr><tr><td><code>/etc/rc.d/init.d/mogilefsd</code></td><td>启动程序</td></tr><tr><td><code>/usr/bin/mogdbsetup</code></td><td>数据库初始化工具</td></tr></tbody></table><h3 id="etc-mogilefsd-conf配置文件详解"><a href="#etc-mogilefsd-conf配置文件详解" class="headerlink" title="/etc/mogilefsd.conf配置文件详解"></a><code>/etc/mogilefsd.conf</code>配置文件详解</h3><pre><code>  1 # Enable daemon mode to work in background and use syslog  2 daemonize = 1   #是否启动守护进程  3 # Where to store the pid of the daemon (must be the same in the init script)  4 pidfile = /var/run/mogilefsd/mogilefsd.pid  #pid文件存放位置  5 # Database connection information  6 db_dsn = DBI:mysql:mogilefs:host=127.0.0.1  #数据库连接地址  7 db_user = username  #数据库名称  8 db_pass = password  #数据库密码  9 # IP:PORT to listen on for mogilefs client requests 10 listen = 127.0.0.1:7001 #监听地址及端口 11 # Optional, if you don&#39;t define the port above. 12 conf_port = 7001 13 # Number of query workers to start by default. 14 query_jobs = 10 #工作线程 15 # Number of delete workers to start by default. 16 delete_jobs = 1 #删除工作线程 17 # Number of replicate workers to start by default. 18 replicate_jobs = 5  #复制数量 19 # Number of reaper workers to start by default. 20 # (you don&#39;t usually need to increase this) 21 reaper_jobs = 1 22 # Number of fsck workers to start by default. 23 # (these can cause a lot of load when fsck&#39;ing) 24 #fsck_jobs = 1  #检查 25 # Minimum amount of space to reserve in megabytes 26 # default: 100 27 # Consider setting this to be larger than the largest file you 28 # would normally be uploading. 29 #min_free_space = 200 30 # Number of seconds to wait for a storage node to respond. 31 # default: 2 32 # Keep this low, so busy storage nodes are quickly ignored. 33 #node_timeout = 2   #超时时长 34 # Number of seconds to wait to connect to a storage node. 35 # default: 2 36 # Keep this low so overloaded nodes get skipped. 37 #conn_timeout = 2   #连接超时时长</code></pre><h2 id="3、MogileFS-Server-mogstored安装包文件"><a href="#3、MogileFS-Server-mogstored安装包文件" class="headerlink" title="3、MogileFS-Server-mogstored安装包文件"></a>3、MogileFS-Server-mogstored安装包文件</h2><table><thead><tr><th>文件</th><th>描述</th></tr></thead><tbody><tr><td><code>/etc/mogilefs/mogstored.conf</code></td><td>主配置文件</td></tr><tr><td><code>/etc/rc.d/init.d/mogstored</code></td><td>启动程序</td></tr></tbody></table><h3 id="etc-mogilefs-mogstored-conf详解"><a href="#etc-mogilefs-mogstored-conf详解" class="headerlink" title="/etc/mogilefs/mogstored.conf详解"></a><code>/etc/mogilefs/mogstored.conf</code>详解</h3><pre><code>  1 maxconns = 10000    #最大连接数量  2 httplisten = 0.0.0.0:7500   #http监听的地址及端口  3 mgmtlisten = 0.0.0.0:7501   #mogilefs管理端口  4 docroot = /var/mogdata  #数据存放位置</code></pre><h2 id="4、mogdbsetup命令"><a href="#4、mogdbsetup命令" class="headerlink" title="4、mogdbsetup命令"></a>4、mogdbsetup命令</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><pre><code>Usage: mogdbsetup [opts]</code></pre><table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>–dbhost</td><td>localhost</td><td>数据库主机IP或主机名</td></tr><tr><td>–dbport</td><td>dbd default</td><td>数据库端口</td></tr><tr><td>–dbname</td><td>mogilefs</td><td>数据库名称</td></tr><tr><td>–dbrootuser</td><td>root</td><td>数据库用户</td></tr><tr><td>–dbrootpass</td><td><blank></blank></td><td>数据库密码</td></tr><tr><td>–dbuser</td><td>mogile</td><td>数据库dbname使用者</td></tr><tr><td>–dbpass</td><td><blank></blank></td><td>数据库密码</td></tr><tr><td>–type</td><td>MySQL</td><td>数据库类型</td></tr></tbody></table><h2 id="5、mogstored命令"><a href="#5、mogstored命令" class="headerlink" title="5、mogstored命令"></a>5、mogstored命令</h2><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><pre><code>Usage: mogstored [OPTS]</code></pre><p>|选项|描述<br>|–daemonize，-d|是否守护进行运行<br>|–config|指定配置文件，默认为<code>/etc/mogilefs/mogstored.conf</code><br>|–httplisten=<ip:port>|HTTP服务监听地址和端口<br>|–docroot|数据存储位置，默认为<code>/var/mogdata</code><br>|–maxconns|最大连接数</ip:port></p><h2 id="6、mogadm命令"><a href="#6、mogadm命令" class="headerlink" title="6、mogadm命令"></a>6、mogadm命令</h2><ul><li>mogadm host 管理主机节点<ul><li>host add 添加主机到MogileFS</li><li>host delete 删除</li><li>host list 列出所有节点</li><li>host mark 标记主机节点状态</li><li>host modify 修改属性</li></ul></li><li>mogadm device 管理设备<ul><li>device add 添加设备到一个主机中</li><li>device list 列出所有设备从每个主机中</li><li>device marik 标记设备状态（alive、dead、down、drain、readonly）</li><li>device modify 修改设备属性</li><li>device next 显示下一个可用设备</li></ul></li><li>mogadm domain 管理域<ul><li>domain add 添加一个域</li><li>domain delete 删除一个域</li><li>domain list 列出所有</li></ul></li><li>mogadm class 管理文件属性<ul><li>class add 添加一个文件属性到域中</li><li>class delete 删除一个属性</li><li>class list 列出所有</li><li>class modify 修改属性</li></ul></li><li>mogadm fsck 检测<ul><li>fsck clearlog 清除检测日志</li><li>fsck printlog 显示检测日志</li><li>fsck status 显示检测状态</li></ul></li></ul><h2 id="7、mogupload命令"><a href="#7、mogupload命令" class="headerlink" title="7、mogupload命令"></a>7、mogupload命令</h2><h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h3><pre><code>mogupload --trackers=host --domain=foo --class=bar  --key=&quot;/hello.jpg&quot; --file=&quot;input.jpg&quot;</code></pre><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>–trackers=host:7001,host2:7002</td><td>指定trakcers</td></tr><tr><td>–domain</td><td>指定域</td></tr><tr><td>–key</td><td>指定key</td></tr><tr><td>–file</td><td>指定文件，如果使用“-”，读文件标准输入</td></tr></tbody></table><h1 id="四、MogileFS集群构建"><a href="#四、MogileFS集群构建" class="headerlink" title="四、MogileFS集群构建"></a>四、MogileFS集群构建</h1><table><thead><tr><th>主机名</th><th>IP地址</th><th>功用</th><th>安装的包</th></tr></thead><tbody><tr><td>node1</td><td>192.168.4.61</td><td>tracker、storged、mogilefsd</td><td>MogileFS-Server-2.46-2.el7.centos.noarch.rpm 、MogileFS-Server-mogilefsd-2.46-2.el7.centos.noarch.rpm、 MogileFS-Server-mogstored-2.46-2.el7.centos.noarch.rpm 、MogileFS-Utils-2.19-1.el7.centos.noarch.rpm perl-Danga-Socket-1.61-1.el6.rf.noarch.rpm、 perl-MogileFS-Client-1.14-1.el7.centos.noarch.rpm 、perl-Perlbal-1.78-1.el6.noarch.rpm</td></tr><tr><td>node2</td><td>192.168.4.62</td><td>storged、mogilefsd</td><td>MogileFS-Server-mogstored-2.46-2.el7.centos.noarch.rpm 、perl-Danga-Socket-1.61-1.el6.rf.noarch.rpm 、perl-MogileFS-Client-1.14-1.el7.centos.noarch.rpm 、perl-Perlbal-1.78-1.el6.noarch.rpm</td></tr><tr><td>node3</td><td>192.168.4.63</td><td>storged、mogilefsd</td><td>MogileFS-Server-mogstored-2.46-2.el7.centos.noarch.rpm 、perl-Danga-Socket-1.61-1.el6.rf.noarch.rpm、 perl-MogileFS-Client-1.14-1.el7.centos.noarch.rpm 、perl-Perlbal-1.78-1.el6.noarch.rpm</td></tr></tbody></table><p><strong>注意：一定要同步时间，否则复制时会报错。</strong></p><h3 id="（1）安装所需要的包"><a href="#（1）安装所需要的包" class="headerlink" title="（1）安装所需要的包"></a>（1）安装所需要的包</h3><p><code>[root@node1~]#yum install perl-Net-Netmask perl-IO-string perl-Sys-Syslog perl-IO-AIO -y</code> 三个节点都安装</p><p><code>[root@node1~]#yum localinstall -y *.rpm</code></p><p><code>[root@node2~]#yum localinstall -y *.rpm</code></p><p><code>[root@node3~]#yum localinstall -y *.rpm</code></p><h3 id="（2）node1节点上配置MySQL"><a href="#（2）node1节点上配置MySQL" class="headerlink" title="（2）node1节点上配置MySQL"></a>（2）node1节点上配置MySQL</h3><p><code>[root@node1~]#yum install -y mariadb-server</code></p><p><code>[root@node1~]#systemctl start mariadb.service</code></p><h4 id="授权用户"><a href="#授权用户" class="headerlink" title="授权用户"></a>授权用户</h4><p><code>MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;mogile&#39;@&#39;127.0.0.1&#39; IDENTIFIED BY &#39;mogile&#39; WITH GRANT OPTION;</code>  </p><p><code>MariaDB [(none)]&gt; FLUSH PRIVILEGES;</code></p><h4 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h4><p><code>[root@node1~]#mogdbsetup --dbhost=127.0.0.1 --dbpass=mogile</code></p><pre><code>This will attempt to setup or upgrade your MogileFS database.It won&#39;t destroy existing data.Run with --help for more information.  Run with --yes to shut up these prompts. #询问是否继续Continue? [N/y]: yCreate/Upgrade database name    &#39;mogilefs&#39;? [Y/n]: y    #是否创建数据库名为mogilefsGrant all privileges to user &#39;mogile&#39;, connecting from anywhere, to the mogilefs database &#39;mogilefs&#39;? [Y/n]: y  #是否所有权限给用户mogile</code></pre><h3 id="（3）修改mogilefsd-conf配置文件"><a href="#（3）修改mogilefsd-conf配置文件" class="headerlink" title="（3）修改mogilefsd.conf配置文件"></a>（3）修改<code>mogilefsd.conf</code>配置文件</h3><pre><code>daemonize = 1pidfile = /var/run/mogilefsd/mogilefsd.piddb_dsn = DBI:mysql:mogilefs:host=127.0.0.1  #修改数据库连接地址db_user = mogile    #数据库使用者db_pass = mogile    #数据库密码listen = 127.0.0.1:7001     #修改mogilefsd监听的地址和端口conf_port = 7001query_jobs = 10delete_jobs = 1replicate_jobs = 5reaper_jobs = 1</code></pre><h3 id="（4）启动mogilefsd服务"><a href="#（4）启动mogilefsd服务" class="headerlink" title="（4）启动mogilefsd服务"></a>（4）启动mogilefsd服务</h3><p><code>[root@node1~]#systemctl status mogilefsd.service</code></p><h3 id="（5）启动mogstored服务"><a href="#（5）启动mogstored服务" class="headerlink" title="（5）启动mogstored服务"></a>（5）启动mogstored服务</h3><p><code>[root@node1~]#mkdir -pv /data/mogilefs/</code></p><p><code>[root@node1~]#chown -R mogilefs.mogilefs /data/mogilefs</code></p><p><code>[root@node1~]#vim /etc/mogilefs/mogstored.conf</code></p><pre><code>  1 maxconns = 10000  2 httplisten = 0.0.0.0:7500  3 mgmtlisten = 0.0.0.0:7501  4 docroot = /data/mogilefs</code></pre><p><code>[root@node1~]#service mogstored start</code></p><h3 id="（6）node2和node3安装"><a href="#（6）node2和node3安装" class="headerlink" title="（6）node2和node3安装"></a>（6）node2和node3安装</h3><p><code>[root@node3~]#mkdir -pv /data/mogilefs</code></p><p><code>[root@node3~]#chown -R mogilefs.mogilefs /data/mogilefs/</code><br><code>[root@node3~]#systemctl status mogstored</code></p><h1 id="五、MogileFS管理"><a href="#五、MogileFS管理" class="headerlink" title="五、MogileFS管理"></a>五、MogileFS管理</h1><p>mogstored程序启动使主机本身成为一个存储节点，mogstored的启动后，需要使用mogadm管理工具将当前的主机加入到MogileFS的系统中。</p><p><strong>注意：存储节点中还需要添加设备，每个设备有一个uuiq的ID号，同样也需要使用mogadm加入到MogileFS系统中。</strong></p><h2 id="1、添加主机到tracker"><a href="#1、添加主机到tracker" class="headerlink" title="1、添加主机到tracker"></a>1、添加主机到tracker</h2><p>告诉注册自己到tracker，相当于为每个主机加入MogileFS的存储系统。</p><p><code>[root@node1~]#mogadm host add node1 --ip 192.168.4.61 --port=7500 --status=alive</code></p><p><code>[root@node1~]#mogadm host add node2 --ip 192.168.4.62 --port=7500 --status=alive</code><br><code>[root@node1~]#mogadm host add node3 --ip 192.168.4.63 --port=7500 --status=alive</code></p><p><code>[root@node1~]#mogadm host list</code>    显示所有主机</p><pre><code>node1 [1]: alive  IP:       192.168.4.61:7500node2 [2]: alive  IP:       192.168.4.62:7500node3 [3]: alive  IP:       192.168.4.63:7500</code></pre><h2 id="2、MogileFS存储设备管理"><a href="#2、MogileFS存储设备管理" class="headerlink" title="2、MogileFS存储设备管理"></a>2、MogileFS存储设备管理</h2><p><strong>注意：所有系统中ID不能重复，也必须和配置文件中的路径一致。</strong></p><p><code>[root@node1~]#mkdir /data/mogilefs/dev1 -pv</code><br><code>[root@node2~]#mkdir /data/mogilefs/dev2 -pv</code><br><code>[root@node3~]#mkdir -pv /data/mogilefs/dev3</code></p><p><strong>注意：给相对应的块设备mount到这个点，软连接也行，不然写文件都会写到系统硬件上，其他的硬盘都是空的。</strong></p><p><code>[root@node1~]#mogadm device add node1 1</code><br><code>[root@node1~]#mogadm device add node2 2</code><br><code>[root@node1~]#mogadm device add node3 3</code><br><code>[root@node1~]#mogadm device list</code></p><p><strong>标记失效的设备，当硬盘坏了，设备有问题时，这时会自动在一个域内复制到最小设备的保存分数。恢复时和add操作一遍即可。</strong></p><h2 id="3、MogileFS域的管理"><a href="#3、MogileFS域的管理" class="headerlink" title="3、MogileFS域的管理"></a>3、MogileFS域的管理</h2><p>当创建上述完成之后，MogileFS运行中时，建一个自己的名字空间和加入文件到存储中。</p><p><code>[root@node1~]#mogadm domain add test</code><br><code>[root@node1~]#mogadm domain list</code></p><p><code>[root@node1~]#mogadm class add test class1 --mindevcount=3</code>    #在域中建类，并加入最小保存分数</p><p><strong>建议一个类的最小存储分数为3份；因为可以保证整个集群挂掉2台还能正常工作。在加入和修改的时候，都可以加上mindevcount、replpolicy和hashtype参数。</strong></p><h2 id="4、MogileFS文件管理"><a href="#4、MogileFS文件管理" class="headerlink" title="4、MogileFS文件管理"></a>4、MogileFS文件管理</h2><p>使用如下命令需要在<code>/etc/mogilefs/mogilefs.conf</code>中指定trackers，不然就需要在命令中加<code>--trackers</code>来指定。</p><p><code>[root@node1~]#mogupload --trackers=127.0.0.1:7001 --domain=test --key=fstab --file=/etc/fstab</code></p><h4 id="查询信息"><a href="#查询信息" class="headerlink" title="查询信息"></a>查询信息</h4><p><code>[root@node1~]#mogfileinfo --trackers=127.0.0.1:7001 --domain=test --key=fstab</code></p><pre><code>- file: fstab     class:              default  devcount:                    1    domain:                 test       fid:                    3       key:                fstab    length:                  541 - http://192.168.4.62:7500/dev2/0/000/000/0000000003.fid    通过此网址可以访问到数据</code></pre><p><code>[root@node1~]#mogfiledebug --trackers=127.0.0.1:7001 --paths=print --domain=test --key=fstab</code>   #显示更多详细信息</p><p><code>[root@node1~]#mogdelete --trackers=127.0.0.1:7001 --domain=test --key=fstab</code>   #删除指定文件</p><p><code>[root@node1~]#moglistkeys --trackers=127.0.0.1:7001 --domain=test</code>    #列出某个域下的文件key</p><p><code>moglistfids --trackers=host --fromfid=123 --count=5000</code><br><strong>fromid是之mogileFS内部文件的ID，这个是自增的，可以指定从一个开始的位置，指定显示多杀个文件。</strong><br><code>[root@node1~]#moglistfids --trackers=127.0.0.1 --fromid=1 --count=5</code></p><h2 id="5、MogileFS服务器管理"><a href="#5、MogileFS服务器管理" class="headerlink" title="5、MogileFS服务器管理"></a>5、MogileFS服务器管理</h2><p>如果需要维护一个服务器，如更新内存、升级操作系统之类的需要关机操作，操作之前先设置为“down”。</p><p><code>[root@node1~]#mogadm host mark node1 down</code></p><p><code>[root@node1~]#mogadm host mark node1 alive</code></p><h2 id="6、MogileFS硬盘管理"><a href="#6、MogileFS硬盘管理" class="headerlink" title="6、MogileFS硬盘管理"></a>6、MogileFS硬盘管理</h2><p>添加新的硬盘设备需要给一个唯一的，增量的设备ID。如果使用一个新的硬盘来替换坏掉的硬盘，总是需要给一个新的设备ID，不能使用旧的。因为这样可以从就设备中给所有文件列表中的文件重新复制到其他的MogileFS硬盘中；不然容器引起文件复制到这个中和错误的更新，也不会重新复制旧文件。</p><h2 id="7、MogileFS只读模式和耗尽模式"><a href="#7、MogileFS只读模式和耗尽模式" class="headerlink" title="7、MogileFS只读模式和耗尽模式"></a>7、MogileFS只读模式和耗尽模式</h2><p>如果想要冻结设备上的所有文件，只读模式就可以解决。这样将停掉MogileFS存放新文件到这个设备上，但它也将阻止删除文件，替代删除的操作会给这些内容放到丢列中等待为标记的’alive’和“drain”。</p><p><code>[root@node1~]#mogadm device mark node2 2 readonly</code></p><p><strong>注意：耗尽模式，在2.40和更高版本以上，MogileFS不会有新的文件写入设备，但是在耗尽模式，文件可能被删除，如果不希望将文件写到这个设备上，可以设置为drain模式。</strong></p><h2 id="8、MogileFS复制"><a href="#8、MogileFS复制" class="headerlink" title="8、MogileFS复制"></a>8、MogileFS复制</h2><p>如果一个硬盘坏了，MogileFS可以自动的让请求不再访问这个设备，但是不会自动的重新复制这个硬盘文件，必须通过mogadm来手工标志位dead，MogileFS将开始删除设备上的文件，并试图在集群间重新复制他们到其他设备上。</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mogilefs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastDFS</title>
      <link href="/2017/12/16/FastDFS/"/>
      <url>/2017/12/16/FastDFS/</url>
      
        <content type="html"><![CDATA[<h1 id="一、FastDFS"><a href="#一、FastDFS" class="headerlink" title="一、FastDFS"></a>一、FastDFS</h1><p>FastDFS是一个国产开源的轻量级分布式文件系统；对文件进行管理，功能包括：文件存储、文件同步、文件访问等，解决了大容量存储和负载均衡的问题。特别适合以中小文件为载体的在线服务，如相册网站、视频网站等。</p><h2 id="1、FastDS结构"><a href="#1、FastDS结构" class="headerlink" title="1、FastDS结构"></a>1、FastDS结构</h2><p><img src="http://owatlfstl.bkt.clouddn.com/BRbA7bm.png%21web" alt=""></p><ul><li>tracker server：跟踪服务器，主要做调度工作，起到负载均衡作用。负责管理所有的storage server和group，每个storage启动之后会连接tracker，告诉tracker属于哪个group，并保持周期性心跳，tracker根据storage心跳信息，创建映射表；tracker管理的元数据较少，并且直接存储在内存中，本身不需要持久化任何数据。</li><li>storage server，存储服务器，用来保存文件和文件属性的。以group为单位进行组织，任何一个storage server都应该属于某个group，一个group应该包含多个storage  server；在同一个group内部，各storage server数据互相冗余。</li><li>client，作为业务请求的发起方，使用TCP/IP协议与跟踪器服务器或存储节点进行数据交互。</li></ul><h3 id="FastDFS拓展"><a href="#FastDFS拓展" class="headerlink" title="FastDFS拓展"></a>FastDFS拓展</h3><p><strong>所有服务器都是对等的，不存在Master-Slave关系。</strong><br><strong>存储服务器采用分组方式，同组内存储服务器上的文件完全相同。</strong><br><strong>存储服务器采用分组方式，同组内存储服务器上的文件完全相同。</strong><br><strong>不同组的storage server 之间不会相互通信。</strong><br><strong>由storage server主动向tracker server报告状态信息，tracker server之间通常不会相互通信。</strong></p><h2 id="2、FastDFS特性"><a href="#2、FastDFS特性" class="headerlink" title="2、FastDFS特性"></a>2、FastDFS特性</h2><ul><li>分组存储，灵活简介，对等结构，不存在单点</li><li>文件ID由FastDFS生成，作为文件访问凭证。FastDFS不需要传统的name server</li><li>FastDFS提供apache和nginx扩展模块</li><li>支持多块硬盘，支持单盘数据恢复</li><li>支持相同文件内容只保存一份，节省存储空间</li><li>存储服务器上可以保存文件附加属性</li><li>下载文件支持多线程方式，支持断点续传</li></ul><h2 id="3、FastDFS工作原理"><a href="#3、FastDFS工作原理" class="headerlink" title="3、FastDFS工作原理"></a>3、FastDFS工作原理</h2><p><img src="http://owatlfstl.bkt.clouddn.com/IvQF3uU.jpg%21web" alt=""></p><p><strong>上传流程：</strong></p><ul><li>（1）client询问tracker上传到storage</li><li>（2）tracker返回一台可用的storage</li><li>（3）client直接和storage通信，完成文件上传</li></ul><p><strong>下载流程</strong></p><ul><li>（1）client询问tracker下载文件的storage，参数为文件ID（组名和文件名）</li><li>（2）tracker返回一台可用的storage</li><li>（3）client直接和storage通信完成文件下载</li></ul><h2 id="4、-FastDFS同步机制"><a href="#4、-FastDFS同步机制" class="headerlink" title="4、 FastDFS同步机制"></a>4、 FastDFS同步机制</h2><ul><li>（1）采用binlog文件记录更新操作，根据binlog进行文件同步。同一组内的storage server之间是对等的，文件上传、删除等操作可以在任意一台storage server上进行。</li><li>（2）文件同步只在通组内的storage server之间进行，采用push方式，即源服务器同步给目标服务器。<strong>例外情况</strong>新增加一台storage server时，由已有的一台storage server将已有的所有数据（包括源头数据和备份数据）同步给该新增的服务器。</li><li>（3）源头数据才需要同步；备份数据不需要再次同步，否则造成环路。</li></ul><h2 id="5、FastDFS中group规则"><a href="#5、FastDFS中group规则" class="headerlink" title="5、FastDFS中group规则"></a>5、FastDFS中group规则</h2><ul><li>（1）round robin，轮询</li><li>（2）specified group，上传指定某个group</li><li>（3）load balance，生成存储空间较多的group优先</li></ul><h2 id="6、FastDFS中选择storage-server"><a href="#6、FastDFS中选择storage-server" class="headerlink" title="6、FastDFS中选择storage server"></a>6、FastDFS中选择storage server</h2><ul><li>（1）round robin，轮询</li><li>（2）根据IP地址进行排序，选择第一个服务器（IP地址最小者优先）</li><li>（3）根据优先级进行排序，上传优先级由storage server来设置，参数为<code>upload_priority</code></li></ul><h2 id="7、FastDFS中选择storage-path"><a href="#7、FastDFS中选择storage-path" class="headerlink" title="7、FastDFS中选择storage path"></a>7、FastDFS中选择storage path</h2><ul><li>（1）round robin，轮询</li><li>（2）load balance，选择使用剩余空间最大的存储路径</li></ul><h2 id="8、FastDFS中File-ID"><a href="#8、FastDFS中File-ID" class="headerlink" title="8、FastDFS中File ID"></a>8、FastDFS中File ID</h2><p>选择存储目录之后，storage会生成一个file_id，采用base64编码，包括：storage server ip，文件创建时间，文件大小，文件CRC32校验码和随机数。每个存储目录下有两个256*256个子目录；storage会按文件file_id进行两次hash，路由到其中一个子目录下，然后将文件以file_id为名字存储。</p><h3 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h3><pre><code>groupID/MID/H1ID/H2ID/file_name    groupID：组编号    MID：存储路径编号    H1ID/H2ID：目录分层，用于存储数据文件    file_name：文件名，不同于用户上传时使用的文件名，而是由服务器生成hash文件名。文件名包括：源存储服务器IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。</code></pre><h1 id="二、FastDFS安装及文件介绍"><a href="#二、FastDFS安装及文件介绍" class="headerlink" title="二、FastDFS安装及文件介绍"></a>二、FastDFS安装及文件介绍</h1><h2 id="1、FastDFS安装"><a href="#1、FastDFS安装" class="headerlink" title="1、FastDFS安装"></a>1、FastDFS安装</h2><p>参考安装：<a href="http://joelhy.github.io/2015/01/27/FastDFS-v5-06-deploy/" target="_blank" rel="noopener">http://joelhy.github.io/2015/01/27/FastDFS-v5-06-deploy/</a></p><h2 id="2、tracker-conf文件介绍"><a href="#2、tracker-conf文件介绍" class="headerlink" title="2、tracker.conf文件介绍"></a>2、tracker.conf文件介绍</h2><pre><code>disabled=false  是否启动此配置文件bind_addr=  监听的IP地址port=22122  监听的端口connect_timeout=30  连接超时network_timeout=60  网络超时base_path=/home/yuqing/fastdfs  存储数据和文件的目录max_connections=256 最大连接accept_threads=1    接受线程数work_threads=4  工作线程数min_buff_size = 8KB max_buff_size = 128KBstore_lookup=2store_group=group2store_server=0store_path=0download_server=0reserved_storage_space = 10%log_level=inforun_by_group=run_by_user=allow_hosts=*sync_log_buff_interval = 10check_active_interval = 120thread_stack_size = 64KBstorage_ip_changed_auto_adjust = truestorage_sync_file_max_delay = 86400storage_sync_file_max_time = 300use_trunk_file = false slot_min_size = 256slot_max_size = 16MBtrunk_file_size = 64MBtrunk_create_file_advance = falsetrunk_create_file_time_base = 02:00trunk_create_file_interval = 86400trunk_create_file_space_threshold = 20Gtrunk_init_check_occupying = falsetrunk_init_reload_from_binlog = falsetrunk_compress_binlog_min_interval = 0use_storage_id = falsestorage_ids_filename = storage_ids.confid_type_in_filename = ipstore_slave_file_use_link = falserotate_error_log = falseerror_log_rotate_time=00:00rotate_error_log_size = 0log_file_keep_days = 0use_connection_pool = falseconnection_pool_max_idle_time = 3600http.server_port=8080http.check_alive_interval=30http.check_alive_type=tcphttp.check_alive_uri=/status.html</code></pre><h2 id="3、storage-conf配置文件"><a href="#3、storage-conf配置文件" class="headerlink" title="3、storage.conf配置文件"></a>3、storage.conf配置文件</h2><pre><code>disabled=falsegroup_name=group1bind_addr=client_bind=trueport=23000connect_timeout=30network_timeout=60heart_beat_interval=30stat_report_interval=60base_path=/home/yuqing/fastdfsmax_connections=256buff_size = 256KBaccept_threads=1work_threads=4disk_rw_separated = truedisk_reader_threads = 1disk_writer_threads = 1sync_wait_msec=50sync_interval=0sync_start_time=00:00sync_end_time=23:59write_mark_file_freq=500store_path_count=1store_path0=/home/yuqing/fastdfssubdir_count_per_path=256tracker_server=192.168.209.121:22122log_level=inforun_by_group=run_by_user=allow_hosts=*file_distribute_path_mode=0file_distribute_rotate_count=100fsync_after_written_bytes=0sync_log_buff_interval=10sync_binlog_buff_interval=10sync_stat_file_interval=300thread_stack_size=512KBupload_priority=10if_alias_prefix=check_file_duplicate=0file_signature_method=hashkey_namespace=FastDFSkeep_alive=0use_access_log = falserotate_access_log = falseaccess_log_rotate_time=00:00rotate_error_log = falseerror_log_rotate_time=00:00rotate_access_log_size = 0rotate_error_log_size = 0log_file_keep_days = 0file_sync_skip_invalid_record=falseuse_connection_pool = falseconnection_pool_max_idle_time = 3600http.domain_name=http.server_port=8888</code></pre><h1 id="三、集群环境"><a href="#三、集群环境" class="headerlink" title="三、集群环境"></a>三、集群环境</h1><table><thead><tr><th>主机名</th><th>IP地址</th></tr></thead><tbody><tr><td>node1</td><td>192.168.4.61</td></tr><tr><td>node2</td><td>192.168.4.62</td></tr><tr><td>node3</td><td>192.168.4.63</td></tr></tbody></table><h2 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h2><p><code>[root@node1/etc/fdfs]#cp storage.conf.sample storage.conf</code><br><code>[root@node1/etc/fdfs]#vim storage.conf</code></p><pre><code>disabled=falseport=23000base_path=/data/fasdfs/storage  base源路径tracker_server=192.168.4.61:22122store_path0=/data/fastdfs/storage   实际存储目录</code></pre><p><code>[root@node1/etc/fdfs]#mkdir /data/fastdfs/storage -pv</code></p><p><code>[root@node1/etc/fdfs]#cp tracker.conf.sample tracker.conf</code><br><code>[root@node1/etc/fdfs]#vim tracker.conf</code></p><pre><code>disabled=falseport=23000base_path=/data/fastdfs/tracker</code></pre><p><code>[root@node1/etc/fdfs]#mkdir /data/fastdfs/tracker -pv</code></p><p><code>[root@node1/etc/fdfs]#systemctl start fdfs_storaged.service</code></p><p><code>[root@node1/etc/fdfs]#systemctl start fdfs_trackerd.service</code></p><p>其他两个类似 </p><h2 id="2、配置客户端"><a href="#2、配置客户端" class="headerlink" title="2、配置客户端"></a>2、配置客户端</h2><p><code>[root@node1/etc/fdfs]#cp client.conf.sample client.conf</code><br><code>[root@node1/etc/fdfs]#vim client.conf</code></p><pre><code> base_path=/data/fastdfs/tracker tracker_server=192.168.4.61:22122</code></pre><h2 id="3、查看存储节点状态"><a href="#3、查看存储节点状态" class="headerlink" title="3、查看存储节点状态"></a>3、查看存储节点状态</h2><p><code>[root@node1/etc/fdfs]#fdfs_monitor /etc/fdfs/client.conf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-17_172431.jpg" alt=""></p><h2 id="4、上传文件测试"><a href="#4、上传文件测试" class="headerlink" title="4、上传文件测试"></a>4、上传文件测试</h2><p><code>[root@node1~]#fdfs_upload_file /etc/fdfs/client.conf /etc/fstab</code>   </p><pre><code>group1/M00/00/00/wKgEPVo2OLGAWWK2AAACHaVbhes1677203</code></pre><h2 id="5、文件查看"><a href="#5、文件查看" class="headerlink" title="5、文件查看"></a>5、文件查看</h2><p><code>[root@node1~]#fdfs_file_info /etc/fdfs/client.conf group1/M00/00/00/wKgEPVo2OLGAWWK2AAACHaVbhes1677203</code></p><pre><code>source storage id: 0source ip address: 192.168.4.61file create timestamp: 2017-12-17 17:28:17file size: 541file crc32: 2774238699 (0xA55B85EB)</code></pre><h2 id="6、文件下载"><a href="#6、文件下载" class="headerlink" title="6、文件下载"></a>6、文件下载</h2><p><code>[root@node1~]#fdfs_download_file /etc/fdfs/client.conf group1/M00/00/00/wKgEPVo2OLGAWWK2AAACHaVbhes1677203</code> </p><h1 id="四、FastDFS实现nginx-代理"><a href="#四、FastDFS实现nginx-代理" class="headerlink" title="四、FastDFS实现nginx 代理"></a>四、FastDFS实现nginx 代理</h1><p><code>[root@node1~]#vim /etc/nginx/nginx.conf</code></p><pre><code>     location /group1/M00 {            root /data/fastdfs/storage;             ngx_fastdfs_module;    }</code></pre><p><code>[root@node1~]#vim /etc/fdfs/mod_fastdfs.conf</code></p><pre><code>tracker_server=192.168.4.61:22122url_have_group_name = truestore_path0=/data/fastdfs/storage</code></pre><h3 id="在地址栏输入：http-192-168-4-61-group1-M00-00-00-wKgEPVo2PeWAejJ6AAAIo8JoUSg9541373"><a href="#在地址栏输入：http-192-168-4-61-group1-M00-00-00-wKgEPVo2PeWAejJ6AAAIo8JoUSg9541373" class="headerlink" title="在地址栏输入：http://192.168.4.61/group1/M00/00/00/wKgEPVo2PeWAejJ6AAAIo8JoUSg9541373"></a>在地址栏输入：<a href="http://192.168.4.61/group1/M00/00/00/wKgEPVo2PeWAejJ6AAAIo8JoUSg9541373" target="_blank" rel="noopener">http://192.168.4.61/group1/M00/00/00/wKgEPVo2PeWAejJ6AAAIo8JoUSg9541373</a></h3>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fastdfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Harbor</title>
      <link href="/2017/12/14/Harbor/"/>
      <url>/2017/12/14/Harbor/</url>
      
        <content type="html"><![CDATA[<p><img src="http://owatlfstl.bkt.clouddn.com/img.html" alt=""></p><h1 id="一、harbor"><a href="#一、harbor" class="headerlink" title="一、harbor"></a>一、harbor</h1><p>Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器，通过添加一些企业必须的功能性，扩展了开源Docker Distribution。Harbor支持安装在多个Registry节点的镜像资源复制，镜像全部存储在私有Registry中，确保数据和知识产权在公司内部网络中管控。</p><h2 id="1、Harbor安装"><a href="#1、Harbor安装" class="headerlink" title="1、Harbor安装"></a>1、Harbor安装</h2><p>下载地址：<a href="http://owatlfstl.bkt.clouddn.com/img.html" target="_blank" rel="noopener">http://owatlfstl.bkt.clouddn.com/img.html</a></p><p><code>[root@node3~]#tar xf harbor-offline-installer-v1.3.0-rc4.tgz -C /usr/local/</code></p><h2 id="2、harbor-cfg配置文件"><a href="#2、harbor-cfg配置文件" class="headerlink" title="2、harbor.cfg配置文件"></a>2、<code>harbor.cfg</code>配置文件</h2><pre><code>hostname = reg.mydomain.com 目标主机的主机名，用于访问用户界面和注册表服务；不要使用localhost或127.0.0.1为主机名ui_url_protocol = http 用于访问UI和令牌协议db_password = root123   数据库密码max_job_workers = 3     工作线程customize_crt = on  是否开启证书认证功能ssl_cert = /data/cert/server.crt SSL证书的路径ssl_cert_key = /data/cert/server.key    SSL密钥的路径secretkey_path = /data  密钥路径admiral_url = NA    clair_db_password = passwordlog_rotate_count = 50   是否启动滚动功能log_rotate_size = 200M 日志大小电子邮件配置：email_identity = email_server = smtp.mydomain.comemail_server_port = 25email_username = sample_admin@mydomain.comemail_password = abcemail_from = admin &lt;sample_admin@mydomain.com&gt;email_ssl = falseemail_insecure = falseharbor_admin_password =     Harbor12345 管理员初始密码auth_mode = db_auth 认证类型ladp配置：ldap_url = ldaps://ldap.mydomain.comldap_basedn = ou=people,dc=mydomain,dc=comldap_uid = uid ldap_scope = 3 ldap_timeout = 5self_registration = on  是否启动用户注册自己的功能token_expiration = 30project_creation_restriction = everyone数据库配置：db_host = mysqldb_port = 3306db_user = rootuaa_endpoint = uaa.mydomain.orguaa_clientid= iduaa_clientsecret= secretuaa_ca_root= /path/to/uaa_ca.pem</code></pre><h2 id="3、启动服务"><a href="#3、启动服务" class="headerlink" title="3、启动服务"></a>3、启动服务</h2><p><code>[root@node3/usr/local/harbor]#./install.sh</code></p><p>在地址栏输入刚刚在配置文件中设置的hostname<br><img src="http://owatlfstl.bkt.clouddn.com/2017-12-14_202442.jpg" alt=""></p><h1 id="二、Harbor-功能"><a href="#二、Harbor-功能" class="headerlink" title="二、Harbor 功能"></a>二、Harbor 功能</h1><h2 id="1、Harbor复制"><a href="#1、Harbor复制" class="headerlink" title="1、Harbor复制"></a>1、Harbor复制</h2><p><img src="http://owatlfstl.bkt.clouddn.com/harbor.html" alt=""></p><p>当复制策略被激活时，源项目下的所有镜像都会被复制到目标实例。此外，当源项目下的镜像被添加或删除，只要策略还在激活状态，镜像的变化都会同步到目标实例上去。</p>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> harbor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Compose</title>
      <link href="/2017/12/13/Docker%20Compose/"/>
      <url>/2017/12/13/Docker%20Compose/</url>
      
        <content type="html"><![CDATA[<p><img src="http://owatlfstl.bkt.clouddn.com/docker-compose1.png" alt=""></p><h1 id="一、Docker-Compose"><a href="#一、Docker-Compose" class="headerlink" title="一、Docker Compose"></a>一、Docker Compose</h1><p>Compose项目时Docker官方为开源项目，负责实现对Docker容器集群的快速编排。</p><h2 id="1、Compose两个概念"><a href="#1、Compose两个概念" class="headerlink" title="1、Compose两个概念"></a>1、Compose两个概念</h2><ul><li><p>服务（service），一个应用容器，实际上可以包括若干运行相同镜像容器示例。</p></li><li><p>项目（project），由一组关联的应用容器组成的一个完整业务单元，在  <code>docker-compose.yml</code>文件中定义。</p></li></ul><h2 id="2、Docker-compose安装"><a href="#2、Docker-compose安装" class="headerlink" title="2、Docker compose安装"></a>2、Docker compose安装</h2><p>下载地址：<a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">https://github.com/docker/compose/releases</a></p><blockquote><p>下载到指定位置<br><code>[root@node3~]#curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-</code>uname -s<code>-</code>uname -m<code>-o /usr/local/bin/docker-compose</code></p><p>赋予执行权限<br><code>[root@node3~]#chmod +x /usr/local/bin/docker-compose</code></p><p>查看是否安装成功</p></blockquote><p><code>[root@node3~]#docker-compose --version</code></p><pre><code>docker-compose version 1.17.0, build ac53b73</code></pre><h2 id="3、docker-compose命令"><a href="#3、docker-compose命令" class="headerlink" title="3、docker-compose命令"></a>3、docker-compose命令</h2><h3 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h3><pre><code>docker-compose [-f &lt;arg&gt;...] [options] [COMMAND] [ARGS...]</code></pre><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-f，–file FILE</td><td>指定使用的Compose模板文件，默认为<code>docker-compose.yml</code></td></tr><tr><td>-p，–project-name NAME</td><td>指定项目名称，默认将使用所在目录名作为项目名</td></tr><tr><td>-x-networking</td><td>使用Docker的可拔插网络后端特性</td></tr><tr><td>-x-network-driver DRIVER</td><td>指定网络后端驱动，默认为bridge</td></tr><tr><td>–verbose</td><td>输出更多调试信息</td></tr><tr><td>-v，–version</td><td>打印版本并退出</td></tr></tbody></table><h3 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h3><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>构建项目中的服务容器</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>–force-rm</td><td>删除构建过程中的临时容器</td></tr><tr><td>–no-cache</td><td>构建镜像过程中不使用cache</td></tr><tr><td>–pull</td><td>始终尝试通过pull俩获取更新版本的镜像</td></tr></tbody></table><h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><p>验证Compose文件格式是否正确</p><h4 id="down"><a href="#down" class="headerlink" title="down"></a>down</h4><p>停止UP命令所启动的容器，并移除网络</p><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p>进入指定容器</p><h4 id="images"><a href="#images" class="headerlink" title="images"></a>images</h4><p>列出Compose文件中包含的镜像</p><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>通过发送SIGKILL信号来强制停止服务容器</p><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>指定服务上执行一个命令</p><p><strong>默认情况下，如果存在关联，则所有关联的服务将自动被启动，除非这些服务已经在运行中。</strong></p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-d</td><td>后台运行</td></tr><tr><td>–name</td><td>容器指定一个名称</td></tr><tr><td>–entrypoint</td><td>覆盖默认的容器启动指令</td></tr><tr><td>-e</td><td>设置环境变量</td></tr><tr><td>-u，–user</td><td>指定运行容器的用户名或UID</td></tr><tr><td>–rm</td><td>运行命令后自动删除容器</td></tr><tr><td>-P，–pulish</td><td>映射容器端口到本地主机</td></tr><tr><td>–service-ports</td><td>配置服务器端口并映射到本地主机</td></tr><tr><td>-T</td><td>不分配伪终端</td></tr></tbody></table><h4 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h4><p>设置指定服务运行的容器个数</p><h1 id="二、Compose模板文件"><a href="#二、Compose模板文件" class="headerlink" title="二、Compose模板文件"></a>二、Compose模板文件</h1><h2 id="1、build"><a href="#1、build" class="headerlink" title="1、build"></a>1、build</h2><p>指定Dockerfile所在文件的路径</p><h3 id="content-上下文"><a href="#content-上下文" class="headerlink" title="content 上下文"></a>content 上下文</h3><p>Dockerfile的目录路径，或者git仓库的URL</p><h3 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h3><p>备用的dockerfile</p><h3 id="ARGS"><a href="#ARGS" class="headerlink" title="ARGS"></a>ARGS</h3><p>添加构建参数，这些参数是仅在构建过程中可访问的环境变量。</p><h3 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h3><pre><code>build: /path/to/build/dir</code></pre><h2 id="2、cap-add，cap-drop"><a href="#2、cap-add，cap-drop" class="headerlink" title="2、cap_add，cap_drop"></a>2、cap_add，cap_drop</h2><p>指定容器的内核能力分配</p><h2 id="3、command"><a href="#3、command" class="headerlink" title="3、command"></a>3、command</h2><p>覆盖容器启动后默认执行命令</p><h2 id="4、configs"><a href="#4、configs" class="headerlink" title="4、configs"></a>4、configs</h2><p>使用每个服务configs配置授予对每个服务的配置访问权限。</p><pre><code>source：Docker中存在的配置名称target：将被安装在服务的任何容器中的文件路径和名称。uid和gid：指定uid和gidmode：设置权限</code></pre><h2 id="5、cgroup-parent"><a href="#5、cgroup-parent" class="headerlink" title="5、cgroup_parent"></a>5、cgroup_parent</h2><p>指定父cgroup组，意味着继承该组的资源限制</p><h2 id="6、container-name"><a href="#6、container-name" class="headerlink" title="6、container_name"></a>6、container_name</h2><p>指定容器名称。默认将会使用<code>项目名称_服务名称_序号</code></p><p><strong>指定名称后，该服务将无法进行扩展；因为Docker不允许多个容器具有相同的名称。</strong></p><h2 id="7、devices"><a href="#7、devices" class="headerlink" title="7、devices"></a>7、devices</h2><p>指定设备映射关系</p><h2 id="8、depends-on"><a href="#8、depends-on" class="headerlink" title="8、depends_on"></a>8、depends_on</h2><p>解决容器的依赖、启动先后问题。</p><h2 id="9、dns"><a href="#9、dns" class="headerlink" title="9、dns"></a>9、dns</h2><p>自定义DNS服务器</p><h2 id="10、dns-search"><a href="#10、dns-search" class="headerlink" title="10、dns_search"></a>10、dns_search</h2><p>配置DNS搜索域。</p><h2 id="11、tmpfs"><a href="#11、tmpfs" class="headerlink" title="11、tmpfs"></a>11、tmpfs</h2><p>挂载一个tmpfs文件系统到容器</p><h2 id="12、env-file"><a href="#12、env-file" class="headerlink" title="12、env_file"></a>12、env_file</h2><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p><h2 id="13、environment"><a href="#13、environment" class="headerlink" title="13、environment"></a>13、environment</h2><p>设置环境变量</p><h2 id="14、expose"><a href="#14、expose" class="headerlink" title="14、expose"></a>14、expose</h2><p>暴露端口，但不映射到宿主机，只被连接的服务访问</p><h2 id="15、image"><a href="#15、image" class="headerlink" title="15、image"></a>15、image</h2><p>指定为镜像名称或镜像ID</p><h2 id="16、labels"><a href="#16、labels" class="headerlink" title="16、labels"></a>16、labels</h2><p>为容器添加docker元数据信息。</p><h2 id="17、network-mode"><a href="#17、network-mode" class="headerlink" title="17、network_mode"></a>17、network_mode</h2><p>设置网络模式</p><h2 id="18、networks"><a href="#18、networks" class="headerlink" title="18、networks"></a>18、networks</h2><p>配置容器连接的网络</p><h2 id="19、sysctls"><a href="#19、sysctls" class="headerlink" title="19、sysctls"></a>19、sysctls</h2><p>配置容器的内核参数</p><h2 id="20、volumes"><a href="#20、volumes" class="headerlink" title="20、volumes"></a>20、volumes</h2><p>数据卷所挂载路径位置</p><h1 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h1><pre><code>version: &#39;3&#39;services:    nginx:        image: &quot;lnmp-nginx:latest&quot;        build:            context: .            dockerfile: Dockerfile.nginx        ports:            - &quot;80:80&quot;        networks:            - frontend        depends_on:            - php    php:        image: &quot;lnmp-php:latest&quot;        build:            context: .            dockerfile: Dockerfile.php        networks:            - frontend            - backend        environment:            MYSQL_PASSWORD: Passw0rd        depends_on:            - mysql    mysql:        image: mysql:latest        volumes:            - mysql-data:/var/lib/mysql        environment:            TZ: &#39;Asia/Shanghai&#39;            MYSQL_ROOT_PASSWORD: Passw0rd        command: [&#39;mysqld&#39;, &#39;--character-set-server=utf8&#39;]        networks:            - backendvolumes:    mysql-data:networks:    frontend:    backend:</code></pre>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile指令</title>
      <link href="/2017/12/13/Dockerfile%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2017/12/13/Dockerfile%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Dockerfile"><a href="#一、Dockerfile" class="headerlink" title="一、Dockerfile"></a>一、Dockerfile</h1><p><img src="http://owatlfstl.bkt.clouddn.com/docker-images.png" alt=""><br>Dockerfile是一种被Docker程序解释的脚本，Dockerfile由一条条的指令组成，每条指令对应linux下面的一条命令。Docker程序将这些Dockerfile指令翻译真正的linux命令。</p><h2 id="1、FROM"><a href="#1、FROM" class="headerlink" title="1、FROM"></a>1、FROM</h2><p>FROM指令时最重要的一个且必须为Dockerfile文件开篇的第一个非注释行，用于为映像文件构建过程指定基础镜像，后续的指令运行于此基准镜像所提供的运行环境。</p><p><strong>注意：如果没有指定tag，默认使用latest版本。</strong></p><p>实践中，基准镜像可以是任何可用镜像文件，默认情况下，<code>docker build</code>会在docker主机上查找指定的镜像文件，若不存在时，则会从Docker Hub Registry上拉去所需的镜像文件。</p><h3 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h3><pre><code>FROM &lt;image&gt;[:&lt;tag&gt;] 或FROM &lt;image&gt;@&lt;digest&gt;&lt;image&gt;：指定作为base image 的名称&lt;tag&gt;：base image的标签，为可选项，省略时默认为latest</code></pre><h2 id="2、MAINTANIER"><a href="#2、MAINTANIER" class="headerlink" title="2、MAINTANIER"></a>2、MAINTANIER</h2><p>用于让镜像制作者提供本人的详细信息。Dockerfile并不限制于MAINTAINER指令可在出现的位置，但推荐将其防止与FROM指令之后。</p><h3 id="使用格式-1"><a href="#使用格式-1" class="headerlink" title="使用格式"></a>使用格式</h3><pre><code>MAINTAINER &lt;author&#39;s detail&gt;&lt;author&#39;s detail&gt;：可是任何文本信息，但约定俗成地使用作者名称及邮件地址</code></pre><h2 id="3、COPY"><a href="#3、COPY" class="headerlink" title="3、COPY"></a>3、COPY</h2><p>用于从Docker主机复制文件至创建的新映像文件</p><h3 id="使用格式-2"><a href="#使用格式-2" class="headerlink" title="使用格式"></a>使用格式</h3><pre><code>COPY &lt;src&gt; ... &lt;dest&gt; 或COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]&lt;src&gt;：要复制的源文件或目录，支持使用通配符&lt;dest&gt;：目标路径，即正在创建的image的文件系统路径；建议为&lt;dest&gt;使用绝对路径，否则COPY指定则以WORKDIR为其起始路径</code></pre><h3 id="文件复制准则"><a href="#文件复制准则" class="headerlink" title="文件复制准则"></a>文件复制准则</h3><ul><li><src>必须是build上下文中的路径，不能是其父目录中的文件</src></li><li>如果<src>是目录，则其内部文件或子目录会被递归复制，但<src>目录自身不会被复制</src></src></li><li>如果指定了多个<src>，或在<src>中使用了通配符，则<dest>必须是一个目录，其必须以“/”结尾</dest></src></src></li><li>如果<dest>事先不存在，它将会被自动创建，这包括其父目录路径。</dest></li></ul><h2 id="4、ADD"><a href="#4、ADD" class="headerlink" title="4、ADD"></a>4、ADD</h2><p>ADD指令类似于COPY指令，ADD支持使用TAR文件和URL路径</p><h3 id="使用格式-3"><a href="#使用格式-3" class="headerlink" title="使用格式"></a>使用格式</h3><pre><code>ADD &lt;src&gt; ... &lt;dest&gt; 或ADD [&quot;&lt;src&gt;&quot;,...&quot;&lt;dest&gt;&quot;]</code></pre><h3 id="准则"><a href="#准则" class="headerlink" title="准则"></a>准则</h3><ul><li>如果<src>为URL，且<dest>不以“/”结尾，则<src>指定的文件将被下载并直接被创建为<dest>;如果<dest>以”/“结尾，则文件名URL指定的文件将被直接下载并保存为<dest>/<filename></filename></dest></dest></dest></src></dest></src></li><li>如果<src>是一个本地系统上的压缩格式的tar文件，它将被展开为一个目录，其行为类似于“tar -x” 命令；但是，通过URL获取到的tar文件将不会自动展开</src></li><li>如果<src>有多个，或其间接或直接使用了通配符，则<dest>必须是一个以“/”结尾的目录路径；如果<dest>不以”/“结尾，则将被视作一个普通文件，<src>的内容将直接写入到<dest>;</dest></src></dest></dest></src></li></ul><h2 id="5、WORKDIR"><a href="#5、WORKDIR" class="headerlink" title="5、WORKDIR"></a>5、WORKDIR</h2><p>用于为Dockerfile中的所有的RUN、CMD、ENTRYPOINT、COPY和ADD指定工作目录,如果目录不存在时，WORKDIR会自动建立。</p><h3 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h3><pre><code>WORKDIR &lt;dirpath&gt;</code></pre><h3 id="准则-1"><a href="#准则-1" class="headerlink" title="准则"></a>准则</h3><p>在Dockerfile文件中，WORKDIR指令可出现多次，其路径也可以为相对路径，不过，其实相对于此前一个WORKDIR指令指定的路径。WORKDIR也可以调用ENV指定定义的变量。</p><h2 id="6、VOLUME"><a href="#6、VOLUME" class="headerlink" title="6、VOLUME"></a>6、VOLUME</h2><p>用于在image中创建一个挂载点目录，以挂载Docker host上的卷或其他容器上的卷</p><h3 id="使用语法-1"><a href="#使用语法-1" class="headerlink" title="使用语法"></a>使用语法</h3><pre><code>VOLUME &lt;mountpoint&gt; 或VOLUME [&quot;&lt;mountpoint&gt;&quot;]</code></pre><p>如果挂载点路径下此前存在文件，docker run命令会在卷挂载完成后将此前的所有文件复制到新挂在卷中。</p><h2 id="7、EXPOSE"><a href="#7、EXPOSE" class="headerlink" title="7、EXPOSE"></a>7、EXPOSE</h2><p>用于为容器打开指定要监听的端口以实现与外部通信</p><h3 id="使用语法-2"><a href="#使用语法-2" class="headerlink" title="使用语法"></a>使用语法</h3><pre><code>EXPOSE &lt;port&gt; [/&lt;protocol&gt;[&lt;port&gt;&lt;/protocol&gt;]...]&lt;protocol&gt;：用于指定传输层协议，可为tcp或udp二者之一，默认为tcp</code></pre><h2 id="8、ENV"><a href="#8、ENV" class="headerlink" title="8、ENV"></a>8、ENV</h2><p>用于为镜像定义所需的环境变量，并可被Dockerfile文件位于其后的其他指令所调用</p><h3 id="使用语法-3"><a href="#使用语法-3" class="headerlink" title="使用语法"></a>使用语法</h3><pre><code>ENV &lt;key&gt; &lt;value&gt; 或ENV &lt;key&gt;=&lt;value&gt;...</code></pre><p>第一种格式中，<key>之后的所有内容均会被视作其<value>的组成部分，一次只能设置一个变量</value></key></p><p>第二种格式中可以设置多个变量，每个变量为一个“<key>=<value>”的键值对，如果<value>包括空格，可以以斜线进行转义，也可通过对<value>加引号进行标识；另外，反斜线也可用于续行。</value></value></value></key></p><p><strong>建议定义多个变量时，使用第二种方式，以便于在同一层中完成所有功能。</strong></p><h3 id="变量的调用方式"><a href="#变量的调用方式" class="headerlink" title="变量的调用方式"></a>变量的调用方式</h3><p>$variable_name或者$(variable_name)</p><h2 id="9、RUN"><a href="#9、RUN" class="headerlink" title="9、RUN"></a>9、RUN</h2><p>用于指定Docker build过程中运行程序，其可以是任何命令</p><h3 id="使用语法-4"><a href="#使用语法-4" class="headerlink" title="使用语法"></a>使用语法</h3><pre><code>RUN &lt;command&gt; 或RUN [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;...]</code></pre><p>第一种格式中，<command>通常是一个shell命令，且以“/bin/sh -c”来运行它，这意味着此进程在容器中的PID不为1，不能接受unix信号，因此，当使用<code>docker stop &lt;container&gt;</code>命令停止容器时，此进程接受不到SIGTERM信号</p><p>第二种方式中的参数是一个JSON格式的数组，其中<exectable>为要运行的命令，后面<paramn>为传递给命令的选项或参数；但是，此种格式指定的命令不会以“/bin/bash -c”发起，因此常见的shell操作如变量替换以及通配符替换将不会进行，不过如果要运行的命令依赖于shell特性的话，可以将其替换为类似于下面的格式：</paramn></exectable></p><pre><code>RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;]</code></pre><h2 id="10、CMD"><a href="#10、CMD" class="headerlink" title="10、CMD"></a>10、CMD</h2><p>类似于RUN指令，CMD指令也可用于运行任何命令或应用程序，不过二者的时间点不同。RUN指令运行于映像文件构建过程中，而CMD指令运行于基于Dockerfile构建出的新镜像文件启动一个容器时。</p><p>CMD指令的首要目的在于为启动的容器指定默认要运行的程序，且其运行结束后，容器也将终止；不过，CMD指定的命令其可以被docker run的命令行选项所覆盖。</p><p><strong>注意：在Dockerfile中可以存在多个CMD命令，但仅最后一个会生效。</strong></p><h3 id="使用语法-5"><a href="#使用语法-5" class="headerlink" title="使用语法"></a>使用语法</h3><pre><code>CMD &lt;command&gt; 或CMD [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;] 或CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;]</code></pre><p><strong>第三种格式用于ENTRYPOINT指令提供默认参数。</strong></p><h2 id="11、ENTRYPOINT"><a href="#11、ENTRYPOINT" class="headerlink" title="11、ENTRYPOINT"></a>11、ENTRYPOINT</h2><p>类似于CMD指令的功能，用于为容器指定默认运行程序，从而使得容器像是一个单独的可执行程序。</p><p>与CMD不同的是，由ENTRYPOINT启动的程序不会被docker run命令行指定的参数所覆盖，而且这些命令行参数会被当做参数传递给ENTRYPOINT指定的程序。</p><p><strong>docker run命令的 <code>--entrypoint</code>选项的参数可覆盖ENTRYPOINT指令指定的程序。</strong></p><h3 id="使用语法-6"><a href="#使用语法-6" class="headerlink" title="使用语法"></a>使用语法</h3><pre><code>ENTRYPOINT &lt;command&gt;ENTRYPOINT [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;]</code></pre><p><strong>注意：docker run 命令传入的参数会覆盖CMD指令的内容并且附加到ENTRYPOINT命令最后作为其参数使用。</strong></p><p><strong>Dockerfile文件中也可以存在多个ENTRYPOINT指令，但仅有最后一个会生效。</strong></p><h2 id="12、USER"><a href="#12、USER" class="headerlink" title="12、USER"></a>12、USER</h2><p>用于指定运行image时或运行Dockerfile中任何RUN、CMD或ENTRYPOINT指令指定的程序时的用户名或UID。</p><p><strong>默认情况下，container的运行身份为root用户。</strong></p><h3 id="使用语法-7"><a href="#使用语法-7" class="headerlink" title="使用语法"></a>使用语法</h3><p>USER <uid> |<username></username></uid></p><p><strong>注意：<uid>可以任意数字，但实践中必须为/etc/passwd中某用户的有效UID，否则，docker run命令将运行失败。</uid></strong></p><h2 id="13、ONBUILD"><a href="#13、ONBUILD" class="headerlink" title="13、ONBUILD"></a>13、ONBUILD</h2><p>用于在Dockerfile中定义一个触发器。Dockerfile用于build映像文件，此映像文件也可作为base image被另一个Dockerfile用于FROM指令的参数，并以之构建新的映像文件。在后面的这个Dockerfile中的FROM指令在build过程中被执行时，将会“触发”创建其base image 的Dockerfile文件中的ONBUILD指令定义的触发器。</p><h3 id="使用语法-8"><a href="#使用语法-8" class="headerlink" title="使用语法"></a>使用语法</h3><pre><code>ONBUILD &lt;INSTRUCTION&gt;</code></pre><p><strong>尽管任何指令都可注册成为触发器指令，但ONBUILD不能自我嵌套，且不会触发FROM和MAINTAINER指令。</strong></p><p><strong>在ONBUILD指令中使用ADD或COPY指令应该格外小心，因为构建过程的上下文在缺少指定的源文件时会失败。</strong></p><p><strong>使用包含ONBUILD指令的Dockerfile构建的镜像应该使用特殊的标签，如ruby:2.0-onbuild。</strong></p><h1 id="二、docker-build命令"><a href="#二、docker-build命令" class="headerlink" title="二、docker build命令"></a>二、docker build命令</h1><h2 id="1、使用格式"><a href="#1、使用格式" class="headerlink" title="1、使用格式"></a>1、使用格式</h2><pre><code>docker build [OPTIONS] PATH | URL | -</code></pre><h2 id="2、选项"><a href="#2、选项" class="headerlink" title="2、选项"></a>2、选项</h2><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>–build-arg</td><td>设置构建时的变量</td></tr><tr><td>–no-cache</td><td>是否使用build cache构建镜像，默认为false</td></tr><tr><td>–pull</td><td>是否尝试最新版本，默认为false</td></tr><tr><td>–compress</td><td>是否使用压缩构建上下文，默认为false</td></tr><tr><td>–file，-f</td><td>Dockerfile完整路径</td></tr><tr><td>–label</td><td>为生成镜像设置metadata</td></tr><tr><td>–tag，-t</td><td>镜像的名称及标签<code>name:tag</code></td></tr><tr><td>–rm</td><td>整个构建过程宏成功后删除中间环节的容器</td></tr></tbody></table><h1 id="四、示例"><a href="#四、示例" class="headerlink" title="四、示例"></a>四、示例</h1><pre><code>  1 #MySql Dockerfile  2   3 FROM centos  4   5 MAINTAINER &quot;Joah&lt;473823554@qq.com&gt;&quot;  6   7 # COPY file  8 COPY base.repo /etc/yum.repos.d/  9  10 # Install development 11  12 RUN yum install mariadb-server -y &amp;&amp; \ 13     yum clean all &amp;&amp; \ 14     rm -rf /var/cache/yum &amp;&amp;\ 15     sed -i.bak  &#39;/^\[server/ a\innodb_file_per_table = ON\nmax_connections = 5000\nskip_name_res    olve = ON&#39; /etc/my.cnf.d/server.cnf 16  17 CMD    echo  &quot;/usr/libexec/mariadb-prepare-db-dir&quot; &gt;&gt; /tmp/mariadb.sh &amp;&amp;\ 18     echo &quot;/usr/bin/mysqld_safe --basedir=/usr&quot; &gt;&gt; /tmp/mariadb.sh &amp;&amp;\ 19     bash /tmp/mariadb.sh &amp;&amp;\ 20     rm -rf /tmp/mariadb.sh 21  22 VOLUME &quot;/var/lib/mysql&quot; 23  24 EXPOSE 3306/tcp</code></pre><p><code>[root@node3~/workshop]#docker build -t mysql:v1 .</code></p><p><code>[root@node3~/workshop]#docker run --name mysql -it --rm mysql:v1</code></p>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker，dockerfile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker存储</title>
      <link href="/2017/12/12/Docker%E5%AD%98%E5%82%A8/"/>
      <url>/2017/12/12/Docker%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Docker-卷"><a href="#一、Docker-卷" class="headerlink" title="一、Docker 卷"></a>一、Docker 卷</h1><p><img src="http://owatlfstl.bkt.clouddn.com/types-of-mounts-volume.png" alt=""></p><h2 id="1、数据卷"><a href="#1、数据卷" class="headerlink" title="1、数据卷"></a>1、数据卷</h2><p>数据卷时一个可以绕过联合文件系统的，专门指定的可在一个或多个容器间共享目录。卷为提供持久化或共享数据提供了一些有用的特性。数据卷的初衷时独立于容器的生命周期实现数据持久化，因此删除容器之时既不会删除卷，也不会对哪怕未被引用的卷做垃圾回收操作。</p><h2 id="2、使用数据卷的原因"><a href="#2、使用数据卷的原因" class="headerlink" title="2、使用数据卷的原因"></a>2、使用数据卷的原因</h2><p>如果运行中的容器修改了现有的一个已经存在的文件，那该文件将会读写层下的只读层复制到读写层，该文件的只读版本仍然存在，只是已经被被读写层中的该文件的副本隐藏。当关闭并重启容器，其数据不受影响；但删除容器，则其更改的内容将全部丢失。</p><h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><ul><li>存储于联合文件系统中，不易于宿主机访问<ul><li>容器间数据共享不方便</li><li>删除容器其数据全部丢失</li></ul></li></ul><h2 id="3、数据卷的工作原理"><a href="#3、数据卷的工作原理" class="headerlink" title="3、数据卷的工作原理"></a>3、数据卷的工作原理</h2><p>卷时容器上的一个或多个目录，此类目录可绕过联合文件系统，与宿主机上的某目录绑定（关联）。</p><p><img src="http://owatlfstl.bkt.clouddn.com/2361692670-576f5d95d36fb_articlex.png" alt=""></p><h2 id="4、卷类型"><a href="#4、卷类型" class="headerlink" title="4、卷类型"></a>4、卷类型</h2><ul><li><p>绑定挂在卷<br>将一个卷绑定在宿主机上的某个目录下</p></li><li><p>Docker管理的卷<br>Docker守护进程创建并管理的卷</p></li></ul><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-12_192532.jpg" alt=""></p><h2 id="5、数据卷的特性"><a href="#5、数据卷的特性" class="headerlink" title="5、数据卷的特性"></a>5、数据卷的特性</h2><ul><li>当创建容器时，自动初始化</li><li>数据卷可以在容器之间共享和复用</li><li>对数据卷的数据的更新，不会影响到镜像</li><li>对数据卷的修改会立即生效</li><li>数据卷中的数据会一直存在，直到删除最后一个挂载该数据卷的容器被删除时，还需要显示指定删除关联的数据卷</li><li><h1 id="二、卷管理命令"><a href="#二、卷管理命令" class="headerlink" title="二、卷管理命令"></a>二、卷管理命令</h1></li></ul><h2 id="1、管理卷的命令"><a href="#1、管理卷的命令" class="headerlink" title="1、管理卷的命令"></a>1、管理卷的命令</h2><p>docker volume COMMAND</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>create</td><td>创建一个卷</td></tr><tr><td>inspect</td><td>显示详细信息</td></tr><tr><td>ls</td><td>列出所有卷</td></tr><tr><td>prune</td><td>删除所有不使用的卷</td></tr><tr><td>rm</td><td>删除指定的卷</td></tr></tbody></table><h2 id="2、添加数据卷"><a href="#2、添加数据卷" class="headerlink" title="2、添加数据卷"></a>2、添加数据卷</h2><p>需要使用<code>-v, --volume list</code>绑定挂载卷</p><h3 id="（1）Docker管理卷"><a href="#（1）Docker管理卷" class="headerlink" title="（1）Docker管理卷"></a>（1）Docker管理卷</h3><p><code>[root@node3~]#docker run --name test2 -it -v /data busybox</code></p><h4 id="查看数据卷在宿主机上的位置"><a href="#查看数据卷在宿主机上的位置" class="headerlink" title="查看数据卷在宿主机上的位置"></a>查看数据卷在宿主机上的位置</h4><p><code>[root@node3~]#docker inspect -f \{\{.Mounts\}\} test2</code></p><pre><code>[{volume bd7717309c8ae0c9a82e0a9ccab00a3eea3bb98472927e7eaad80365916c2f16 /var/lib/docker/volumes/bd7717309c8ae0c9a82e0a9ccab00a3eea3bb98472927e7eaad80365916c2f16/_data /data local  true }]</code></pre><p>可以直接在宿主机上进行操作</p><p><img src="http://owatlfstl.bkt.clouddn.com/docker0.1.gif" alt=""></p><h3 id="（2）绑定数据卷"><a href="#（2）绑定数据卷" class="headerlink" title="（2）绑定数据卷"></a>（2）绑定数据卷</h3><blockquote><p>在宿主机上创建一个挂载的目录</p></blockquote><p><code>[root@node3~]#mkdir /test3/data -pv</code></p><p><code>[root@node3~]#docker run --name test3 -it -v /test3/data:/data busybox</code></p><p><strong>注意：需要注意两种方式中 <code>-v</code>后的使用格式，绑定数据卷格式如<code>HOSTDIR:VOLUMEDIR</code></strong></p><h4 id="查看挂载目录"><a href="#查看挂载目录" class="headerlink" title="查看挂载目录"></a>查看挂载目录</h4><p><code>[root@node3~]#docker inspect -f \{\{.Mounts\}\} test3</code></p><pre><code>[{bind  /test3/data /data   true rprivate}]</code></pre><p><strong>注意：挂载本地目录到容器目录时，如果容器内的数据卷中已经存在数据，那么容器中的数据将被隐藏，而不会被删除。</strong><br><strong>容器目录必须使用绝对路径，而本地目录可以使用绝对路径或相对路径。</strong></p><p><strong><code>-v</code>参数不仅可以挂载目录，而且也可以挂载单个文件。</strong></p><h3 id="（3）复制使用其他容器卷"><a href="#（3）复制使用其他容器卷" class="headerlink" title="（3）复制使用其他容器卷"></a>（3）复制使用其他容器卷</h3><p>使用<code>--volumes-from</code>选项，后跟容器名称或者ID</p><p><code>[root@node3~]#docker run --name test5 -it --volumes-from test3 busybox:latest</code></p><h3 id="（4）多个容器使用同一个主机目录"><a href="#（4）多个容器使用同一个主机目录" class="headerlink" title="（4）多个容器使用同一个主机目录"></a>（4）多个容器使用同一个主机目录</h3><p><code>[root@node3~]#docker run --name test6 -it -v /test/data:/data busybox:latest</code></p><p><code>[root@node3~]#docker run --name test7 -it -v /test/data:/data busybox:latest</code></p>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 命令</title>
      <link href="/2017/12/11/Docker%E5%91%BD%E4%BB%A4/"/>
      <url>/2017/12/11/Docker%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Docker命令"><a href="#一、Docker命令" class="headerlink" title="一、Docker命令"></a>一、Docker命令</h1><p><img src="http://owatlfstl.bkt.clouddn.com/Whale%20Logo332@2x_5.png" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/404256463-545a1d114c535_articlex.png" alt=""></p><h2 id="docker命令选项列表"><a href="#docker命令选项列表" class="headerlink" title="docker命令选项列表"></a>docker命令选项列表</h2><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>–config [string]</td><td>客户端本地配置文件路径，默认为<code>~/.docker</code></td></tr><tr><td>-D,–debug</td><td>启动调试模式</td></tr><tr><td>-H，–host list</td><td>通过socket访问指定的docker守护进程</td></tr><tr><td>-l，–log-level</td><td>设置日志级别</td></tr><tr><td>–tls</td><td>启用TLS加密</td></tr></tbody></table><h2 id="1、查看docker信息"><a href="#1、查看docker信息" class="headerlink" title="1、查看docker信息"></a>1、查看docker信息</h2><ul><li><p>docker version [OPTIONS]    显示版本信息</p><p>-f, –format=””   Format the output using the given Go template</p></li></ul><p><strong>示例：</strong></p><p><code>[root@node3~]#docker version --format &#39;\{\{.Server.Version\}\}&#39;</code></p><pre><code>17.09.1-ce</code></pre><ul><li>docker info [OPTIONS] 显示系统信息</li></ul><p><strong>示例：</strong></p><p><code>[root@node3~]#docker info</code></p><h2 id="2、image操作命令"><a href="#2、image操作命令" class="headerlink" title="2、image操作命令"></a>2、image操作命令</h2><ul><li>docker search [OPTIONS] TERM  检索image</li></ul><p><strong>由于国内的某些因素，访问docker官方网站较慢，所以需要使用镜像加速器。如阿里云镜像加速器。</strong></p><blockquote><p>配置daemon.json文件</p></blockquote><p><code>[root@node3~]#vim /etc/docker/daemon.json</code></p><pre><code>  1 {  2   &quot;registry-mirrors&quot;: [&quot;https://加速地址&quot;]  3 }</code></pre><p><code>[root@node3~]#systemctl daemon-reload</code><br><code>[root@node3~]#systemctl restart docker.service</code></p><p><strong>注意：此文件在最新版中是没有的，需要手动创建即可。</strong></p><p><strong>示例：</strong></p><p><code>[root@node3~]#docker search busybox</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-11_211011.jpg" alt=""></p><ul><li>docker pull [OPTIONS] NAME[:TAG|@DIGEST]  下载镜像</li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-a,–all-tags</td><td>下载所有镜像文件</td></tr><tr><td>–disable-content-trust</td><td>跳过镜像检测</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@node3~]#docker pull busybox</code><br><strong>如果不指定标签，默认是下载最新版本。</strong></p><p><strong>也可以直接从官网下载<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></strong></p><ul><li>docker rm [OPTIONS] CONTAINER [CONTAINER…]  删除一个或者多个镜像</li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-f，–force</td><td>强制移除</td></tr><tr><td>-l，–link</td><td>移除链接</td></tr><tr><td>-v，–volume</td><td>移除卷有关联容器</td></tr></tbody></table><p><strong>注意：如果使用镜像ID作为参数，可以只输入前几位即可，能唯一确定即可。</strong></p><ul><li>docker history [OPTIONS] IMAGE 显示镜像的历史</li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>–no-trunc</td><td>显示全部信息</td></tr><tr><td>-q，–quiet</td><td>仅仅显示ID号</td></tr></tbody></table><h2 id="3、容器创建、启动并执行命令"><a href="#3、容器创建、启动并执行命令" class="headerlink" title="3、容器创建、启动并执行命令"></a>3、容器创建、启动并执行命令</h2><ul><li>docker run [参数] [镜像名 or 镜像id] [命令]</li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-d</td><td>后台运行容器，并返回容器ID</td></tr><tr><td>-i，–interactive=true</td><td>false</td><td>以交互式模式运行容器</td></tr><tr><td>-t，–tty=true</td><td>false</td><td>为容器重新分配一个伪输入终端</td></tr><tr><td>–name</td><td>为容器指定一个别名，不指定随机生成</td></tr><tr><td>-h,–hostname</td><td>为容器指定主机名</td></tr><tr><td>–dns</td><td>指定容器DNS服务器，默认和宿主机一致</td></tr><tr><td>-e</td><td>设置环境变量</td></tr><tr><td>–cpuset</td><td>绑定容器到指定的CPU运行</td></tr><tr><td>-m，–memory</td><td>指定容器的内存</td></tr><tr><td>–net</td><td>指定容器的网络连接类型</td></tr><tr><td>–ip</td><td>为容器指定IP地址</td></tr><tr><td>–expose</td><td>开放一个端口或一组端口，会覆盖镜像中开放的端口</td></tr><tr><td>-p [宿主机端口]:[容器内端口]</td><td>宿主机端口映射</td></tr><tr><td>–add-host [主机名]:[IP]</td><td>为容器hosts文件追加host，默认会在hosts文件最后追加[主机名]:[容器IP]</td></tr><tr><td>–volumes-from [其他容器]</td><td>将其他容器的数据卷添加此容器</td></tr><tr><td>–link [其他容器名]:[该容器中的别名]</td><td>添加链接到另一个容器</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@node3~]#docker run --name bbox -it busybox:latest</code></p><ul><li>docker create [OPTIONS] IMAGE [COMMAND] [ARG…] 创建容器</li></ul><p><strong>docker create 与docker run 区别</strong><br><img src="http://owatlfstl.bkt.clouddn.com/1789386-debe5c8093b7e1a1.png" alt=""></p><h2 id="4、查看容器"><a href="#4、查看容器" class="headerlink" title="4、查看容器"></a>4、查看容器</h2><p>docker ps [OPTIONS]</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-a，–all</td><td>显示所有容器</td></tr><tr><td>-l，–latest</td><td>列出最近一次启动的容器</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@node3~]#docker ps -a</code></p><pre><code>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES9e60d2dba3e4        busybox:latest      &quot;sh&quot;                3 minutes ago       Up 3 minutes                            bbox</code></pre><p><code>[root@node3~]#docker ps -l</code></p><pre><code>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES9e60d2dba3e4        busybox:latest      &quot;sh&quot;                3 minutes ago       Up 3 minutes                            bbox</code></pre><h2 id="5、容器管理命令"><a href="#5、容器管理命令" class="headerlink" title="5、容器管理命令"></a>5、容器管理命令</h2><ul><li>删除容器</li></ul><p><code>[root@node3~]#docker rm b1</code></p><ul><li>docker kill [OPTIONS] CONTAINER [CONTAINER…]  强制停止</li></ul><p><strong>示例：</strong></p><p><code>[root@node3~]#docker ps -a</code></p><ul><li>docker start [OPTIONS] CONTAINER [CONTAINER…]  启动容器</li></ul><p><strong>示例：</strong></p><p><code>[root@node3~]#docker start b2</code></p><ul><li>docker restart [OPTIONS] CONTAINER [CONTAINER…]    重启容器</li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-t，–time int</td><td>等待多久在重启</td></tr></tbody></table><p><code>[root@node3~]#docker restart -t 5 b2</code></p><ul><li>docker logs [OPTIONS] CONTAINER 输出容器日志</li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>–details</td><td>输出详细信息</td></tr><tr><td>-f，–follow</td><td>前台输出</td></tr><tr><td>–since string</td><td>从某个时间戳之后显示</td></tr><tr><td>–tail string</td><td>从尾部显示，默认为全部</td></tr><tr><td>-t，–timestamps</td><td>指定时间戳</td></tr></tbody></table><ul><li>docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-<pre><code>  docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH      从容器里面拷贝文件/目录到本地一个路径</code></pre></li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-a，–archive</td><td>归档模式</td></tr><tr><td>-L，–follow-link</td><td>复制符号链接</td></tr></tbody></table><ul><li>docker attach [OPTIONS] CONTAINER 附加到一个运行的容器上</li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>–detach-keys string</td><td>脱离</td></tr><tr><td>–no-stdin</td><td>不附加输入</td></tr><tr><td>–sig-proxy</td><td>代理全部信息号进程</td></tr></tbody></table><h2 id="6、保存和加载镜像"><a href="#6、保存和加载镜像" class="headerlink" title="6、保存和加载镜像"></a>6、保存和加载镜像</h2><ul><li>docker save [OPTIONS] IMAGE [IMAGE…] 保存镜像到指定文件中</li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-o，–output string</td><td>指定文件</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@node3~]#docker save 6ad -o /root/test</code></p><ul><li>docker load [OPTIONS] 加载镜像</li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-i，–input string</td><td>指定镜像存储的文件</td></tr><tr><td>-q，–quiet</td><td>静默加载</td></tr></tbody></table><p><strong>示例：</strong><br><code>[root@node3~]#docker load -i /root/test</code> </p><pre><code>Loaded image ID: sha256:6ad733544a6317992a6fac4eb19fe1df577d4dec7529efec28a5bd0edad0fd30</code></pre><h2 id="7、查看容器详情"><a href="#7、查看容器详情" class="headerlink" title="7、查看容器详情"></a>7、查看容器详情</h2><p>docker inspect [OPTIONS] NAME|ID [NAME|ID…]</p><p><strong>示例：</strong></p><p><code>[root@node3~]#docker inspect b2</code> 显示的格式为json格式</p><h2 id="8、查看容器正在运行的进程"><a href="#8、查看容器正在运行的进程" class="headerlink" title="8、查看容器正在运行的进程"></a>8、查看容器正在运行的进程</h2><p>docker top CONTAINER [ps OPTIONS]</p><p><strong>示例：</strong></p><p><code>[root@node3~]#docker top b2</code></p><pre><code>UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMDroot                46135               46124               0                   22:43               pts/0               00:00:00            sh</code></pre><h2 id="9、将容器保存为镜像"><a href="#9、将容器保存为镜像" class="headerlink" title="9、将容器保存为镜像"></a>9、将容器保存为镜像</h2><p> docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-a，–author string</td><td>作者信息，一般格式为<code>作者名 &lt;邮箱地址&gt;</code></td></tr><tr><td>-c，–change list</td><td>应用Dockerfile结构创建镜像</td></tr><tr><td>-m，–message string</td><td>注释信息</td></tr><tr><td>-p，–pause</td><td>在提交时暂停提交操作</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@node3~]#docker commit -a &quot;joah &lt;admin@root&gt;&quot; -m &quot;test&quot; -p b2</code></p><pre><code>sha256:f3209df6c828869dd65f4e74e5b62101c3633dca764fe48ed3f5f565c0a58873</code></pre><p><code>[root@node3~]#docker image ls</code></p><pre><code>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE&lt;none&gt;              &lt;none&gt;              f3209df6c828        6 seconds ago       1.13MBbusybox             latest              6ad733544a63        5 weeks ago         1.13MB</code></pre><p><strong>示例：</strong></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-11_231413.jpg" alt=""></p><h2 id="10、显示容器的数据库"><a href="#10、显示容器的数据库" class="headerlink" title="10、显示容器的数据库"></a>10、显示容器的数据库</h2><p>docker stats [OPTIONS] [CONTAINER…]</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-a，–all</td><td>显示所有容器</td></tr><tr><td>–no-stream</td><td>不显示流式状态仅仅显示第一次结果</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@node3~]#docker stats --no-stream b2</code></p><pre><code>CONTAINER           CPU %               MEM USAGE / LIMIT   MEM %               NET I/O             BLOCK I/O           PIDSb2                  0.00%               56KiB / 976.3MiB    0.01%               648B / 0B           0B / 0B             1</code></pre><h2 id="11、执行命令"><a href="#11、执行命令" class="headerlink" title="11、执行命令"></a>11、执行命令</h2><p>docker exec [OPTIONS] CONTAINER COMMAND [ARG…]</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-d，–detach</td><td>运行在后台</td></tr><tr><td>-e，–env list</td><td>设置环境变量</td></tr><tr><td>-i，–interactive</td><td>交互式运行</td></tr><tr><td>-t，–tty</td><td>添加的伪终端</td></tr><tr><td>-u，–user string</td><td>指定用户</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@node3~]#docker exec -it -d b2 ifconfig</code></p><h2 id="12、将镜像存储到仓库中"><a href="#12、将镜像存储到仓库中" class="headerlink" title="12、将镜像存储到仓库中"></a>12、将镜像存储到仓库中</h2><p><code>docker push [OPTIONS] NAME[:TAG]</code></p><p><code>docker login [OPTIONS] [SERVER]</code>  登录Docker仓库</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>–p,–password string</td><td>登录仓库密码</td></tr><tr><td>-u，–username string</td><td>登录仓库用户名</td></tr></tbody></table><p><strong>示例：</strong></p><blockquote><p>登录仓库<br><code>[root@node3~]#docker login --username=账户 registry.cn-shanghai.aliyuncs.com</code></p></blockquote><pre><code>Password:   #此处的密码是登录仓库的密码Login Succeeded</code></pre><p><code>[root@node3~]#docker tag f3209df registry.cn-shanghai.aliyuncs.com/joah/test:v0.1</code> #打标签</p><p><code>[root@node3~]#docker push registry.cn-shanghai.aliyuncs.com/joah/test:v0.1</code>    #将仓库推上去</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-12_093015.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker四种网络模式</title>
      <link href="/2017/12/11/Docker%20%E5%9B%9B%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/12/11/Docker%20%E5%9B%9B%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Docker四种网络模式"><a href="#一、Docker四种网络模式" class="headerlink" title="一、Docker四种网络模式"></a>一、Docker四种网络模式</h1><p>通常来说，要实现网络通信，机器需要至少一个网络接口来收发数据包，另外，如果在不同的子网进行通信，还需要路由机制。<br><img src="http://owatlfstl.bkt.clouddn.com/network-container-archetypes.png" alt=""></p><h2 id="1、Bridge-containers"><a href="#1、Bridge-containers" class="headerlink" title="1、Bridge containers"></a>1、Bridge containers</h2><p><img src="http://owatlfstl.bkt.clouddn.com/network-container-archetypes02.png" alt=""><br>当Docker启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。从docker0子网中分配一个IP地址给容器使用，并设置docker0的IP地址为容器的默认网关。</p><p><img src="http://owatlfstl.bkt.clouddn.com/819128-20170504225154632-2077649980.png" alt=""><br>在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一段放在新创建的容器中，并命名为eth0（容器网卡），另一端放在主机中，并以vethXXX命名，并将这个网络设备加入到docker0网桥中。可以通过brctl 命令查看。</p><p>这种模式是docker使用的默认网络。</p><p><code>[root@node3~]#docker run --name bbox1 -it --rm --net=bridge busybox:latest</code></p><pre><code>/ # ifconfigeth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:04            inet addr:172.17.0.4  Bcast:0.0.0.0  Mask:255.255.0.0          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:6 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0           RX bytes:508 (508.0 B)  TX bytes:0 (0.0 B)lo        Link encap:Local Loopback            inet addr:127.0.0.1  Mask:255.0.0.0          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1           RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-13_210739.jpg" alt=""></p><h2 id="2、closed-containers"><a href="#2、closed-containers" class="headerlink" title="2、closed containers"></a>2、closed containers</h2><p><img src="http://owatlfstl.bkt.clouddn.com/network-container-archetypes01.png" alt=""></p><p>Docker容器拥有自己的network Namespace，并不为Docker容器进行任何网络配置。只能使用loopback接口（即可以使用127.0.0.1或localhost）。这种原型最具隔离性和安全性。使用于无需网络连接的任务。</p><p><code>[root@node3~]#docker run --name bbox1 -it --net=none --rm busybox:latest</code></p><pre><code>/ # ifconfiglo        Link encap:Local Loopback            inet addr:127.0.0.1  Mask:255.0.0.0          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1           RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</code></pre><h2 id="3、joined-containers"><a href="#3、joined-containers" class="headerlink" title="3、joined containers"></a>3、joined containers</h2><p><img src="http://owatlfstl.bkt.clouddn.com/network-container-archetypes03.png" alt=""></p><p>指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，而是和一个指定的容器共享IP、端口范围等。两个容器除了网络以外，其他的还是隔离的。</p><p><code>[root@node3~]#docker run --name bbox2 -it --rm --net=container:bbox1 busybox:latest</code></p><pre><code>/ # ifconfigeth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02            inet addr:172.17.0.2  Bcast:0.0.0.0  Mask:255.255.0.0          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:8 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0           RX bytes:648 (648.0 B)  TX bytes:0 (0.0 B)lo        Link encap:Local Loopback            inet addr:127.0.0.1  Mask:255.0.0.0          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1           RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/docker0.2.gif" alt=""></p><h3 id="（1）使用这种模式情况："><a href="#（1）使用这种模式情况：" class="headerlink" title="（1）使用这种模式情况："></a>（1）使用这种模式情况：</h3><ul><li>当不同容器中的程序向通过一个lo接口进行同行时</li><li>当一个容器中的程序修改网络堆栈，而另一个容器中的程序向使用这个修改过的网络堆栈</li><li>当向对另一个容器中的程序进行网络流量监测时</li></ul><h2 id="4、open-containers"><a href="#4、open-containers" class="headerlink" title="4、open containers"></a>4、open containers</h2><p><img src="http://owatlfstl.bkt.clouddn.com/network-container-archetypes04.png" alt=""></p><p>如果使用这种模式，docker容器将不会获得一个独立的Network Namespace，而是和宿主机功用一个Network Namespace。容器将不会虚拟出自己的网卡，而是使用宿主机的IP和端口。</p><p><code>[root@node3~]#docker run --name bbox1 -it --rm --net=host busybox:latest</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/docker0.3.gif" alt=""></p><h1 id="二、docker-网络命令"><a href="#二、docker-网络命令" class="headerlink" title="二、docker 网络命令"></a>二、docker 网络命令</h1><h2 id="1、docker-network命令你给"><a href="#1、docker-network命令你给" class="headerlink" title="1、docker network命令你给"></a>1、docker network命令你给</h2><p>docker network COMMAND</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>connect</td><td>连接容器到某个网络中</td></tr><tr><td>create</td><td>创建一个网络</td></tr><tr><td>disconnect</td><td>剥离网络</td></tr><tr><td>inspect</td><td>查看详细信息</td></tr><tr><td>ls</td><td>列出网络</td></tr><tr><td>prune</td><td>移除所有网络</td></tr><tr><td>rm</td><td>删除指定网络</td></tr></tbody></table><h3 id="（1）docker-network-create命令"><a href="#（1）docker-network-create命令" class="headerlink" title="（1）docker network create命令"></a>（1）docker network create命令</h3><p>docker network create [OPTIONS] NETWORK</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-d，–dirver string</td><td>指定网络类型，默认为bridge</td></tr><tr><td>–gateway</td><td>指定网关</td></tr><tr><td>–label list</td><td>相当于设置标签</td></tr><tr><td>–subnet stringSlice</td><td>设定子网</td></tr><tr><td>–internal</td><td>限制外网网络连接到这个网络</td></tr><tr><td>–ip-range</td><td>从一个IP范围分配IP</td></tr></tbody></table><p><strong>示例：</strong><br><code>[root@node3~]#docker network create --subnet 192.168.101.0/24 --ip-range=192.168.101.0/24 mytest3</code></p><p><code>[root@node3~]#docker network prune</code><br><strong>注意：此操作非常危险，建议不要使用。</strong></p><h1 id="三、容器间的依赖关系"><a href="#三、容器间的依赖关系" class="headerlink" title="三、容器间的依赖关系"></a>三、容器间的依赖关系</h1><p>创建容器时，可以指定关联其他正在运行的容器。在新建容器关联其他容器时会发生3件事情：</p><ul><li>一个描述目标容器端点的环境变量会被创建</li><li>目标容器的别名及IP会在新建容器的/etc/hosts中创建</li><li>假如容器间的通信被禁止的话，Docker会特意为这两个关联的容器添加专门的防火墙规则</li></ul><p><code>[root@node3~]#docker run --name bbox1 -it --rm busybox:latest</code></p><p><code>[root@node3~]#docker run --name bbox2 -it --rm --link bbox1 busybox:latest</code></p>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker初识</title>
      <link href="/2017/12/10/Docker%E5%88%9D%E8%AF%86/"/>
      <url>/2017/12/10/Docker%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Docker初识"><a href="#一、Docker初识" class="headerlink" title="一、Docker初识"></a>一、Docker初识</h1><p><img src="http://owatlfstl.bkt.clouddn.com/Whale%20Logo332@2x_5.png" alt=""><br>Docker是一个开放源代码软件项目，让应用程序部署在软件容器下的工作可以自动化进行，借此在linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。</p><h2 id="1、Docker与虚拟化技术区别"><a href="#1、Docker与虚拟化技术区别" class="headerlink" title="1、Docker与虚拟化技术区别"></a>1、Docker与虚拟化技术区别</h2><p><img src="http://owatlfstl.bkt.clouddn.com/1488766392928_3.png" alt=""><br><img src="http://owatlfstl.bkt.clouddn.com/1488766393160_4.png" alt=""></p><ul><li>更高效的利用系统资源</li><li>更快速的启动时间</li><li>一致的运行环境</li><li>持续交付和部署</li><li>更轻松的迁移</li><li>更轻松的维护和扩展<br><img src="http://owatlfstl.bkt.clouddn.com/VM@2x.png" alt=""><br><img src="http://owatlfstl.bkt.clouddn.com/Container@2x.png" alt=""></li></ul><h2 id="2、Docker构成"><a href="#2、Docker构成" class="headerlink" title="2、Docker构成"></a>2、Docker构成</h2><p><img src="http://owatlfstl.bkt.clouddn.com/1488766393778_6.png" alt=""></p><ul><li>Docker服务器守护程序，用于管理所有容器</li><li>Docker命令行客户端，实际上使docker的二进制程序；用户控制服务器守护程序</li><li>Docker镜像，查找和浏览docker容器镜像</li></ul><h2 id="3、Docker内部构成"><a href="#3、Docker内部构成" class="headerlink" title="3、Docker内部构成"></a>3、Docker内部构成</h2><ul><li>Docker images 镜像<br><img src="http://owatlfstl.bkt.clouddn.com/f6aab13f31fbc9f040f83978ca3f8089.png" alt=""><br>Docker镜像时一个特殊的文件系统，除了提供容器运行时所需要的程序、库、资源、配置文件等外，还包含了一些为运行时嘴巴的一些配置参数。</li></ul><p><img src="http://owatlfstl.bkt.clouddn.com/docker-filesystems-generic.png" alt=""><br>采用分层构建机制，最底层为bootfs，其上为rootfs。</p><pre><code>- bootfs：用于系统引导的文件系统，包括bootloader和kernel，容器启动完成后会被卸载以节约内存资源- rootfs：位于bootfs之上，为docker容器的根文件系统；与传统模式不同的是，docker中的rootfs由内核挂载为“只读”模式，而后通过“联合挂载”技术额外挂载一个“可写”层。</code></pre><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己的这一层。比如，删除前一层文件的操作，实际不是真的删除前一层文件，而是仅在当前文件标记为文件已删除。在最终容器运行时候，虽然不会看到此文件但是实际上该文件会一致跟随镜像。</p><ul><li>Docker registeries 仓库</li></ul><p>Docker仓库用来保存镜像，包括惊喜哪个的层次结构和元数据；可以理解为代码控制中的代码仓库。由某特定的docker镜像的所有迭代版本组成的镜像仓库。每个仓库可以包含多个Tag，每个标签对应一个镜像版本。</p><p>一个Docker Registry中可以包含多个仓库；每个仓库可以包含多个标签，每个标签对应一个镜像。通常一个仓库包含同一个软件不同版本的镜像，而标签就常用语对应该软件的各个版本。如果不指定标签，默认为<code>latest</code>最为默认标签。</p><p>Index，维护用户账户、镜像的校验以及公共命名空间的信息；相当于为registry提供了一个完成用户认证等功能的检索接口。</p><h5 id="Docker-Registry分类"><a href="#Docker-Registry分类" class="headerlink" title="Docker Registry分类"></a>Docker Registry分类</h5><ul><li>sponsor registry：第三方的registry，公客户和Docker社区使用</li><li>Mirror Register：第三方的registry，只让客户使用</li><li>Vendor Registry：由发布Docker镜像的供应商提供的registry</li><li><p>Private Registrt：通过设有防火墙和额外的安全曾的私有实体提供的registry</p></li><li><p>Docker container 容器<br>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行属于自己的独立命名空间。每个容器运行时是以镜像为基础层，在其上创建一个当前容器的存储层；容器存储层的生命周期和容器一样，容器消亡时，容器存储层也随之消亡。</p></li></ul><p><img src="http://owatlfstl.bkt.clouddn.com/%E4%B8%80%E5%9B%BE%E7%9C%8B%E5%B0%BDDocker%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png" alt=""></p><h2 id="4、Docker镜像管理"><a href="#4、Docker镜像管理" class="headerlink" title="4、Docker镜像管理"></a>4、Docker镜像管理</h2><p><img src="http://owatlfstl.bkt.clouddn.com/001.jpg" alt=""></p><p>（1）获取repo所有的镜像ID<br>（2）获取repo所有tag信息<br>（3）根据tag找到对应的镜像UUID，并下载该镜像</p><pre><code>- 获取该镜像history信息，并依次下载这些镜像层- 如果这些镜像层存在，就跳过- 获取镜像层的json信息- 下载镜像内容- 下载完成后，把下载的内容存放到本地UnionFS系统- 在TagStore添加刚下载的镜像信息</code></pre><h2 id="5、Docker特性"><a href="#5、Docker特性" class="headerlink" title="5、Docker特性"></a>5、Docker特性</h2><ul><li>文件系统隔离：每个进程容器运行在完全独立的根文件系统里</li><li>资源隔离：可以使用Cgroup为每个进程容器分配不同的系统资源</li><li>网络隔离：每个进程容器运行在自己的网络命名的空间里，拥有自己的虚拟接口和IP地址</li><li>写时复制：采用写时复制方式创建根文件系统，让部署变的更为快捷，并且节省内存和硬盘空间</li><li>日志记录：Docker将会收集和记录每个进程容器的标准流，用于实时检索或批量检索</li><li>变更管理：容器文件系统的变更可以提交到新的映像中，并可重复使用以创建更多的容器</li><li>交互式shell：Docker可以分配一个虚拟终端并关联到任何容器的标准输出上。</li></ul><h1 id="二、Docker安装"><a href="#二、Docker安装" class="headerlink" title="二、Docker安装"></a>二、Docker安装</h1><p><img src="http://owatlfstl.bkt.clouddn.com/Whale%20Logo332@2x_5.png" alt=""></p><h2 id="1、extra仓库安装"><a href="#1、extra仓库安装" class="headerlink" title="1、extra仓库安装"></a>1、extra仓库安装</h2><p>这里我配置的是CentOS仓库，选择使用阿里云镜像。</p><p><code>[root@node3~]#vim /etc/yum.repos.d/base.repo</code></p><pre><code>  [extra]  name=extra  baseurl=https://mirrors.aliyun.com/centos/7/extras/x86_64/  gpgcheck=0</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-11_194830.jpg" alt=""></p><p><code>[root@node3~]#yum install -y docker</code></p><p><code>[root@node3~]#systemctl restart docker.service</code>    #启动服务</p><blockquote><p>查看版本信息</p></blockquote><p><code>[root@node3~]#docker version</code></p><pre><code>Client: Version:         1.12.6 API version:     1.24 Package version: docker-1.12.6-61.git85d7426.el7.centos.x86_64 Go version:      go1.8.3 Git commit:      85d7426/1.12.6 Built:           Tue Oct 24 15:40:21 2017 OS/Arch:         linux/amd64Server: Version:         1.12.6 API version:     1.24 Package version: docker-1.12.6-61.git85d7426.el7.centos.x86_64 Go version:      go1.8.3 Git commit:      85d7426/1.12.6 Built:           Tue Oct 24 15:40:21 2017 OS/Arch:         linux/amd64</code></pre><h2 id="2、官方仓库安装"><a href="#2、官方仓库安装" class="headerlink" title="2、官方仓库安装"></a>2、官方仓库安装</h2><blockquote><p>安装仓库</p></blockquote><p><code>[root@node3~]#yum-config-manager     --add-repo     https://download.docker.com/linux/centos/docker-ce.repo</code></p><blockquote><p>查看是否安装成功</p></blockquote><p><code>[root@node3~]#ls /etc/yum.repos.d/</code></p><pre><code>backup  base.repo  docker-ce.repo</code></pre><blockquote><p>安装docker</p></blockquote><p><strong>注意：如果之前安装过docker，需要执行如下命令删除原有文件，否则会报错。</strong><br><img src="http://owatlfstl.bkt.clouddn.com/2017-12-11_201154.jpg" alt=""></p><p><code>[root@node3~]#yum remove docker docker-common docker-selinux docker-engine</code></p><p><code>[root@node3~]#yum install -y docker-ce</code></p><blockquote><p>启动服务</p></blockquote><p><code>[root@node3~]#systemctl start docker.service</code></p><blockquote><p>查看是否启动成功</p></blockquote><p><code>[root@node3~]#docker version</code></p><pre><code>Client: Version:      17.09.1-ce API version:  1.32 Go version:   go1.8.3 Git commit:   19e2cf6 Built:        Thu Dec  7 22:23:40 2017 OS/Arch:      linux/amd64Server: Version:      17.09.1-ce API version:  1.32 (minimum version 1.12) Go version:   go1.8.3 Git commit:   19e2cf6 Built:        Thu Dec  7 22:25:03 2017 OS/Arch:      linux/amd64 Experimental: false</code></pre><h2 id="3、rpm安装包安装"><a href="#3、rpm安装包安装" class="headerlink" title="3、rpm安装包安装"></a>3、rpm安装包安装</h2><p>下载地址：<a href="https://download.docker.com/linux/centos/7/x86_64/stable/Packages/" target="_blank" rel="noopener">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a></p><p><code>[root@node3~]#yum install -y docker-ce-17.09.1.ce-1.el7.centos.x86_64.rpm docker-ce-selinux-17.03.2.ce-1.el7.centos.noarch.rpm</code></p><h1 id="二、Docker目录"><a href="#二、Docker目录" class="headerlink" title="二、Docker目录"></a>二、Docker目录</h1><h2 id="1、Docker数据目录"><a href="#1、Docker数据目录" class="headerlink" title="1、Docker数据目录"></a>1、Docker数据目录</h2><p><code>[root@node3/var/lib/docker]#tree</code></p><pre><code>.├── builder│   └── fscache.db├── containers  用来存储容器信息├── image│   └── overlay│       ├── distribution│       ├── imagedb│       │   ├── content│       │   │   └── sha256│       │   └── metadata│       │       └── sha256│       ├── layerdb│       └── repositories.json├── network docker网络目录│   └── files│       └── local-kv.db├── overlay├── plugins docker插件目录│   ├── storage│   │   └── blobs│   │       └── tmp│   └── tmp├── swarm├── tmp docker临时目录├── trust   docker信任目录└── volumes docker卷目录    └── metadata.db 卷元数据数据库</code></pre>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LXC介绍</title>
      <link href="/2017/12/10/LXC%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/12/10/LXC%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="一、LXC"><a href="#一、LXC" class="headerlink" title="一、LXC"></a>一、LXC</h1><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-10_190453.jpg" alt=""><br>Linux Containers的缩写，一种操作系统层虚拟化（Operating system-level virtualization）技术，为linux内核容器功能的一个用户空间接口。它将应用软件系统打包成一个软件容器，以及所需要的操作系统核心和库。通过统一的名字空间和功用API来分配不同软件容器的可用硬件资源，创造出应用程序的独立沙箱运行环境，使得linux用户可以容器的创建和管理系统或应用容器。<br>LXC实现是基于内核中的namespace和cgroup实现。</p><h2 id="1、namespace（命名空间）"><a href="#1、namespace（命名空间）" class="headerlink" title="1、namespace（命名空间）"></a>1、namespace（命名空间）</h2><p>在linux操作系统中，系统资源如：进程、用户账户、文件系统、网络都属于某个namespace。namespace的生效主要是通过clone系统调用来实现的。</p><h3 id="（1）pid-namespace"><a href="#（1）pid-namespace" class="headerlink" title="（1）pid namespace"></a>（1）pid namespace</h3><p>不同用户的进程就是通过pid namespace隔离开的，且不同namespace中可以有相同的PID。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>每个namespace中的pid有自己的pid=1的进程（类似/sbin/init进程）</li><li>每个namespace中的进程只能影响自己的同一个namespace或子namespace中的进程</li><li>/proc包含正在运行的进程，在container中的pesudo-filesystem的/proc目录只能看到自己namespace中的进程</li><li>namespace允许嵌套，父namespace可以影响子namespace的进程，所以子namespace的进程可以在父namespace中看到，但是具有不同的PID</li></ul><p><img src="http://owatlfstl.bkt.clouddn.com/872539-20160812175010437-24878092.jpg" alt=""></p><h3 id="（2）net-namespace"><a href="#（2）net-namespace" class="headerlink" title="（2）net namespace"></a>（2）net namespace</h3><p>每个net namespace有独立的network device 、ip address、ip routing tables和/proc/net目录。<br><img src="http://owatlfstl.bkt.clouddn.com/872539-20160812173604500-523951321.jpg" alt=""></p><h3 id="（3）ipc-namespace"><a href="#（3）ipc-namespace" class="headerlink" title="（3）ipc namespace"></a>（3）ipc namespace</h3><p>container中进程交互还是采用linux常见的进程间交互方法，包括常见的信号量、消息队列和共享内存。但是在同一个VM不同，container的进程间交互时间上还是host上具有相同pid namespace中的进程间交互，因此需要在IPC资源申请时加入namespace信息，每个IPC资源有一个唯一的32bit ID。只有处理在同一个namespace下的进程可以进行进程间通信<br><img src="http://owatlfstl.bkt.clouddn.com/872539-20160812173228312-781937108.jpg" alt=""></p><h3 id="（4）mnt-namespace"><a href="#（4）mnt-namespace" class="headerlink" title="（4）mnt namespace"></a>（4）mnt namespace</h3><p>类似chroot，将一个进程放到一个特定的目录执行。但是同chroot不同的是，每个namespace中的container在/proc/mounts的信息只包含在namespace的mount point。<br><img src="http://owatlfstl.bkt.clouddn.com/872539-20160812172504843-1384235657.jpg" alt=""></p><h3 id="（5）uts-namespace"><a href="#（5）uts-namespace" class="headerlink" title="（5）uts namespace"></a>（5）uts namespace</h3><p>UTS(UNIX Time-sharing System) namespace允许每个container拥有独立的hostname的domain name，使其在网络上可以被看做一个独立的节点而非host上的一个进程。</p><h3 id="（6）user-namespace"><a href="#（6）user-namespace" class="headerlink" title="（6）user namespace"></a>（6）user namespace</h3><p>每个container可以有不同的user和group id，即container内部的用户在container内部执行程序而非Host上的用户。在Guest-OS中创建的root用户会被映射到Host-OS中的普通用户中去。<br><img src="http://owatlfstl.bkt.clouddn.com/872539-20160813150906375-1848115443.jpg" alt=""></p><h2 id="2、Cgroup"><a href="#2、Cgroup" class="headerlink" title="2、Cgroup"></a>2、Cgroup</h2><p>Cgroup（Control groups）是linux内核提供的一种可以限制、记录、隔离进程组所使用的物理资源（CPU、I/O、内存等）的机制。Cgroup是LXC实现虚拟化所使用的资源管理手段。</p><h3 id="（1）Cgroup功能"><a href="#（1）Cgroup功能" class="headerlink" title="（1）Cgroup功能"></a>（1）Cgroup功能</h3><ul><li>限制进程组可以使用的资源数量</li><li>控制进程组的优先级</li><li>记录进程组使用资源的数量</li><li>进程组隔离</li><li>进程组控制</li></ul><h3 id="（2）Cgroup子系统"><a href="#（2）Cgroup子系统" class="headerlink" title="（2）Cgroup子系统"></a>（2）Cgroup子系统</h3><ul><li>blkio：设定输入输出控制</li><li>cpu：使用调度程序对CPU的Cgroup任务访问</li><li>cpuacct：自动生成Cgroup任务所使用的CPU报告</li><li>cpuset：为Cgroup中的任务分配独立的CPU和内存节点</li><li>devices：允许或拒绝Cgroup中的任务访问设备</li><li>freezer：挂起或回复Cgroup中的任务</li><li>memory：Cgroup中任务使用的内存控制</li><li>net_cls：允许linux流量控制程序识别从Cgroup中生成的数据包</li><li>ns：命名空间子系统</li></ul><h3 id="（3）Cgroup常见关键词"><a href="#（3）Cgroup常见关键词" class="headerlink" title="（3）Cgroup常见关键词"></a>（3）Cgroup常见关键词</h3><ul><li>任务：任务就是系统中的一个进程</li><li>控制族群：一组按某种标准划分的进程，控制族群通常按照应用划分，即与某应用相关的一组进程，被划分为一个进程组。Cgroup中资源控制都是都是以控制族群为单位实现的。</li><li>层级：控制族群可以组织成层级的形式，控制族群数</li><li>子系统：资源控制器。</li></ul><h1 id="二、LXC和KVM"><a href="#二、LXC和KVM" class="headerlink" title="二、LXC和KVM"></a>二、LXC和KVM</h1><p><img src="http://owatlfstl.bkt.clouddn.com/872539-20160812165840453-2118039400.jpg" alt=""></p><p>KVM的优点时一个物理机上可以跑多个操作系统，每个操作系统运行应用，通过这种方式实现应用的隔离。</p><p>LXC直接可以在宿主机的基础上实现隔离。</p><p>但是如果有两个应用一个是在Windows中运行的，另一个是在Linux中运行的，这时只能在KVM技术上实现了。</p><h1 id="三、LXC管理命令"><a href="#三、LXC管理命令" class="headerlink" title="三、LXC管理命令"></a>三、LXC管理命令</h1><h2 id="1、lxc-version"><a href="#1、lxc-version" class="headerlink" title="1、lxc-version"></a>1、lxc-version</h2><p>用于显示系统LXC版本号</p><h2 id="2、lxc-checkconfig"><a href="#2、lxc-checkconfig" class="headerlink" title="2、lxc-checkconfig"></a>2、lxc-checkconfig</h2><p>用于判断linux内核是否支持LXC</p><h2 id="3、lxc-creste"><a href="#3、lxc-creste" class="headerlink" title="3、lxc-creste"></a>3、lxc-creste</h2><p>创建一个容器</p><p>用法：</p><pre><code>lxc-create --name=NAME -t template [-w] [-r] [-P lxcpath]</code></pre><table><thead><tr><th>选型</th><th>描述</th></tr></thead><tbody><tr><td>-n，–name=NAME</td><td>容器名称</td></tr><tr><td>-f,–config=file</td><td>初始化配置文件</td></tr><tr><td>-t，–template=t</td><td>创建容器使用的容器</td></tr><tr><td>-P，–lxcpath=PATH</td><td>指定容器的安装位置，默认/var/lib/lxc目录下</td></tr></tbody></table><p><strong>注意：容器命名空间是全局的，系统中不允许存在重名的容器。</strong></p><h2 id="4、lxc-execute"><a href="#4、lxc-execute" class="headerlink" title="4、lxc-execute"></a>4、lxc-execute</h2><p>执行应用程序</p><p>用法：</p><pre><code>lxc-execute --name=NAME -- COMMAND</code></pre><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-n，–name=NAME</td><td>指定容器的名称</td></tr><tr><td>-f，–rcfile=FILE</td><td>加载配置文件</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>如果容器不存在，lxc-execute会自动创建一个，容器停止运行后会被自动销毁</li><li>lxc-execute启用应用程序，配置文件优先级：如果指定-f选项，之前创建容器的配置文件不会被使用；执行-s选项，命令行中的配置键值对会覆盖配置文件相同配置。</li></ul><h2 id="5、lxc-start"><a href="#5、lxc-start" class="headerlink" title="5、lxc-start"></a>5、lxc-start</h2><p>用于在容器中执行给定的命令</p><p>用法：</p><pre><code>lxc-start --name=NAME -- COMMAND</code></pre><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-d，–daemon</td><td>守护方式运行</td></tr><tr><td>-n，–name=NAME</td><td>指定容器的名称</td></tr><tr><td>-c，–console-log=FILE</td><td>指定一个文件作为容器的输出，默认输出终端</td></tr></tbody></table><p><strong>lxc-start和lxc-execute都可以在容器中启动进程，区别在于lxc-start直接创建进程，lxc-execute先创建lxc-init进程，然后在lxc-init中fork一个进程来执行。</strong></p><h2 id="6、lxc-stop"><a href="#6、lxc-stop" class="headerlink" title="6、lxc-stop"></a>6、lxc-stop</h2><p>停止容器中的所有进程</p><p>用法：</p><pre><code>lxc-stop --name=NAME</code></pre><h2 id="7、lxc-cgroup"><a href="#7、lxc-cgroup" class="headerlink" title="7、lxc-cgroup"></a>7、lxc-cgroup</h2><p>用户获取或调整cgroup相关的参数</p><p>用法：</p><pre><code> lxc-cgroup --name=NAME state-object [value]</code></pre><h2 id="8、lxc-info"><a href="#8、lxc-info" class="headerlink" title="8、lxc-info"></a>8、lxc-info</h2><p>获取容器的状态</p><h2 id="9、lxc-monitor"><a href="#9、lxc-monitor" class="headerlink" title="9、lxc-monitor"></a>9、lxc-monitor</h2><p>监视一个容器状态变换，当一个容器的状态发生变化时，会在屏幕上打印容器的状态</p><h2 id="10、lxc-top"><a href="#10、lxc-top" class="headerlink" title="10、lxc-top"></a>10、lxc-top</h2><p>监视容器统计数据</p><p>用法：</p><pre><code>lxc-top [--help] [--max count] [--delay delay] [--sort sortby] [--reverse]</code></pre><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-m，–max count</td><td>限制容器数量显示</td></tr><tr><td>-d，–delay delay</td><td>设置多少时间更新</td></tr><tr><td>-s，–sort sortby</td><td>指定使用什么方式显示</td></tr><tr><td>-r，–reverse</td><td>逆序显示</td></tr></tbody></table><h2 id="11、lxc-console"><a href="#11、lxc-console" class="headerlink" title="11、lxc-console"></a>11、lxc-console</h2><p>附加至指定容器的控制台</p><p>用法：</p><pre><code>lxc-console {-n name} [-e escape character] [-t ttynum]</code></pre><h2 id="12、lxc-destory"><a href="#12、lxc-destory" class="headerlink" title="12、lxc-destory"></a>12、lxc-destory</h2><p>删除处于停机状态的容器</p><h2 id="13、lxc-snapshot"><a href="#13、lxc-snapshot" class="headerlink" title="13、lxc-snapshot"></a>13、lxc-snapshot</h2><p>创建和恢复快照</p><p>用法：</p><pre><code>   lxc-snapshot {-n, --name name} [-c, --comment file]   lxc-snapshot {-n, --name name} {-d, -destroy snapshot-name}   lxc-snapshot {-n, --name name} {-L, --list } [-C, --showcomments ]   lxc-snapshot {-n, --name name} {-r, -restore snapshot-name} [ newname]</code></pre><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-c，–comment comment_file</td><td>描述信息</td></tr><tr><td>-d，–destory snapshot-name</td><td>删除快照</td></tr><tr><td>-L，–list</td><td>列出快照</td></tr><tr><td>-C，–showcomments</td><td>显示快照的描述信息</td></tr><tr><td>-r，–restore snapshot-name</td><td>创建快照</td></tr></tbody></table><h1 id="四、LXC安装"><a href="#四、LXC安装" class="headerlink" title="四、LXC安装"></a>四、LXC安装</h1><h2 id="1、安装LXC"><a href="#1、安装LXC" class="headerlink" title="1、安装LXC"></a>1、安装LXC</h2><p>LXC是存放在epel仓库中，前提需要配置epel仓库。</p><p><code>[root@node4~]#yum install -y lxc lxc-template</code></p><table><thead><tr><th>安装包</th><th>描述</th></tr></thead><tbody><tr><td>lxc</td><td>LXC主程序包</td></tr><tr><td>lxc-templates</td><td>创建容器的模板</td></tr></tbody></table><h2 id="2、LXC文件"><a href="#2、LXC文件" class="headerlink" title="2、LXC文件"></a>2、LXC文件</h2><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td><code>/usr/sharelxc/config</code></td><td>LXC配置文件目录</td></tr><tr><td><code>/usr/share/lxc/templates</code></td><td>LXC模板文件目录</td></tr></tbody></table><h1 id="五、LXC容器"><a href="#五、LXC容器" class="headerlink" title="五、LXC容器"></a>五、LXC容器</h1><h2 id="1、LXC容器创建"><a href="#1、LXC容器创建" class="headerlink" title="1、LXC容器创建"></a>1、LXC容器创建</h2><p><strong>注意：在创建容器之前，需检查配置环境是否适合创建。</strong></p><p><code>[root@node4~]#lxc-checkconfig</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-10_211856.jpg" alt=""></p><p>如果所在的环境中没有互联网，可以将仓库指向本地仓库。<br><img src="http://owatlfstl.bkt.clouddn.com/2017-12-10_213415.jpg" alt=""></p><p><code>[root@node4~]#lxc-create --name=centos -t /usr/share/lxc/templates/lxc-centos</code>     #创建centos容器</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-10_213859.jpg" alt=""></p><p><code>[root@node4~]#cat /var/lib/lxc/centos/tmp_root_pass</code>  密码存放位置</p><pre><code>Root-centos-4y1g32</code></pre><p><code>[root@node4~]#chroot /var/lib/lxc/centos/rootfs passwd</code>    #修改密码</p><pre><code>修使用chroot切换根，然后执行密码操作</code></pre><h2 id="2、-var-lib-lxc-centos目录"><a href="#2、-var-lib-lxc-centos目录" class="headerlink" title="2、/var/lib/lxc/centos目录"></a>2、<code>/var/lib/lxc/centos</code>目录</h2><table><thead><tr><th>文件或目录</th><th>描述</th></tr></thead><tbody><tr><td>config</td><td>配置文件</td></tr><tr><td>rootfs</td><td>根文件系统</td></tr><tr><td>rootfs.dev</td><td>设备文件</td></tr><tr><td>tem_root_pass</td><td>临时密码</td></tr></tbody></table><h2 id="3、操作命令"><a href="#3、操作命令" class="headerlink" title="3、操作命令"></a>3、操作命令</h2><h3 id="1、查看容器信息状态"><a href="#1、查看容器信息状态" class="headerlink" title="1、查看容器信息状态"></a>1、查看容器信息状态</h3><p><code>[root@node4~]#lxc-info --name centos</code>  </p><pre><code>Name:           centosState:          STOPPED</code></pre><h3 id="2、启动centos容器"><a href="#2、启动centos容器" class="headerlink" title="2、启动centos容器"></a>2、启动centos容器</h3><p><code>[root@node4~]#lxc-start --name centos</code></p><p><code>[root@node4~]#lxc-start -d --name centos</code> 运行在后台<br><img src="http://owatlfstl.bkt.clouddn.com/2017-12-10_214403.jpg" alt=""></p><h3 id="3、查看状态信息"><a href="#3、查看状态信息" class="headerlink" title="3、查看状态信息"></a>3、查看状态信息</h3><p><code>[root@node4~]#lxc-info --name centos</code></p><pre><code>Name:           centosState:          RUNNINGPID:            40945IP:             192.168.122.155CPU use:        0.11 secondsBlkIO use:      6.92 MiBMemory use:     3.95 MiBKMem use:       0 bytesLink:           vethCH1SV6 TX bytes:      1.76 KiB RX bytes:      9.75 KiB Total bytes:   11.51 KiB</code></pre><h1 id="六、LXC-Web-Panel"><a href="#六、LXC-Web-Panel" class="headerlink" title="六、LXC-Web-Panel"></a>六、LXC-Web-Panel</h1><p>LXC Web显示<br>详细地址：<a href="[root@node4~]#lxc-start -d --name centos">[root@node4~]#lxc-start -d –name centos</a></p><p><strong>注意：需要<code>/var/lib/lxc为LXC root路径</code></strong></p><h2 id="1、安装LXC-Web-Panel"><a href="#1、安装LXC-Web-Panel" class="headerlink" title="1、安装LXC-Web-Panel"></a>1、安装LXC-Web-Panel</h2><p><code>[root@node4~]#git clone https://github.com/lxc-webpanel/LXC-Web-Panel.git</code></p><p><code>[root@node4~/LXC-Web-Panel]#pip install --upgrade pip</code></p><p><code>[root@node4~/LXC-Web-Panel]#python lwp.py</code> 此运行在前台</p><p><code>[root@node4~/LXC-Web-Panel]#nuhop python lwp.py &amp;</code></p><p>在地址栏中输入：<a href="https://192.168.4.64:5000" target="_blank" rel="noopener">https://192.168.4.64:5000</a>  登录的默认账户和密码都是admin<br><img src="http://owatlfstl.bkt.clouddn.com/2017-12-10_222902.jpg" alt=""></p><h5 id="这样就可以在桌面管理LXC容器了。"><a href="#这样就可以在桌面管理LXC容器了。" class="headerlink" title="这样就可以在桌面管理LXC容器了。"></a>这样就可以在桌面管理LXC容器了。</h5><p>默认是使用桥接模式。</p>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LXC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP正向和反向代理</title>
      <link href="/2017/12/09/HTTP%E6%AD%A3%E5%90%91%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2017/12/09/HTTP%E6%AD%A3%E5%90%91%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、正向代理"><a href="#一、正向代理" class="headerlink" title="一、正向代理"></a>一、正向代理</h1><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-09_160455.jpg" alt=""></p><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>正向代理是一个位于客户端和目标服务器之间的代理服务器。为了从原始服务器取得内容，客户端向代理服务器发送一个请求，并且指定代理服务器向目标服务器转交并获得内容返回给客户端。</p><h2 id="2、正向代理服务器作用"><a href="#2、正向代理服务器作用" class="headerlink" title="2、正向代理服务器作用"></a>2、正向代理服务器作用</h2><ul><li>访问无法访问的服务器B</li><li>加速访问服务器B</li><li>Cache作用</li><li>隐藏访问者行踪</li></ul><h1 id="二、反向代理"><a href="#二、反向代理" class="headerlink" title="二、反向代理"></a>二、反向代理</h1><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-09_160748.jpg" alt=""></p><h2 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h2><p>反向代理是为服务端转发请求，客户端将请求发送至反向代理服务器，反向代理服务器再将服务器请求转发给真正的服务器进行处理请求，响应时后端真正的服务器将处理结果发送给反向代理，再由反向代理构建响应并响应给客户端。</p><h2 id="2-、反向代理作用"><a href="#2-、反向代理作用" class="headerlink" title="2 、反向代理作用"></a>2 、反向代理作用</h2><ul><li>保护和隐藏原始资源服务器</li><li>负载均衡作用</li><li>加密和SSL加速</li><li>缓存静态内容</li><li>压缩功能</li></ul><h1 id="三、HTTP正向代理"><a href="#三、HTTP正向代理" class="headerlink" title="三、HTTP正向代理"></a>三、HTTP正向代理</h1><h2 id="1、ProxyRequest指令"><a href="#1、ProxyRequest指令" class="headerlink" title="1、ProxyRequest指令"></a>1、ProxyRequest指令</h2><pre><code>Description:    Enables forward (standard) proxy requestsSyntax:    ProxyRequests On|OffDefault:    ProxyRequests OffContext:    server config, virtual hostStatus:    ExtensionModule:    mod_proxy</code></pre><h2 id="2、ProxyVia指令"><a href="#2、ProxyVia指令" class="headerlink" title="2、ProxyVia指令"></a>2、ProxyVia指令</h2><p>是否在响应首部添加Via字段</p><pre><code>Description:    Information provided in the Via HTTP response header for proxied requestsSyntax:    ProxyVia On|Off|Full|BlockDefault:    ProxyVia OffContext:    server config, virtual hostStatus:    ExtensionModule:    mod_proxy</code></pre><p>off：将不会采取特殊处理<br>on：每个请求和应答都会对应当前主机得到一个“Via：”头<br>full：每个产生的“Via：”头都会额外加入Apache服务器的版本<br>block：每个代理请求中的所有”Via：”头行都将被删除</p><p><strong>示例：</strong></p><pre><code>  1 &lt;VirtualHost *:80&gt;  2         ServerName www.test.com  3         DocumentRoot &quot;/app/web/test&quot;  4         ProxyRequests ON  5         ProxyVia ON  6         &lt;Directory &quot;/app/web/test&quot;&gt;  7                 Require all granted  8         &lt;/Directory&gt;  9         &lt;Proxy *&gt; 10                 Require all granted 11         &lt;/Proxy&gt; 12 &lt;/VirtualHost&gt;</code></pre><h4 id="设置浏览器"><a href="#设置浏览器" class="headerlink" title="设置浏览器"></a>设置浏览器</h4><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-09_164821.jpg" alt=""></p><h4 id="访问www-test-com"><a href="#访问www-test-com" class="headerlink" title="访问www.test.com"></a>访问<a href="www.test.com">www.test.com</a></h4><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-09_164712.jpg" alt=""></p><h1 id="四、HTTP反向代理"><a href="#四、HTTP反向代理" class="headerlink" title="四、HTTP反向代理"></a>四、HTTP反向代理</h1><h2 id="1、Proxy指令"><a href="#1、Proxy指令" class="headerlink" title="1、Proxy指令"></a>1、Proxy指令</h2><pre><code>Description:    Container for directives applied to proxied resourcesSyntax:    &lt;Proxy wildcard-url&gt; ...&lt;/Proxy&gt;Context:    server config, virtual hostStatus:    ExtensionModule:    mod_proxy</code></pre><h2 id="2、ProxyMatch指令"><a href="#2、ProxyMatch指令" class="headerlink" title="2、ProxyMatch指令"></a>2、ProxyMatch指令</h2><pre><code>Description:    Container for directives applied to regular-expression-matched proxied resourcesSyntax:    &lt;ProxyMatch regex&gt; ...&lt;/ProxyMatch&gt;Context:    server config, virtual hostStatus:    ExtensionModule:    mod_proxy</code></pre><p>可以使用正则表达式。</p><h2 id="3、ProxyPass指令"><a href="#3、ProxyPass指令" class="headerlink" title="3、ProxyPass指令"></a>3、ProxyPass指令</h2><p>此指令可以防止在location容器中使用。</p><pre><code>Description:    Maps remote servers into the local server URL-spaceSyntax:    ProxyPass [path] !|url [key=value [key=value ...]] [nocanon] [interpolate] [noquery]Context:    server config, virtual host, directoryStatus:    ExtensionModule:    mod_proxyCompatibility:    Unix Domain Socket (UDS) support added in 2.4.7</code></pre><p><strong>注意：如果第一个参数加了“/”，则URL部分也必须加“/”.</strong></p><pre><code>选项：keepalive=off|on：设置后端是否发开启长连接lbset=N：设置优先级ping=N：检查将康状态的时间间隔retry=N：尝试时长status=VALUE：将节点设置为何种状态    D：禁用，不再接受任何请求    S：停止    I：忽视状态    H：备份节点    E：错误状态    N：drain模式timeout：超时时长</code></pre><h2 id="4、ProxyPassMatch指令"><a href="#4、ProxyPassMatch指令" class="headerlink" title="4、ProxyPassMatch指令"></a>4、ProxyPassMatch指令</h2><pre><code>Description:    Maps remote servers into the local server URL-space using regular expressionsSyntax:    ProxyPassMatch [regex] !|url [key=value [key=value ...]]Context:    server config, virtual host, directoryStatus:    ExtensionModule:    mod_proxy</code></pre><h2 id="5、ProxyPassReverse指令"><a href="#5、ProxyPassReverse指令" class="headerlink" title="5、ProxyPassReverse指令"></a>5、ProxyPassReverse指令</h2><pre><code>Description:    Adjusts the URL in HTTP response headers sent from a reverse proxied serverSyntax:    ProxyPassReverse [path] url [interpolate]Context:    server config, virtual host, directoryStatus:    ExtensionModule:    mod_proxy</code></pre><h2 id="6、ProxyPreserveHost指令"><a href="#6、ProxyPreserveHost指令" class="headerlink" title="6、ProxyPreserveHost指令"></a>6、ProxyPreserveHost指令</h2><pre><code>Description:    Use incoming Host HTTP request header for proxy requestSyntax:    ProxyPreserveHost On|OffDefault:    ProxyPreserveHost OffContext:    server config, virtual host, directoryStatus:    ExtensionModule:    mod_proxyCompatibility:    Usable in directory context in 2.3.3 and later.</code></pre><h2 id="7、ProxyStatus指令"><a href="#7、ProxyStatus指令" class="headerlink" title="7、ProxyStatus指令"></a>7、ProxyStatus指令</h2><p>决定是否开启proxy状态信息</p><pre><code>Description:    Show Proxy LoadBalancer status in mod_statusSyntax:    ProxyStatus Off|On|FullDefault:    ProxyStatus OffContext:    server config, virtual hostStatus:    ExtensionModule:    mod_proxyCompatibility:    Available in version 2.2 and later</code></pre><h2 id="8、BalancerMember指令"><a href="#8、BalancerMember指令" class="headerlink" title="8、BalancerMember指令"></a>8、BalancerMember指令</h2><p>指定负载均衡成员</p><pre><code>Description:    Add a member to a load balancing groupSyntax:    BalancerMember [balancerurl] url [key=value [key=value ...]]Context:    directoryStatus:    ExtensionModule:    mod_proxyCompatibility:    BalancerMember is only available in Apache HTTP Server 2.2 and later.</code></pre><h2 id="9、ProxySet"><a href="#9、ProxySet" class="headerlink" title="9、ProxySet"></a>9、ProxySet</h2><pre><code>Description:    Set various Proxy balancer or member parametersSyntax:    ProxySet url key=value [key=value ...]Context:    directoryStatus:    ExtensionModule:    mod_proxyCompatibility:    ProxySet is only available in Apache HTTP Server 2.2 and later.</code></pre><h3 id="（1）http均衡算法"><a href="#（1）http均衡算法" class="headerlink" title="（1）http均衡算法"></a>（1）http均衡算法</h3><pre><code>byrequests：默认算法，基于请求数量计算权重bytraffic：基于I/O流量大小计算权重bybusyness：基于挂起的请求数量计算权重</code></pre><p><strong>示例：</strong></p><pre><code>  1 &lt;VirtualHost *:80&gt;  2         ServerName 192.168.4.61  3         DocumentRoot &quot;/app/web/test&quot;  4         ProxyRequests OFF  5         ProxyPass &quot;/&quot; &quot;balancer://http&quot;  6         ProxyPassReverse &quot;/&quot; &quot;balancer://http&quot;  7         &lt;Directory &quot;/app/web/test&quot;&gt;  8                 Require all granted  9         &lt;/Directory&gt; 10         &lt;Proxy balancer://http&gt; 11                 BalancerMember http://192.168.4.62 12                 BalancerMember http://192.168.4.63  13                 ProxySet lbmethod=byrequests 14         &lt;/Proxy&gt; 15 &lt;/VirtualHost&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logstash</title>
      <link href="/2017/12/07/logstash/"/>
      <url>/2017/12/07/logstash/</url>
      
        <content type="html"><![CDATA[<p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-07_095835.jpg" alt=""></p><h1 id="一、Logstash"><a href="#一、Logstash" class="headerlink" title="一、Logstash"></a>一、Logstash</h1><p>开源的服务器端数据处理管道，能够同时从多个来源采集数据、转换数据，然后将数据发送到指定的存储库中。</p><h2 id="1、Logstash功能"><a href="#1、Logstash功能" class="headerlink" title="1、Logstash功能"></a>1、Logstash功能</h2><ul><li>（1）即插即用</li><li>（2）可扩展，Logstash采用可插拔框架。</li><li>（3）可靠性，如果Logstash节点发生故障，Logstash会通过持久化队列来保证运行中的事件至少一次被送达。</li><li>（4）监控，全方位监视每个节点的部署</li></ul><h2 id="2、Logstash安装"><a href="#2、Logstash安装" class="headerlink" title="2、Logstash安装"></a>2、Logstash安装</h2><p>下载地址：<a href="http://owatlfstl.bkt.clouddn.com/2017-12-07_095835.jpg" target="_blank" rel="noopener">http://owatlfstl.bkt.clouddn.com/2017-12-07_095835.jpg</a></p><p><code>[root@node4 ~]# yum install -y java-1.8.0-openjdk</code> #安装jdk环境</p><p><code>[root@node4 ~]# java -version</code> #查案是否安装成功</p><pre><code>openjdk version &quot;1.8.0_102&quot;OpenJDK Runtime Environment (build 1.8.0_102-b14)OpenJDK 64-Bit Server VM (build 25.102-b14, mixed mode)</code></pre><p><code>[root@node4 ~]# yum install -y logstash-6.0.0.rpm</code>    #安装Logstash</p><h3 id="（1）Logstash目录介绍"><a href="#（1）Logstash目录介绍" class="headerlink" title="（1）Logstash目录介绍"></a>（1）Logstash目录介绍</h3><table><thead><tr><th>位置</th><th>说明</th></tr></thead><tbody><tr><td><code>/usr/share/logstash</code></td><td>logstash安装的主目录</td></tr><tr><td><code>/usr/share/logstash/bin</code></td><td>二进制脚本位置</td></tr><tr><td><code>/etc/logstash</code></td><td>配置文件存放位置</td></tr><tr><td><code>/etc/logstash/conf.d</code></td><td>logstash管道配置文件，注意只要文件放置在此目录下都生效</td></tr><tr><td><code>/var/log/logstash</code></td><td>日志位置</td></tr><tr><td><code>/usr/share/logstash/plugins</code></td><td>插件位置</td></tr><tr><td><code>/var/lib/logstash</code></td><td>数据存放位置</td></tr></tbody></table><h3 id="（2）-etc-logstash-logstash-yml配置文件"><a href="#（2）-etc-logstash-logstash-yml配置文件" class="headerlink" title="（2）/etc/logstash/logstash.yml配置文件"></a>（2）<code>/etc/logstash/logstash.yml</code>配置文件</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>node.name</td><td>节点名称</td></tr><tr><td>path.data</td><td>数据路径</td></tr><tr><td>pipeline.workers</td><td>工作的并行数量</td></tr><tr><td>pipeline.batch.size</td><td>单工作线程最大事件数量</td></tr><tr><td>path.config</td><td>配置文件路径</td></tr><tr><td>config.reload.automatic</td><td>设置为true定期检查是否已更改</td></tr><tr><td>config.reload.interval</td><td>检查配置文件更改的间隔时长</td></tr><tr><td>config.debug</td><td>是否显示调试信息</td></tr><tr><td>http.host</td><td>绑定的IP地址</td></tr><tr><td>http.port</td><td>绑定的端口号</td></tr><tr><td>log.level</td><td>日志级别</td></tr><tr><td>log.format</td><td>日志格式</td></tr><tr><td>path.logs</td><td>日志路径</td></tr><tr><td>path.plugins</td><td>插件位置</td></tr></tbody></table><h2 id="3、logstash修改配置文件"><a href="#3、logstash修改配置文件" class="headerlink" title="3、logstash修改配置文件"></a>3、logstash修改配置文件</h2><p><code>[root@node4 ~]# grep &#39;^[^#]&#39; /etc/logstash/logstash.yml</code></p><pre><code>node.name: node4path.data: /var/lib/logstashpath.config: /etc/logstash/conf.d/*.confhttp.host: &quot;172.18.4.66&quot;http.port: 9600-9700path.logs: /var/log/logstash</code></pre><h2 id="4、输入插件"><a href="#4、输入插件" class="headerlink" title="4、输入插件"></a>4、输入插件</h2><h3 id="（1）file插件"><a href="#（1）file插件" class="headerlink" title="（1）file插件"></a>（1）file插件</h3><table><thead><tr><th>选型</th><th>输入类型</th></tr></thead><tbody><tr><td>path</td><td>array</td></tr><tr><td>start_position</td><td>string，one of[beginning,end]</td></tr><tr><td>exclude</td><td>处理某种类型的文件</td></tr><tr><td>max_open_files</td><td>打开的最大文件数</td></tr><tr><td>stat_interval</td><td>间隔时长</td></tr></tbody></table><p><strong>示例：</strong></p><pre><code>  1 input {  2         file {  3                 path    =&gt; &quot;/root/test&quot;  4                 start_position  =&gt; beginning  5         }  6 }</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-07_111036.jpg" alt=""></p><h3 id="（2）exec"><a href="#（2）exec" class="headerlink" title="（2）exec"></a>（2）exec</h3><table><thead><tr><th>选项</th><th>类型</th></tr></thead><tbody><tr><td>command</td><td>string</td></tr><tr><td>interval</td><td>number</td></tr></tbody></table><p><strong>示例：</strong></p><pre><code>  1 input {  2         exec {  3                 command =&gt; &quot;ls -s /etc/fstab&quot;  4                 interval        =&gt; 5  5         }  6 }</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-07_111731.jpg" alt=""></p><h3 id="（3）http插件"><a href="#（3）http插件" class="headerlink" title="（3）http插件"></a>（3）http插件</h3><table><thead><tr><th>选项</th><th>类型</th></tr></thead><tbody><tr><td>host</td><td>string</td></tr><tr><td>password</td><td>password</td></tr><tr><td>port</td><td>number</td></tr><tr><td>response_headers</td><td>hash</td></tr><tr><td>user</td><td>string</td></tr><tr><td>ssl</td><td>boolean</td></tr></tbody></table><p><strong>示例：</strong></p><pre><code>  1 input {  2         http {  3                 host =&gt; &quot;127.0.0.1&quot;  4                 port    =&gt; &quot;80&quot;  5                 codec   =&gt; &quot;plain&quot;  6         }  7 }</code></pre><h3 id="（4）tcp插件"><a href="#（4）tcp插件" class="headerlink" title="（4）tcp插件"></a>（4）tcp插件</h3><table><thead><tr><th>选项</th><th>类型</th></tr></thead><tbody><tr><td>port</td><td>number</td></tr><tr><td>host</td><td>string</td></tr><tr><td>mode</td><td>string，one of [server,client]</td></tr><tr><td>proxy_protocol</td><td>boolean</td></tr></tbody></table><p><strong>示例：</strong></p><pre><code>  1 input {  2         tcp {  3                 port    =&gt; 80  4                 mode    =&gt; &quot;server&quot;  5                 ssl_enable      =&gt; false  6         }  7 }</code></pre><h3 id="（5）redis插件"><a href="#（5）redis插件" class="headerlink" title="（5）redis插件"></a>（5）redis插件</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>data_type</td><td>string，one of[list，channel，pattern_channel]</td></tr><tr><td>db</td><td>number，默认为0</td></tr><tr><td>host</td><td>string</td></tr><tr><td>password</td><td>password</td></tr><tr><td>port</td><td>number</td></tr></tbody></table><p>timeout|number<br>|key|stirng</p><p><strong>示例：</strong></p><pre><code>  1 input {  2         redis {  3                 data_type       =&gt; &quot;list&quot;  4                 port    =&gt; &quot;6379&quot;  5                 db      =&gt; &quot;0&quot;  6                 password        =&gt; &quot;centos&quot;  7                 host    =&gt; &quot;172.18.4.66&quot;  8         }  9 }</code></pre><h2 id="5、输出插件"><a href="#5、输出插件" class="headerlink" title="5、输出插件"></a>5、输出插件</h2><h3 id="（1）stdout插件"><a href="#（1）stdout插件" class="headerlink" title="（1）stdout插件"></a>（1）stdout插件</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>codec</td><td>codec，默认为plain，rubydebug、json</td></tr><tr><td>enable_metric</td><td>boolean</td></tr><tr><td>id</td><td>string</td></tr></tbody></table><p><strong>示例：</strong></p><pre><code> 14 output { 15         stdout { 16                 codec   =&gt; rubydebug 17         } 18 }</code></pre><h3 id="（2）file插件"><a href="#（2）file插件" class="headerlink" title="（2）file插件"></a>（2）file插件</h3><table><thead><tr><th>选项</th><th>类型</th></tr></thead><tbody><tr><td>path</td><td>string</td></tr><tr><td>gzip</td><td>boolean，是否压缩</td></tr></tbody></table><p><strong>示例：</strong></p><pre><code> 14 output { 15         file { 16                 path    =&gt; &quot;root/test&quot; 17                 gzip    =&gt; true 18         } 19 }</code></pre><h3 id="（3）elasticsearch插件"><a href="#（3）elasticsearch插件" class="headerlink" title="（3）elasticsearch插件"></a>（3）elasticsearch插件</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>hosts</td><td>主机，默认为“//127.0.0.1”</td></tr><tr><td>password</td><td>密码</td></tr><tr><td>path</td><td>路径</td></tr><tr><td>user</td><td>使用者</td></tr><tr><td>index</td><td>索引，默认为“logstash-%{+YYYY.MM.dd}”</td></tr><tr><td>document_type</td><td>文档类型</td></tr></tbody></table><p><strong>示例：</strong></p><pre><code> 14 output { 15         elasticsearch { 16                 hosts   =&gt; [&quot;http://192.168.4.61:9200/&quot;,&quot;http://192.168.4.62:9200/&quot;,&quot;http://192.    168.4.63:9200/&quot;] 17                 index   =&gt; &quot;logstash-%{YYYY.MM.dd}&quot; 18                 document_type   =&gt; &quot;redis_logs&quot; 19         } 20 }</code></pre><h3 id="（4）"><a href="#（4）" class="headerlink" title="（4）"></a>（4）</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>data_type</td><td>数据类型</td></tr><tr><td>db</td><td>数据库，默认为0</td></tr><tr><td>host</td><td>主机</td></tr><tr><td>key</td><td>关键字</td></tr><tr><td>password</td><td>密码</td></tr><tr><td>port</td><td>端口</td></tr><tr><td>timeout</td><td>超时时长</td></tr></tbody></table><p><strong>示例：</strong></p><pre><code> 14 output { 15         redis { 16                 data_type       =&gt; &quot;channel&quot; 17                 key     =&gt; &quot;logstash-chan-%{+yyyy.MM.dd}&quot; 18                 host    =&gt; &quot;172.18.4.66&quot; 19                 password        =&gt; &quot;centos&quot; 20         } 21 }</code></pre><h2 id="6、过滤插件"><a href="#6、过滤插件" class="headerlink" title="6、过滤插件"></a>6、过滤插件</h2><h3 id="（1）grok插件"><a href="#（1）grok插件" class="headerlink" title="（1）grok插件"></a>（1）grok插件</h3><p>通过将文本模式组合成与日志匹配的东西来工作。</p><p>grok模式的语法是：%{SYNTAX:SEMANTIC}</p><ul><li><p>选项<br>match，默认值为{}</p><p>  filter {</p><pre><code>  match =&gt; {              &quot;message&quot; =&gt; &quot;%{COMBINEDAPCHEDLOG}&quot;  }</code></pre><p>  }</p></li></ul><p>removed_field，默认值为[]</p><p><strong>示例：</strong></p><pre><code>  4 filter {  5         grok {  6                 match =&gt; {  7                         &quot;message&quot; =&gt; &quot;%{COMBINEDAPACHELOG}&quot;  8                 }  9                 remove_field    =&gt; &quot;message&quot; 10         } 11 }</code></pre><h3 id="（2）geoip插件"><a href="#（2）geoip插件" class="headerlink" title="（2）geoip插件"></a>（2）geoip插件</h3><p>GeoIP过滤器来自Maxmind GeoLite2数据库添加有关的IP地址的地址位置的信息。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>source</td><td>数据来源</td></tr><tr><td>target</td><td>指定logstash应该存储geoip数据的字段，默认为geoip</td></tr><tr><td>database</td><td>存放数据库的路径</td></tr></tbody></table><p>下载地址：<a href="https://dev.maxmind.com/zh-hans/geoip/geoip2/geolite2-%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93/" target="_blank" rel="noopener">https://dev.maxmind.com/zh-hans/geoip/geoip2/geolite2-%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93/</a></p><p>如果我们需要使用GeoIP插件需要下载数据库</p><p><strong>示例：</strong><br><code>[root@node4 logstash]#gzip -d GeoLite2-City.mmdb.gz</code>  #加压数据库到当前目录下</p><pre><code>  4 filter {  5         grok {  6                 match =&gt; {  7                         &quot;message&quot; =&gt; &quot;%{COMBINEDAPACHELOG}&quot;  8                 }  9                 remove_field    =&gt; &quot;message&quot; 10         } 11         geoip { 12                 sourece =&gt; &quot;clientip&quot; 13                 target  =&gt; &quot;geoip&quot; 14                 database        =&gt; &quot;/etc/logstash/Geolite2-City.mmdb&quot; 15         } 16 }</code></pre><h3 id="（3）mutate"><a href="#（3）mutate" class="headerlink" title="（3）mutate"></a>（3）mutate</h3><p>mutate筛选器可以重命名、删除、替换和修改事件中的字段。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>gsub</td><td>仅对字符串字段有效</td></tr><tr><td>split</td><td>分隔</td></tr><tr><td>join</td><td>仅对数组类型有效</td></tr><tr><td>merge</td><td>合并两个数组或哈希字段</td></tr><tr><td>rename</td><td>重命名</td></tr><tr><td>update</td><td>更新某个字段</td></tr><tr><td>replace</td><td>替代某个字段</td></tr></tbody></table><h2 id="7、编码插件（codec）"><a href="#7、编码插件（codec）" class="headerlink" title="7、编码插件（codec）"></a>7、编码插件（codec）</h2><h3 id="采用JSON编码"><a href="#采用JSON编码" class="headerlink" title="采用JSON编码"></a>采用JSON编码</h3><p>直接输入预定义好的JSON数据，这样就可以省略掉fileter/grok配置</p><p><strong>注意：</strong><br>Nginx作为一个代理服务器运行的话，访问日志里有些变量，如$upstream_response_time，可能不是一个数据，可能是一个“-”字符串，这会直接导致logstash对输入数据验证报异常。</p><p>使用sed在输入之前先替换“-”为0</p><h1 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h1><h2 id="1、把http日志发送到elasticsearch"><a href="#1、把http日志发送到elasticsearch" class="headerlink" title="1、把http日志发送到elasticsearch"></a>1、把http日志发送到elasticsearch</h2><pre><code>  1 input {  2         file {  3                 path    =&gt; &quot;/var/log/httpd/access_log*&quot;  4                 start_position  =&gt; beginning  5         }  6 }  7 filter {  8         grok {  9                 match   =&gt; { 10                         &quot;message&quot;       =&gt; &quot;%{COMBINEDAPACHELOG}&quot; 11                 } 12         } 13         geoip { 14                 source  =&gt; &quot;clientip&quot; 15                 database        =&gt; &quot;/etc/logstash/GeoLite2-City.mmdb&quot; 16                 target  =&gt; &quot;geoip&quot; 17         } 18 } 19 output { 20         elasticsearch { 21                 hosts   =&gt; [&quot;http://192.168.4.61:9200/&quot;,&quot;http://192.168.4.62:9200/&quot;,&quot;http://192.    168.4.63:9200/&quot;] 22                 index   =&gt; &quot;logstash-%{+YYYY.MM.dd}&quot; 23                 action  =&gt; &quot;index&quot; 24                 document_type   =&gt; &quot;apache_log&quot; 25         } 26 }</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-07_174532.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-07_174446.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 日志系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logstash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kibana</title>
      <link href="/2017/12/04/Kibana/"/>
      <url>/2017/12/04/Kibana/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Kibana"><a href="#一、Kibana" class="headerlink" title="一、Kibana"></a>一、Kibana</h1><p>一个开源的分析和可视化平台。Kibana可以很容易地理解大量的数据，其简单的基于浏览器的界面使您能够快速创建和共享动态仪表盘，实时显示Eleasticsearch查询变化。</p><h2 id="1、Kibana安装"><a href="#1、Kibana安装" class="headerlink" title="1、Kibana安装"></a>1、Kibana安装</h2><p>下载地址：<a href="http://owatlfstl.bkt.clouddn.com/2017-12-07_174532.jpg" target="_blank" rel="noopener">http://owatlfstl.bkt.clouddn.com/2017-12-07_174532.jpg</a></p><p><code>[root@node5 ~]# yum install -y kibana-6.0.0-x86_64.rpm</code></p><h2 id="2、kibana-yml配置文件介绍"><a href="#2、kibana-yml配置文件介绍" class="headerlink" title="2、kibana.yml配置文件介绍"></a>2、kibana.yml配置文件介绍</h2><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>console.enabled</td><td>是否启用控制台</td></tr><tr><td>server.host</td><td>设置指定后端服务器的主机</td></tr><tr><td>server.name</td><td>kibana示例的可读显示名称</td></tr><tr><td>server.port</td><td>指定端口</td></tr><tr><td>server.basePath</td><td>指定将Kibana挂载到的路径</td></tr><tr><td>elasticsearch.url</td><td>用于所有查询的Elasticsearch的示例的URL</td></tr><tr><td>elasticsearch.username和elasticsearch.password</td><td>使用Elasticsearch使用基于身份验证进行保护</td></tr></tbody></table><h2 id="3、启动Kibana"><a href="#3、启动Kibana" class="headerlink" title="3、启动Kibana"></a>3、启动Kibana</h2><p><code>[root@node5 kibana]#vim kibana.yml</code></p><pre><code>server.port: 5601server.host: &quot;172.18.4.67&quot;server.basePath: &quot;&quot;server.name: &quot;node5&quot;elasticsearch.url: &quot;http://192.168.4.61:9200&quot;</code></pre><p><code>[root@node5 kibana]#systemctl start kibana</code></p><p><code>[root@node5 kibana]#systemctl status kibana</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-07_181211.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 日志系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kibana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch</title>
      <link href="/2017/12/04/Elasticsearch/"/>
      <url>/2017/12/04/Elasticsearch/</url>
      
        <content type="html"><![CDATA[<h1 id="一、ELK"><a href="#一、ELK" class="headerlink" title="一、ELK"></a>一、ELK</h1><h2 id="1、完整日志系统特点"><a href="#1、完整日志系统特点" class="headerlink" title="1、完整日志系统特点"></a>1、完整日志系统特点</h2><ul><li>收集，能够采集多种来源的日志数据</li><li>传输，能够稳定的把日志数据传输到中央系统</li><li>存储，如何存储日志数据</li><li>分析，可以支持UI分析</li><li>警告，能够提供错误报告，监控机制</li></ul><h2 id="2、ELK-stack介绍及体系结构"><a href="#2、ELK-stack介绍及体系结构" class="headerlink" title="2、ELK  stack介绍及体系结构"></a>2、ELK  stack介绍及体系结构</h2><p><img src="http://owatlfstl.bkt.clouddn.com/ELKR-log-platform.jpg" alt=""></p><p>ELK是Elasticsearch、Logstash和Kibana首字母的缩写。</p><h3 id="（1）Elasticsearch"><a href="#（1）Elasticsearch" class="headerlink" title="（1）Elasticsearch"></a>（1）Elasticsearch</h3><p>一个实时的分布式搜索和分析引擎，可以用于全文搜索，结构化搜索以及分析；是ELK的核心组件，相当于人体的大脑。它是一个建立在全文搜索引擎Apache Lucene基础上的搜索引擎，使用Java语言编写。</p><h4 id="a、主要特点"><a href="#a、主要特点" class="headerlink" title="a、主要特点"></a>a、主要特点</h4><ul><li>实时分析</li><li>分布式实时文件存储，并将每一个字段都编入索引</li><li>文档导向，所有的对象全部是文档</li><li>高可用性，易扩展，支持集群、分片和复制</li><li>支持JSON</li></ul><h4 id="b、Elasticsearch核心术语"><a href="#b、Elasticsearch核心术语" class="headerlink" title="b、Elasticsearch核心术语"></a>b、Elasticsearch核心术语</h4><ul><li>NRT<br>Elasticsearch是一个近似实时的搜索平台，从索引文档到可搜索有些延迟，通常为1秒</li><li>集群<br>集群时一个或多个节点存储数据，并提供跨界节点的联合索引和搜索的功能。集群有一个唯一表示，默认为elasticsearch，每个节点都是通过集群名加入此集群中。<br><img src="http://owatlfstl.bkt.clouddn.com/img002.png" alt=""></li><li><p>节点<br>节点就是集群中的一台主机。</p></li><li><p>索引<br>索引是由名字表示，名字全部需小写；这个名字用来进行索引、搜索、更新和删除文档操作。</p></li><li><p>文档<br>文档是信息的基本单元，可以被索引。文档是以JSON格式表现的。</p></li><li><p>分片和副本<br>当创建索引时，可以定义想要分片的数量。每一个分片就是一个全功能的独立的索引，可以位于集群中任何节点上。</p><ul><li>分片的原因<ul><li>水平分割扩展，增大存储量</li><li>分布式并行跨分片操作，提高性能和吞吐量</li></ul></li><li>副本的原因<ul><li>高可用，以应对分片或者节点故障</li><li>提高性能，增大吞吐量，所搜可以并行在所有副本上执行<br>默认情况下，Elasticsearch为每个索引分片5个主分片和1个副本</li></ul></li></ul></li></ul><p><img src="http://owatlfstl.bkt.clouddn.com/img003.png" alt=""></p><h3 id="（2）Logstash"><a href="#（2）Logstash" class="headerlink" title="（2）Logstash"></a>（2）Logstash</h3><p>一个具有实时渠道能力的数据收集引擎。使用JRuby语言编写</p><h4 id="a、主要特点-1"><a href="#a、主要特点-1" class="headerlink" title="a、主要特点"></a>a、主要特点</h4><ul><li>几乎可以访问任何数据</li><li>可以和多种外部应用结合</li><li>支持弹性扩展</li></ul><h4 id="b、组成部分"><a href="#b、组成部分" class="headerlink" title="b、组成部分"></a>b、组成部分</h4><ul><li>shipper，发送日志数据</li><li>Broker，收集数据，缺省内置redis</li><li>Indexer，数据写入</li></ul><p><img src="http://owatlfstl.bkt.clouddn.com/img004.png" alt=""></p><h3 id="（3）Kibana"><a href="#（3）Kibana" class="headerlink" title="（3）Kibana"></a>（3）Kibana</h3><p>一款基于Apache开源协议，使用JavaScript语言编写，为Elasticsearch提供分析和可视化Web平台。它可以在Elasticsearch的索引中查找，交互数据，并生成各种维度的表图。</p><h4 id="a、Kibana组件"><a href="#a、Kibana组件" class="headerlink" title="a、Kibana组件"></a>a、Kibana组件</h4><ul><li>Discover页面，交互式的浏览数据，可以访问所匹配的索引模式的每个索引的每个文档；可以提交搜索查询、过滤搜索结果和查看文档数据；可以所搜查询匹配的文档数据和字段值的统计数据；可以选定时间以及刷新频率</li><li>Visualize页面，设计数据可视化。</li><li>Dashboard页面，自由排列已保存的可视化，保存这个仪表板并可以分享或者重载</li><li>Settings，配置一个或多个索引</li></ul><h3 id="（4）Beats"><a href="#（4）Beats" class="headerlink" title="（4）Beats"></a>（4）Beats</h3><p>一个代理，将不同类型的数据发送到Elasticsearch。Beats可以直接将数据发送到Elasticsearch，也可以通过logstash将数据发送Elasticsearch。</p><p><img src="http://owatlfstl.bkt.clouddn.com/beats-platform.png" alt=""></p><h4 id="a、Beats分类"><a href="#a、Beats分类" class="headerlink" title="a、Beats分类"></a>a、Beats分类</h4><ul><li>Winlogbeat，搜集Windows事件日志数据</li><li>Topbeat，收集系统基础设置数据，如CPU、内存、每个进程统计信息</li><li>Packbeat，网络分析工具，统计收集网络信息</li><li><p>Filebeat，一个开源你的文件收集器，主要用于获取日志文件，并把它们发送到logstash或elasticsearch。与libbeat lumberjack一起替代logstash-forwarder。</p><ul><li>Filebeat结构<br><img src="http://owatlfstl.bkt.clouddn.com/filebeat.png" alt=""></li></ul></li></ul><h2 id="3、消息队列机制架构"><a href="#3、消息队列机制架构" class="headerlink" title="3、消息队列机制架构"></a>3、消息队列机制架构</h2><p><img src="http://owatlfstl.bkt.clouddn.com/image004.png" alt=""></p><p>Beats还不能支持输出到消息队里，所以在消息队里前后两段只能是logstash示例。这种结构使用logstash从各个数据源搜集数据，然后经消息队里输出插件输出到消息队列中。然后Logstash通过消息队列输入插件从队列中获取数据，分析过滤后经输出插件发送到Elasticsearch，最后通过Kibana展示。</p><h2 id="4、基于Filebeat的ELK集群框架"><a href="#4、基于Filebeat的ELK集群框架" class="headerlink" title="4、基于Filebeat的ELK集群框架"></a>4、基于Filebeat的ELK集群框架</h2><p><img src="http://owatlfstl.bkt.clouddn.com/image005.png" alt=""></p><h1 id="二、Elasticsearch文件"><a href="#二、Elasticsearch文件" class="headerlink" title="二、Elasticsearch文件"></a>二、Elasticsearch文件</h1><h2 id="1、Elasticsearch文件"><a href="#1、Elasticsearch文件" class="headerlink" title="1、Elasticsearch文件"></a>1、Elasticsearch文件</h2><table><thead><tr><th>配置文件</th><th>说明</th></tr></thead><tbody><tr><td><code>/usr/share/elasticsearch</code></td><td>elasticsearch安装的家目录</td></tr><tr><td><code>/usr/share/elasticsearch/bin</code></td><td>二进制脚本文件目录</td></tr><tr><td><code>/etc/elasticsearch</code></td><td>配置文件目录</td></tr><tr><td><code>/etc/elasticsearch/elasticsearch.yml</code></td><td>Elasticsearch配置文件</td></tr><tr><td><code>/etc/elasticsearch/jvm.options</code></td><td>Elasticsearch JVM配置文件</td></tr><tr><td><code>/etc/elasticsearch/log4j2.properties</code></td><td>Elasticsearch日志配置文件</td></tr><tr><td><code>/etc/sysconfig/elasticsearch</code></td><td>环境变量配置文件</td></tr><tr><td><code>/var/lib/elasticsearch</code></td><td>节点索引和分片的数据目录</td></tr><tr><td><code>/var/log/elasticsearch</code></td><td>日志文件目录</td></tr><tr><td><code>/usr/share/eleaticsearch/plugins</code></td><td>插件目录</td></tr></tbody></table><h2 id="2、-etc-elasticsearch-elasticsearch-yml文件文件详解"><a href="#2、-etc-elasticsearch-elasticsearch-yml文件文件详解" class="headerlink" title="2、/etc/elasticsearch/elasticsearch.yml文件文件详解"></a>2、<code>/etc/elasticsearch/elasticsearch.yml</code>文件文件详解</h2><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>cluster.name</td><td>集群名称</td></tr><tr><td>node.name</td><td>节点名称</td></tr><tr><td>path.data</td><td>数据路径，可用逗号分隔多个路径</td></tr></tbody></table><p>path.logs|日志路径<br>|bootstrap.mlockall|内存锁，用来确保用户在es-jvm中设置的<code>ES_HEAP_SIZE</code>参数内存可以使用一半以上而不溢出<br>|network.host|主机IP<br>|http.port|对外访问的端口号，默认为9200<br>|transport.tcp.port|集群间通信的端口号<br>|discovery.zen.minimum_master_nodes|最少的主节点个数，（nodes/2）+1个<br>|gateway.recover_after_nodes|网关控制在n个节点启动之后才恢复整个集群<br>|action.destrutive_requires_name|删除indices是否显示名字</p><h2 id="3、Restful-API"><a href="#3、Restful-API" class="headerlink" title="3、Restful API"></a>3、Restful API</h2><h3 id="（1）格式"><a href="#（1）格式" class="headerlink" title="（1）格式"></a>（1）格式</h3><pre><code>curl -X&lt;VERB&gt; &#39;&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&#39; -d &#39;&lt;BODY&gt;&#39;</code></pre><p>#<br>    <verb>类型：GET,POST,PUT,DELETE<br>    <body>：json格式请求主体</body></verb></p><h3 id="（2）cat-APIs"><a href="#（2）cat-APIs" class="headerlink" title="（2）cat APIs"></a>（2）cat APIs</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>_cat/aliase</td><td>显示目前配置的别名索引，包括过滤的路由相关的信息</td></tr><tr><td>_cat/allocation</td><td>提供了每个数据节点分配了多少分片和使用了多少磁盘空间快照</td></tr><tr><td>_cat/count</td><td>快速查看整个集群的文档数或单个索引</td></tr><tr><td>_cat/fielddata</td><td>显示集群中每个数据点fielddata当前所使用的heap内存大小</td></tr><tr><td>_cat/health</td><td>查看集群状态</td></tr><tr><td>_cat/indices</td><td>查看索引状态</td></tr><tr><td>_cat/master</td><td>显示ID、IP地址和节点名</td></tr><tr><td>_cat/nodeattrs</td><td>显示自定义节点属性</td></tr><tr><td>_cat/nodes</td><td>显示节点信息</td></tr><tr><td>_cat/shards</td><td>显示分片状态</td></tr></tbody></table><h3 id="（3）Cluster-APIs"><a href="#（3）Cluster-APIs" class="headerlink" title="（3）Cluster APIs"></a>（3）Cluster APIs</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>_cluster/health</td><td>显示集群健康信息</td></tr><tr><td>_cluster/state</td><td>显示集群状态</td></tr><tr><td>_cluster/stats</td><td>查看集群统计信息</td></tr></tbody></table><h3 id="（4）Search-APIs"><a href="#（4）Search-APIs" class="headerlink" title="（4）Search APIs"></a>（4）Search APIs</h3><p>格式：</p><pre><code>curl -X GET &#39;&lt;SCHEME://&lt;HOST&gt;:&lt;PORT&gt;/[INDEX/TYPE/]_search?q=KEYWORD&amp;sort=DOMAIN:[asc|desc]&amp;from=#&amp;size=#&amp;_source=DOMAIN_LIST&#39;    /_search：搜索所有的索引和类型    /INDEX_NAME/_search：搜索指定的单个索引    /IDNEX1，INDEX2/_search：搜索指定的多个索引    /s*/_search：搜索所有以s开头的索引    /INDEX_NAME/TYPE_NAME/_search：搜索指定的单个索引的指定类型    默认是在_all字段上搜索</code></pre><p>具体搜索方法：<a href="http://lucene.apache.org/core/6_6_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package.description" target="_blank" rel="noopener">http://lucene.apache.org/core/6_6_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package.description</a></p><h4 id="URL搜索"><a href="#URL搜索" class="headerlink" title="URL搜索"></a>URL搜索</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>q</td><td>查询字符串</td></tr><tr><td>df</td><td>在查询中未定义字段前缀时使用的默认字段</td></tr><tr><td>analyer</td><td>分析查询字符串时要使用的分析器名称</td></tr><tr><td>analyze_wildcard</td><td>是否应该分析通配符和前缀查询。默认为false</td></tr><tr><td>explain</td><td>对于每个命中，包含如何计算命中计分解释</td></tr><tr><td>_source</td><td>设置为false禁止检索_source字段</td></tr><tr><td>sort</td><td>排序</td></tr><tr><td>timeout</td><td>所搜超时时长</td></tr><tr><td>from</td><td>从命中的索引开始返回，默认为0</td></tr><tr><td>size</td><td>返回的点击次数，默认为10</td></tr><tr><td>search_type</td><td>索索操作类型</td></tr></tbody></table><h1 id="二、Elasticsearch-head"><a href="#二、Elasticsearch-head" class="headerlink" title="二、Elasticsearch-head"></a>二、Elasticsearch-head</h1><p>一个WEB前端管理Elasticsearch集群。</p><p><a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head</a></p><h3 id="1、修改elasticsearch-yml配置文件-为了允许elasticsearch-head运行时的跨域"><a href="#1、修改elasticsearch-yml配置文件-为了允许elasticsearch-head运行时的跨域" class="headerlink" title="1、修改elasticsearch.yml配置文件,为了允许elasticsearch-head运行时的跨域"></a>1、修改elasticsearch.yml配置文件,为了允许elasticsearch-head运行时的跨域</h3><p><code>[root@node1~]#vim /etc/elasticsearch/elasticsearch.yml</code></p><pre><code> 95 http.cors.enabled: true 96 http.cors.allow-origin: &quot;*&quot;</code></pre><h3 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h3><p><code>[root@node1~]#git clone https://github.com/mobz/elasticsearch-head.git</code></p><p><code>[root@node1~/elasticsearch-head]#npm install</code> </p><p><code>[root@node1~/elasticsearch-head]#npm run start</code>    #启动服务</p><p>地址栏输入：<a href="http://localhost:9100" target="_blank" rel="noopener">http://localhost:9100</a></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-04_212008.jpg" alt=""></p><h1 id="三、安装ELK"><a href="#三、安装ELK" class="headerlink" title="三、安装ELK"></a>三、安装ELK</h1><table><thead><tr><th>主机名</th><th>IP</th></tr></thead><tbody><tr><td>node1</td><td>192.168.4.61</td></tr><tr><td>node2</td><td>192.168.4.62</td></tr><tr><td>node3</td><td>192.168.4.63</td></tr></tbody></table><h2 id="1、安装准备"><a href="#1、安装准备" class="headerlink" title="1、安装准备"></a>1、安装准备</h2><h3 id="（1）同步时间"><a href="#（1）同步时间" class="headerlink" title="（1）同步时间"></a>（1）同步时间</h3><h3 id="（2）主机名通信（非必须）"><a href="#（2）主机名通信（非必须）" class="headerlink" title="（2）主机名通信（非必须）"></a>（2）主机名通信（非必须）</h3><h3 id="（3）基于密钥通信（非必须）"><a href="#（3）基于密钥通信（非必须）" class="headerlink" title="（3）基于密钥通信（非必须）"></a>（3）基于密钥通信（非必须）</h3><h3 id="（4）确保iptables和selinux关闭（非必须）"><a href="#（4）确保iptables和selinux关闭（非必须）" class="headerlink" title="（4）确保iptables和selinux关闭（非必须）"></a>（4）确保iptables和selinux关闭（非必须）</h3><h2 id="1、安装JDK环境"><a href="#1、安装JDK环境" class="headerlink" title="1、安装JDK环境"></a>1、安装JDK环境</h2><p>因为Elasticsearch是基于JDK环境运行的，因此安装JDK环境。<br><code>[root@node1~]#tar xf jdk-8u151-linux-x64.tar.gz -C /usr/local/</code></p><p><code>[root@node1/usr/local]#ln -sv jdk1.8.0_151/ jdk</code> #创建软连接</p><p><code>[root@node1/usr/local]#vim /etc/profile.d/jdk.sh</code>  #修改环境变量<br>      1 JAVA_HOME=”/usr/local/jdk”<br>      2 export PATH=$JAVA_HOME/bin:$PATH</p><p><code>[root@node1/usr/local]#source /etc/profile.d/jdk.sh</code>  #使环境变量生效</p><p>为什么设置：<a href="http://www.cnblogs.com/samcn/archive/2011/03/16/1986248.html" target="_blank" rel="noopener">http://www.cnblogs.com/samcn/archive/2011/03/16/1986248.html</a></p><p><code>[root@node1~]#java -version</code>   #查看是否安装成功</p><pre><code>java version &quot;1.8.0_151&quot;Java(TM) SE Runtime Environment (build 1.8.0_151-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode)</code></pre><h2 id="2、安装Elasticsearch"><a href="#2、安装Elasticsearch" class="headerlink" title="2、安装Elasticsearch"></a>2、安装Elasticsearch</h2><p>下载地址：<a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/downloads/elasticsearch</a></p><p><code>[root@node1~]#rpm -ivh     elasticsearch-6.0.0.rpm</code>   #安装</p><p><code>[root@node1~]#systemctl daemon-reload</code> #重新装载所有守护进程的UNIT文件</p><p><code>[root@node1~]#systemctl enable elasticsearch.service</code> #设置为开机启动</p><h5 id="node2和node3安装一样"><a href="#node2和node3安装一样" class="headerlink" title="node2和node3安装一样"></a>node2和node3安装一样</h5><h2 id="3、配置集群环境"><a href="#3、配置集群环境" class="headerlink" title="3、配置集群环境"></a>3、配置集群环境</h2><h3 id="node1配置"><a href="#node1配置" class="headerlink" title="node1配置"></a>node1配置</h3><p><code>[root@node1~]#vim /etc/elasticsearch/elasticsearch.yml</code></p><pre><code>cluster.name: myelk     #设置集群名字，如果要加入此集群，需要集群名相同，否则不能加入。node.name: node1    #节点名称，建议使用主机名path.data: /var/lib/elasticsearch   #数据存放位置path.logs: /var/log/elasticsearch   #日志存放位置network.host: 192.168.4.61  #监听的IP地址http.port: 9200 #监听的端口discovery.zen.ping.unicast.hosts: [&quot;192.168.4.61&quot;,&quot;192.168.4.62&quot;,&quot;192.168.4.63&quot;]    #集群中的节点，通过单播方式发送心跳信息discovery.zen.minimum_master_nodes: 2   #投票机制，nodes / 2 + 1</code></pre><h3 id="node2配置"><a href="#node2配置" class="headerlink" title="node2配置"></a>node2配置</h3><p><code>[root@node2~]#grep  &quot;^[^#]&quot; /etc/elasticsearch/elasticsearch.yml</code></p><pre><code>cluster.name: myelknode.name: node2path.data: /var/lib/elasticsearchpath.logs: /var/log/elasticsearchnetwork.host: 192.168.4.62http.port: 9200discovery.zen.ping.unicast.hosts: [&quot;192.168.4.61&quot;,&quot;192.168.4.62&quot;,&quot;192.168.4.63&quot;]discovery.zen.minimum_master_nodes: 2</code></pre><h3 id="node3配置"><a href="#node3配置" class="headerlink" title="node3配置"></a>node3配置</h3><p><code>[root@node3~]#grep  &quot;^[^#]&quot; /etc/elasticsearch/elasticsearch.yml</code></p><pre><code>cluster.name: myelknode.name: node3path.data: /var/lib/elasticsearchpath.logs: /var/log/elasticsearchnetwork.host: 192.168.4.63http.port: 9200discovery.zen.ping.unicast.hosts: [&quot;192.168.4.61&quot;,&quot;192.168.4.62&quot;,&quot;192.168.4.63&quot;]discovery.zen.minimum_master_nodes: 2</code></pre><p><code>[root@node1~]#systemctl start elasticsearch.service</code><br><img src="http://owatlfstl.bkt.clouddn.com/2017-12-04_170231.jpg" alt=""></p><h5 id="此时只开启9300-TCP集群端口，而9200-TCP搜索服务没有开启。只有投票机制达到2时才可以开启"><a href="#此时只开启9300-TCP集群端口，而9200-TCP搜索服务没有开启。只有投票机制达到2时才可以开启" class="headerlink" title="此时只开启9300/TCP集群端口，而9200/TCP搜索服务没有开启。只有投票机制达到2时才可以开启"></a>此时只开启9300/TCP集群端口，而9200/TCP搜索服务没有开启。只有投票机制达到2时才可以开启</h5><p><code>[root@node2~]#systemctl status elasticsearch</code>  #启动node节点上的elasticsearch服务</p><h5 id="此时查看node1节点上的端口，已经开启了9200-TCP端口"><a href="#此时查看node1节点上的端口，已经开启了9200-TCP端口" class="headerlink" title="此时查看node1节点上的端口，已经开启了9200/TCP端口"></a>此时查看node1节点上的端口，已经开启了9200/TCP端口</h5><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-04_172327.jpg" alt=""></p><h4 id="查看node1日志"><a href="#查看node1日志" class="headerlink" title="查看node1日志"></a>查看node1日志</h4><p><code>[root@node1~]#cat /var/log/elasticsearch/myelk.log</code></p><pre><code>[2017-12-04T17:25:24,125][INFO ][o.e.c.s.ClusterApplierService] [node1] added {{node3}{6TNtOOBPRNyzxsHSM4wqNQ}{scOUPDlqSD-a6uBUOYG5FA}{192.168.4.63}{192.168.4.63:9300},}, reason: apply cluster state (from master [master {node2}{Gd2arUUCREyog9lptHAV8A}{5QcohzrHS2yzgfsYLKBU5g}{192.168.4.62}{192.168.4.62:9300} committed version [3]])</code></pre><h5 id="从日志中可以看到node3节点已经加入到集群中。"><a href="#从日志中可以看到node3节点已经加入到集群中。" class="headerlink" title="从日志中可以看到node3节点已经加入到集群中。"></a>从日志中可以看到node3节点已经加入到集群中。</h5>]]></content>
      
      
      <categories>
          
          <category> 日志系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2017/12/03/git%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/12/03/git%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Git是一个分布式版本控制软件。用于敏捷高效地处理任何大小项目。</p><h2 id="一、Git三种状态"><a href="#一、Git三种状态" class="headerlink" title="一、Git三种状态"></a>一、Git三种状态</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-02_152052.jpg" alt=""></p><ul><li>已提交（committed），表示该文件已经被安全地保存在本地数据库中</li><li>已修改（modified），表示修改了某文件，但还没有提交保存</li><li>已暂存（staged），表示把已修改的文件放在下次提交时要保存的清单中</li></ul><h3 id="Git工作区域"><a href="#Git工作区域" class="headerlink" title="Git工作区域"></a>Git工作区域</h3><ul><li>工作目录，从项目中取出某个版本的所有文件和目录，用于开始后续工作；这些文件实际上都是从Git目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑</li><li>暂存区域，只不过简单的文件（索引文件），一般都放在Git目录中</li><li>本地仓库</li></ul><h3 id="Git基本的工作流程"><a href="#Git基本的工作流程" class="headerlink" title="Git基本的工作流程"></a>Git基本的工作流程</h3><ul><li>（1）在工作目录中修改某文件</li><li>（2）对修改后的文件进行快照，然后保存到暂存区域</li><li>（3）提交更新，将保存在暂存区域的文件快照用具转储到Git目录中</li></ul><p><strong>注意：在Git目录下有一个隐藏目录.git，是用来保存元数据和对象数据库的地方。因此此目录非常重要。</strong></p><h2 id="2、Git工作"><a href="#2、Git工作" class="headerlink" title="2、Git工作"></a>2、Git工作</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-02_153555.jpg" alt=""></p><p>Git是把变化的文件做快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件做一快照，然后保存一个指向这次快照的索引。为了提高性能，若文件没有变化，Git不会再次保存，而只对上次保存的快照做一连接。</p><h1 id="二、Git基本用法"><a href="#二、Git基本用法" class="headerlink" title="二、Git基本用法"></a>二、Git基本用法</h1><p><img src="http://owatlfstl.bkt.clouddn.com/basic-usage.svg" alt=""></p><h3 id="Git配置存放位置"><a href="#Git配置存放位置" class="headerlink" title="Git配置存放位置"></a>Git配置存放位置</h3><ul><li>/etc/gitconfig文件：系统中对所有用户都普遍适用的配置。使用<code>git config --system</code>配置</li><li>~/.gitconfig文件：用户目录下的配置文件只适用于该用户。使用<code>git config --config</code>配置</li><li>工作目录下.git/config文件：配置仅仅针对当前项目有效</li></ul><p><strong>注意：每一级别的配置都会覆盖上层的相同配置。</strong></p><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>刚开始安装Git时，首先要配置个人用户名称和电子邮件。每次Git提交时都会引用这两条信息，说明是谁提交了更新。</p><pre><code>git config --global user.name &quot;your.name&quot;git cofnig --global user.email &quot;your.email&quot;</code></pre><h3 id="初始化新仓库"><a href="#初始化新仓库" class="headerlink" title="初始化新仓库"></a>初始化新仓库</h3><p><code>git init</code>初始化后，在当前目录下会出现一个名为.git的目录，所有Git需要的数据和资源都存放在这个目录中。</p><p><code>[root@node5/app/git/.git]#tree</code></p><pre><code>.├── branches├── config     #包含了项目特有配置选项├── description #仅供GitWeb程序使用├── HEAD       #文件指向当前分支├── hooks   #保存了客户端或服务端钩子脚本│   ├── applypatch-msg.sample│   ├── commit-msg.sample│   ├── post-update.sample│   ├── pre-applypatch.sample│   ├── pre-commit.sample│   ├── prepare-commit-msg.sample│   ├── pre-push.sample│   ├── pre-rebase.sample│   └── update.sample├── info    #保存了一份不希望在.gitignore文件中管理模式的全局可执行文件│   └── exclude├── objects #目录存储所有数据内容│   ├── info│   └── pack└── refs    #存储指向数据提交对象指针    ├── heads    └── tagsindex文件保存了暂存区域信息</code></pre><h4 id="Git的对象类型-git-objects"><a href="#Git的对象类型-git-objects" class="headerlink" title="Git的对象类型 .git/objects"></a>Git的对象类型 <code>.git/objects</code></h4><p><img src="http://owatlfstl.bkt.clouddn.com/18333fig0901-tn.png" alt=""></p><pre><code>块（blob）对象：文件的每个版本表现为一个块（blob）树（tree）对象：一个目录代表一层目录信息提交（commit）对象：用于保存版本库一次变化的元数据；每个提交对象都指定一个目录树对象标签（tag）对象：用于给定一个特定一个易读的名称</code></pre><p>#</p><pre><code>git ls-files：列出文件    -s 列出暂存区中的文件对象git cat-file：查看我呢间    -p：美观排版显示文件内容git hash-object：计算文件的hash码git write-tree：根据当前索引中的内容创建数对象</code></pre><h3 id="Git文件分类"><a href="#Git文件分类" class="headerlink" title="Git文件分类"></a>Git文件分类</h3><p><img src="http://owatlfstl.bkt.clouddn.com/18333fig0201-tn.png" alt=""></p><ul><li>已追踪（tracked），已经在版本中，或者已经使用git add命令添加至索引中的文件</li><li>被忽略的（Ignore）：在版本中通过“忽略文件列表”明确声明为被忽略的文件</li><li>未追踪的（untracked）：上述两类之外的其他文件</li></ul><p>#<br>    git add files 把当前文件存放入暂存区域内<br>    git rm：删除工作目录中的文件，及索引中的映射<br>        –cached：只删除索引中的映射<br>    git mv：改变工作目录中的文件名，及索引中的映射<br>    git commit 给暂存区域生成快照并提交<br>    git reset –files 用来撤销最后一次git add file操作。git reset表示撤销所有暂存区域文件<br>    git checkout –files 把文件从暂存区域复制到工作目录中，用来丢弃本地修改。</p><p><img src="http://owatlfstl.bkt.clouddn.com/basic-usage-2.svg" alt=""></p><pre><code>git commit -a 相当于运行git add 把所有当前目录下的文件加入暂存区再运行 git commit。git commit files 进行一次包含最后一次提交加上工作目录中文件快照的提交，并且文件被添加到暂存区域。</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/checkout-files.svg" alt=""></p><pre><code>git checkout HEAD --files 回滚到复制最后一次提交，复制到工作目录并且加到暂存区域中。</code></pre><p><strong>注意：当前分支不会发生变化。</strong></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-02_165117.jpg" alt=""></p><pre><code>git commit --amend 使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消。</code></pre><h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><h4 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a>标签类型</h4><ul><li>轻量级的（lightweight），是个不会变化的分支，实际上它就是指向特定提交对象的引用</li><li><p>含附注的（annotated），存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明。</p><p>  git tag|列出所有标签<br>  git tag [tag] 新建一个标签在当前commit<br>  git tag [tag] [commit] 新建一个tag在指定的commit<br>  git tag -d [tag] 删除本地标签<br>  git checkout -b [branch] [tag] 新建一个分支执行某个标签</p></li></ul><p><img src="http://owatlfstl.bkt.clouddn.com/checkout-b-detached.svg" alt=""></p><pre><code>git checkout -b NAME 创建一个新分支</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/reset-commit.svg" alt=""></p><pre><code>git reset ：撤销此前的操作    --soft：将HEAD引用指向给定的提交，但不影响索引和工作目录    --mixed：将HEAD引用指向给定的提交，并将索引内容改变为指定提交的快照；当不改变工作目录    --hard：将HEAD引用指向给定的提交、将索引内容改变为指定提交的快照，并改变工作目录中的内容反映指定提交的内容</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/bg2015120901.png" alt=""></p><pre><code>git fetch：取回远程服务器的更新git pull：取回远程服务器更新，而后与本地指定分支合并    git pull &lt;远程主机名&gt; &lt;本地分指明&gt; ：&lt;远程分指明&gt;git push：将本地的更新推送到远程主机    git push &lt;远程主机名&gt; &lt;本地分支名&gt;：&lt;远程分支名&gt;</code></pre><p>参考：<a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html#diff" target="_blank" rel="noopener">https://marklodato.github.io/visual-git-guide/index-zh-cn.html#diff</a></p><p><a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html#diff" target="_blank" rel="noopener">https://marklodato.github.io/visual-git-guide/index-zh-cn.html#diff</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HAProxy</title>
      <link href="/2017/11/29/HAproxy/"/>
      <url>/2017/11/29/HAproxy/</url>
      
        <content type="html"><![CDATA[<p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-31_200948.jpg" alt=""></p><h1 id="一、HAProxy"><a href="#一、HAProxy" class="headerlink" title="一、HAProxy"></a>一、HAProxy</h1><p>HAProxy（High Available Proxy）是基于四层和七层的高可用负载均衡代理服务器，对客户端10000以上的同时连接的高性能的TCP和HTTP负载均衡器。</p><h2 id="1、HAProxy功能"><a href="#1、HAProxy功能" class="headerlink" title="1、HAProxy功能"></a>1、HAProxy功能</h2><ul><li>TCP/HTTP反向代理服务器，尤其适合于高可用性环境</li><li>可以针对HTTP请求添加cookie，进行路由后端服务器</li><li>可平衡负载至后端服务器，并支持持久连接</li><li>支持基于cookie进行调度</li><li>支持所有主服务器故障切换至备用服务器</li><li>支持专用端口实现监控服务</li><li>支持不影响现有连接情况下停止接受新连接请求</li><li>可以在双向添加、修改或删除HTTP报文首部</li><li>支持基于PATTERN实现连接请求的访问控制</li><li>通过特定的URI为授权用户提供详细的状态信息</li></ul><h2 id="2、HAProxy工作原理"><a href="#2、HAProxy工作原理" class="headerlink" title="2、HAProxy工作原理"></a>2、HAProxy工作原理</h2><p><img src="http://owatlfstl.bkt.clouddn.com/haproxy-pmode.png" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-31_203624.jpg" alt=""></p><p>HAProxy和lvs的工作类似，只不过是在名称上有所改变。</p><p>HAProxy由前段（frontend）和后端（backend）过程，前后端都可以有多个，并且可以实现交叉调度。如果前段和后端是一对一的情况可以使用listen来实现。frontend区域根据Client的请求调度到backend服务器上。不过frontend可以根据HTTP请求的header信息来定义一些规则，将符合规则的请求转发至backend服务器上去。</p><h2 id="3、HAProxy安装及配置文件详解"><a href="#3、HAProxy安装及配置文件详解" class="headerlink" title="3、HAProxy安装及配置文件详解"></a>3、HAProxy安装及配置文件详解</h2><p><code>[root@localhost~]#yum install -y haproxy</code></p><blockquote><p>HAProxy主配置文件</p></blockquote><pre><code>/etc/haproxy/haproxy.cfg</code></pre><blockquote><p>定义错误页面文件</p></blockquote><pre><code>/usr/share/haproxy/400.http/usr/share/haproxy/403.http/usr/share/haproxy/408.http/usr/share/haproxy/500.http/usr/share/haproxy/502.http/usr/share/haproxy/503.http/usr/share/haproxy/504.http</code></pre><h3 id="etc-haproxy-haproxy-cfg配置文件详解"><a href="#etc-haproxy-haproxy-cfg配置文件详解" class="headerlink" title="/etc/haproxy/haproxy.cfg配置文件详解"></a><code>/etc/haproxy/haproxy.cfg</code>配置文件详解</h3><p>配置段<br>-</p><blockquote><p>global：全局配置段</p></blockquote><pre><code>定义进程及安全配置相关的参数性能调整相关参数debug参数</code></pre><blockquote><p>proxies：代理配置段</p></blockquote><pre><code>default：为frontend、backend、listen提供默认配置frontend：定义一组接受客户端侦听的套接字连接backend：定义代理将连接的一组服务器转发连接listen：同时拥有前后端，适用于一对一环境；通常用于TCP中。</code></pre><p>配置指令详解<br>-</p><h3 id="global配置参数"><a href="#global配置参数" class="headerlink" title="global配置参数"></a>global配置参数</h3><ul><li>nbproc <number> ：要启动的haproxy的进程数量，系统默认单进程，要求使用daemon模式</number></li><li>ulimit-n<number>：每个haproxy进程可打开的最大文件数，系统自动会自定，不建议设置</number></li><li>daemon：后端方式运行，建议使用</li><li>log：定义全局syslog服务器；最多可以定义两个</li></ul><p>格式：</p><pre><code>log &lt;address&gt; [len &lt;length&gt;] &lt;facility&gt; [max level [min level]]    &lt;address&gt;：日志服务器地址    [len &lt;length&gt;]：最大长度，默认1024    &lt;facility&gt;：日志设施    [max level [min level]]：指定日志级别</code></pre><ul><li><p>no log 不启用日志</p></li><li><p>log global 如果需要使用日志，引用global日志</p></li><li><p>log-format  <string> ：定义日志格式</string></p></li></ul><p><strong>示例：</strong></p><p>（1）配置日志服务器</p><p><code>[root@log~]#yum install -y mariadb-server</code> #安装数据库</p><p><code>[root@log~]#systemctl restart mariadb.service</code></p><p><code>[root@log~]#systemctl enable mariadb.service</code>  #设置为开机启动</p><p><code>[root@log~]#yum install -y rsyslog-mysql</code>  #安装基于mysql的模块</p><p><code>[root@log~]#mysql -uroot -p &lt; /usr/share/doc/rsyslog-8.24.0/mysql-createDB.sql</code>    #创建日志数据库</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-02_170043.jpg" alt=""></p><pre><code>MariaDB [(none)]&gt; GRANT ALL ON Syslog.* TO joah@&#39;192.168.4.65&#39; IDENTIFIED BY &#39;123456&#39;;  #授权用户</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-02_170833.jpg" alt=""></p><pre><code>74 local2.*                                                :ommysql:192.168.4.65,Syslog,joah,123456</code></pre><blockquote><p>将特定信息记录在日志中</p></blockquote><ul><li><p>capture cookie <name> len <length>：捕获请求和响应报文中的cookie并记录日志</length></name></p></li><li><p>capture request header <name> len <length>：捕获请求报文中指定的首部并记录日志</length></name></p></li><li><p>capture response header <name> len <length>：捕获响应报文中的首部并记录日志</length></name></p></li></ul><p><strong>示例：</strong><br><code>[root@haproxy/etc/haproxy]#vim haproxy.cfg</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-02_190210.jpg" alt=""></p><p><code>[root@node1~]#vim /etc/httpd/conf/httpd.conf</code><br><img src="http://owatlfstl.bkt.clouddn.com/2017-11-02_190455.jpg" alt=""></p><p>重启服务测试</p><p><code>[root@client~]#curl http://172.18.4.62</code></p><pre><code>node1</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-02_190710.jpg" alt=""></p><p>上述的定义均需在httpd.conf选项Log_Format中定义 ：例如{X-Forwarded-For} 如果有多个需要使用“|”分隔。<br>-</p><h4 id="性能优化指令"><a href="#性能优化指令" class="headerlink" title="性能优化指令"></a>性能优化指令</h4><ul><li>maxconn <number>：设定每个haproxy进程所能接受的最大并发连接数</number></li><li>maxconnrate <number>：设置每个进程每秒种所能建立的最大连接数量</number></li><li>maxsessrate<number>：设置每个进程每秒钟所能建立的最大会话数量；一个连接里面可以有多个会话</number></li><li>maxsslconn  <number>：每个进程支持SSL的最大连接数量</number></li><li>spread-checks <0..50,in percent="">：健康监测延迟时长比；建议2-5之间，默认为0</0..50,in></li></ul><h3 id="配置段"><a href="#配置段" class="headerlink" title="配置段"></a>配置段</h3><ul><li>defaults <name>：默认配置段</name></li><li>frontend <name>：指定接受客户端连接侦听套接字设置</name></li><li>backend <name>：指定将连接请求转发至后端服务器的相关设置</name></li><li><p>listen <name>：指定完整前后端设置，只对TCP有效，只有前后端一对一时使用。</name></p></li><li><p>bind：指定一个或多个前段侦听地址和端口</p></li></ul><p>格式：</p><pre><code>bind [&lt;address&gt;]:&lt;port_range&gt; [, ...] [param*]bind /&lt;path&gt; [, ...] [param*][param*]常用选项    user：设置用户    mode：设置权限    accept-proxy：接受代理</code></pre><p><strong>示例：</strong></p><p><code>[root@haproxy/etc/haproxy]#vim haproxy.cfg</code></p><pre><code> 68 frontend web 69     bind 172.18.4.62:80 70     default_backend websrvs</code></pre><h3 id="balance配置"><a href="#balance配置" class="headerlink" title="balance配置"></a>balance配置</h3><ul><li>balance：后端服务器组内调度算法</li></ul><p>格式：</p><pre><code>balance &lt;algorithm&gt; [ &lt;arguments&gt; ]balance url_param &lt;param&gt; [check_post]</code></pre><blockquote><p>\<algorithm>类型</algorithm></p></blockquote><pre><code>roundrobin：基于权重轮询，动态算法，支持权重的运行时调整，支持慢启动；每个后端backend中最多支持4095个serverstatic-rr：基于权重轮询，静态算法，不支持权重的运行时调整及慢启动；后端主机数量无上限leastconn：加权最少连接，动态算法，最少连接的后端服务器优先分配接受新连接，相同连接时轮询；推荐在较长会话场景使用，如mysql、LDAP等first：根据服务器中列表中的位置，自上而下进行调度；前面服务器的连接数达到上限，新请求才会分配给下一台服务器source：源地址hash，新连接先按权重分配，后续连接按source分配请求uri：对于URI的左半部分或整个URI做hash计算，并除以服务器总权重取模，以后派发至挑出的服务器，仅适用于后端缓存服务器；只要会话是同一个URI则一直访问同一台服务器    示例：        &lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;            左半部分：/&lt;path&gt;;&lt;params&gt;            整个URI：/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;url_param：对用于请求的URI听&lt;params&gt;部分中的参数的值做hash计算，并由服务器总权重相除以后派发至某挑选的服务器；通常用于追踪用户，以确保俩字同一个用户的请求始终发往同一个backend serverhadr （&lt;name&gt;）：对于每个http请求，此处由&lt;name&gt;指定的http首部将会被取出做hash计算；并由服务器总权重相除以后派发至某跳出的服务器；无有效值的会被轮询调度rdp-cookie：远程桌面相关</code></pre><ul><li>hash-type：哈希算法</li></ul><p>格式：</p><pre><code>hash-type &lt;method&gt; &lt;function&gt; &lt;modifier&gt;</code></pre><blockquote><p>\<mothed></mothed></p></blockquote><pre><code>map-based：除权取余法，哈希数据结构时静态数组consistent：一致性哈希，哈希数据结构是一棵树</code></pre><ul><li>default_backend：无use_backend匹配时，使用默认的backend，用于frontend中</li></ul><p>格式：</p><pre><code>default_backend &lt;backend&gt;</code></pre><ul><li>default-server ：backend中的各server设定默认选项</li></ul><p>格式：</p><pre><code>default-server [param*]</code></pre><p><strong>示例：</strong></p><pre><code>  default_backend websrvs</code></pre><ul><li>server ：定义后端服务器机器选项</li></ul><p>格式：</p><pre><code>server &lt;name&gt; &lt;address&gt;[:[port]] [param*]&lt;name&gt;：服务器在haproxy上的内部名称；出现在日志及警告信息&lt;address&gt;：服务器地址，支持使用主机名[:[port]]：端口映射；省略时表示同bind中绑定的端口[param*]：定义参数    weight &lt;weight&gt;：权重，默认为1    maxconn&lt;maxconn&gt;：当前server的最大并发连接数    backlog&lt;backlog&gt;：当server的连接数达到上限后的后援队列长度    backup：设定当前server为备用服务器    check：对当前server做健康状态检测，只用于四层检测;注意：httpchk、smtpchk、mysql-check、pgsql-check和ssl-hello-chk用于定义应用层检测方法    addr：针对此IP地址    port：针对此端口进行检测    inter &lt;delay&gt;：连续两次检测之间的时间间隔，默认为2000ms    rise &lt;conunt&gt;：连续多少次检测结果为“成功”才标记服务器为可用；默认为2    fall &lt;count&gt;：连续多少次检测结果为“失败”才标记位不可用；默认为3    cookie &lt;value&gt;：为当前server指定cookie值，实现基于cookie的会话粘性    disabled：标记位不可用；用于服务器维护，更换    redir &lt;prefix&gt;：将发往此server的所有GET和HEAD类的请求重定向到指定的URL</code></pre><p><strong>示例：</strong></p><p><code>[root@haproxy/etc/haproxy]#vim haproxy.cfg</code></p><pre><code> 73 backend websrvs 74     balance roundrobin 75     server srv1 192.168.4.63:80 check weight 1 addr 192.168.4.163 port 80 inter 3000 rise 2 fall 3 76     server srv2 192.168.4.64:80 check disabled</code></pre><p>重启服务测试</p><p><code>[root@client~]#curl http://172.18.4.62</code></p><pre><code>node1</code></pre><p><code>[root@client~]#curl http://172.18.4.62</code></p><pre><code>node1</code></pre><p>通过上述测试出的结果只能调度到node1中。接下来把192.168.4.163 down掉</p><p><code>[root@client~]#curl http://172.18.4.62</code></p><pre><code>&lt;html&gt;&lt;body&gt;&lt;h1&gt;503 Service Unavailable&lt;/h1&gt;No server is available to handle this request.&lt;/body&gt;&lt;/html&gt;</code></pre><p><code>[root@client~]#curl http://172.18.4.62</code></p><pre><code>&lt;html&gt;&lt;body&gt;&lt;h1&gt;503 Service Unavailable&lt;/h1&gt;No server is available to handle this request.&lt;/body&gt;&lt;/html&gt;</code></pre><p>此时再次测试访问不到页面出现503错误</p><h3 id="cookie配置"><a href="#cookie配置" class="headerlink" title="cookie配置"></a>cookie配置</h3><ul><li>cookie：基于cookie长连接用于backend</li></ul><p>格式：</p><pre><code>cookie &lt;name&gt; [ rewrite | insert | prefix ] [ indirect ] [ nocache ]          [ postonly ] [ preserve ] [ httponly ] [ secure ]          [ domain &lt;domain&gt; ]* [ maxidle &lt;idle&gt; ] [ maxlife &lt;life&gt; ]&lt;name&gt;：cookie名称，用于实现持久连接rewrite：重写insert：插入prefix：前缀</code></pre><p><strong>示例：</strong><br>基于cookie的session sticky的实现</p><p><code>[root@haproxy/etc/haproxy]#vim haproxy.cfg</code></p><pre><code> 73 backend websrvs 74     balance roundrobin 75     cookie SRV insert nocache indirect 76     server srv1 192.168.4.63:80 check weight 2 cookie service1 77     server srv2 192.168.4.64:80 check cookie service2</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-02_193758.jpg" alt=""></p><p>统计接口启用相关参数<br>-</p><ul><li><p>stats enable：启动统计也；基于默认的参数启动stats page</p><p>  默认设置</p><ul><li>stats uri：/ haproxy？stats <ul><li>stats realm：“HAProxy Statistics” </li><li>stats auth：no authentication </li><li>stats scope：no restriction</li></ul></li></ul></li><li><p>stats uri <prefix> ：自定义stats page URI</prefix></p></li><li>stats auth <user>:<passwd>：认证账户和密码，可定义多个</passwd></user></li><li>stats realm <relam>：认证时的提示信息</relam></li><li>stats hide-version：隐藏版本</li><li>stats refresh <delay>：设定自动刷新时间间隔</delay></li><li>stats admin {if|unless} <cond>：启用stats page中管理功能，如果stats auth认证成功才可以启用管理功能</cond></li></ul><p><strong>示例：</strong></p><p><code>[root@haproxy/etc/haproxy]#vim haproxy.cfg</code></p><pre><code> 73 listen stats 74     bind 192.168.4.62:9000 75     stats enable 76     stats uri /hastats 77     stats auth ha1:123456 78     stats realm &quot;testhaproxy&quot; 79     stats hide-version 80     stats refresh 2s 81     stats admin if TRUE</code></pre><p>重启服务</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-02_195302.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-02_195343.jpg" alt=""></p><blockquote><p>工作模式</p></blockquote><ul><li>maxconn <conns>：为指定的frontend定义其最大并发连接数，默认为2000</conns></li><li><p>mode {tcp|http|health}：定义haproxy工作模式</p><p>  tcp：基于L4实现代理，可代理mysql，pgsql，ssh，ssl等协议，https时使用此模式，默认模式<br>  http：仅当代理协议为http时使用，CentOS默认模式<br>  health：工作为健康状态检查的响应模式，当连接请求到达时回应ok后即断开连接，较少使用</p></li></ul><p><strong>示例：</strong></p><pre><code> 82 listen ssh 83     bind :220 84     balance leastconn 85     mode tcp 86     server sshsrv1 192.168.4.63:22 check 87     server sshsrv2 192.168.4.64:22 check</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-02_195723.jpg" alt=""></p><blockquote><p>健康状态检测</p></blockquote><p>对后端服务器做http协议的健康状态检测</p><pre><code>option httpchk  默认为：/OPTIONS HTTP/1.0option httpchk &lt;uri&gt;    option httpchk &lt;method&gt; &lt;uri&gt;option httpchk &lt;method&gt; &lt;uri&gt; &lt;version&gt;定义基于http协议的L7健康状态检测机制http-check expect [!] &lt;match&gt; &lt;pattern&gt;：http协议健康状态检测响应内容或指定响应码</code></pre><p><strong>示例：</strong></p><pre><code> 89 backend websrvs 90     balance roundrobin 91     server srv1 192.168.4.63:80 check weight 2 92     server srv2 192.168.4.64:80 check 93     option httpchk GET /index.html HTTP/1.1 \r\n host:</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-02_200306.jpg" alt=""></p><blockquote><p>forwardfor配置</p></blockquote><p>在由haproxy发往后端主机请求报文中添加“X-Forwardde-For”首部，其值为前端客户端的地址，用于向后端主发送真实客户端IP</p><p>格式</p><pre><code>option forwardfor [ except &lt;network&gt; ] [ header &lt;name&gt; ] [ if-none ][except &lt;network&gt;]：请求报文来自此处指定的网络是不予添加此首部[header &lt;name&gt;]：使用自定义首部名称，而非“X-Forwarded-For”[if-none]：如果没有首部才添加首部，如果有使用默认值；</code></pre><p><strong>示例：</strong></p><pre><code> 48     option forwardfor       except 127.0.0.0/8 header test</code></pre><blockquote><p>指定MIME类型启用压缩传输功能</p></blockquote><ul><li>compression algo <algorithm>：启用http协议的压缩机制，指明压缩算法gzip、deflate</algorithm></li><li>compression type <mime type="">：指明压缩的MIME类型</mime></li></ul><p><strong>注意：如果添加首部，需要在http服务的日志中定义。</strong></p><blockquote><p>错误页配置</p></blockquote><ul><li><p>errorfile <code> <file>：自定义错误页</file></code></p><p>  <code>:HTTP status；支持200、400、403、408、500、502、503、504<br>  <file>：错误页文件路径</file></code></p></li><li><p>errorloc <code> <url>：相当于errorloc02 <code> <url>，利用302重定向指定URL</url></code></url></code></p></li></ul><p><strong>示例：</strong></p><pre><code>errorloc 503 http://www.magedu.com/error_pages/503.html</code></pre><blockquote><p>报文首部</p></blockquote><ul><li>reqadd <string> [{if|unless} <cond>]：修改请求报文尾部添加指定首部</cond></string></li><li>rspadd <string> [{if|unless} <cond>]：在响应首部尾部添加指定首部</cond></string></li><li>reqdel <search> [{if|unless} <cond>]：从请求报文中删除匹配正则表达式的首部</cond></search></li><li>reqidel <search> [{if|unless} <cond>]（ignore case）：从请求报文中删除匹配正则表达式的首部（不区分大小写）</cond></search></li><li>rspdel  <search> [{if|unless} <cond>]</cond></search></li><li>rspidel  <search> [{if|unless} <cond>]（ignore case）：从响应报文汇总删除正则表达式的首部</cond></search></li></ul><blockquote><p>连接超时</p></blockquote><ul><li>time client <timeout>：客户端最长空闲连接超时时长，默认单位为毫秒</timeout></li><li>timeout server <timeout>：后端服务器最长空闲连接超时时长</timeout></li><li>timeout http-keep-alive  <timeout>：持久连接的持久时长</timeout></li><li>timeout http-request <timeout>：一次完整的HTTP请求的最大等待时长</timeout></li><li>timeout connect <timeout>：成功连接后端服务器的最大等待时长</timeout></li><li>timeout client-fin <timeout>：客户端半连接的空闲时长</timeout></li><li>timeout server-fin <timeout>：后端服务器半连接得空闲时长</timeout></li></ul><blockquote><p>ACL</p></blockquote><p>访问控制列表的使用提供了一个灵活的解决方案来执行内容交换，并且通常基于从请求中提取的内容、响应或任何环境状态进行决策。</p><p>格式：</p><pre><code>acl &lt;aclname&gt; &lt;criterion&gt; [flags] [operator] &lt;value&gt; ...&lt;value&gt;的类型    boolean    integer or integer range    IP address /network    string     hex block&lt;flags&gt;    -i ：不区分大小写    -m：使用指定的pattern匹配方法    -n：不做DNS解析    -u：强制每个ACL必须唯一ID，否则多个同名ACL为“或”的关系    -- ：强制flag结束，当字符串和某个flag相似时使用[operator]    匹配整数值：eq、ge、gt、le、lt    匹配字符串：        -exact match （-m str）：字符串必须完全匹配模式        -substring mathc （-m sub）：在提取的字符串查找模式，如果其中任何一个被发现，ACL将匹配        -suffix match （-m end）：将模式与提取字符串的尾部进行比较，如果其中任何一个匹配，则ACL进行匹配        -prefix match （-m beg）：在提取的字符串首部中查找模式，如果其中任何一个被发现，ACL将匹配        -subdir mathc （-m dir）：查看提取出来的用斜线分隔的字符串，如果其中任何一个匹配，则ACL进行匹配        -domain match （-m dom）：查找提取的用“.”分隔字符串，如果其中任何一个匹配，则ACL进行匹配    acl作为条件时的逻辑关系：        与：隐式（默认）使用        或：使用“or”或”||“        否定：使用“！”使用    &lt;aclname&gt;：ACL名称，可使用字母数字，区分字符大小写&lt;criterion&gt;：比较的标准和条件    dst：目标IP    dst_port：目标port    src：源IP    src_port：源port</code></pre><p> base string</p><p>返回第一个主机头和请求的路径部分的链接，该请求从第一个斜杠开始，并在问好之前结束，对虚拟主机有用</p><p><strong>示例：</strong></p><p>\<scheme>:/\<user>:\<password>@*<host>:<port>/\<path></path>;\&lt; params&gt;*?\<query>#\<frag></frag></query></port></host></password></user></scheme></p><pre><code>  base     : exact string match  base_beg : prefix match  base_dir : subdir match  base_dom : domain match  base_end : suffix match  base_len : length match  base_reg : regex match  base_sub : substring match同acl类似</code></pre><p> path ：string</p><p>提取请求的URL路径，该路径从第一个斜杠开始，并在问号之前结束</p><p><strong>示例：</strong></p><p>\<scheme>:/\<user>:\<password>@\<host>:<port><em>/\<path></path>;\&lt; params&gt;</em>?\<query>#\<frag></frag></query></port></host></password></user></scheme></p><pre><code>    path    : exact string match    path_beg : prefix match    path_dir : subdir match    path_dom : domain match    path_end : suffix match    path_len : length match    path_reg : regex match    path_sub : substring match</code></pre><p>url：string</p><p>提取请求中的URL。一个典型的应用是具有预取能力的缓存，以及需要从数据库聚合多个信息并将它们保存在缓存中的网页门户入口</p><pre><code>    url    : exact string match    url_beg : prefix match    url_dir : subdir match    url_dom : domain match    url_end : suffix match    url_len : length match    url_reg : regex match    url_sub : substring match</code></pre><p>req.har（[<name>[.<occ>]]）:string</occ></name></p><p>提取在一个HTTP请求报文的首部</p><pre><code>    hdr([&lt;name&gt;[,&lt;occ&gt;]])    : exact string match    hdr_beg([&lt;name&gt;[,&lt;occ&gt;]]) : prefix match    hdr_dir([&lt;name&gt;[,&lt;occ&gt;]]) : subdir match    hdr_dom([&lt;name&gt;[,&lt;occ&gt;]]) : domain match    hdr_end([&lt;name&gt;[,&lt;occ&gt;]]) : suffix match    hdr_len([&lt;name&gt;[,&lt;occ&gt;]]) : length match    hdr_reg([&lt;name&gt;[,&lt;occ&gt;]]) : regex match    hdr_sub([&lt;name&gt;[,&lt;occ&gt;]]) : substring match</code></pre><p>status：integer</p><p>返回在响应报文中的状态码</p><blockquote><p>预定义ACL</p></blockquote><table><thead><tr><th>ACL名称</th><th>等价于</th><th>说明</th></tr></thead><tbody><tr><td>TRUE</td><td>always_true</td><td>总是匹配</td></tr><tr><td>FALSE</td><td>always_false</td><td>从不匹配</td></tr><tr><td>HTTP</td><td>req_proto_http</td><td>匹配HTTP协议</td></tr><tr><td>HTTP_1.0</td><td>req_ver 1.0</td><td>匹配HTTP协议1.0</td></tr><tr><td>HTTP_1.1</td><td>req_ver 1.1</td><td>匹配HTTP协议1.1</td></tr><tr><td>HTTP_CONTENT</td><td>hdr_val(content-length) gt 0</td><td>匹配已经存在内容长度</td></tr><tr><td>HTTP_URL_ABS</td><td>url_reg ^[^/:]*://</td><td>匹配URL的绝对路径</td></tr><tr><td>HTTP_URL_SLASH</td><td>url_beg /</td><td>匹配URL相对路径</td></tr><tr><td>HTTP_URL_STAR</td><td>url *</td><td>匹配URL等于“*”</td></tr><tr><td>LOCALHOST</td><td>src 127.0.0.1/8</td><td>匹配从localhost来的链接</td></tr><tr><td>METH_CONNECT</td><td>method CONNECT</td><td>匹配HTTP CONNECT 方法</td></tr><tr><td>METH_GET</td><td>method GET HEAD</td><td>匹配GET和HEAD方法</td></tr><tr><td>METH_HEAD</td><td>method HEAD</td><td>匹配head方法</td></tr><tr><td>METH_OPTONS</td><td>method OPTIONS</td><td>匹配OPTIONS方法</td></tr><tr><td>METH_POST</td><td>method POST</td><td>匹配POST方法</td></tr><tr><td>METH_TRACE</td><td>method TRACE</td><td>匹配TRACE方法</td></tr><tr><td>RDP_COOKIE</td><td>req_rdp_cookie_cnt gt 0</td><td>match presence of an RDP cookie</td></tr><tr><td>REQ_CONNTENT</td><td>req_len gt 0</td><td>匹配数据在请求缓存中</td></tr><tr><td>WAIT_END</td><td>wait_end</td><td>等待内容分析</td></tr></tbody></table><ul><li>use_backend <backend> [{if|unless}<condition>]</condition></backend></li></ul><p>当if|unless一个基于ACL的条件匹配时切换指定</p><ul><li>backend {if|unless} <condition></condition></li></ul><p>阻止L7请求if|unless一个条件匹配</p><ul><li>http-request {allow|deny|add-header <name> <fmt>|set-header <name> <fmt>}[{if|unless} <condition>]</condition></fmt></name></fmt></name></li></ul><p>对L7层请求的访问控制</p><ul><li>tcp-request connection {accept|reject} [{if|unless} <condition>]<br>根据L4条件对传入连接执行操作</condition></li></ul><p><strong>示例：</strong></p><pre><code> 72 frontend mysql 73     bind 172.18.4.62:3306 74     mode tcp 75     default_backend mysqlsrv 76 backend mysqlsrv 77     mode tcp 78     server mysqlsrv1 192.168.4.63:3306 check 79     server mysqlsrv2 192.168.4.64:3306 check</code></pre><p>这时我们查看下是谁发起的链接</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-02_204032.jpg" alt=""></p><p>由此我们可知，真正发起的是代理服务器</p><blockquote><p>支持https协议</p></blockquote><p>（1）支持ssl会话</p><pre><code>bind *:443 ssl crt /PATH/TO/SOME_PEM_FILE</code></pre><p><strong>注意：crt文件的后缀为PEM格式，且同时包含证书和所有私钥内容</strong></p><p>（2）把80端口请求重定向到443</p><pre><code>bind *:80redirect scheme https if!{ssl_fc}</code></pre><p>（3）向后端传递用户请求的协议和端口</p><pre><code>http_request set-header X-Forwarded-Port %[dst_port]http_request add-header X-Forwarded-Proto https if { ssl_fc } </code></pre><p><strong>示例：</strong></p><p>（1）生成证书文件</p><p><code>[root@haproxy/etc/pki/tls/certs]#make httpd.pem</code></p><p><code>[root@haproxy/etc/pki/tls/certs]#cp httpd.pem /root</code></p><p>（2）修改haproxy.cfg文件</p><pre><code> 68 frontend web 69     bind 172.18.4.62:330 ssl crt /root/httpd.pem 70     redirect scheme https if !{ ssl_fc }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HAProxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>firewalld</title>
      <link href="/2017/11/29/firewalld/"/>
      <url>/2017/11/29/firewalld/</url>
      
        <content type="html"><![CDATA[<h1 id="firewalld"><a href="#firewalld" class="headerlink" title="firewalld"></a>firewalld</h1><p>firewalld是CentOS 7新退出的管理netfilter的工具。firewalld 提供了支持网络 / 防火墙区域 (zone) 定义网络链接以及接口安全等级的动态防火墙管理工具。它支持 IPv4, IPv6 防火墙设置以及以太网桥接，并且拥有运行时配置和永久配置选项。它也支持允许服务或者应用程序直接添加防火墙规则的接口。以前的 iptables 防火墙是静态的，每次修改都要求防火墙完全重启。这个过程包括内核 netfilter 防火墙模块的卸载和新配置所需模块的装载等。而模块的卸载将会破坏状态防火墙和确立的连接。</p><h2 id="1、firewalld-zone分类"><a href="#1、firewalld-zone分类" class="headerlink" title="1、firewalld zone分类"></a>1、firewalld zone分类</h2><table><thead><tr><th>zone名称</th><th>默认配置</th></tr></thead><tbody><tr><td>trusted</td><td>允许所有流量</td></tr><tr><td>home</td><td>拒绝除和传出流量相关的，以及ssh、mdsn、ipp-client、samba-client、dhcpv6-client预定于服务之外其他所有传入流量</td></tr><tr><td>internal</td><td>允许所有流量</td></tr><tr><td>work</td><td>拒绝除和传出流量相关的，以及ssh、ipp-client、dhcpv6-client预定于服务之外的其他所有传入流量</td></tr><tr><td>public</td><td>拒绝除和传出流量相关的，以及ssh、dhcpv6-client预定于服务之外的其他所有传入流量，新家的网卡默认属于public zone</td></tr><tr><td>external</td><td>拒绝除和传出流量相关的，以及ssh预定义服务之外的其他所有传入流量，属于external zone的传出ipv4流量的源地址将被伪装为传出网卡的地址</td></tr><tr><td>dmz</td><td>拒绝除和传出流量相关的，以及ssh预定义服务之外的其他所有传入流量</td></tr><tr><td>block</td><td>拒绝除和传出流量相关的所有传入流量</td></tr><tr><td>drop</td><td>拒绝除和传出流量的所有传入流量</td></tr></tbody></table><h2 id="2、预定于服务"><a href="#2、预定于服务" class="headerlink" title="2、预定于服务"></a>2、预定于服务</h2><table><thead><tr><th>服务名称</th><th>配置</th></tr></thead><tbody><tr><td>ssh</td><td>Local SSH server. Traffic to 22/tcp    </td></tr><tr><td>dhcpv6-client</td><td>Local DHCPv6 client. Traffic to 546/udp on the fe80::/64 IPv6 network    </td></tr><tr><td>ipp-client</td><td>Local IPP printing. Traffic to 631/udp.</td></tr><tr><td>samba-client</td><td>Local Windows file and print sharing client. Traffic to 137/udp and 138/udp.</td></tr><tr><td>Multicast DNS (mDNS)</td><td>local-link name resolution. Traffic to mdns 5353/udp to the 224.0.0.251 (IPv4) or ff02::fb (IPv6) multicast addresse </td></tr></tbody></table><p>##3、firewalld-cmd命令选项</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>–get-zones</td><td>列出所有可用区域</td></tr><tr><td>–get-default-zone</td><td>查询默认区域，只能有一种策略可以使用</td></tr><tr><td>–set-default-zone=<zone></zone></td><td>设置默认区域</td></tr><tr><td>–get-active-zones</td><td>列出当前所使用的区域</td></tr><tr><td>–add-source=<cidr>[–zone=<zone>]</zone></cidr></td><td>添加源地址的流量到指定区域，如果无–zone选项，使用默认区域</td></tr><tr><td>–remove-source=<cidr>[–zone=<zone>]</zone></cidr></td><td>从指定区域中删除源地址的流量，如无–zone选项，使用默认区域</td></tr><tr><td>–add-interface=<interface>[–zone=<zone>]</zone></interface></td><td>添加来自于指定接口的流量到特定区域，如无–zone选项使用默认区域</td></tr><tr><td>–change-interface=<interface>[–zone=<zone>]</zone></interface></td><td>改变指定接口至新的区域，如无–zone选项使用默认区域</td></tr><tr><td>–list-all [–zone=<zone>]</zone></td><td>列出指定区域的所有配置信息，包括接口、源地址、端口、服务等，如无–zone选项使用默认区域</td></tr><tr><td>–add-service=<service>[–zone=<zone>]</zone></service></td><td>允许指定端口和协议的流量，如无–zone选项使用默认区域</td></tr><tr><td>–add-port=<port protocol="">[–zone=<zone>]</zone></port></td><td>允许指定端口和协议流量如无–zone选项使用默认区域</td></tr><tr><td>–remove-port=<port protocol="">[–zone=<zone>]</zone></port></td><td>从区域中删除指定端口和协议，禁止该端口的流量，如无–zone选项使用默认区域</td></tr><tr><td>–reload</td><td>删除当前运行时的配置，应用加载永久配置</td></tr></tbody></table><p>##4、其他规则</p><p>当基本firewalld语法规则不能满足要求时，可以使用以下更复杂的规则；rich-rules富规则。rich规则比基本的firewalld语法实现更强的功能，不仅实现允许/拒绝，还可以实现日志syslog和auditd，也可以实现端口转发、伪装和限制速率。</p><p>###1、rich语法</p><pre><code>[source][destination] service|port|protocol|icmp-block|masquerade|forward-port [log][audit][accept|reject|drop]</code></pre><p>###2、规则实施顺序</p><pre><code>该区域的端口转发，伪造规则该区域的日志规则该区域的允许规则该区域的拒绝规则</code></pre><p><strong>注意：每个区域的规则生效，所有规则都不匹配，该区域默认规则生效。</strong></p><p>###3、rich规则选线</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>–add-rich-rule=’<rule>‘</rule></td><td>Add <rule> to the specified zone, or the default zone if no zone is specified.</rule></td></tr><tr><td>–remove-rich-rule=’<rule>‘</rule></td><td>Remove <rule> to the specified zone, or the default zone if no zone is specified.</rule></td></tr><tr><td>–query-rich-rule=’<rule>‘</rule></td><td>Query if <rule> has been added to the specified zone, or the default zone if no zone is specified. Returns 0 if the rule is present, otherwise 1.</rule></td></tr><tr><td>–list-rich-rules</td><td>Outputs all rich rules for the specified zone, or the default zone if no zone is specified.</td></tr></tbody></table><p> 当选项使用source或destination时，必须用rule [family=”ipv4|ipv6”]</p><p>需要制定服务时使用 service name=”service name”</p><p>Port</p><pre><code>port port=&quot;port value&quot; protocol=&quot;tcp|udp&quot;</code></pre><p>Protocol</p><pre><code>protocol value=&quot;protocol value&quot;</code></pre><p>ICMP-Block</p><pre><code>icmp-block name=&quot;icmptype name&quot;</code></pre><p>Masquerade</p><pre><code>masquerade</code></pre><p><code>firewall-cmd --permanent --zone=&lt;ZONE&gt; --add-rich-rule=&#39;rule family=ipv4 source address=192.168.0.0/24 masquerade&#39;</code></p><p>Source-Port</p><pre><code>source-port port=&quot;port value&quot; protocol=&quot;tcp|udp&quot;</code></pre><p>Log</p><pre><code>log [prefix=&quot;prefix text&quot;] [level=&quot;log level&quot;] [limit value=&quot;rate/duration&quot;]</code></pre><p>Audit</p><pre><code>audit [limit value=&quot;rate/duration&quot;]</code></pre><p>Action</p><pre><code>An action can be one of accept, reject, drop or mark.</code></pre><p>Limit</p><pre><code>limit value=&quot;rate/duration&quot;</code></pre><p>Destination</p><pre><code>destination [not] address=&quot;address[/mask]&quot;</code></pre><p>Source</p><pre><code>source [not] address=&quot;address[/mask]&quot;|mac=&quot;mac-address&quot;|ipset=&quot;ipset&quot;</code></pre><p>##端口转发：将发往本机的特定端口的流量转发到本机或不同机器的另一个端口。</p><p>格式</p><pre><code>firewall-cmd --permanent --zone=&lt;ZONE&gt; --add-forward port=port=&lt;PORTNUMBER&gt;:proto=&lt;PROTOCOL&gt;[:topor t=&lt;PORTNUMBER&gt;][:toaddr=&lt;IPADDR&gt;]</code></pre><p><strong>注意：toport和toaddr至少指定一个</strong></p><p>示例：</p><p><code>firewall-cmd --permanent --zone=public --add-forward-port=port=513:proto=tcp:toport=132:toaddr=192.168.0.25</code></p>]]></content>
      
      
      <categories>
          
          <category> 防火墙 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> firewalld </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx介绍</title>
      <link href="/2017/11/28/Nginx%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/11/28/Nginx%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-24_200136.jpg" alt=""></p><p>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强。</p><h1 id="一、Nginx介绍"><a href="#一、Nginx介绍" class="headerlink" title="一、Nginx介绍"></a>一、Nginx介绍</h1><p><img src="http://owatlfstl.bkt.clouddn.com/nginx.jpg" alt="Nginx架构"></p><h2 id="1、Nginx程序架构"><a href="#1、Nginx程序架构" class="headerlink" title="1、Nginx程序架构"></a>1、Nginx程序架构</h2><p>Nginx程序架构：master/worker结构</p><p>（1）一个master主进程：负载加载和分析配置文件、管理worker进程、平滑升级；一个或多个worker进程处理并响应用户请求。</p><p>（2）事件驱动机制</p><p>（3）支持sendfile</p><p>（4）支持AIO（异步非阻塞）</p><p>（5）支持mmap</p><h2 id="2、Nginx功能"><a href="#2、Nginx功能" class="headerlink" title="2、Nginx功能"></a>2、Nginx功能</h2><ul><li>基本功能：</li></ul><p>静态资源的web服务器；能缓存打开文件描述符（fd）</p><p>http、smtp、pop3协议的反向代理服务器</p><p>缓存加速、负载均衡功能</p><p>支持FastCGI，uWSGI</p><p>模块化（非DSO机制）、过滤器zip、SSI及图像大小的调整</p><ul><li>扩展功能</li></ul><p>基于名称和IP的虚拟主机</p><p>支持keeplive</p><p>支持平滑升级</p><p>定制范文日志、支持日志缓冲区提供日志存储性能</p><p>支持url和rewrite</p><p>支持路径别名</p><p>支持基于IP及用户的访问控制</p><p>支持速率限制；支持并发数限制</p><h2 id="3、Nginx特性"><a href="#3、Nginx特性" class="headerlink" title="3、Nginx特性"></a>3、Nginx特性</h2><p>模块化设计，较好的扩展性</p><p>高可靠性</p><p>支持热部署：不停机更新配置文件，升级版本；更新日志文件</p><p>低内存消耗：10000个keep-alive连接模式下的非活动连接，仅需要2.5M内存</p><h2 id="4、Nginx工作模式"><a href="#4、Nginx工作模式" class="headerlink" title="4、Nginx工作模式"></a>4、Nginx工作模式</h2><p>非阻塞、事件驱动、由一个master进程生成多个worker进程，每个worker进程响应多个请求。</p><h1 id="二、Nginx配置文件详解"><a href="#二、Nginx配置文件详解" class="headerlink" title="二、Nginx配置文件详解"></a>二、Nginx配置文件详解</h1><p><code>/etc/nginx/nginx.conf和/etc/nginx/*.conf</code><br>-</p><h1 id="1、配置文件的组成部分"><a href="#1、配置文件的组成部分" class="headerlink" title="#1、配置文件的组成部分"></a>#1、配置文件的组成部分</h1><ul><li>全局配置段：main .block 对全局生效</li></ul><ul><li>http{}段：定义http协议相关的配置</li></ul><p>格式：</p><pre><code>http{   各server的公共配置server用于定义一个虚拟主机    server{             location [OPERATOR] URL { 指定URL的特性                    if CONDITION {                    }            }    }}</code></pre><ul><li><p>event{}段：定义event模型工作特性</p></li><li><p>mail{}段：定义mail协议相关配置段</p></li><li><p>stream{}端：定义stream服务器相关配置段</p></li></ul><h2 id="2、配置文件格式"><a href="#2、配置文件格式" class="headerlink" title="2、配置文件格式"></a>2、配置文件格式</h2><pre><code>directive  value1 value2 ...</code></pre><p><strong>注意：</strong></p><p><strong>1、配置指令都要以“；”结尾。</strong></p><p><strong>2、支持使用配置变量：内置变量，模块提供的内建变量；自定义变量，set var_name value </strong></p><h1 id="二、nginx源码编译安装"><a href="#二、nginx源码编译安装" class="headerlink" title="二、nginx源码编译安装"></a>二、nginx源码编译安装</h1><p><a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">https://nginx.org/en/download.html</a>  源码包下载地址<br>-</p><h2 id="1、源码编译nginx选项介绍"><a href="#1、源码编译nginx选项介绍" class="headerlink" title="1、源码编译nginx选项介绍"></a>1、源码编译nginx选项介绍</h2><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>–prefix=/path/</td><td>指定nginx安装路径</td></tr><tr><td>–sbin-path=/path</td><td>指明nginx程序文件安装路径</td></tr><tr><td>–conf-path=/path</td><td>主配置文件安装路径</td></tr><tr><td>–error-log-path=/path</td><td>错误日志文件安装位置</td></tr><tr><td>–http-log-path=/path</td><td>访问日志文件安装路径</td></tr><tr><td>–pid-path=/path</td><td>指明pid文件安装位置</td></tr><tr><td>–lock-path=/path</td><td>锁文件安装路径</td></tr><tr><td>–http-client-body-temp-path=/path</td><td>客户端body部分的临时文件存放路径，如果服务器允许客户端使用put方法提交大数据时，临时存放的磁盘路径</td></tr><tr><td>–http-proxy-temp-path=/path</td><td>作为代理服务器，服务器响应报文临时文件存放路径</td></tr><tr><td>–http-fastcgi-temp-path=/path</td><td>作为fastcgi代理服务器，服务器响应报文的临时文件存放路径</td></tr><tr><td>–http-uwsgi-temp-path=/path</td><td>作为uwsgi代理服务器，服务器响应报文临时文件存放的路径</td></tr><tr><td>–http-scgi-temp-path=/path</td><td>作为scgi反代理服务器，服务器响应报文的临时文件存放的路径</td></tr><tr><td>–user=USERNAME</td><td>指明以哪个身份运行worker进程，主控进程一般由root运行</td></tr><tr><td>–group=GROUPNAME</td><td>指明组</td></tr><tr><td>–with-http_ssl_module</td><td>是否编译ssl模块</td></tr></tbody></table><h2 id="2、nginx编译过程"><a href="#2、nginx编译过程" class="headerlink" title="2、nginx编译过程"></a>2、nginx编译过程</h2><p>（1）源码下载并加压缩</p><p><code>[root@localhost/usr/local/src]#tar xf nginx-1.12.2.tar.gz</code></p><p><code>[root@localhost/usr/local/src]#cd nginx-1.12.2/</code></p><p>（2）安装编译环境</p><p><code>[root@localhost/usr/local/src/nginx-1.12.2]#yum groupinstall -y &quot;development tools&quot;</code></p><p><code>[root@localhost/usr/local/src/nginx-1.12.2]#yum install -y pcre-devel openssl-devel zlib-devel</code></p><p>（3）源码编译安装</p><p><code>[root@localhost/usr/local/src/nginx-1.12.2]#./configure --prefix=/usr/local/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx/nginx.lock --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_dav_module --with-http_stub_status_module --with-threads --with-file-aio</code>  #根据自己所需的要求添加模块</p><p><code>[root@localhost/usr/local/src/nginx-1.12.2]#make &amp;&amp; make install</code></p><p>如果想自定义版本名，设置如下行</p><p>nginx服务运行时显示</p><p><code>[root@localhost/usr/local/src/nginx-1.12.2/src/core]#vim nginx.h</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-28_205121.jpg" alt=""></p><p>nginx服务停止时显示</p><p><code>[root@localhost/usr/local/src/nginx-1.12.2/src/http]#vim ngx_http_header_filter_module.c</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-28_205632.jpg" alt=""></p><p>（4）修改环境变量</p><p><code>[root@localhost~]#vim /etc/profile.d/nginx.sh</code></p><pre><code>1 PATH=/usr/local/nginx/sbin:$PATH</code></pre><p><code>[root@localhost~]#source /etc/profile.d/nginx.sh</code></p><p>（5）测试是否可以启动</p><p><code>[root@localhost~]#nginx</code></p><p><code>[root@localhost~]#ss -tnlp</code></p><pre><code>LISTEN     0      128             *:80                          *:*                   users:((&quot;nginx&quot;,pid=57986,fd=6),(&quot;nginx&quot;,pid=57985,fd=6))</code></pre><p>至此源码编译nginx安装成功。</p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP请求报文</title>
      <link href="/2017/11/28/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87/"/>
      <url>/2017/11/28/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><p>在之前我们介绍了Web请求的过程里面说了当Client向Serve发送建立请求时即发送请求报文。Server处理完成之后向Client发送响应报文，即响应报文。下面我们来具体说说这两个的结构。</p><p><img src="http://owatlfstl.bkt.clouddn.com/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.jpg" alt=""></p><p>请求报文语法格式：</p><pre><code>&lt;Method&gt;&lt;Request-URL&gt;&lt;VERSION&gt;&lt;Headers&gt;&lt;Entity-body&gt;</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpg" alt=""></p><p>响应报文语法格式：</p><pre><code>&lt;Version&gt;&lt;Status-code&gt;&lt;Reson-phrase&gt;&lt;Headers&gt;&lt;Entity-body&gt;</code></pre><blockquote><p>具体解释说明</p></blockquote><p>method方法类型：</p><table><thead><tr><th>method方法类型</th><th>说明</th></tr></thead><tbody><tr><td>GET</td><td>从服务器获取一个资源</td></tr><tr><td>HEAD</td><td>只从服务器获取文档的响应头部</td></tr><tr><td>POST</td><td>向服务器输入数据，通常会再由网关程序继续处理</td></tr><tr><td>PUT</td><td>将请求的主体部分存储在服务器上，如上传文件</td></tr><tr><td>DELETE</td><td>请求删除服务器上指定的文档</td></tr><tr><td>TRACE</td><td>追踪请求到达服务器中间经过的代理服务器</td></tr><tr><td>OPTIONS</td><td>请求服务器返回对指定资源支持使用的请求方法</td></tr></tbody></table><p>VERSION构成：</p><pre><code>HTTP/&lt;major&gt;.&lt;minor&gt;</code></pre><p>Header</p><pre><code>每个请求或响应报文可包含任意首部；每个首部都有首部名称，后面跟一个冒号，而后跟一个可选空格，接着一个值。</code></pre><p>Entity-body</p><pre><code>请求时附加的数据或响应时附加的数据</code></pre><p>Reson-phrase</p><pre><code>状态码所标记状态简要描述</code></pre><p>状态码种类</p><p>HTTP状态码分类</p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>状态码详解说明</p><table><thead><tr><th>状体码</th><th>描述</th><th>简要描述</th></tr></thead><tbody><tr><td>200</td><td>成功，请求数据通过响应报文的Eentity-body部分发送</td><td>ok</td></tr><tr><td>301</td><td>请求的URL指向的资源已经删除；但在响应报文中通过首部Location指明了资源现有资源所处的新位置</td><td>Moved Permanently</td></tr><tr><td>302</td><td>响应报文Location指明资源临时位置</td><td>Moved Temporarily</td></tr><tr><td>304</td><td>客户端发出了条件式请求，但服务器上的资源未曾发生改变，则通过此响应状态码通知客户端</td><td>Not Modified</td></tr><tr><td>401</td><td>需要填入账号和密码认证才能访问资源</td><td>Unautorized</td></tr><tr><td>403</td><td>访问被禁止</td><td>Forbidden</td></tr><tr><td>404</td><td>服务器无法找到客户端请求资源</td><td>Not Found</td></tr><tr><td>500</td><td>服务器内部错误</td><td>Internal Server Error</td></tr><tr><td>502</td><td>代理服务器从后端服务器收到了一条伪响应，如无法连接网关</td><td>Bad Gateway</td></tr><tr><td>503</td><td>服务不可用，临时服务器维护或过载，服务器无法处理请求</td><td>Service Unavailable</td></tr><tr><td>504</td><td>网关超时</td><td>Gateway Timeout</td></tr><tr><td>505</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td><td>HTTP Version Not Support</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@localhost ~]# curl -i www.360buy.com</code>    #响应报文示例</p><pre><code>HTTP/1.1 301 Moved Permanently  Age: 2822Content-Type: text/htmlDate: Thu, 28 Sep 2017 13:23:54 GMTLocation: http://www.jd.com/Server: JDWSVia: BJ-H-NX-112(), http/1.1 LA-1-JCS-40 ( [cRs f ])Content-Length: 272&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=&quot;white&quot;&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;p&gt;The requested resource has been assigned a new permanent URI.&lt;/p&gt;&lt;hr/&gt;Server: JDWS&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p>http协议头部</p></blockquote><ul><li>通用首部</li></ul><table><thead><tr><th>首部信息</th><th>说明</th></tr></thead><tbody><tr><td>Date</td><td>报文的创建时间</td></tr><tr><td>Connnection</td><td>连接状态，如keep-alive，close</td></tr><tr><td>Via</td><td>显示报文经过的中间节点 （代理、网关）</td></tr><tr><td>Cache-Control</td><td>控制缓存，如缓存时长</td></tr><tr><td>MIME-Version</td><td>发送端使用的MIME版本</td></tr></tbody></table><ul><li>请求首部</li></ul><table><thead><tr><th>请求首部信息</th><th>说明</th></tr></thead><tbody><tr><td>Accept</td><td>通知服务器自己可接受的媒体类型</td></tr><tr><td>Accept-Charset</td><td>客户端可接受的字符集</td></tr><tr><td>Accept-Encoding</td><td>客户端可接受编码格式</td></tr><tr><td>Accept-Language</td><td>客户端可接受的语言</td></tr><tr><td>Client-IP</td><td>请求客户端IP</td></tr><tr><td>Host</td><td>请求服务器名称和端口号</td></tr><tr><td>Referer</td><td>跳转至当前URL的前一个URL</td></tr><tr><td>User-Agent</td><td>客户端代理，浏览器版本</td></tr></tbody></table><p><em>条件式请求首部</em></p><table><thead><tr><th>条件请求首部信息</th><th>说明</th></tr></thead><tbody><tr><td>Expect</td><td>允许客户端列出某请求所要求的服务器行为</td></tr><tr><td>If-Modified-Since</td><td>自从指定的时间之后，请求的资源是否发生过修改</td></tr><tr><td>If-Unmodified-Since</td><td>自从指定的时间之后，请求的资源是否没有发生过修改</td></tr><tr><td>If-None-Match</td><td>本地缓存中存储的文档的ETag标签是否与服务器文档的ETag不匹配</td></tr><tr><td>If-Match</td><td>本地缓存中的存储文档ETag标签是否与服务器文档的ETag匹配</td></tr></tbody></table><p><em>安全请求首部</em></p><table><thead><tr><th>安全请求首部</th><th>说明</th></tr></thead><tbody><tr><td>Authorization</td><td>向服务器发送认证信息，如账号和密码</td></tr><tr><td>Cookie</td><td>客户端向服务器发送cookie</td></tr><tr><td>Cookie2</td><td>用于说明请求端支持的cookie版本</td></tr></tbody></table><p><em>代理服务请求首部</em></p><p>Proxy-Authorization    向代理服务器认证</p><ul><li>响应首部</li></ul><table><thead><tr><th>响应首部信息</th><th>说明</th></tr></thead><tbody><tr><td>Age</td><td>从最初创建开始响应持续时长</td></tr><tr><td>Server</td><td>服务器程序软件名称和版本</td></tr><tr><td>Accept-Ranges</td><td>服务器可接受的请求范围类型</td></tr><tr><td>Vary</td><td>服务器查看的其他首部列表</td></tr></tbody></table><p><em>安全响应首部</em></p><table><thead><tr><th>安全首部信息</th><th>说明</th></tr></thead><tbody><tr><td>Set-Cookie</td><td>向客户端设置cookie</td></tr><tr><td>Set-Cookie</td><td>向客户端发送cookie2版本</td></tr><tr><td>WWW-Authenticate</td><td>来自服务器对客户端的质询列表</td></tr></tbody></table><ul><li>实体首部：</li></ul><table><thead><tr><th>实体首部信息</th><th>说明</th></tr></thead><tbody><tr><td>Allow</td><td>列出对此资源实体可使用的请求方法</td></tr><tr><td>Location</td><td>告诉客户端真正的实体位于何处</td></tr><tr><td>Content-Encoding</td><td>对主体执行的编码</td></tr><tr><td>Content-Language</td><td>文本使用的语言</td></tr><tr><td>Content-Location</td><td>实体真正所处的位置</td></tr><tr><td>Content-type</td><td>主体的对象类型</td></tr><tr><td>ETag</td><td>实体的扩展标签</td></tr><tr><td>Expires</td><td>实体的过期时间</td></tr><tr><td>Last-Modified</td><td>最后一次修改时间</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS访问控制和智能DNS</title>
      <link href="/2017/11/28/DNS%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E6%99%BA%E8%83%BDDNS/"/>
      <url>/2017/11/28/DNS%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E6%99%BA%E8%83%BDDNS/</url>
      
        <content type="html"><![CDATA[<h2 id="DNS的管理功能"><a href="#DNS的管理功能" class="headerlink" title="DNS的管理功能"></a>DNS的管理功能</h2><p>你是不是有这样的想法，只想让某个IP或者某个IP端的地址进行访问，实现访问控制功能。DNS服务给我们提供了很好的解决方法。</p><h3 id="1、选项"><a href="#1、选项" class="headerlink" title="1、选项"></a>1、选项</h3><p>|<br>|allow-query {}；|  允许查询的主机，相当于白名单<br>|allow-transfer {}；|允许区域传送的主机<br>|allow-recursion{};|允许递归的主机，这个选项建议在options中使用<br>|allow-update{}；|允许更新区域数据库中的内容</p><h3 id="2、acl"><a href="#2、acl" class="headerlink" title="2、acl"></a>2、acl</h3><blockquote><p>acl：是把某个IP或IP端合并为一个集合，通过一个统一的名称调用；可以把这个理解为bash函数的功能。</p></blockquote><p>（1）acl内置的选项</p><p>|<br>|none|没有一个主机|<br>|any|任意主机|<br>|localhost|本机|<br>|localnet|本机的IP同掩码运算后得到的网络地址|</p><p><strong>注意：acl只能先定义再使用；建议一般定义再options的前面。</strong></p><p>（2）示例</p><p><code>[root@localhost ~]# vim /etc/named.conf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-21_202629.png" alt=""></p><p>重新启动服务然后在本机测试<br><code>[root@localhost ~]# dig www.test.com @127.0.0.1</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-21_202925.png" alt=""></p><p>由于我们设置了acl功能，所有本机也不能访问了。实现我们的预期效果。</p><h2 id="view"><a href="#view" class="headerlink" title="view"></a>view</h2><p>大家小时候去网吧的时候有没有遇到这样一个问题，如果你玩问道在电信1玩，而你的网络是联通的网络，这样开始玩游戏的过程中，我们的屏反应会迟钝，频很高；但是网络提供一个网络转换程序，如果你切换到电信网络，问道游戏运行流畅；这相当于我们这里<em>view</em>的功能。实现只能DNS解析，不过不需要我们手动切换网络。</p><p>（1）一个bind服务器可以定义多个view；每个view可以定义多个zone。每个view匹配一组客户端。</p><p>（2）如果多个view对同一个zone进行解析时，使用不同的zone解析库文件。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a><strong>实战</strong></h3><p>如果我们在北京和广州有两台DNS服务器，北京和广州用户通过访问<a href="www.test.com">www.test.com</a>的时候，我希望北京访问直接在北京DNS解析并返回，广州与它相同，如何实现嗯？</p><blockquote><p>在一台由于我电脑有两个不同的IP段，在一台机器上实现这个功能</p></blockquote><p>（a）修改<code>/etc/named.conf</code>文件</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-21_212202.png" alt=""><br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-21_212250.png" alt=""></p><p>（b)创建<code>/etc/named.rfc1912.zones.test</code>和<code>/etc/named.rfc1912.zones.app</code>分别修改</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-21_212508.png" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-21_212553.png" alt=""></p><p>（3）创建zone文件 <code>/var/named/app.com.zone</code>和<code>/var/named/app.com.zone</code>分别修改</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-21_212818.png" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-21_212852.png" alt=""></p><p>（4）重启dns服务<br><code>[root@localhost named]# service named restart</code></p><blockquote><p>在Clinet客户机上测试（IP 192.168.4.148和172.18.253.86）</p></blockquote><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-21_213117.png" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-21_213211.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP介绍</title>
      <link href="/2017/11/28/Httpd%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
      <url>/2017/11/28/Httpd%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="一、HTTP概念及相关术语"><a href="#一、HTTP概念及相关术语" class="headerlink" title="一、HTTP概念及相关术语"></a>一、HTTP概念及相关术语</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><pre><code>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</code></pre><h3 id="2、HTTP协议介绍"><a href="#2、HTTP协议介绍" class="headerlink" title="2、HTTP协议介绍"></a>2、HTTP协议介绍</h3><blockquote><p>http/0.9</p></blockquote><p>1991，原型版本，功能简陋，只有一个命令GET。GET /index.html ,服务器只能回应HTML格式字符串，不能回应别的格式</p><blockquote><p>http/1.0</p></blockquote><p>1996年5月,支持cache, MIME, method每个TCP连接只能发送一个请求，发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。（1）引入了POST命令和HEAD命令头信息是 ASCII 码，后面数据可为任何格式。服务器回应时会告诉客户端，数据是什么格式，即<strong>Content-Type</strong>字段的作用。这些数据类型总称为MIME 多用途互联网邮件扩展，每个值包括一级类型和二级类型，预定义的类型，也可自定义类型。</p><blockquote><p>http/1.1</p></blockquote><p>1997年1月（1）引入了持久连接（<strong>persistent connection</strong>），即TCP连接默认不关闭，可以被多个请求复用，不用声明<strong>Connection: keep-alive</strong>。对于同一个域名，大多数浏览器允许同时建立<em>6</em>个持久连接。（2）引入了管道机制（pipelining），即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率。新增方法：PUT、PATCH、OPTIONS、DELETE。</p><p>同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只能顺序处理回应，前面的回应慢，会有许多请求排队，造成”队头堵塞”（Head-of-line blocking）。为避免这种问题出现：一是减少请求数，二是同时多开持久连接。</p><p>网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等。</p><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。请求的很多字段都是重复的，浪费带宽，影响速度<br>Spdy：2009年,谷歌研发,解决 HTTP/1.1 效率不高问题。</p><blockquote><p>http/2.0</p></blockquote><p>2015年头信息和数据体都是二进制，称为头信息帧和数据帧。（1）复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免了“队头堵塞“,此双向的实时通信称为多工（Multiplexing）。（2）引入头信息压缩机制（header compression）,头信息使用gzip或compress压缩后再发送；客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，不发送同样字段，只发送索引号，提高速度。（3）HTTP/2 允许服务器未经请求，主动向客户端发送资源，即服务器推送（server push）。</p><h3 id="3、MIME（Multiprocess-Internet-Mail-Extensions）"><a href="#3、MIME（Multiprocess-Internet-Mail-Extensions）" class="headerlink" title="3、MIME（Multiprocess Internet Mail Extensions）"></a>3、MIME（Multiprocess Internet Mail Extensions）</h3><h4 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h4><p>多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。</p><h4 id="2、MIME类型"><a href="#2、MIME类型" class="headerlink" title="2、MIME类型"></a>2、MIME类型</h4><ul><li><p>魔法分类：Apache web服务器可以扫描每个资源的内容，并将其与一个已知模式表(被称为魔法文件)进行匹配，以决定每个文件的MIME类型。这样做可能比较慢，但很方便，尤其是文件没有标准扩展名的时候</p></li><li><p>显式分类：可以对Web服务器进行配置，使其不考虑文件的扩展名或内容，强制特定文件或目录内容拥有某个MIME类型</p></li><li><p>类型协商： 有些Web服务器经过配置，可以以多种文档格式来存储资源。在这种情况下，可以配置Web服务器，使其可以通过与用户的协商来决定使用哪种格式(及相关的MIME类型)”最好”</p></li></ul><h4 id="3、MIME格式"><a href="#3、MIME格式" class="headerlink" title="3、MIME格式"></a>3、MIME格式</h4><pre><code>Content-Type: [type]/[subtype]; parameter</code></pre><p><strong>type类型</strong></p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Text</td><td>用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的；</td></tr><tr><td>Multipart</td><td>用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据；</td></tr><tr><td>Application</td><td>用于传输应用程序数据或者二进制数据；</td></tr><tr><td>Message</td><td>用于包装一个E-mail消息；</td></tr><tr><td>Image</td><td>用于传输静态图片数据；</td></tr><tr><td>Audio</td><td>用于传输音频或者音声数据；</td></tr><tr><td>Video</td><td>用于传输动态影像数据，可以是与音频编辑在一起的视频数据格式</td></tr></tbody></table><p><strong>subtype类型</strong></p><p>subtype是用于指定type详细形式。</p><table><thead><tr><th>子类型</th><th>说明</th></tr></thead><tbody><tr><td>text/plain</td><td>纯文本，文件扩展名.txt</td></tr><tr><td>text/html</td><td>HTML文，文件扩展名.html 或.htm</td></tr><tr><td>application/xhtml+xml</td><td>XHTML文</td></tr><tr><td>image/gif</td><td>GIF图像</td></tr><tr><td>image/jpeg</td><td>JPEG图像</td></tr><tr><td>image/png</td><td>PNG图像</td></tr><tr><td>video/mpeg</td><td>MPEG动画</td></tr><tr><td>application/octet-stream</td><td>任意的二进制数据</td></tr><tr><td>application/pdf</td><td>PDF文档</td></tr><tr><td>application/msword</td><td>Microsoft Word文件</td></tr><tr><td>application/vnd.wap.xhtml+xml</td><td>wap1.0+</td></tr><tr><td>application/xhtml+xml</td><td>wap2.0+</td></tr><tr><td>message/rfc822</td><td>RFC 822形式</td></tr><tr><td>multipart/alternative</td><td>HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示</td></tr><tr><td>application/x-www-form-urlencoded</td><td>使用HTTP的POST方法提交的表单</td></tr><tr><td>multipart/form-data</td><td>同上，但主要用于表单提交时伴随文件上传的场合</td></tr></tbody></table><p><strong>parameter</strong></p><p>可用来指定附加的信息，更多情况下是用于指定text/plain和text/html等的文字编码方式的charset参数。</p><pre><code> Content-Transfer-Encoding: [mechanism]</code></pre><p>内容传输编码，指定ASCII意外的字符编码方式，用来对附件进行解码。</p><table><thead><tr><th>编码格式</th><th>说明</th></tr></thead><tbody><tr><td>7bit</td><td>用在US ASCII字符集上</td></tr><tr><td>8bit和binary</td><td>一般不使用</td></tr><tr><td>quoted printable</td><td>可读的标准文本，如果传输要经过对格式有影响的网关时对其进行保护</td></tr><tr><td>base64</td><td>通用方法，通常在二进制中，非文本数据</td></tr></tbody></table><p>如果想查看MIME的类型可以查看文件<code>/etc/mime.types</code></p><h3 id="4、URI"><a href="#4、URI" class="headerlink" title="4、URI"></a>4、URI</h3><p>统一资源标识符（Uniform Resource Identifier，或URI）是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对网络中（一般指万维网）的资源通过特定的协议进行交互操作。分为两种URL（Uniform Resource Location）和URN（Uniform Resource Name）。URL用于描述某服务器某特定资源位置。URN其目的是通过提供一种途径，用于在特定的命名空间资源的标识，以补充网址并不指定地址。说白了URL就是一个人的住址，URN是一个人的名字。URN定义某事物的身份，而URL提供查找该事物的方法。</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-27_200240.png" alt=""></p><blockquote><p>URL组成</p></blockquote><pre><code>                hierarchical part    ┌───────────────────┴─────────────────────┐                authority               path    ┌───────────────┴───────────────┐┌───┴────┐  abc://username:password@example.com:123/path/data?key=value&amp;key2=value2#fragid1  └┬┘   └───────┬───────┘ └────┬────┘ └┬┘           └─────────┬─────────┘ └──┬──┘scheme  user information     host     port                  query         fragment  urn:example:mammal:monotreme:echidna  └┬┘ └──────────────┬───────────────┘scheme              path</code></pre><table><thead><tr><th>种类</th><th>说明</th></tr></thead><tbody><tr><td>scheme</td><td>方案，访问服务器以获取资源时要使用哪种协议</td></tr><tr><td>user</td><td>用户，某些方案访问资源时需要用户名</td></tr><tr><td>password</td><td>用户对应的密码；user:password</td></tr><tr><td>host</td><td>资源宿主机主机名或IP地址</td></tr><tr><td>part</td><td>资源宿主机正在监听的端口号，很多方案都有默认的端口号</td></tr><tr><td>path</td><td>服务器资源的本地名，有一个/将其与前面的URL组件分割</td></tr><tr><td>params</td><td>指定输入的参数，参数为名/值对，用“；”分隔</td></tr><tr><td>query</td><td>查询，传递参数给程序，用”?”分隔，多个查询使用“&amp;”分隔</td></tr><tr><td>frag</td><td>片段，一小片或一部分资源的名字，此组件在客户端使用，用“#”分隔</td></tr></tbody></table><p>示例：</p><pre><code>http://www.test.com:8080/images/logo.jpgftp://xiaoming:password@192.168.4.150/pub/linux.pptrtsp://videoserver/video_demo/Real Time Streaming Protocolhttp://wwwtest.com/bbs/hello;gender=f/send;type=titlehttps://list.jd.com/list.html?cat=670,671,672&amp;ev=149_2992&amp;sort=sort_totalsales15_desc&amp;trans=1http://apache.org/index.html#projects-list</code></pre><h2 id="二、HTTP的工作机制"><a href="#二、HTTP的工作机制" class="headerlink" title="二、HTTP的工作机制"></a>二、HTTP的工作机制</h2><p>当我们去访问一个网站是一个网页并不是单单的一个资源，是由多个资源展示出来；每个资源都要单独的请求。</p><p>现在我们需要区分两个概念静态文件和动态文件</p><pre><code>静态文件：无需服务端做出额外处理，说白了就是写死的，任何人访问此资源时，都显示同一个页面内容。文件后缀：.jpg .html  .txt .js .css .mp3 .avi动态文件：服务端执行程序之后，返回执行结果。说白了就是不同的人、不同时候访问此页面，显示的内容可能不同。文件后缀：.asp .php .jsp</code></pre><blockquote><p>非持久连接和持久连接</p></blockquote><p>非持久连接：一个请求与服务器连接传输完成之后，端口。如果下一个请求过来，再建立连接。</p><blockquote><p>缺点</p></blockquote><p>(1)客户为每个待请求的对象建立并维护一个新得连接。对于每个这个的连接，TCP必须同时在客户端和服务器端分配TCP缓冲区，并维护TCP变量。对于有可能同时为来自数百个不同客户的请求提供服务的Web服务器来说，这会严重增加服务器的负担；</p><p>(2)对每个对象请求都有2个RTT(Round-Trip Time 往返时延)的响应延迟：一个RTT用于建立TCP连接，另一个RTT用于请求和接收对象；<a href="http://blog.csdn.net/jackywangjia/article/details/27643379" target="_blank" rel="noopener">http://blog.csdn.net/jackywangjia/article/details/27643379</a></p><p>(3)每个对象都要经历 TCP 缓启动，因为每个TCP连接都要起始于slow start 阶段。并行TCP连接的使用能够部分减轻RTT延迟和缓启动的影响。</p><p>持久连接：当完成一次请求之后，服务器在发出响应后让TCP连接继续打开着。同一对客户/服务器之间的后续请求和响应可以通过这个连接发送。</p><p>缺点：服务器送出一个对象后开始等待下一个请求，而这个新请求却不能马上到达。这段时间服务器资源便闲置了。</p><blockquote><p>如何提高HTTP连接性能呢？</p></blockquote><ul><li>并行连接：通过多条TCP连接发起并发的HTTP请求</li></ul><p><img src="http://owatlfstl.bkt.clouddn.com/rr.jpg" alt=""></p><ul><li>持久连接：keep-alive,长连接，重用TCP连接，以消除连接和关闭的时延,以事务个数和时间来决定是否关闭连接</li></ul><p><img src="http://owatlfstl.bkt.clouddn.com/dd.jpg" alt=""></p><ul><li>管道化连接：通过共享TCP连接发起并发的HTTP请求</li></ul><p><img src="http://owatlfstl.bkt.clouddn.com/eew.jpg" alt=""></p><ul><li>复用的连接：交替传送请求和响应报文（实验阶段）</li></ul><blockquote><p>Web响应模型介绍</p></blockquote><ul><li><p>单进程I/O模型：启动一个进程处理用户请求，而且一次只处理一个，当发出多个请求时，被串联响应。<br><img src="http://owatlfstl.bkt.clouddn.com/aaqq.jpg" alt=""></p></li><li><p>多进程I/O模型：并行启动多个进程，每个进程响应一个连接请求。<br><img src="http://owatlfstl.bkt.clouddn.com/aae.jpg" alt=""></p></li><li><p>复用I/O请求：启动一个进程，同时响应N个连接请求。<br><img src="http://owatlfstl.bkt.clouddn.com/er.jpg" alt=""></p></li><li><p>复用多进程I/O模型：启动M个进程，每个进程响应N个请求，同时接受M*N个请求。</p></li></ul><p><img src="http://owatlfstl.bkt.clouddn.com/rrt.jpg" alt=""></p><h2 id="三、新特性"><a href="#三、新特性" class="headerlink" title="三、新特性"></a>三、新特性</h2><ul><li>MPM支持运行为DSO机制，以模块形式按需加载</li><li>event MPM生产环境可用</li><li>异步读写机制</li><li>支持每模块及每目录的单独自制级别定义</li><li>每请求相关的专用配置</li><li>增强版的表达式分析式</li><li>毫秒级持久连接时长定义</li><li>基于FQDN的虚拟主机不需要NameVirtualHost指令</li><li>新指令，AllowOverList</li><li>支持用户自定义变量</li><li>更低的内存消耗</li><li>不再支持使用Order，Deny,Allow来做基于IP的访问控制新模块</li></ul><h2 id="httpd-2-4文件介绍"><a href="#httpd-2-4文件介绍" class="headerlink" title="httpd-2.4文件介绍"></a>httpd-2.4文件介绍</h2><p>-配置文件</p><pre><code>/etc/httpd/conf/httpd/conf/etc/httpd/conf.d/*.conf</code></pre><ul><li><p>模块相关的配置文件</p><p>  /etc/httpd/conf.modules.d/*.conf</p></li><li><p>系统启动文件</p><p>  /usr/lib/systemd/system/httpd/service</p></li><li><p>主程序文件</p><p>  /usr/sbin/httpdd</p></li><li><p>日志文件</p><p>  /var/log/httpd/access_log<br>  /var/log/httpd/error_log</p></li><li><p>站点文档</p><p>  /var/www/html</p></li><li><p>模块文件路径</p><p>  /usr/lib64/httpd/moudles<br>  /etc/httpd/modules</p></li></ul><h2 id="相关设置介绍"><a href="#相关设置介绍" class="headerlink" title="相关设置介绍"></a>相关设置介绍</h2><p>（1）切换使用MPM</p><p><code>[root@localhost/etc/httpd/conf.modules.d]#vim 00-mpm.conf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-01_211652.jpg" alt=""></p><p>如上图所示，如果要使用其他MPM将注释取消重启即可。</p><p>（2）认证方式</p><ul><li><p>无明确授权的记录，默认拒绝</p><p>  允许所有主机访问：Require all granted<br>  拒绝所有主机访问：Require all denied</p></li><li><p>控制特定的IP访问</p><p>  Require ip IPADDR :授权指定来源的IP访问<br>  Require not ip IPADDR：拒绝特定的IP访问</p></li><li><p>控制特定的主机访问</p><p>  Require host HOSTNAME :授权特定主机访问<br>  Require not host HOSTNAME：拒绝特定主机访问</p><pre><code>  HOSTNAME:      FQDN:特定主机      domain.tld：指定域名下的所有主机</code></pre></li></ul><blockquote><p>使用示例</p></blockquote><pre><code>&lt;RequireAll&gt;    Require all granted    Require not ip 192.168.4.150&lt;/RequireAll&gt;不能又失败，至少有一个成功匹配。&lt;RequireAny&gt;    Require all deny    Require not ip 192.168.4.150&lt;/RequireAny&gt;多个语句有一个成功，即成功优先。</code></pre><p>（3）虚拟主机</p><p><strong>注意：基于FQDN的虚拟主机也不需要NameVirtualHost指令</strong></p><blockquote><p>示例</p></blockquote><pre><code>&lt;VirtualHost *:80&gt;    ServerName www.x.com    DocumentRoot  &quot;/app/www/x.com&quot;    &lt;Document &quot;/app/www/x.com&quot;&gt;        Option None        AllowOverride None        Require all granted    &lt;/Document&gt;&lt;/VirtualHost&gt;</code></pre><p><strong>注意：任意目录下的页面只有显示授权才能被访问。</strong></p><p>（4）Sendfile机制</p><blockquote><p>不使用Sendfile的过程</p></blockquote><pre><code>1、系统调用read()产生一个上下文切换：从user mode 切换到Kernel mode，然后DMA(Direct Memory Access，直接内存存取)执行拷贝，把文件数据从硬盘读到一个Kernel buffer里。2、数据从Kernel buffer拷贝到user buffer，然后系统调用read()返回，这时又产生一个上下文切换：从kernel mode 切换到user mode3、系统调用write()产生一个上下文切换：从user mode 切换到kernel mode，然后把步骤2读到user buffer的数据拷贝到kernel buffer，不过关这次是相关联的。4、系统调用write()返回，产生一个上下文切换：从Kernel mode 切换到User mode，然后DMA从kernel buffer拷贝数据到协议栈。</code></pre><blockquote><p>使用Sendfile机制过程</p></blockquote><pre><code>1、系统调用sendfile()通过DMA把硬盘数据拷贝到Kernel buffer，然后数据被kernel直接拷贝到另一个与socket相关的kernel buffer。这里没有user mode和kernel mode 之间的切换。在kernel中直接完成了从一个buffer到另一个buffer的拷贝。2、DMA把数据从kernel buffer直接拷贝给协议栈，没有切换也不需要把数据从user mode拷贝到kernel mode，以为数据就在Kernel 里。</code></pre><p>（5）方向代理功能</p><pre><code>ProxyPass “/” &quot;http://www.example.com/&quot;ProxyPassReverse &quot;/&quot; &quot;http://www.example.com/&quot;</code></pre><p>特定URL反向代理</p><pre><code>ProxyPass “/image” &quot;http://www.example.com/&quot;ProxyPassReverse &quot;/image&quot; &quot;http://www.example.com&quot;</code></pre><blockquote><p>示例</p></blockquote><pre><code>&lt;VirtualHost *:80&gt;    ServerName www.x.com    ProxyPass / http://localhost:8080    ProxyPassReserver / http://localhost:8080&lt;/VirtualHost&gt;</code></pre><p>准备三台虚拟注意，CentOS 7 做web服务器，CentOS 7做代理服务器，另一台CentOS 6 做客户端</p><p>（5）APR（Apache Portalbe Run-time Libararies，Apache 可移植运行库）</p><p>主要为上层的应用程序提供一个可以跨越多操作系统平台使用的底层支持接口库。在早起的Apache版本中，应用程序本身必须能够处理各种具体操作系统平台的细节，并针对不同的平台调用不同的处理函数。</p>]]></content>
      
      
      <categories>
          
          <category> 服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Apache，HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS实战</title>
      <link href="/2017/11/28/DNS%E5%AE%9E%E6%88%98%E4%B8%80/"/>
      <url>/2017/11/28/DNS%E5%AE%9E%E6%88%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="（1）搭建主DNS服务器"><a href="#（1）搭建主DNS服务器" class="headerlink" title="（1）搭建主DNS服务器"></a>（1）搭建主DNS服务器</h4><p>（a）<code>[root@localhost ~]# yum install -y bind</code>   #安装包<br>（b）<code>[root@localhost ~]# vim /etc/named.conf</code>   #修改主配置文件</p><p>方式一：<br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_091807.png" alt=""></p><p>方式二：<br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_092049.png" alt=""></p><p>（c）<code>[root@localhost ~]# vim /etc/named.rfc1912.zones</code>   #修改zone文件</p><pre><code>zone &quot;test.com&quot; IN {        type master;        file &quot;test.com.zone&quot;    #此地方可以写绝对路径和相对路径，如果写相对路径，默认为`/var/named/test.com.zone`，因此在`/var/named`目录下文件名一定要与这里的文件名一致。};</code></pre><p>（d）<code>[root@localhost ~]# named-checkconf</code>    #使用命令对配置文件检查</p><pre><code>/etc/named.rfc1912.zones:27: missing &#39;;&#39; before &#39;}&#39; #此时检查为27行处没有加&quot;;&quot;修改完再检查即可。</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_092600.png" alt=""></p><p><strong>注意：修改rfc1912.zones文件时，要以“；”结尾；参数与选项之间必须有空格隔开。</strong></p><p>（e）修改zone文件<br><code>[root@localhost named]# cp named.localhost test.com.zone</code></p><p>但是这里有一个问题，bind程序是以who的身份运行呢？下面通过命令查询看下：<br><code>[root@localhost named]# ps aux |grep named</code></p><pre><code>named      4002  0.2  1.2 161124 13028 ?        Ssl  09:55   0:00 /usr/sbin/named -u named</code></pre><p>通过命令查看我们看到是以name身份运行的，但是我们在复制文件时，文件名时root，如下图；所以在复制过来以后记得修改文件的权限。</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_095035.png" alt=""></p><p>方法一：修改文件的所属组</p><p><code>[root@localhost named]# chgrp named test.com.zone</code></p><p>方法二：复制模板文件时，直接加“-p”</p><p><code>[root@localhost named]# cp -p named.localhost test.com.zone</code><br><code>[root@localhost named]# vim test.com.zone</code>    #修改ZONE文件</p><pre><code>$TTL 1D@       IN SOA  dns1 mail.test.com. (                                        0       ; serial                                        1D      ; refresh                                        1H      ; retry                                        1W      ; expire                                        3H )    ; minimum        NS      dns1dns1    A       192.168.4.132</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_093930.png" alt=""></p><p>（f）加载zone文件</p><p><code>[root@localhost named]# rndc reload</code></p><p>（g）查看是否可以解析</p><p><code>[root@localhost named]# dig-t ns test.com  @192.168.4.132</code> #在本机测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_115226.png" alt=""></p><p>在另外一台机器上测试</p><p>修改这台机器上的DNS<br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_115354.png" alt=""></p><p>测试</p><p><code>[root@localhost/etc/sysconfig/network-scripts]#dig -t ns test.com @192.168.4.132</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_115520.png" alt=""></p><h4 id="（2）搭建从DNS服务器"><a href="#（2）搭建从DNS服务器" class="headerlink" title="（2）搭建从DNS服务器"></a>（2）搭建从DNS服务器</h4><p>在主机IP地址为192.168.4.144搭建从服务器</p><p>（a）安装bind包</p><p>（b）编辑<code>/etc/named.conf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_140721.png" alt=""></p><p>（c）编辑配置zone文件<code>/etc/named.rfc1912zones</code></p><pre><code> zone &quot;test.com&quot; IN {        type slave;     #修改类型        masters { 192.168.4.132; }; #主DNS服务器的地址        file &quot;slaves/test.com.slave.zone&quot;;  #从DNS服务文件存放的位置 };</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_140912.png" alt=""></p><p>（d）启动bind服务，使其生效</p><p><code>[root@localhost~]#systemctl restart named</code><br><code>[root@localhost~]#ls /var/named/slaves/test.com.slave.zone</code></p><p>（e）测试</p><p><code>[root@localhost~]#dig www.test.com @192.168.4.144</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_141458.png" alt=""></p><h4 id="（3）实现转发功能"><a href="#（3）实现转发功能" class="headerlink" title="（3）实现转发功能"></a>（3）实现转发功能</h4><p>假如一个公司有三台DNS服务器，A,B,C并且这三台主机不在同一个位置；A机器可以直接连接互联网，而B，C不可以直接连接互联网。用户使用电脑想访问www.qq.com，只能通过专线先到C再到A，然后才能访问www.qq.com，通过C转发到A。</p><p>方式一：全局转发</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_144032.png" alt=""></p><p>（1）分别在CentOS 6和CentOS 7 主机上设置，CentOS 7为转发</p><p>(A)在CentOS 6主机上配置</p><p><code>[root@localhost ~]# vim /etc/named.conf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_181534.png" alt=""></p><p><code>[root@localhost ~]# vim /etc/named.rfc1912.zones</code></p><pre><code>zone &quot;test.com&quot; IN {        type master;        file &quot;test.com.zone&quot;;};</code></pre><p>重启服务</p><p><code>[root@localhost ~]# service named restart</code></p><p>(B)在CentOS 7主机上配置</p><p><code>[root@localhost~]#vim /etc/named.conf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_182100.png" alt=""></p><p><strong>切记，做这个实验室一定要关闭dnssec功能；dnssec-enable no; dnssec-validation no。</strong></p><p>重启服务</p><p><code>[root@localhost~]#systemctl restart named</code></p><p>(C)修改客户端机器的dns</p><p><code>[root@localhost~]#vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_182517.png" alt=""></p><p>(D)在客户端机器上测试</p><p><code>[root@localhost~]#dig www.test.com @192.168.4.148</code><br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_182708.png" alt=""></p><p><strong>在这里给大家提个醒：自己搞这个明明很简单的搞了一个多小时都没有成功，原因在于没有关闭dnssce功能。</strong></p><p>方式二：特定区域转发</p><p>在CentOS 主机上配置</p><p><code>[root@localhost~]#vim /etc/named.rfc1912.zones</code></p><pre><code>zone &quot;test.com&quot; IN {              type forward;           forward first;            forwarders {192.168.4.132;}; };</code></pre><p><code>[root@localhost~]#systemctl restart named</code> #重启服务</p><p>在客户端主机上测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_182708.png" alt=""></p><h4 id="（4）实现父域与子域的关系"><a href="#（4）实现父域与子域的关系" class="headerlink" title="（4）实现父域与子域的关系"></a>（4）实现父域与子域的关系</h4><p>在前面实验的基础上，执行如下操作：</p><p>（A）在CentOS 7主机上</p><p><code>[root@localhost~]#vim /etc/named.rfc1912.zones</code> 创建zone</p><pre><code>zone &quot;do.test.com&quot; IN {       type master;       file &quot;do.test.com.zone&quot;;  };</code></pre><p><code>[root@localhost/var/named]#vim do.test.com.zone</code>   #配置解析库</p><pre><code> $TTL 1D @       IN SOA  dns1 rname.invalid. (                                             0       ; serial                                             1D      ; refresh                                             1H      ; retry                                             1W      ; expire                                             3H )    ; minimum                    NS      dns1 dns1           A       192.168.4.148 webserver   A     192.168.4.148 www           CNAME   webserver</code></pre><p>(B)<code>[root@localhost named]# vim test.com.zone</code>    #在CentOS 6主机上修改解析库<br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_184101.png" alt=""></p><p><code>[root@localhost named]# service named restart</code> #重启服务</p><p>(C)重启服务测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_185513.png" alt=""></p><h4 id="（5）主从服务器"><a href="#（5）主从服务器" class="headerlink" title="（5）主从服务器"></a>（5）主从服务器</h4><p>案例前提：准备4台虚拟机</p><p>（A）CentOS6主机作为主DNS服务器，同上面的配置类似，这里就不再阐述。</p><p>（B）在CentOS 7两台主机上做从DNS服务器，进行如下配置：</p><p><code>[root@localhost ~]# vim /etc/named.conf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_181534.png" alt=""></p><p><code>[root@localhost~]#vim /etc/named.rfc1912.zones</code>#创建zone</p><pre><code>zone &quot;test.com&quot; IN {      type slave;      masters {192.168.4.132;};       file &quot;slaves/test.com.slave.zone&quot;; };</code></pre><p>启动bind的服务即可以同步到<code>/var/named/slaves</code>目录下</p><p><code>[root@localhost~]#systemctl restart named</code><br><code>[root@localhost~]#ll /var/named/slaves/test.com.slave1.zone</code></p><pre><code>    -rw-r--r--. 1 named named 382 Sep 20 19:08 /var/named/slaves/test.com.slave1.zone</code></pre><p>如果主从服务器想指定从DNS服务器，可以在<code>/etc/named.conf</code>配置文件中添加选项 allow-transfer {IP;}；</p><p>在从服务器上添加“allow-transfer {none;};”在主DNS服务器上“allow-transfer {IP;};”这样就限制了。</p><p><strong>注意：通过以上几个实验总结出需要注意的一些地方</strong></p><p>1、在做实验过程中一定要关闭dnssec功能；</p><p>2、复制文件<code>/var/named/named.localhost</code>做模板时，一定要加选项“-a”或“-p”选项。复制完成后一定看所有者、所属组和权限。</p><h2 id="实战二"><a href="#实战二" class="headerlink" title="实战二"></a>实战二</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_193605.png" alt=""></p><p>如何实现上述的拓扑图呢？先从底部网上一步一步的搭建</p><p>（1）实现主从DNS服务器</p><p>（a）修改主DNS服务器</p><p><code>[root@localhost~]#vim /etc/named.conf</code>    #修改主配置文件</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_181534.png" alt=""></p><p><code>[root@localhost~]#vim /etc/named.rfc1912.zones</code>    #创建zone</p><pre><code>zone &quot;test.com&quot; IN {         type master;         file &quot;test.com.zone&quot;; };</code></pre><p><code>[root@localhost ~]# vim /var/named/test.com.zone</code>  #创建解析库文件</p><pre><code>$TTL 1D@       IN SOA  dns1 test.com. (                                        2       ; serial                                        1D      ; refresh                                        1H      ; retry                                        1W      ; expire                                        3H )    ; minimum        IN      NS      dns1dns1    A       192.168.4.132webserver       IN      A       192.168.4.132www     IN      CNAME   webserver</code></pre><p><code>[root@localhost~]#vim /var/named/named.ca</code>    #修改根服务器文件</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_195721.png" alt=""></p><p><code>[root@localhost ~]# service named restart</code> #重启bind服务</p><p>（b）配置从DNS服务器</p><p>主配置文件和配置从服务器一样，这里就不再阐述<br><code>[root@localhost~]#vim /etc/named.rfc1912.zones</code></p><pre><code> zone &quot;localhost&quot; IN {         type master;         file &quot;named.localhost&quot;;         allow-update { none; }; };</code></pre><p><code>[root@localhost~]#systemctl restart named</code>#重启服务<br><code>[root@localhost~]#ll /var/named/slaves/test.com.slave.zone</code>   #查看是否成功</p><p>（2）配置子域</p><p><code>[root@localhost~]#vim /etc/named.rfc1912.zones</code>   #创建zone</p><pre><code>zone &quot;com&quot; {         type master;       file &quot;com.zone&quot;; }; </code></pre><p><code>[root@localhost~]#vim /var/named/com.zone</code> #创建解析库</p><pre><code>  $TTL 1D @       IN SOA  dns1 rname.invalid. (                                         0       ; serial                                         1D      ; refresh                                         1H      ; retry                                         1W      ; expire                                        3H )    ; minimum         NS      dns1 test    NS      dns2 dns1    A       192.168.4.147 dns2    A       192.168.4.132 www     A       192.168.4.66</code></pre><p><code>[root@localhost~]#systemctl restart named</code> #重启bind服务</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_212355.png" alt=""></p><p>（3）根</p><p> <code>[root@localhost~]#vim /etc/named.rfc1912.zones</code></p><pre><code> zone &quot;.&quot; IN {          type master;         file &quot;root.zone&quot;; };</code></pre><p>删除配置文件中<code>/etc/named.conf</code>如下内容<br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_204827.png" alt=""></p><p><code>[root@localhost/var/named]#vim root.zone</code> #创建解析库</p><pre><code>   $TTL 1D   @       IN SOA  dns1 rname.invalid. (                                           0       ; serial                                           1D      ; refresh                                           1H      ; retry                                           1W      ; expire                                           3H )    ; minimum           NS      dns1   com     NS      dns2  dns1    A       192.168.4.146  dns2    A       192.168.4.147</code></pre><p><code>[root@localhost/var/named]#systemctl restart named</code>重启服务</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-20_212932.png" alt=""></p><p>这样我们搭建完成了。是否是很有成就感呢？哈哈。当大家看到这里的时候是不是发现我们没有对从DNS服务器做设置呢？如果主DNS挂了，那么从DNS能工作么？下面我们就来说道说道。</p><blockquote><p>假设主DNS服务器down（IP 192.168.4.132 ）</p></blockquote><p><code>[root@localhost ~]# ifconfig eth0 down</code>    #将主DNS服务器down掉</p><p><code>[root@localhost ~]# rndc flush</code>    #清除主DNS服务器的缓存</p><blockquote><p>在Client客户机测试 （IP 192.168.4.149）</p></blockquote><p><code>[root@localhost~]#dig www.test.com @192.168.4.147</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-21_194440.png" alt=""></p><p>如图所示，没有解析成功，说明我们的从DNS服务器没有起作用，没有实现负载均衡作用。有没有想过为什么出现这种情况呢？因为我们没有在<strong>com域</strong>中没有添加这条域，下面我们在<strong>com域</strong>中添加此<strong>从DNS服务器</strong>的dns记录测试</p><blockquote><p>在com域中添加如下记录</p></blockquote><p><code>[root@localhost/var/named]#vim com.zone</code><br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-21_194536.png" alt=""></p><p><code>[root@localhost/var/named]#rndc flush</code> #清除缓存</p><blockquote><p>在client客户机上测试</p></blockquote><p><code>[root@localhost~]#dig www.test.com @192.168.4.148</code><br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-21_195643.png" alt=""></p><p>这样说明我们从DNS服务器起到了，达到了容错功能。是不是有点小小的成就感呢？</p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KVM基础</title>
      <link href="/2017/11/28/KVM/"/>
      <url>/2017/11/28/KVM/</url>
      
        <content type="html"><![CDATA[<p>KVM（Kernel-based Virtual Machine）是一种用于Linux内核中的虚拟化的基础设施，可以将Linux内核转换为一个hypervisor（虚拟机器监视器，virtual machine monitor，VMM）。KVM在具备Intel VT或AMD-V功能的X86平台上运行。它包含一个为处理器提供底层虚拟化可加载的核心模块kvm.ko。</p><h1 id="一、KVM"><a href="#一、KVM" class="headerlink" title="一、KVM"></a>一、KVM</h1><h2 id="1、Hypervisor类型"><a href="#1、Hypervisor类型" class="headerlink" title="1、Hypervisor类型"></a>1、Hypervisor类型</h2><h3 id="（1）本地或逻辑"><a href="#（1）本地或逻辑" class="headerlink" title="（1）本地或逻辑"></a>（1）本地或逻辑</h3><p>直接运行在主机的硬件来控制和管理客体操作系统上。</p><p><img src="http://owatlfstl.bkt.clouddn.com/VMM-Type1.JPG" alt=""></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>需要硬件支持</li><li>虚拟机监视器作为主操作系统</li><li>运行效率高</li></ul><h3 id="（2）主机类型"><a href="#（2）主机类型" class="headerlink" title="（2）主机类型"></a>（2）主机类型</h3><p>这些虚拟机管理程序运行在传统的操作系统上，就像其他计算机程序一样。</p><p><img src="http://owatlfstl.bkt.clouddn.com/VMM-Type2.JPG" alt=""></p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>虚拟机监视器为应用程序运行在主操作系统环境中</li><li>运行效率一般较低于上一中类型</li></ul><h3 id="两种类型对比"><a href="#两种类型对比" class="headerlink" title="两种类型对比"></a>两种类型对比</h3><p><img src="http://owatlfstl.bkt.clouddn.com/Hyperviseur.png" alt=""></p><h2 id="2、KVM架构"><a href="#2、KVM架构" class="headerlink" title="2、KVM架构"></a>2、KVM架构</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-30_203741.jpg" alt=""></p><h3 id="（1）KVM组成"><a href="#（1）KVM组成" class="headerlink" title="（1）KVM组成"></a>（1）KVM组成</h3><ul><li>Guest：客户机系统，包括CPU(VCPU)、内存、驱动等，被KVM置于一种受限制的CPU模式下运行</li><li>KVM：运行在内核空间，提供CPU和内存的虚拟化，以及客户机的IO拦截。Guest的IO被KVM拦截后，交给Qemu处理。</li><li>QEMU：修改过的为KVM虚拟机使用的QEMU代码，运行在用户空间，提供硬件IO虚拟化，通过IOCTL /dev/kvm设备和KVM交互</li></ul><h3 id="（2）KVM功能"><a href="#（2）KVM功能" class="headerlink" title="（2）KVM功能"></a>（2）KVM功能</h3><ul><li>支持CUP和内存虚拟化</li><li>支持半虚拟化IO</li><li>支持热插拔</li><li>支持对称处理（Symmetric Mutlti-Processing，SMP）</li><li>支持实时迁移</li><li>支持PCI设备直接分配和单根IO虚拟化</li><li>支持内核同页合并</li><li>支持NUMA（Non-Unifom Memory Access，非一致存储访问结构）</li></ul><h3 id="（3）KVM工具"><a href="#（3）KVM工具" class="headerlink" title="（3）KVM工具"></a>（3）KVM工具</h3><ul><li>libvirt：操作和管理KVM虚拟机的虚拟化API</li><li>Virsh：基于libvirt的命令行工具</li><li>Virt-Manager：基于libvirt的GUI工具</li><li>Virt-v2v：虚拟机格式迁移工具</li><li>Virt-install：创建KVM虚拟机的命令行工具</li><li>Virt-viewer：连接到虚拟机屏幕的工具</li><li>Virt-clone：虚拟机克隆工具</li></ul><h3 id="（4）KVM组件"><a href="#（4）KVM组件" class="headerlink" title="（4）KVM组件"></a>（4）KVM组件</h3><ul><li>（kvm.ko）/dev/kvm：工作在hypervisor，在用户空间可通过系统调用ioctl（）与内核中的kvm模块交互，从而完成虚拟机的创建、启动、停止、删除等各种管理功能</li><li>qemu-kvm进程：工作在用户空间，用于实现IO设备模拟；用于实现一个虚拟机示例</li></ul><h3 id="（5）KVM模块加载到内存中，运行模式"><a href="#（5）KVM模块加载到内存中，运行模式" class="headerlink" title="（5）KVM模块加载到内存中，运行模式"></a>（5）KVM模块加载到内存中，运行模式</h3><ul><li>内核模式：GuestOS执行IO类的操作时，或其他的特殊指令操作时的模式；</li><li>用户模式：Host OS用户空间，用于代为GuestOS发出IO请求</li><li>来宾模式：GuestOS的用户空间，所有的非IO类请求</li></ul><h1 id="二、CentOS上安装KVM功能模块步骤"><a href="#二、CentOS上安装KVM功能模块步骤" class="headerlink" title="二、CentOS上安装KVM功能模块步骤"></a>二、CentOS上安装KVM功能模块步骤</h1><h2 id="1、KVM需要有CPU的支持，安装KVM之前检查CPU是否支持虚拟技术。"><a href="#1、KVM需要有CPU的支持，安装KVM之前检查CPU是否支持虚拟技术。" class="headerlink" title="1、KVM需要有CPU的支持，安装KVM之前检查CPU是否支持虚拟技术。"></a>1、KVM需要有CPU的支持，安装KVM之前检查CPU是否支持虚拟技术。</h2><pre><code>基于Intel处理器的系统，查看是否有vmx关键词基于AMD处理器的系统，查看是否有svm关键词</code></pre><p><code>[root@node3~]#grep -i -E &#39;(vmx|svm|lm)&#39; /proc/cpuinfo</code></p><h2 id="2、安装与启动"><a href="#2、安装与启动" class="headerlink" title="2、安装与启动"></a>2、安装与启动</h2><p><code>[root@node3~]#modprobe kvm</code>    #装载KVM模块</p><p><code>[root@node3~]#yum install -y qemu-kvm libvirt-daemon-kvm virt-manager</code> #安装所需要的包</p><p><code>[root@node3~]#systemctl status libvirtd.service</code></p><h2 id="3、qemu-kvm命令"><a href="#3、qemu-kvm命令" class="headerlink" title="3、qemu-kvm命令"></a>3、qemu-kvm命令</h2><p><code>[root@node3~]#ln -sv /usr/libexec/qemu-kvm /usr/bin/</code>  #创建链接直接调用</p><p>语法：</p><pre><code>qemu-kvm [options] [disk_image]</code></pre><h3 id="标准选项"><a href="#标准选项" class="headerlink" title="标准选项"></a>标准选项</h3><pre><code>-machine [type=]name: -machine help 类获取列表，用于指定模拟的主机类型-cpu cpu：用于指定要模拟CPU型号-smp n[,maxcpus=cpus][,cores=cores][,threads=threads][,sockets=sockets]：指明虚拟机上的vcpu的数量及拓扑-boot [order=dirves][,once=dirvices][,menu=on|off][,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_time][,strict=on|off]：指定引导次序        order：各设备的引导次序，c表示第一块硬盘，d表示第一个光驱设备，--boot order=dc，once=d表示引导次序为光驱先引导后硬盘引导，光驱只使用一次-m megs：虚拟机内存大小-name NAME：当前虚拟机的名称，要唯一。</code></pre><h3 id="块设备相关的选项"><a href="#块设备相关的选项" class="headerlink" title="块设备相关的选项"></a>块设备相关的选项</h3><pre><code>-hda/-hdb file：指明IDE总线类型的硬盘映射文件路径；第0和第1个-hdc/-hdd file：第2个和第3个-cdrom file：指定要使用光盘映像文件-dirve [file=file][,if=type][,media=d][,index=i] [,cache=writethrough|writeback|none|directsync|unsafe][,format=f]：    file=/PATH/TO/SOME_IMAGE_FIEL：映像文件路径    if=TYPE：块设备总线类型，ide，scsi，sd等    media=TYPE：介质类型，cdrom和disk    index=i：设定同一类型设备多个设备的编号    cache=writethrough|writeback|none|directsync|unsafe：缓存方式    format=f：磁盘映像文件的格式</code></pre><h3 id="显示选项："><a href="#显示选项：" class="headerlink" title="显示选项："></a>显示选项：</h3><pre><code>-display type：显示类型，sdl，curses，none和vnc-nographic：不使用图形接口-vga [std|cirrus|vmware|qxl|xenfb|none]：模拟出显卡的型号-vnc display[,option[,option]...]：启动一个vnc server来显示虚拟机接口；让qemu进行监听一个vnc接口    display：        HOST:N 在host主机的第N个桌面输出VNC，5900+N        unix：/PATH/TO/SOCK_FILE        none    password：连接此服务所需要的密码-monitor stdio：在标准输出上显示monitor界面</code></pre><h3 id="网络选项"><a href="#网络选项" class="headerlink" title="网络选项"></a>网络选项</h3><pre><code>-net nic[,vlan=n][,macaddr=mac][,model=type][,name=str][,add=str][,vectors=v]：为虚拟机创建一个网络接口，并将添加至指定的VLAN    model=type：指明模拟出的网卡型号    macaddr=mac：指明mac地址-net tap[,vlan=n][,name=str][,fd=h][,fds=x:y:...z][,script=file][,downscript=dfile]：通过物理的TAP网络接口连接至vlan    script=file：启动虚拟机时要执行的脚本，默认为/etc/qemu-ifup    downscript=file：关闭虚拟机时要执行的脚本/etc/qemu-ifdown    ifname=NAME：自定义接口名称</code></pre><h2 id="4、qemu-img命令"><a href="#4、qemu-img命令" class="headerlink" title="4、qemu-img命令"></a>4、qemu-img命令</h2><p>是QEMU的磁盘管理工具</p><p>语法：</p><pre><code>qemu-img command [command options]check [-f fmt] filename：对磁盘镜像文件进行一致性检查，查找镜像文件中的错误。支持的格式：qcow2、qed、vdi。create [-f fmt] [-o options] filename [size]：创建一个格式为fmt大小为size文件名为filename的镜像文件。size大小默认单位为字节（bytes）。    size             Virtual disk size    compat           Compatibility level (0.10 or 1.1)    backing_file     File name of a base image    backing_fmt      Image format of the base image    encryption       Encrypt the image    cluster_size     qcow2 cluster size    preallocation    Preallocation mode (allowed values: off, metadata, falloc, full)    lazy_refcounts   Postpone refcount updatescommit [-f fmt] [-t cache] filename：提交filename文件中的更改后端支持镜像文件中去（创建时通过backing_file指定）。info [-f fmt] filename：显示filename镜像文件的信息。如果文件是使用稀疏文件的存储方式，也会显示他的本来分配的大小，以及实际已占用磁盘空间大小。如果文件中存放由客户机快照，快照信息也会被显示出来。snapshot [-l|-a snapshot |-c snapshot|-d snapshot] filename    -l：查询并列出镜像文件中的所有快照    -a snapshot：让镜像文件使用某个快照    -c snapshot：创建一个快照    -d snapshot：删除一个快照resize filename [+|-] size：改变镜像文件大小；qcow2格式文件不支持缩小镜像操作。 </code></pre><h2 id="5、brctl命令"><a href="#5、brctl命令" class="headerlink" title="5、brctl命令"></a>5、brctl命令</h2><p>网桥管理工具</p><p>格式：</p><pre><code>brctl [command]</code></pre><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>addbr</td><td>添加网桥</td></tr><tr><td>delbr</td><td>删除网桥</td></tr><tr><td>addif</td><td>添加接口</td></tr><tr><td>delif</td><td>删除接口</td></tr><tr><td>show</td><td>显示网桥</td></tr><tr><td>showmacs</td><td>显示网口mac地址</td></tr></tbody></table><h2 id="6、建立虚拟机"><a href="#6、建立虚拟机" class="headerlink" title="6、建立虚拟机"></a>6、建立虚拟机</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-30_211636.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-30_234950.jpg" alt=""></p><p>后续的操作跟安装操作系统一样。</p><h2 id="6、使用qemu-kvm命令创建虚拟机"><a href="#6、使用qemu-kvm命令创建虚拟机" class="headerlink" title="6、使用qemu-kvm命令创建虚拟机"></a>6、使用qemu-kvm命令创建虚拟机</h2><h3 id="（1）创建网桥"><a href="#（1）创建网桥" class="headerlink" title="（1）创建网桥"></a>（1）创建网桥</h3><p><code>[root@node3~]#brctl addbr br0</code><br><code>[root@node3~]#brctl show</code></p><pre><code>bridge name     bridge id               STP enabled     interfacesbr0             8000.000000000000       no</code></pre><p><code>[root@node3~]#ip link set br0 up</code>  #启动链路<br><code>[root@node3~]#ifconfig</code></p><pre><code>br0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</code></pre><p>不过此时还没有IP地址。</p><h3 id="配置br0地址"><a href="#配置br0地址" class="headerlink" title="配置br0地址"></a>配置br0地址</h3><p><code>[root@node3~]#brctl addif br0 eth1</code>    #添加设备<br><code>[root@node3~]#ip addr add 172.18.4.63 dev br0</code> #设置IP地址<br><code>[root@node3~]#ifconfig br0 up</code> #启动</p><h3 id="raw和qcow2"><a href="#raw和qcow2" class="headerlink" title="raw和qcow2"></a>raw和qcow2</h3><p>qcow2镜像格式是qemu模拟器支持的一种磁盘镜像。它也是可以用一个文件的形式来表示一块固定大小的块设备磁盘。与普通的raw格式镜像相比：</p><ul><li>更小的空间占用，即时文件系统不支持空桶（holes）</li><li>支持写时拷贝，镜像文件只反映底层磁盘的变化</li><li>支持快照</li><li>可选择基于zlib的压缩格式</li><li>可选择AES加密</li></ul><h3 id="准备虚拟磁盘文件"><a href="#准备虚拟磁盘文件" class="headerlink" title="准备虚拟磁盘文件"></a>准备虚拟磁盘文件</h3><p><code>[root@node3/app/test]#qemu-img create -o preallocation=metadata -f qcow2 /app/test/linux.qcow2 20G</code></p><pre><code>Formatting &#39;/app/test/linux.qcow2&#39;, fmt=qcow2 size=21474836480 encryption=off cluster_size=65536 preallocation=&#39;metadata&#39; lazy_refcounts=off  </code></pre><p>官网下载镜像文件</p><p><a href="https://launchpad.net/cirros/" target="_blank" rel="noopener">https://launchpad.net/cirros/</a></p><h3 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h3><p><code>[root@node3/app/test]#qemu-kvm -cpu host -smp 1 -name linux.test -m 64 -drive file=/app/test/linux.qcow2,if=ide,media=disk,format=qcow2 -drive file=/root/cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso,media=cdrom -boot dc -vnc :2</code></p><h4 id="启动cirrors虚拟机系统"><a href="#启动cirrors虚拟机系统" class="headerlink" title="启动cirrors虚拟机系统"></a>启动cirrors虚拟机系统</h4><p><code>[root@node3/app/test]#qemu-kvm -m 64 -name c1 -drive file=/root/cirros-no_cloud-i386.img,media=disk,format=qcow2,if=ide -boot c -vnc :5</code></p><h3 id="安装vnc远程管理工具"><a href="#安装vnc远程管理工具" class="headerlink" title="安装vnc远程管理工具"></a>安装vnc远程管理工具</h3><p><code>[root@node3~]#yum install -y vnc-server tigervnc</code></p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p><code>[root@node3~]#vncviewer :5901</code><br>连接上就可以自由的操作了 </p><h3 id="启动虚拟机将网卡桥接到桥接设备上"><a href="#启动虚拟机将网卡桥接到桥接设备上" class="headerlink" title="启动虚拟机将网卡桥接到桥接设备上"></a>启动虚拟机将网卡桥接到桥接设备上</h3><pre><code>[root@node3~]#vim /etc/qemu-ifup  1 #!/bin/bash  2 bridge=br0  3 if [ -n &quot;$1&quot; ]; then  4         ip link set $1 up  5         sleep 1  6         brctl addif $bridge $1  7         [ $? -eq 0 ] &amp;&amp; exit 0 || exit 1  8 else      9         echo &quot;error:no interface.&quot; 10         exit 1 11 fi </code></pre><h3 id="关闭虚拟机后自动将网卡从桥接设备上移除"><a href="#关闭虚拟机后自动将网卡从桥接设备上移除" class="headerlink" title="关闭虚拟机后自动将网卡从桥接设备上移除"></a>关闭虚拟机后自动将网卡从桥接设备上移除</h3><pre><code>[root@node3~]#vim /etc/qemu-ifdown  1 #!/bin/bash  2 bridge=br0  3 if [ -n &quot;$1&quot; ] ;then  4         brctl delif $bridge $1  5         ip link set $1 down  6         exit 0  7 else      8         echo &quot;error:no interface.&quot;  9         exit 1 10 fi   </code></pre><p><code>[root@node3~]#qemu-kvm -name c6 -smp 2,maxcpus=4,sockets=2,cores=2 -m 64 -drive file=/root/cirros-no_cloud-i386.img,if=virtio -vnc :8 -daemonize -net nic,model=e1000,macaddr=52:54:00:00:00:11 -net tap,script=/etc/qemu-ifup</code></p><h1 id="二、-virsh"><a href="#二、-virsh" class="headerlink" title="二、 virsh"></a>二、 virsh</h1><p>虚拟机的生成需要依赖于预定义的xml格式的配置文件，其生成工具有两种：virt-manager，virt-install</p><h2 id="1、virt-install命令"><a href="#1、virt-install命令" class="headerlink" title="1、virt-install命令"></a>1、virt-install命令</h2><p>安装新的虚拟机</p><p>语法：</p><pre><code>virt-install [OPTION]...</code></pre><h3 id="一般选项"><a href="#一般选项" class="headerlink" title="一般选项"></a>一般选项</h3><pre><code>-n NAME,--name=NAME：虚拟机名称，需全局唯一-r MEMORY：虚拟机内存大小，单位为MB--vcpus=VCPUS[,maxvcpus=MAX][,sockets=#][,cores=#][,threads=#]：vcpu个数及相关配置--cpu=CPU：cpu模式及特性</code></pre><h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><pre><code>-c CDROM,--cdrom=CDROM：光盘安装介质-l LOCATION,--location=LOCATION：安装源URL，支持FTP,HTTP及NFS等--pex：基于pxe完成安装--livedc：把光盘当做liveCD--os-type 指定操作系统类型，linux、unix、windows-boot 指定安装过程后的配置选项，</code></pre><h3 id="存储配置"><a href="#存储配置" class="headerlink" title="存储配置"></a>存储配置</h3><pre><code>--disk=DISKOPTS：指定存储设备及其属性</code></pre><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><pre><code>-w NETWORK，--network=NETWORK，opt1=val1,opt2=val2... 将虚拟机连入宿主机中    bridge=BRIDGE：连接至桥的设备    network=NAME：连接至NAME的网络中    model：网络设备型号    mac：固定的mac地址</code></pre><h3 id="图形配置"><a href="#图形配置" class="headerlink" title="图形配置"></a>图形配置</h3><pre><code>--graphics TYPE，opt1，val1... 指定图形显示相关的配置    TYPE：指定显示类型，vnc、sdl、spice、none，默认为vnc    port：监听的端口    listen：监听的地址    password：认证密码</code></pre><h3 id="设备选项"><a href="#设备选项" class="headerlink" title="设备选项"></a>设备选项</h3><pre><code>--serial=CHAROPTS：附加一个串行设备至当前虚拟机    --serial pty：创建伪终端    --serial dev,path=HOSTPATH：附加主机设备至虚拟机    --video=VIDEO：指定显卡设备类型，cirrus，vga，qxl，vmvga</code></pre><h3 id="虚拟化平台选项"><a href="#虚拟化平台选项" class="headerlink" title="虚拟化平台选项"></a>虚拟化平台选项</h3><pre><code>-v，--hvm：当物理机同时支持完全虚拟化和半虚拟化时，指定使用完全虚拟化-p，--paravirt：指定使用半虚拟化--virt-type：使用的hypervisor，如kvm、qemu等</code></pre><h2 id="virsh命令"><a href="#virsh命令" class="headerlink" title="virsh命令"></a>virsh命令</h2><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>list</td><td>查看运行的虚拟机</td></tr><tr><td>list –all</td><td>查看所有虚拟机</td></tr><tr><td>console</td><td>连接虚拟机</td></tr><tr><td>ctrl+]</td><td>退出虚拟机</td></tr><tr><td>shutdown</td><td>关闭虚拟机</td></tr><tr><td>destroy</td><td>这种方式的关闭，是一种删除方式，只是在virsh list中删除了该虚拟机</td></tr><tr><td>suspend</td><td>挂起虚拟机</td></tr><tr><td>resume</td><td>恢复被挂起的虚拟机</td></tr><tr><td>autostart</td><td>子机随宿主机启动而启动</td></tr><tr><td>undefine</td><td>删除虚拟机</td></tr><tr><td>start</td><td>启动虚拟机</td></tr><tr><td>restore</td><td>保存虚拟机的当前状态至文件中</td></tr><tr><td>attach-disk/detach-disk</td><td>磁盘设备的热插播</td></tr><tr><td>attach-interface/detach-interface</td><td>网络接口设备的热插播，无需事先创建网络接口设备</td></tr></tbody></table><p><code>[root@node3~]#virt-install --name=c6 -r 64 --vcpus=2 -f /root/cirros-0.3.0-x86_64-disk.img  --cdrom=/root/kubuntu-17.10-desktop-amd64.iso --graphics vnc,listen=0.0.0.0,port=5930 --network bridge=br0</code></p><p>安装完以后会生成xml配置文件。<code>/etc/libvirt/qemu</code>目录下存放。</p><p><code>[root@node3/etc/libvirt/qemu]#vim c5.xml</code></p><pre><code> 1 &lt;!--  2 WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE  3 OVERWRITTEN AND LOST. Changes to this xml configuration should be made using:  4   virsh edit c5  5 or other application using the libvirt API.  6 --&gt;  7   8 &lt;domain type=&#39;kvm&#39;&gt;  9   &lt;name&gt;c5&lt;/name&gt; 10   &lt;uuid&gt;e656a4fe-de06-4fb2-8592-5130ef3a2c7c&lt;/uuid&gt; 11   &lt;memory unit=&#39;KiB&#39;&gt;65536&lt;/memory&gt; 12   &lt;currentMemory unit=&#39;KiB&#39;&gt;65536&lt;/currentMemory&gt; 13   &lt;vcpu placement=&#39;static&#39;&gt;2&lt;/vcpu&gt; 14   &lt;os&gt; 15     &lt;type arch=&#39;x86_64&#39; machine=&#39;pc-i440fx-rhel7.0.0&#39;&gt;hvm&lt;/type&gt; 16     &lt;boot dev=&#39;hd&#39;/&gt; 17   &lt;/os&gt; 18   &lt;features&gt; 19     &lt;acpi/&gt; 20     &lt;apic/&gt; 21   &lt;/features&gt; 22   &lt;cpu mode=&#39;custom&#39; match=&#39;exact&#39; check=&#39;partial&#39;&gt; 23     &lt;model fallback=&#39;allow&#39;&gt;Haswell-noTSX&lt;/model&gt; 26     &lt;timer name=&#39;rtc&#39; tickpolicy=&#39;catchup&#39;/&gt; 27     &lt;timer name=&#39;pit&#39; tickpolicy=&#39;delay&#39;/&gt; 28     &lt;timer name=&#39;hpet&#39; present=&#39;no&#39;/&gt; 29   &lt;/clock&gt; 30   &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt; 31   &lt;on_reboot&gt;restart&lt;/on_reboot&gt; 32   &lt;on_crash&gt;destroy&lt;/on_crash&gt; 33   &lt;pm&gt; 34     &lt;suspend-to-mem enabled=&#39;no&#39;/&gt; 35     &lt;suspend-to-disk enabled=&#39;no&#39;/&gt; 36   &lt;/pm&gt; 37   &lt;devices&gt; 38     &lt;emulator&gt;/usr/libexec/qemu-kvm&lt;/emulator&gt; 39     &lt;disk type=&#39;file&#39; device=&#39;disk&#39;&gt; 40       &lt;driver name=&#39;qemu&#39; type=&#39;qcow2&#39;/&gt; 41       &lt;source file=&#39;/root/centos.img&#39;/&gt; 42       &lt;target dev=&#39;hda&#39; bus=&#39;ide&#39;/&gt; 43       &lt;address type=&#39;drive&#39; controller=&#39;0&#39; bus=&#39;0&#39; target=&#39;0&#39; unit=&#39;0&#39;/&gt; 44     &lt;/disk&gt; 45     &lt;disk type=&#39;file&#39; device=&#39;cdrom&#39;&gt; 46       &lt;driver name=&#39;qemu&#39; type=&#39;raw&#39;/&gt; 47       &lt;target dev=&#39;hdb&#39; bus=&#39;ide&#39;/&gt; 48       &lt;readonly/&gt; 49       &lt;address type=&#39;drive&#39; controller=&#39;0&#39; bus=&#39;0&#39; target=&#39;0&#39; unit=&#39;1&#39;/&gt; 50     &lt;/disk&gt; 51     &lt;controller type=&#39;usb&#39; index=&#39;0&#39; model=&#39;ich9-ehci1&#39;&gt; 52       &lt;address type=&#39;pci&#39; domain=&#39;0x0000&#39; bus=&#39;0x00&#39; slot=&#39;0x04&#39; function=&#39;0x7&#39;/&gt; 53     &lt;/controller&gt; 54     &lt;controller type=&#39;usb&#39; index=&#39;0&#39; model=&#39;ich9-uhci1&#39;&gt; 55       &lt;master startport=&#39;0&#39;/&gt; 57     &lt;/controller&gt; 58     &lt;controller type=&#39;usb&#39; index=&#39;0&#39; model=&#39;ich9-uhci2&#39;&gt; 59       &lt;master startport=&#39;2&#39;/&gt; 60       &lt;address type=&#39;pci&#39; domain=&#39;0x0000&#39; bus=&#39;0x00&#39; slot=&#39;0x04&#39; function=&#39;0x1&#39;/&gt; 61     &lt;/controller&gt; 62     &lt;controller type=&#39;usb&#39; index=&#39;0&#39; model=&#39;ich9-uhci3&#39;&gt; 63       &lt;master startport=&#39;4&#39;/&gt; 64       &lt;address type=&#39;pci&#39; domain=&#39;0x0000&#39; bus=&#39;0x00&#39; slot=&#39;0x04&#39; function=&#39;0x2&#39;/&gt; 65     &lt;/controller&gt; 66     &lt;controller type=&#39;pci&#39; index=&#39;0&#39; model=&#39;pci-root&#39;/&gt; 67     &lt;controller type=&#39;ide&#39; index=&#39;0&#39;&gt; 68       &lt;address type=&#39;pci&#39; domain=&#39;0x0000&#39; bus=&#39;0x00&#39; slot=&#39;0x01&#39; function=&#39;0x1&#39;/&gt; 69     &lt;/controller&gt; 70     &lt;interface type=&#39;bridge&#39;&gt; 71       &lt;mac address=&#39;52:54:00:3c:ed:ab&#39;/&gt; 72       &lt;source bridge=&#39;br0&#39;/&gt; 73       &lt;model type=&#39;rtl8139&#39;/&gt; 74       &lt;address type=&#39;pci&#39; domain=&#39;0x0000&#39; bus=&#39;0x00&#39; slot=&#39;0x03&#39; function=&#39;0x0&#39;/&gt; 75     &lt;/interface&gt; 76     &lt;serial type=&#39;pty&#39;&gt; 77       &lt;target port=&#39;0&#39;/&gt; 78     &lt;/serial&gt; 79     &lt;console type=&#39;pty&#39;&gt; 80       &lt;target type=&#39;serial&#39; port=&#39;0&#39;/&gt; 81     &lt;/console&gt; 82     &lt;input type=&#39;mouse&#39; bus=&#39;ps2&#39;/&gt; 83     &lt;input type=&#39;keyboard&#39; bus=&#39;ps2&#39;/&gt; 84     &lt;graphics type=&#39;vnc&#39; port=&#39;5920&#39; autoport=&#39;no&#39; listen=&#39;0.0.0.0&#39;&gt; 85       &lt;listen type=&#39;address&#39; address=&#39;0.0.0.0&#39;/&gt; 86     &lt;/graphics&gt; 87     &lt;video&gt; 88       &lt;model type=&#39;cirrus&#39; vram=&#39;16384&#39; heads=&#39;1&#39; primary=&#39;yes&#39;/&gt; 89       &lt;address type=&#39;pci&#39; domain=&#39;0x0000&#39; bus=&#39;0x00&#39; slot=&#39;0x02&#39; function=&#39;0x0&#39;/&gt; 90     &lt;/video&gt; 91     &lt;memballoon model=&#39;virtio&#39;&gt; 92       &lt;address type=&#39;pci&#39; domain=&#39;0x0000&#39; bus=&#39;0x00&#39; slot=&#39;0x05&#39; function=&#39;0x0&#39;/&gt; 93     &lt;/memballoon&gt; 94   &lt;/devices&gt; 95 &lt;/domain&gt;</code></pre><p>可以通过修改这个文件直接启动一个新的虚拟机。</p><p><strong>注意：修改配置文件需必须修改name、UUID、mac、port，其他的按需修改。</strong></p><p><code>[root@node3/etc/libvirt/qemu]#virsh define c7.xmk</code> #使其配置文件生效</p><p><code>[root@node3/etc/libvirt/qemu]#virsh start c7</code>  #启动虚拟机</p><p><hr></p><blockquote><p>由于在使用virsh、qemu-kvm工具创建虚拟机时，命令繁琐，操作不易，因此推荐一款WEB UI的工具。</p><h1 id="一、图形管理工具"><a href="#一、图形管理工具" class="headerlink" title="一、图形管理工具"></a>一、图形管理工具</h1></blockquote><h2 id="二、图形化工具介绍"><a href="#二、图形化工具介绍" class="headerlink" title="二、图形化工具介绍"></a>二、图形化工具介绍</h2><h3 id="1、Wok"><a href="#1、Wok" class="headerlink" title="1、Wok"></a>1、Wok</h3><p>Wok基于cherrypy的web框架，可以通过一些插件来进行扩展，例如：虚拟化管理、主机管理、系统管理。</p><h3 id="2、Kimchi"><a href="#2、Kimchi" class="headerlink" title="2、Kimchi"></a>2、Kimchi</h3><p>一个基于HTML5的KVM管理工具，是Wok的一个插件，通过Kimchi可以更方便的管理KVM。Kimchi是Wok个一个插件。</p><h2 id="三、安装并启动"><a href="#三、安装并启动" class="headerlink" title="三、安装并启动"></a>三、安装并启动</h2><p>确保已经在VMware虚拟机上开启了虚拟化</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-03_110708.jpg" alt=""></p><p><code>[root@node1~]#grep -i -E &#39;(vmx|svm|lm)&#39; /proc/cpuinfo</code></p><h3 id="1、建议依赖关系相关的包"><a href="#1、建议依赖关系相关的包" class="headerlink" title="1、建议依赖关系相关的包"></a>1、建议依赖关系相关的包</h3><pre><code>[root@node3~]#yum install gcc make autoconf automake gettext-devel git rpm-build \&gt;                     libxslt</code></pre><h3 id="2、安装运行时相关的包"><a href="#2、安装运行时相关的包" class="headerlink" title="2、安装运行时相关的包"></a>2、安装运行时相关的包</h3><pre><code>[root@node3~]#yum install libvirt-python libvirt libvirt-daemon-config-network \&gt;                     qemu-kvm python-ethtool sos python-ipaddr nfs-utils \&gt;                     iscsi-initiator-utils pyparted python-libguestfs \&gt;                     libguestfs-tools novnc spice-html5 \&gt;                     python-configobj python-magic python-paramiko \&gt;                     python-pillow</code></pre><h3 id="3、UI开发所需要的软件包"><a href="#3、UI开发所需要的软件包" class="headerlink" title="3、UI开发所需要的软件包"></a>3、UI开发所需要的软件包</h3><pre><code>[root@node3~]#yum install gcc-c++ python-devel python-pip[root@node3~]#pip install cython libsass</code></pre><p><strong>注意：上述三部也可以不直接这样安装，当安装Wok，Kimchi是自动安装依赖的包。</strong></p><h3 id="4、下载kimchi包"><a href="#4、下载kimchi包" class="headerlink" title="4、下载kimchi包"></a>4、下载kimchi包</h3><p>下载地址：<a href="https://github.com/kimchi-project/kimchi/releases/tag/2.5.0" target="_blank" rel="noopener">https://github.com/kimchi-project/kimchi/releases/tag/2.5.0</a></p><p><code>[root@node3~]#yum install -y wok-2.5.0-0.el7.centos.noarch.rpm</code></p><p><code>[root@node3~]#yum install -y kimchi-2.5.0-0.el7.centos.noarch.rpm</code></p><p><strong>注意：需先安装Wok再安装Kimchi，因为Kimchi是Wok的一个插件。</strong></p><h4 id="5、启动wok服务"><a href="#5、启动wok服务" class="headerlink" title="5、启动wok服务"></a>5、启动wok服务</h4><p><code>[root@node3/etc/wok]#systemctl daemon-reload</code><br><code>[root@node3/etc/wok]#systemctl start wokd</code><br><code>[root@node3/etc/wok]#systemctl status wokd</code></p><p>网页地址输入：<a href="https://192.168.4.63:8001/login.html" target="_blank" rel="noopener">https://192.168.4.63:8001/login.html</a></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-02_113539.jpg" alt=""></p><h5 id="在管理界面就可以直接创建，管理虚拟机了。"><a href="#在管理界面就可以直接创建，管理虚拟机了。" class="headerlink" title="在管理界面就可以直接创建，管理虚拟机了。"></a>在管理界面就可以直接创建，管理虚拟机了。</h5><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-03_111623.jpg" alt=""></p><h5 id="管理界面"><a href="#管理界面" class="headerlink" title="管理界面"></a>管理界面</h5>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LNMT、LAMT环境</title>
      <link href="/2017/11/28/LNMT%E3%80%81LAMT%E7%8E%AF%E5%A2%83/"/>
      <url>/2017/11/28/LNMT%E3%80%81LAMT%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="LNMT环境搭建"><a href="#LNMT环境搭建" class="headerlink" title="LNMT环境搭建"></a>LNMT环境搭建</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_203254.jpg" alt=""></p><blockquote><p>安装mysql数据库</p></blockquote><p>（1）安装mysql并配置环境</p><p><code>[root@mysql ~]# yum install -y mysql-server</code></p><p><code>[root@mysql ~]# service httpd start</code>   #启动服务</p><p><code>[root@mysql ~]# mysql_secure_installation</code>    #mysql安全初始化</p><p>（2）创建数据库并授权用户</p><p><code>[root@mysql ~]# mysql -uroot -p</code></p><pre><code>mysql&gt; CREATE DATABASE testprocess；mysql&gt; GRANT ALL ON testprocess.* TO &#39;joah&#39;@&#39;192.168.4.61&#39; IDENTIFIED BY &#39;123456&#39;;</code></pre><blockquote><p>tomcat</p></blockquote><p>（1）安装jdk环境</p><p><code>[root@tomcat/etc/tomcat]#yum install -y java-1.8.0-openjdk-src</code></p><p>（2）安装tomcat</p><p><code>[root@tomcat~]#yum install -y tomcat tomcat-lib tomcat-admin-webapps tomcat-docs tomcat-webapps</code></p><p>（3）启动服务测试是否成功</p><p><code>[root@tomcat~]#systemctl enable tomcat</code>    #设置为开机自动启动</p><p><code>[root@tomcat~]#systemctl start tomcat</code> #启动服务</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_172452.jpg" alt=""></p><blockquote><p>使tomcat与mysql可以连接</p></blockquote><p>MySQL Connector / J是一个本地Java驱动程序，可以将JDBC（Java Database Connectivity）调用MySQL数据库使用的网络协议。</p><p>（1）安装mysql-connector-java</p><p><code>[root@tomcat~]#yum install -y mysql-connector-java</code>    #用于使用java连接mysql数据库</p><p><code>[root@tomcat~]#cp /usr/share/java/mysql-connector-java.jar /usr/share/tomcat/lib/</code> 将此压缩包复制到此目录下，自动安装部署</p><p><code>[root@tomcat~]#systemctl restart tomcat</code>   #重启服务</p><p>（2）修改mysql中的配置文件</p><p><code>[root@mysql ~]# vim /etc/my.cnf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_192749.jpg" alt=""></p><p><code>[root@mysql ~]# service mysqld restart</code>   #重启服务</p><p>查看是否生效</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_193113.jpg" alt=""></p><p>创建数据库并授权</p><pre><code>mysql&gt; CREATE DATABASE tomcat;mysql&gt; CREATE TABLE tom(id int,name varchar(40));mysql&gt; insert into tom values(1,&#39;test&#39;);mysql&gt; GRANT ALL ON tomcat.* TO &#39;joah&#39;@&#39;192.168.4.61&#39; IDENTIFIED BY &#39;123456&#39;;</code></pre><p>测试是否成功</p><p><code>[root@tomcat~]#mysql -ujoah -p -h 192.168.4.56</code></p><p>编辑test.jsp文件</p><p><code>[root@tomcat/usr/share/tomcat/webapps/ROOT]#vim test.jsp</code></p><pre><code>  1 &lt;%@ page contentType=&quot;text/html;charset=utf-8&quot;%&gt;  2 &lt;%@ page import=&quot;java.sql.*&quot;%&gt;  3 &lt;html&gt;  4     &lt;body&gt;  5     &lt;%Class.forName(&quot;org.gjt.mm.mysql.Driver&quot;).newInstance();  6       String url =&quot;jdbc:mysql://192.168.4.56（此处需要换成mysql的地址）/tomcat?user=joah（连接数据库使用的名字）&amp;password=123456（连接数据库的密码）&amp;useUnicode=tr    ue&amp;characterEncoding=utf-8&quot;;  7       Connection conn= DriverManager.getConnection(url);  8       Statement stmt=conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_    UPDATABLE);  9       String sql=&quot;select * from tom（连接数据库中的表）&quot;; 10       ResultSet rs=stmt.executeQuery(sql); 11       while(rs.next()) {%>     12       step:<%=rs.getstring(1)%>     13       context:<%=rs.getstring(2)%><br><br><%} 14="" 15="" 16="" 17="" 18="" 19="" 20="" 21="" 22="" %&gt;="" &lt;%out.print(&quot;congratulations!!!="" jsp="" connect="" mysql="" is="" ok!!&quot;);%&gt;="" &lt;%rs.close();="" stmt.close();="" conn.close();="" &lt;="" body&gt;="" html&gt;="" <="" code=""></%}></%=rs.getstring(2)%></%=rs.getstring(1)%></code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_195820.jpg" alt=""></p><blockquote><p>修改nginx.conf配置文件</p></blockquote><p><code>[root@nginx/etc/nginx]#vim nginx.conf</code></p><pre><code> 47         location / { 48             proxy_pass http://192.168.4.61:8080; 49         } 50         location ~*\.(jsp|do)$ { 51                 proxy_pass http://test.com:8080; 52         }</code></pre><p><code>[root@nginx/etc/nginx]#nginx -t</code></p><p><code>[root@nginx/etc/nginx]#systemctl restart nginx</code> #重启服务测试</p><blockquote><p>重启服务测试</p></blockquote><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_185820.jpg" alt=""></p><p>至此我们的LNMT环境搭建成功</p><p>###7、LAMT环境搭建</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_203337.jpg" alt=""></p><p>（1）apache安装</p><p><code>[root@web~]#yum install -y httpd</code></p><p><code>[root@web~]#systemctl enable httpd</code>    #设置开机启动</p><p><code>[root@web~]#systemctl start httpd.service</code>  #启动服务</p><p>（2）修改配置文件httpd.conf</p><p><strong>基于http连接</strong></p><p>查看是否有支持http协议的代理模块</p><p><code>[root@web/etc/httpd/conf]#httpd -M |grep http</code></p><pre><code> proxy_http_module (shared)</code></pre><p>编辑配置文件</p><p><code>[root@web/etc/httpd/conf.d]#vim host.conf</code></p><pre><code>  1 &lt;VirtualHost *:80&gt;  2         ServerName www.test.com  3         ProxyRequests off   关闭正向代理  4         ProxyVia    on     是否记录代理  5         ProxyPreserveHost on    #开启保留主机名  6         &lt;Proxy *&gt;  7                 Require all granted  8         &lt;/Proxy&gt;  9         ProxyPass / http://192.168.4.61:8080/ 10         ProxyPassReverse / http://192.168.4.61:8080/ 11         &lt;Location /&gt; 12                 Require all granted 13         &lt;/Location&gt; 14 &lt;/VirtualHost&gt;</code></pre><p>重启服务测试</p><p><code>[root@web/etc/httpd/conf.d]#systemctl restart httpd.service</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_202353.jpg" alt=""></p><p><strong>基于AJP协议连接</strong></p><p>查看是否加载了支持ajp协议的反向代理模块</p><p><code>[root@web/etc/httpd/conf]#httpd -M |grep ajp</code></p><pre><code> proxy_ajp_module (shared)</code></pre><p>编辑配置文件</p><p><code>[root@web/etc/httpd/conf.d]#vim host.conf</code></p><pre><code>  1 &lt;VirtualHost *:80&gt;  2         ServerName www.test.com  3         ProxyRequests off  4         ProxyVia    on  5         ProxyPreserveHost on  6         &lt;Proxy *&gt;  7                 Require all granted  8         &lt;/Proxy&gt;  9         ProxyPass / ajp://192.168.4.61:8009/ 10         ProxyPassReverse / ajp://192.168.4.61:8009/ 11         &lt;Location /&gt; 12                 Require all granted 13         &lt;/Location&gt; 14 &lt;/VirtualHost&gt;</code></pre><p>重启服务测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_202353.jpg" alt=""></p><p>后续的安装和LNMT的安装方法一样，就不再累述。</p><h3 id="二、LNMT实现Jsprun论坛"><a href="#二、LNMT实现Jsprun论坛" class="headerlink" title="二、LNMT实现Jsprun论坛"></a>二、LNMT实现Jsprun论坛</h3><p>mariadb<br>-</p><p><code>[root@mysql~]#yum install -y mariadb-server</code> #安装mariadb服务</p><p><code>[root@mysql~]#systemctl enable mariadb.service</code>    #设置为开机启动</p><p><code>[root@mysql~]#systemctl start mariadb</code> #启动服务</p><p><code>[root@mysql~]#mysql_secure_installation</code>   #安全初始化</p><p><code>[root@mysql~]#mysql -uroot -p</code> #创建使用的数据库</p><pre><code>MariaDB [(none)]&gt; CREATE DATABASE jsprun;MariaDB [(none)]&gt; GRANT ALL ON jsprun.* TO joah@&#39;192.168.4.63&#39; IDENTIFIED By &#39;123456&#39;;</code></pre><blockquote><p>tomcat</p></blockquote><p><code>[root@tomcat~]#yum install -y java-1.8.0-openjdk</code>  #安装java运行环境</p><p><code>[root@tomcat~]#java -version</code>  #查看是否安装成功</p><p><code>[root@tomcat~]#yum install -y tomcat tomcat-admin-webapp tomcat-docs-webapp tomcat-lib tomcat-webapps</code> #安装所需要的包</p><p><code>[root@tomcat~]#unzip JspRun\!_6.0.0_Source_UTF8.zip</code>  #解压此包</p><p><code>[root@tomcat~]#cp JspRun\!_6.0.0_Source_UTF8/source/WebRoot/ /usr/share/tomcat/webapps/jsprun -a</code>  #将此目录下的文件复制到指定目录下</p><p><code>[root@tomcat/usr/share/tomcat/webapps/jsprun]#vim config.properties</code>  #修改数据库信息</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-06_200852.jpg" alt=""></p><p><code>[root@tomcat/etc/tomcat]#vim server.xml</code>  #修改server.xml文件</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-06_201437.jpg" alt=""></p><p><code>[root@tomcat/etc/tomcat]#vim tomcat-users.xml</code> #开启管理功能</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-06_201656.jpg" alt=""></p><p><code>[root@tomcat/etc/tomcat]#systemctl enable tomcat.service</code>  #设置为开机启动</p><p><code>[root@tomcat/etc/tomcat]#systemctl start tomcat.service</code>   #启动tomcat服务</p><blockquote><p>nginx</p></blockquote><p>安装并启动服务</p><p><code>[root@nginx~]#yum install -y nginx</code>    </p><p><code>[root@nginx~]#systemctl enable nginx</code></p><p><code>[root@nginx~]#systemctl start nginx</code></p><p>修改配置文件</p><p><code>[root@nginx/etc/nginx/conf.d]#vim nginx-tomcat.conf</code></p><pre><code>  1 server {  2         listen 80;  3         server_name www.test.com;  4         root /usr/share/tomcat/webapps/jsprun;  5         location / {  6                 index index.jsp;  7                 proxy_pass http://192.168.4.63:8080;  8         }  9         location ~* \.(jsp|do)$ { 10                 proxy_pass http://192.168.4.63:8080; 11         } 12 }</code></pre><p><code>[root@nginx/etc/nginx/conf.d]#nginx -t</code>    #语法检测</p><p>重启服务测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-06_203818.jpg" alt=""></p><p>点击下一步等 会出现图中红框的内容表示不可写</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-06_204116.jpg" alt=""></p><p>修改配置文件并使其文件有写权限和执行权限</p><p><code>[root@tomcat/usr/share/tomcat/webapps/jsprun]#chmod 777 config.properties templates/ attachments/ customavatars/ forumdata/ -R</code> </p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-06_204401.jpg" alt=""></p><p>图中显示数据库的内容我们已经在<code>config.properties</code>配置文件中修改了，所以这里不需要修改了，如果安装之前没有修改此内容要正确填写即可，点击下一步安装完成</p><p>我们去数据库查看生成的表</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-06_204726.jpg" alt=""></p><p><strong>如何实现动静分离呢？</strong></p><p><code>[root@nginx/etc/nginx/conf.d]#vim nginx-tomcat.conf</code>  </p><pre><code>  1 server {  2         listen 80;  3         server_name www.test.com;  4         root /usr/share/tomcat/webapps/jsprun;  5         location ~* \.(gif|png|jpeg|bmp|jpg|html|htm)$ {  6                 proxy_pass http://192.168.4.65:80;  7         }  8         location ~* \.(jsp|do)$ {  9                 proxy_pass http://192.168.4.63:8080; 10         } 11 }</code></pre><p><code>[root@nginx/etc/nginx/conf.d]#systemctl restart nginx.service</code></p><p>将jsprun中image拷贝到apache中<code>/var/www/html</code>目录下</p><p><code>[root@tomcat/usr/share/tomcat/webapps/jsprun]#scp -pr images/* 192.168.4.65:/var/www/html</code></p><p>测试  </p><p><strong>这里的动静分离其实是将图片和html等结尾的文件专门存放在apache服务器上，而不是实现真正的分离。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LAMP</title>
      <link href="/2017/11/28/LAMP/"/>
      <url>/2017/11/28/LAMP/</url>
      
        <content type="html"><![CDATA[<h2 id="一、LAMP"><a href="#一、LAMP" class="headerlink" title="一、LAMP"></a>一、LAMP</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>LAMP指的Linux（操作系统）、ApacheHTTP 服务器，MySQL（有时也指MariaDB，数据库软件） 和PHP（有时也是指Perl或Python） 的第一个字母，一般用来建立web应用平台。</p><h3 id="2、web资源的类型"><a href="#2、web资源的类型" class="headerlink" title="2、web资源的类型"></a>2、web资源的类型</h3><pre><code>静态资源：原始形式与相应内容一致。动态资源：原始形式通常为程序文件，需要在服务器端执行之后哦，将执行结果返回给客户端。</code></pre><h3 id="3、LAMP结构"><a href="#3、LAMP结构" class="headerlink" title="3、LAMP结构"></a>3、LAMP结构</h3><p><img src="http://owatlfstl.bkt.clouddn.com/LAMP_software_bundle.svg.png" alt=""></p><pre><code>CGI：Commom Gateway Interface可以让一个客户端从网页浏览器通过http服务器向执行在网络服务器上的程序传输数据；CGI描述了客户端与服务器程序之间传输的一种标准。程序=指令（代码文件）+数据（数据存储系统、文件）</code></pre><blockquote><p>请求过程：</p></blockquote><pre><code>Client--(http协议)--&gt;httpd--&gt;(CGI)--&gt;application server（program file）--&gt;（mysql）--&gt;mysql    </code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/lamp.jpg" alt="详细过程"></p><h2 id="二、PHP"><a href="#二、PHP" class="headerlink" title="二、PHP"></a>二、PHP</h2><h3 id="1、PHP简介"><a href="#1、PHP简介" class="headerlink" title="1、PHP简介"></a>1、PHP简介</h3><p>PHP（PHP: Hypertext Preprocessor）是通用服务器端脚本编程语言，主要用于web开发实现动态web页面，也是最早实现将脚本嵌入HTML源码文档中的服务器端脚本语言之一。同时，php还提供了一个命令行接口，因此，其也可以在大多数系统上作为一个独立的shell来使用</p><h3 id="2、PHP配置"><a href="#2、PHP配置" class="headerlink" title="2、PHP配置"></a>2、PHP配置</h3><p>（1）配置文件</p><pre><code>/etc/php.ini/etc/php.d/*.ini配置文件在php解释器启动时被读取。</code></pre><p>（2）配置文件格式</p><p>directive = value</p><p>注释符：</p><pre><code>#：纯粹的注释信息;：用于注释可启用的directive；较新的版本中，已经全部使用“；”进行注释。</code></pre><p>（3）php.ini配置文件设置</p><p>max_execution_time = 30 #最长执行时间30s</p><p>memory_limit 128 #内存限制，但是实际生产中不够，可调大此值</p><p>display——startup_errors off #显示启动时出错信息，建议关闭，如果不关闭，会有可能显示一些重要信息</p><p>post_max_size 8M  #最大上传数据大小，生产环境中可能临时调大</p><p>upload_max_filesize 2M #最大上传文件大小，生产环境中可能要调大。但是要比post_max_size值要小。</p><p>max_file_uploads = 20 #同时上传最多文件数</p><p>date.timezone = Aisa/shanghai #指定时区</p><p>short_open_tag = on 开启端标签，如&lt;?phpinfo()&gt;</p><p>如果想了解更多请查看<a href="http://php.net/manual/zh/ini.core.php" target="_blank" rel="noopener">http://php.net/manual/zh/ini.core.php</a></p><h3 id="（4）PHP的加速器"><a href="#（4）PHP的加速器" class="headerlink" title="（4）PHP的加速器"></a>（4）PHP的加速器</h3><p>php的加速器：基于PHP的特殊扩展机制如opcode缓存扩展也可以将opcode缓存于php的共享内存中，从而可以让同一段代码的后续重复执行时跳过编译阶段以提高性能。这些加速器并非真正提高了opcode的运行速度，而仅是通过分析opcode后并将它们重新排列以达到快速执行的目的。</p><blockquote><p>类型</p></blockquote><ul><li><p>APC (Alternative PHP Cache)遵循PHP License的开源框架，PHP opcode缓存加速器，目前的版本不适用于PHP 5.4 项目地址<a href="http://pecl.php.net/package/APC" target="_blank" rel="noopener">http://pecl.php.net/package/APC</a></p></li><li><p>eAccelerator源于Turck MMCache，早期的版本包含了一个PHP encoder和 PHP loader，目前encoder已经不在支持。项目地址 <a href="http://eaccelerator.net/" target="_blank" rel="noopener">http://eaccelerator.net/</a></p></li><li><p>XCache快速而且稳定的PHP opcode缓存，经过严格测试且被大量用于生产环境。项目地址：<a href="http://xcache.lighttpd.net/" target="_blank" rel="noopener">http://xcache.lighttpd.net/</a>,收录EPEL源</p></li><li><p>Zend Optimizer和Zend Guard Loader Zend Optimizer并非一个opcode加速器，它是由ZendTechnologies为PHP5.2及以前的版本提供的一个免费、闭源的PHP扩展，其能够运行由Zend Guard生成的加密的PHP代码或模糊代码。 而Zend Guard Loader则是专为PHP5.3提供的类似于Zend Optimizer功能的扩展。项目地址<a href="http://www.zend.com/en/products/guard/runtime-decoders" target="_blank" rel="noopener"> http://www.zend.com/en/products/guard/runtime-decoders</a></p></li><li><p>加速器，它支持装载通过NuSphere PHP Encoder编码的PHP程序文件，并能够实现对常规PHP文件的<br>执行加速。项目地址，<a href="http://www.nusphere.com/products/phpexpress.htm" target="_blank" rel="noopener">http://www.nusphere.com/products/phpexpress.htm</a></p></li></ul><h2 id="三、LAMP构建"><a href="#三、LAMP构建" class="headerlink" title="三、LAMP构建"></a>三、LAMP构建</h2><p>我们在构建LAMP服务时，需要每一个服务都要测试成功，必须在安装完此服务之后，测试服务是否工作正常；与其他服务是否能测试成功。在安装之前我们必须得知道php是依赖于mysql\mariadb和apache服务的，所有我们必须按前两个服务再安装php。如果先安装php也不是不可，慢慢的拍错，想必一定会成功的。</p><p><strong>下面的过程在CentOS 6 中进行配置。</strong></p><h3 id="1、httpd安装"><a href="#1、httpd安装" class="headerlink" title="1、httpd安装"></a>1、httpd安装</h3><h4 id="（1）使用yum源安装"><a href="#（1）使用yum源安装" class="headerlink" title="（1）使用yum源安装"></a>（1）使用yum源安装</h4><p><code>[root@localhost ~]# yum install -y httpd</code></p><h4 id="（2）配置主配置文件-etc-httpd-conf-httpd-conf"><a href="#（2）配置主配置文件-etc-httpd-conf-httpd-conf" class="headerlink" title="（2）配置主配置文件/etc/httpd/conf/httpd.conf"></a>（2）配置主配置文件/etc/httpd/conf/httpd.conf</h4><p><code>[root@localhost ~]# vim /etc/httpd/conf/httpd.conf</code></p><pre><code>ServerTokens prod   #修改响应报文显示系统信息ServerName www.example.com:79   #如果不开启这项，启动会提示如下内容：    Starting httpd: httpd: Could not reliably determine the server&#39;s fully qualified domain name, using localhost.localdomain for ServerName</code></pre><h4 id="（3）设为开机启动并启动httpd服务"><a href="#（3）设为开机启动并启动httpd服务" class="headerlink" title="（3）设为开机启动并启动httpd服务"></a>（3）设为开机启动并启动httpd服务</h4><p><code>[root@localhost ~]# chkconfig httpd on</code><br><code>[root@localhost ~]# service httpd start</code><br><code>[root@localhost ~]# ss -tnl</code>   #建议启动后查看端口是否启动</p><h4 id="（4）测试是否成功"><a href="#（4）测试是否成功" class="headerlink" title="（4）测试是否成功"></a>（4）测试是否成功</h4><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-10_201625.jpg" alt=""></p><h3 id="2、mysql安装"><a href="#2、mysql安装" class="headerlink" title="2、mysql安装"></a>2、mysql安装</h3><h4 id="（1）使用yum源安装-1"><a href="#（1）使用yum源安装-1" class="headerlink" title="（1）使用yum源安装"></a>（1）使用yum源安装</h4><p><code>[root@localhost ~]# yum install -y mysql-server</code></p><h4 id="（2）设置为开机启动并启动mysql服务"><a href="#（2）设置为开机启动并启动mysql服务" class="headerlink" title="（2）设置为开机启动并启动mysql服务"></a>（2）设置为开机启动并启动mysql服务</h4><p><code>[root@localhost ~]# chkconfig mysqld on</code><br><code>[root@localhost ~]# chkconfig --list mysqld</code></p><pre><code>mysqld             0:off    1:off    2:on    3:on    4:on    5:on    6:off</code></pre><p><code>[root@localhost ~]# service mysqld start</code></p><h4 id="（3）初始化数据库"><a href="#（3）初始化数据库" class="headerlink" title="（3）初始化数据库"></a>（3）初始化数据库</h4><p><code>[root@localhost ~]# mysql_secure_installation</code><br>详细的内容向看mysql配置<a href="http://merit.blog.51cto.com/10757694/1968557" target="_blank" rel="noopener">http://merit.blog.51cto.com/10757694/1968557</a></p><h4 id="（4）创建用户"><a href="#（4）创建用户" class="headerlink" title="（4）创建用户"></a>（4）创建用户</h4><p><code>mysql&gt; CREATE DATABASE wpdb;</code>  #创建数据路</p><p><code>mysql&gt; GRANT ALL PRIVILEGES ON wpdb.* TO joah@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</code> #授权用户对wpdb权限</p><p><code>mysql&gt; GRANT ALL PRIVILEGES ON wpdb.* TO joah@&#39;127.0.0.1&#39; IDENTIFIED BY &#39;123456&#39;;</code> #授权用户对wpdb权限</p><p><code>mysql&gt; SELECT user,host,password FROM mysql.user;</code></p><pre><code>+------+-----------+-------------------------------------------+| user | host      | password                                  |+------+-----------+-------------------------------------------+| root | localhost | *6B8CCC83799A26CD19D7AD9AEEADBCD30D8A8664 || root | 127.0.0.1 | *6B8CCC83799A26CD19D7AD9AEEADBCD30D8A8664 || joah | 127.0.0.1 | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 || joah | localhost | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |+------+-----------+-------------------------------------------+4 rows in set (0.00 sec)</code></pre><h4 id="（5）测试是否成功"><a href="#（5）测试是否成功" class="headerlink" title="（5）测试是否成功"></a>（5）测试是否成功</h4><p><code>[root@localhost ~]# mysql -ujoah -p</code><br><img src="http://owatlfstl.bkt.clouddn.com/2017-10-10_201730.jpg" alt=""></p><h3 id="3、php安装"><a href="#3、php安装" class="headerlink" title="3、php安装"></a>3、php安装</h3><h4 id="（1）使用yum源安装php"><a href="#（1）使用yum源安装php" class="headerlink" title="（1）使用yum源安装php"></a>（1）使用yum源安装php</h4><p><code>[root@localhost ~]# yum install -y php</code></p><p>php安装相当于添加了一份配置文件在<code>/etc/httpd/conf.d/</code>目录，如果要使其生效重新启动httpd服务即可。</p><h3 id="4、测试php和httpd是否配置成功"><a href="#4、测试php和httpd是否配置成功" class="headerlink" title="4、测试php和httpd是否配置成功"></a>4、测试php和httpd是否配置成功</h3><h4 id="（1）在-var-www-html目录下创建文件测试"><a href="#（1）在-var-www-html目录下创建文件测试" class="headerlink" title="（1）在/var/www/html目录下创建文件测试"></a>（1）在<code>/var/www/html</code>目录下创建文件测试</h4><p>[root@localhost html]# vim index.php</p><pre><code>&lt;?php        echo &quot;&lt;h&gt;success&lt;/h&gt;&quot;;        phpinfo();?&gt;</code></pre><p><code>[root@localhost html]# service httpd restart</code> #重启测试是否成功</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-10_202601.jpg" alt=""></p><h3 id="5、测试php是否可以和数据库连接成功"><a href="#5、测试php是否可以和数据库连接成功" class="headerlink" title="5、测试php是否可以和数据库连接成功"></a>5、测试php是否可以和数据库连接成功</h3><h4 id="（1）php-mysql安装"><a href="#（1）php-mysql安装" class="headerlink" title="（1）php-mysql安装"></a>（1）php-mysql安装</h4><p>不过在测试之前需安装一个程序包使其能相互关联作用。</p><pre><code>The php-mysql package contains a dynamic shared object that will add MySQL database support to PHP. MySQL is an object-relational database management system. PHP is an HTML-embeddable scripting language. If you need MySQL support for PHP applications, you will need to install  this package and the php package. 提供了一个动态分享库使mysql数据库支持php</code></pre><p><code>[root@localhost ~]# yum install -y  php-mysql</code></p><h4 id="（2）编辑index-php文件"><a href="#（2）编辑index-php文件" class="headerlink" title="（2）编辑index.php文件"></a>（2）编辑index.php文件</h4><p><strong>测试方法一：</strong></p><pre><code>&lt;?php        $conn = mysql_connect(&#39;localhost&#39;,&#39;joah&#39;,&#39;123456&#39;);        if($conn)            echo &quot;ok&quot;;        else            echo &quot;failure&quot;;        mysql_close();?&gt;</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-10_203951.jpg" alt=""></p><p><strong>测试方法二：</strong></p><p>编辑<code>index.php</code>文件</p><pre><code>&lt;?php        $mysqli=new mysqli(&quot;localhost&quot;,&quot;joah&quot;,&quot;123456&quot;);        if(mysqli_connect_errno()){            echo &quot;failure&quot;;            $mysqli=null;            exit;        }            echo &quot;ok&quot;;            $mysqli-&gt;close();?&gt;</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-10_205453.jpg" alt=""></p><p>此时我们就可以使用这个环境构建一些软件等；下面我们从phpMyadmin和wordpress这两个软件进行说明。</p><h3 id="安装phpMyadmin"><a href="#安装phpMyadmin" class="headerlink" title="安装phpMyadmin"></a>安装phpMyadmin</h3><h4 id="（1）上传软件包并进行编译安装"><a href="#（1）上传软件包并进行编译安装" class="headerlink" title="（1）上传软件包并进行编译安装"></a>（1）上传软件包并进行编译安装</h4><p><code>[root@localhost ~]# mv phpMyAdmin-4.3.5-all-languages.zip  /usr/local/src/</code> #将上传的软件包移到到此目录下方便管理源码编译的安装包</p><p><code>[root@localhost src]# unzip phpMyAdmin-4.3.5-all-languages.zip -d /var/www/html/</code> #将此包解压至<code>/var/www/html</code>目录下</p><h4 id="（2）配置配置文件"><a href="#（2）配置配置文件" class="headerlink" title="（2）配置配置文件"></a>（2）配置配置文件</h4><p><code>[root@localhost html]# ln -sv phpMyAdmin-4.3.5-all-languages/ pma</code> #创建软连接</p><p><code>[root@localhost pma]# cp config.sample.inc.php config.inc.php</code> #准备配置文件<br><code>[root@localhost pma]# vim config.inc.php</code> #编辑配置文件在下面行输入随机数即可<br><img src="http://owatlfstl.bkt.clouddn.com/2017-10-10_211650.jpg" alt=""></p><p>重启服务测试，测试几次也不行。通过官网上查看原来php此不支持phpMyadim这个版本。</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-10_213054.jpg" alt=""></p><p>重新下载一个较低版本安装</p><p><code>[root@localhost html]# unzip phpMyAdmin-4.0.5-all-languages.zip</code></p><p><code>[root@localhost html]# ln -sv phpMyAdmin-4.0.5-all-languages pem</code>  #创建软连接</p><p><code>[root@localhost pem]# cp config.sample.inc.php config.inc.php</code> </p><p><code>[root@localhost pem]# vim config.inc.php</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-10_211650.jpg" alt=""></p><p>重启服务测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-10_213450.jpg" alt=""></p><p>此时会出现错误提示，安装mbsting包即可</p><p><code>[[root@localhost src]# rpm -ivh php-mbstring-5.3.3-22.el6.x86_64.rpm --force</code>  #由于在CentOS6中属于epel所以需要配置epel源，但是由于本机上不了网，所以这种方式安装</p><p>重启httpd服务测试是否成功</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-11_080510.jpg" alt=""></p><p>成功，接下来就是自己配置过程了 ，此时登录的用户名和密码是数据库授权的用户和密码。</p><h3 id="wordpress安装"><a href="#wordpress安装" class="headerlink" title="wordpress安装"></a>wordpress安装</h3><p>WordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。WordPress是一款个人博客系统，并逐步演化成一款内容管理系统软件，它是使用PHP语言和MySQL数据库开发的。用户可以在支持 PHP 和 MySQL数据库的服务器上使用自己的博客。&lt;摘自：百度&gt;</p><h4 id="（1）解压缩安装"><a href="#（1）解压缩安装" class="headerlink" title="（1）解压缩安装"></a>（1）解压缩安装</h4><p><code>[root@localhost src]# tar xvf wordpress-4.8.tar.gz -C /var/www/html/</code></p><h4 id="（2）准备配置文件"><a href="#（2）准备配置文件" class="headerlink" title="（2）准备配置文件"></a>（2）准备配置文件</h4><p><strong>方式一：</strong><br><code>[root@localhost wordpress]# cp wp-config-sample.php wp-config.php</code></p><p><code>[root@localhost wordpress]# vim wp-config.php</code>    #编辑此配置文件<br><img src="http://owatlfstl.bkt.clouddn.com/2017-10-11_091044.jpg" alt=""></p><p><strong>方式二：</strong></p><p><code>[root@localhost wordpress]# setfacl -Rm u:apache:rwx wordpress</code> #由于是基于apache用户运行所有给apache用户对此文件rwx权限即可</p><h4 id="（3）测试是否成功"><a href="#（3）测试是否成功" class="headerlink" title="（3）测试是否成功"></a>（3）测试是否成功</h4><p><a href="http://192.168.4.59/wordpress/wp-admin/setup-config.php" target="_blank" rel="noopener">http://192.168.4.59/wordpress/wp-admin/setup-config.php</a></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-11_093859.jpg" alt=""></p><p>然后下面就可以搭建自己的博客啦！</p><p><strong>注意在装完数据库之后切记一定要把刚刚授权的权限删除<code>[root@localhost html]# setfacl -b blog/</code></strong></p><h2 id="二、编译安装LAMP环境"><a href="#二、编译安装LAMP环境" class="headerlink" title="二、编译安装LAMP环境"></a>二、编译安装LAMP环境</h2><p>在实际环境中我们经常根据自己所处的公司环境进行配置，适合自己公司的配置。下面我们来介绍如何进行编译安装</p><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>在CentOS7 系统:</p><pre><code>关闭iptables将selinux设置为disabledapr-1.6.2.tar.gz       httpd-2.4.27.tar.bz2                php-7.1.10.tar.xzapr-util-1.6.0.tar.gz  mariadb-10.2.8-linux-x86_64.tar.gz  wordpress-4.8.1-zh_CN.tar.gz安装工具包development tools</code></pre><p><strong>注意：这里安装需要按顺序进行的mariadb–&gt;httpd–&gt;php，mariadb和httpd安装顺序没有关系</strong></p><h3 id="源码编译httpd服务"><a href="#源码编译httpd服务" class="headerlink" title="源码编译httpd服务"></a>源码编译httpd服务</h3><p>在之前的apache博客中讲过为什么要安装apr和apr-util包，如果不懂请查看apache博客。</p><h4 id="（1）源码编译安装apr"><a href="#（1）源码编译安装apr" class="headerlink" title="（1）源码编译安装apr"></a>（1）源码编译安装apr</h4><p><code>[root@localhost/usr/local/src]#tar xvf apr-1.6.2.tar.gz</code><br><code>[root@localhost/usr/local/src/apr-1.6.2]#./configure --prefix=/app/apr</code><br><code>[root@localhost/usr/local/src/apr-1.6.2]#make &amp;&amp; make install</code>    </p><h4 id="（2）源码编译安装apr-util"><a href="#（2）源码编译安装apr-util" class="headerlink" title="（2）源码编译安装apr-util"></a>（2）源码编译安装apr-util</h4><p><code>[root@localhost/usr/local/src]#tar xf apr-util-1.6.0.tar.gz</code><br><code>[root@localhost apr-util-1.6.0]# yum install -y expat-devel</code><br><code>[root@localhost/usr/local/src/apr-util-1.6.0]#./configure --prefix=/app/apr-util --with-apr=/app/apr</code><br><code>[root@localhost/usr/local/src/apr-util-1.6.0]#make &amp;&amp; make install</code></p><h4 id="（3）源码安装httpd"><a href="#（3）源码安装httpd" class="headerlink" title="（3）源码安装httpd"></a>（3）源码安装httpd</h4><p>首先确认系统上是否有apache用户，如果没有需要创建</p><p><code>[root@localhost/usr/local/src]#useradd -r -m -d /app/website -s /sbin/nologin apache</code><br><code>[root@localhost/usr/local/src]#tar xf httpd-2.4.27.tar.bz2</code></p><p>在编译安装httpd之前需要安装几个依赖包</p><p><code>[root@localhost/usr/local/src/httpd-2.4.27]#yum install -y pcre-devel apr-devel apr-util-devel openssl-devel</code></p><p><code>[root@localhost/usr/local/src/httpd-2.4.27]#./configure --prefix=/app/httpd24 --enable-so --enable-ssl --enable-cgi --enable-rewrite --with-zlib --with-pcre --with-apr=/app/apr/ --with-apr-util=/app/apr-util/ --enable-modules=most --enable-mpms-shared=all --with-mpm=prefork</code></p><p><code>[root@localhost/usr/local/src/httpd-2.4.27]#make -j 4 &amp;&amp; make install</code></p><h4 id="（4）设置环境变量"><a href="#（4）设置环境变量" class="headerlink" title="（4）设置环境变量"></a>（4）设置环境变量</h4><p><code>[root@localhost/etc/profile.d]#vim httpd24.sh</code></p><pre><code>export PATH=/app/httpd24/bin:$PATH</code></pre><p><code>[root@localhost/etc/profile.d]#source httpd24.sh</code></p><h4 id="（5）设置man手册位置"><a href="#（5）设置man手册位置" class="headerlink" title="（5）设置man手册位置"></a>（5）设置man手册位置</h4><p><code>[root@localhost/etc]#vim /etc/man_db.conf</code></p><pre><code>23 MANDATORY_MANPATH                       /app/httpd24/man</code></pre><h4 id="（6）配置启动脚本"><a href="#（6）配置启动脚本" class="headerlink" title="（6）配置启动脚本"></a>（6）配置启动脚本</h4><p><code>[root@localhost/app/httpd24]#cp bin/apachectl /etc/init.d/httpd24</code></p><h4 id="（7）测试服务是否正常启动"><a href="#（7）测试服务是否正常启动" class="headerlink" title="（7）测试服务是否正常启动"></a>（7）测试服务是否正常启动</h4><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-11_203909.jpg" alt=""><br>已经监听80端口说明可以启动</p><p><a href="http://192.168.4.60/" target="_blank" rel="noopener">http://192.168.4.60/</a><br><img src="http://owatlfstl.bkt.clouddn.com/2017-10-11_204358.jpg" alt=""></p><p>###二进制安装mariadb<br>（1）二进制安装mariadb<br><code>[root@localhost/usr/local]#useradd -r -m -d /app/mysqldb -s /sbin/nologin mysql</code><br><code>[root@localhost/usr/local/src]#tar xf mariadb-10.2.8-linux-x86_64.tar.gz -C /usr/local/</code><br><code>[root@localhost/usr/local]#ln -sv mariadb-10.2.8-linux-x86_64/ mysql</code></p><p>（2）添加环境变量<br><code>[root@localhost/etc/profile.d]#vim mysql.sh</code><br>    PATH=/usr/local/mysql/bin:$PATH</p><p>（3）配置man手册<br><code>[root@localhost/usr/local/mysql/bin]#vim /etc/man_db.conf</code><br>    24 MANDATORY_MANPATH                       /usr/local/mysql/man</p><p>（4）创建启动脚本</p><p><code>[root@localhost/usr/local/mysql]#cp support-files/mysql.server /etc/init.d/mysqld</code><br><code>[root@localhost/usr/local/mysql]#chkconfig --add mysqld</code></p><p>（5）配置主配置文件<br><code>[root@localhost/usr/local/mysql]#mkdir /etc/mysql</code><br><code>[root@localhost/usr/local/mysql]#cp support-files/my-large.cnf /etc/mysql/my.cnf</code><br><code>[root@localhost/usr/local/mysql]#vim /etc/mysql/my.cnf</code><br>     27 [mysqld]<br>     28 datadir         = /app/mysqldb</p><p>（6）创建日志目录<br><code>[root@localhost/usr/local/mysql]#mkdir /var/log/mariadb</code><br><code>[root@localhost/usr/local/mysql]#setfacl -Rm u:mysql:rwx /var/log/mariadb/</code><br>（7）安装数据库<br><code>[root@localhost/usr/local/mysql]#scripts/mysql_install_db --user=mysql --datadir=/app/mysqldb</code></p><p>（8）初始化数据库<br><code>[root@localhost~]#mysql_secure_installation</code><br>（9）测试数据库是否安装成功</p><p><code>[root@localhost~]#mysql -u root -p</code></p><pre><code>MariaDB [(none)]&gt; CREATE DATABASE wpdb;Query OK, 1 row affected (0.00 sec)MariaDB [(none)]&gt; GRANT ALL ON wpdb.* TO &#39;joah&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; GRANT ALL ON wpdb.* TO &#39;joah&#39;@&#39;127.0.0.1&#39; IDENTIFIED BY &#39;123456&#39;;</code></pre><h3 id="源码安装php"><a href="#源码安装php" class="headerlink" title="源码安装php"></a>源码安装php</h3><p>（1）解压缩并编译安装<br><code>[root@localhost/usr/local/src/php-7.1.10]#yum install -y libxml2-devel bzip2-devel libmcrypt-devel</code><br><code>[root@localhost/usr/local/src/php-7.1.10]#./configure --prefix=/app/php --enable-mysqlnd -- with-mysqli=mysqlnd --with-openssl --with-pdo-mysql=mysqlnd --enable-mbstring --with freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml --enable-sockets -- with-apxs2=/app/httpd24/bin/apxs --with-mcrypt -- with-config-file-path=/etc --with-config-file-scan-dir=/etc/php.d --enable-maintainer-zts --disable-fileinfo</code><br><code>[root@localhost/usr/local/src/php-7.1.10]#make &amp;&amp; make install</code><br>（2）配置主配置文件<br><code>[root@localhost/usr/local/src/php-7.1.10]#cp php.ini-production /etc/php.ini</code><br>（3）修改<code>/etc/httpd/conf/httpd.conf</code></p><pre><code>259 &lt;IfModule dir_module&gt;260     DirectoryIndex index.php index.html261 &lt;/IfModule&gt;512 AddType Application/x-httpd-php .php513 AddType Application/x-httpd-php-source .phps</code></pre><p>（4）测试能否与httpd连接成功<br><code>[root@localhost/app/httpd24/htdocs]#vim index.php</code></p><pre><code>  1 &lt;?php  2         phpinfo();  3 ?&gt;</code></pre><p>（5）测试是否能否可以和mariadb连接成功<br><code>[root@localhost/app/httpd24/htdocs]#vim index.php</code></p><pre><code>&lt;?php$mysqli=new mysqli(&quot;localhost&quot;,&quot;root&quot;,&quot;centos&quot;);if(mysqli_connect_errno()){        echo &quot;连接数据库失败!&quot;;        $mysqli=null;        exit;}        echo &quot;连接数据库成功!&quot;;        $mysqli-&gt;close();        phpinfo();?&gt;</code></pre><h3 id="安装wordpress"><a href="#安装wordpress" class="headerlink" title="安装wordpress"></a>安装wordpress</h3><h4 id="（1）解压缩"><a href="#（1）解压缩" class="headerlink" title="（1）解压缩"></a>（1）解压缩</h4><p>[root@localhost/usr/local/src]#tar xf wordpress-4.8.tar.gz -C /app/httpd24/htdocs</p><h4 id="（2）配置主配置文件"><a href="#（2）配置主配置文件" class="headerlink" title="（2）配置主配置文件"></a>（2）配置主配置文件</h4><p><code>[root@localhost/app/httpd24/htdocs/wordpress]#cp wp-config-sample.php wp-config.php</code><br><code>[root@localhost/app/httpd24/htdocs/wordpress]#vim wp-config.php</code></p><pre><code> 23 define(&#39;DB_NAME&#39;, &#39;wpdb&#39;); 24  25 /** MySQL database username */ 26 define(&#39;DB_USER&#39;, &#39;joah&#39;); 27  28 /** MySQL database password */ 29 define(&#39;DB_PASSWORD&#39;, &#39;123456&#39;); 30  31 /** MySQL hostname */ 32 define(&#39;DB_HOST&#39;, &#39;localhost&#39;);</code></pre><p><a href="http://192.168.4.59/wordpress/wp-admin/setup-config.php" target="_blank" rel="noopener">http://192.168.4.59/wordpress/wp-admin/setup-config.php</a></p><p>测试其性能如何<br><code>[root@localhost/app/httpd24/htdocs/wordpress]#ab -c 10 -n 100 http://192.168.4.60/wordpress/</code></p><pre><code>HTML transferred:       5209700 bytesRequests per second:    25.25 [#/sec] (mean)    #在没有加速器性能还不错Time per request:       396.061 [ms] (mean)</code></pre><h1 id="CentOS-6-源码编译"><a href="#CentOS-6-源码编译" class="headerlink" title="CentOS 6 源码编译"></a>CentOS 6 源码编译</h1><p>安装前环境准备<br>    apr-1.6.2.tar.gz<br>    httpd-2.4.27.tar.bz2<br>    php-5.6.31.tar.xz<br>    xcache-3.2.0.tar.bz2<br>    apr-util-1.6.0.tar.gz<br>    mariadb-5.5.57-linux-x86_64.tar.gz  wordpress-4.8.1-zh_CN.tar.gz</p><h2 id="二进制安装mariadb"><a href="#二进制安装mariadb" class="headerlink" title="二进制安装mariadb"></a>二进制安装mariadb</h2><p>（1）二进制安装mariadb<br><code>[root@localhost/usr/local]#useradd -r -m -d /app/mysqldb -s /sbin/nologin mysql</code><br><code>[root@localhost/usr/local/src]#tar xf mariadb-10.2.8-linux-x86_64.tar.gz -C /usr/local/</code><br><code>[root@localhost/usr/local]#ln -sv mariadb-10.2.8-linux-x86_64/ mysql</code></p><p>（2）添加环境变量<br><code>[root@localhost/etc/profile.d]#vim mysql.sh</code><br>    PATH=/usr/local/mysql/bin:$PATH</p><p>（3）配置man手册<br><code>[root@localhost/usr/local/mysql/bin]#vim /etc/man_db.conf</code><br>    24 MANDATORY_MANPATH                       /usr/local/mysql/man</p><p>（4）创建启动脚本</p><p><code>[root@localhost/usr/local/mysql]#cp support-files/mysql.server /etc/init.d/mysqld</code><br><code>[root@localhost/usr/local/mysql]#chkconfig --add mysqld</code></p><p>（5）配置主配置文件<br><code>[root@localhost/usr/local/mysql]#mkdir /etc/mysql</code><br><code>[root@localhost/usr/local/mysql]#cp support-files/my-large.cnf /etc/mysql/my.cnf</code><br><code>[root@localhost/usr/local/mysql]#vim /etc/mysql/my.cnf</code><br>     27 [mysqld]<br>     28 datadir         = /app/mysqldb</p><p>（6）创建日志目录<br><code>[root@localhost mysql]# touch /var/log/mysqld.log</code></p><p>（7）安装数据库<br><code>[root@localhost/usr/local/mysql]#scripts/mysql_install_db --user=mysql --datadir=/app/mysqldb</code></p><p>（8）初始化数据库</p><p><code>[root@localhost~]#mysql_secure_installation</code></p><p>（9）测试数据库是否安装成功</p><p><code>[root@localhost~]#mysql -u root -p</code></p><pre><code>MariaDB [(none)]&gt; CREATE DATABASE wpdb;Query OK, 1 row affected (0.00 sec)MariaDB [(none)]&gt; GRANT ALL ON wpdb.* TO &#39;joah&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; GRANT ALL ON wpdb.* TO &#39;joah&#39;@&#39;127.0.0.1&#39; IDENTIFIED BY &#39;123456&#39;;</code></pre><h2 id="编译安装httpd服务"><a href="#编译安装httpd服务" class="headerlink" title="编译安装httpd服务"></a>编译安装httpd服务</h2><p>（1）解压缩httpd源码包<br><code>[root@localhost httpd-2.4.27]# yum install -y apr-devel apr-util-devel openssl-devel pcre-devel</code><br><code>[root@localhost httpd-2.4.27]# tar xf apr-1.6.2.tar.gz</code><br><code>[root@localhost httpd-2.4.27]# tar xf apr-util-1.6.0.tar.gz</code><br><code>[root@localhost httpd-2.4.27]# mv apr-1.6.2 httpd-2.4.27/srclib/</code><br><code>[root@localhost httpd-2.4.27]# mv apr-util-1.6.0 httpd-2.4.27/srclib/apr-util</code><br><code>[root@localhost httpd-2.4.27]# ./configure --prefix=/app/httpd24 --enable-so --enable-ssl --enable-rewrite --with-zlib --with-pcre --with-included-apr --enable-modules=most --enable-mpms-shared=all --with-mpm=prefork</code><br><code>[root@localhost httpd-2.4.27]# make &amp;&amp; make install</code></p><p>（2）配置环境变量</p><p><code>[root@localhost httpd24]# vim /etc/profile.d/httpd24.sh</code><br>    PATH=/app/httpd24/bin:$PATH<br>（3）配置启动脚本</p><p><code>[root@localhost httpd24]# cp /etc/init.d/httpd /etc/init.d/httpd24</code><br><code>[root@localhost httpd24]# vim /etc/init.d/httpd24</code></p><pre><code>apachectl=/app/httpd24/bin/apachectlhttpd=${HTTPD-/app/httpd24/bin/apachectl}prog=httpdpidfile=${PIDFILE-/app/httd24/logshttpd.pid}lockfile=${LOCKFILE-/var/lock/subsys/httpd24}RETVAL=0STOP_TIMEOUT=${STOP_TIMEOUT-10}</code></pre><p>（4）测试是否配置成功</p><p><code>[root@localhost httpd24]# service httpd24 start</code></p><h2 id="编译安装php"><a href="#编译安装php" class="headerlink" title="编译安装php"></a>编译安装php</h2><h3 id="安装方式一：基于php模块安装"><a href="#安装方式一：基于php模块安装" class="headerlink" title="安装方式一：基于php模块安装"></a>安装方式一：基于php模块安装</h3><p>（1）解压缩并编译安装<br><code>[root@localhost php-5.6.4]#yum install libxml2-devel bzip2-devel libmcrypt-devel</code><br><code>[root@localhost php-5.6.31]# ./configure --prefix=/app/php --with-mysql=/usr/local/mysql --with-openssl --with-mysqli=/usr/local/mysql/bin/mysql_config --enable-mbstring --with-png-dir --with-jpeg-dir --with-freetype-dir --with-zlib --with-libxml-dir=/usr --enable-xml --enable-sockets --with-apxs2=/app/httpd24/bin/apxs --with-mcrypt --with-config-file-path=/etc --with-config-file-scan-dir=/etc/php.d --with-bz2</code></p><p><code>[root@localhost php-5.6.4]# make &amp;&amp; make install</code></p><p>（2）配置主配置文件</p><p><code>[root@localhost php-5.6.31]# cp php.ini-production  /etc/php.ini</code></p><p>（3）在httpd.conf中配置</p><pre><code>259 &lt;IfModule dir_module&gt;260     DirectoryIndex index.php index.html261 &lt;/IfModule&gt;512 AddType Application/x-httpd-php .php513 AddType Application/x-httpd-php-source .phps</code></pre><p>接下的步骤和CentOS 7中的配置类似，请参考上述配置。</p><p>（4）配置环境变量</p><p><code>[root@localhost php]# vim /etc/profile.d/php.sh</code></p><pre><code>PATH=/app/php/bin:$PATH</code></pre><p><code>[root@localhost php]# source /etc/profile.d/php.sh</code></p><p>（5）测试是否可以与apache通信</p><p><code>[root@localhost htdocs]# vim index.php</code></p><pre><code>&lt;?php    phpinfo();</code></pre><p>?&gt;</p><p>（6）测试是否可以与mysql通信</p><pre><code>&lt;?php        $msyqli=new mysqli(&quot;192.168.4.132&quot;,&quot;root&quot;,&quot;123456&quot;);        if(mysqli_connect_errno()){                echo &quot;failure&quot;;                $mysqli=null;                exit;        }                echo &quot;ok&quot;;                $mysqli-&gt;close;                phpinfo();?&gt;</code></pre><p>（7）安装wordpress</p><p>步骤和CentOS7安装一样可以参考</p><p>（8）源码编译安装加速器</p><p><code>[root@localhost xcache-3.2.0]# phpize</code> #生成configure<br><code>[root@localhost xcache-3.2.0]# ./configure --enable-xcache --with-php-config=/app/php/bin/php-config</code><br><code>[root@localhost xcache-3.2.0]# make &amp;&amp; make install</code></p><h3 id="安装方式二：基于php-fpm模块安装"><a href="#安装方式二：基于php-fpm模块安装" class="headerlink" title="安装方式二：基于php-fpm模块安装"></a>安装方式二：基于php-fpm模块安装</h3><p><code>[root@localhost php-5.6.31]# ./configure --prefix=/app/php5 --with-mysql=/usr/local/mysql --with-openssl --with-mysqli=/usr/local/mysql/bin/mysql_config --enable-mbstring --with-freetype-dir  --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml --enable-sockets --enable-fpm --with-mcrypt --with-config-file-path=/etc/php5 --with-config-file-scan-dir=/etc/php5.d --with-bz2</code><br><code>[root@localhost php-5.6.31]# make &amp;&amp; make install</code></p><p>（2）准备启动脚本文件</p><p><code>[root@localhost php-5.6.31]# cp sapi/fpm/init.d.php-fpm.in /etc/rc.d/init.d/php-fpm</code><br><code>[root@localhost php-5.6.31]# chmod +x /etc/rc.d/init.d/php-fpm</code><br><code>[root@localhost php-5.6.31]# chkconfig --add php-fpm</code></p><p>（3）配置环境变量</p><p><code>[root@localhost php-5.6.31]# vim /etc/profile.d/php-fpm.sh</code><br><code>[root@localhost php-5.6.31]# source /etc/profile.d/php-fpm.sh</code></p><p>（4）创建主配置文件</p><p><code>[root@localhost etc]# mkdir /etc/php5</code><br><code>[root@localhost etc]# cp /usr/local/src/php-5.6.31/php.ini-production /etc/php5/php.ini</code></p><p>（5）准备服务配置文件</p><p><code>[root@localhost etc]# cp php-fpm.conf.default php-fpm.conf</code></p><p>（6）编辑<code>/app/httpd24/conf/httpd.conf</code></p><p>取消注释，启用此模块</p><pre><code>LoadModule proxy_module modules/mod_proxy.soLoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so</code></pre><p>在配置文件末尾追加如下</p><pre><code>AddType Application/x-httpd-php .phpAddType Application/x-httpd-php-source .phpsProxyRequests offProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/app/httpd24/htdocs/$1</code></pre><p>（7）启动php-fpm服务</p><p><code>[root@localhost etc]# service php-fpm start</code></p><p>（8）测试是否可以与mysql和httpd连接成功</p><p><a href="http://192.168.4.132/" target="_blank" rel="noopener">http://192.168.4.132/</a></p><p>（9）安装wordpress</p><p>安装过程和CentOS 7中安装一样，可以参考上述过程</p><p>（10）测试性能如何</p><pre><code>Requests per second:    579.84 [#/sec] (mean)Time per request:       17.246 [ms] (mean)Time per request:       1.725 [ms] (mean, across all concurrent requests)Transfer rate:          37900.46 [Kbytes/sec] received</code></pre><hr><h3 id="mysqlnd"><a href="#mysqlnd" class="headerlink" title="mysqlnd"></a>mysqlnd</h3><p>(1) 什么是mysqlnd驱动</p><pre><code>mysqlnd（mysql native driver），是由PHP源码提供的mysql驱动连接代码；目的是代替旧的libmysql驱动。传统编译安装php需添加如下选项：    --with-mysql=/usr/local/mysql    --with-pdo-mysql=/usr/local/mysql这种方式是使用的mysql官方自带的libmysql驱动，PHP5.3已经不建议使用它；建议使用mysqlnd。</code></pre><p>(2)PDO与mysqlnd，libmysql是什么关系呢？</p><pre><code>PDO （php data object）是一个应用层抽象类，底层和mysql server连接交互需要mysql驱动的支持，也就是说无论你使用什么驱动，都可以使用PDO。PDO提供PHP应用层接口，而mysqlnd libmysql则负责与mysql server进行网络协议交互。</code></pre><p>(3)mysqlnd优势</p><ul><li>libmysql驱动是由mysql AB公司编写，并按mysql license许可协议发布，mysqlnd是由php官方开发的驱动，以php license许可协议发布</li><li>mysqlnd内置php源代码，在编译安装时就不需要预先安装mysql server可以提供mysql client API（mysql_connect，pdo，mysqli）</li></ul><p>(4)使用mysqlnd，编译时，选择如下参数即可</p><pre><code>--with-mysql=mysqlnd--with-mysqli=mysqlnd--with-pdo-mysql=mysqlnd</code></pre><p>(5) 编译选项参考</p><pre><code>./configure --prefix=/usr/local/php \--with-mysql=mysqlnd \--with-mysqli=mysqlnd \--with-pdo-mysql=mysqlnd--with-iconv-dir \--with-freetype-dir \--with-jpeg-dir \--with-png-dir \--with-zlib \--with-libxml-dir \--enable-xml \--disable-rpath \--enable-bcmath \--enable-shmop \--enable-sysvsem \--enable-inline-optimization \--with-curl \--with-mcrypt \--with-curlwrappers \--enable-mbregex \--enable-fpm \--enable-mbstring \--with-gd \--enable-gd-native-ttf \--with-openssl \--with-mhash \--enable-pcntl \--enable-sockets \--with-xmlrpc \--enable-zip \--enable-soap \--without-pear</code></pre><p>(6)配置</p><blockquote><p>配置环境变量</p></blockquote><p><code>vim /etc/profile.d/php-fpm.sh</code></p><pre><code>export PATH=/usr/local/php/bin:$PATH</code></pre><blockquote><p>复制配置文件</p></blockquote><p><code>cp php.ini-development /etc/php.ini</code>  #php.ini是php运行核心配置文件</p><p><code>cd /usr/local/php/etc</code></p><p><code>cp php-fpm.conf.default php-fpm.conf</code></p><p><code>cp sapi/fpm/php-fpm.service /etc/systemd/system/</code> #复制启动文件</p><p><code>chmod +x php-fpm.service</code></p><p><em>如果出现如下内容，需修改下启动文件即可</em></p><pre><code>Mar 07 11:31:07 node2 systemd[1]: [/usr/lib/systemd/system/php-fpm.service:7] Not an absolute path, ignoring: ${prefix}/var/run/php-fpm.pidMar 07 11:31:07 node2 systemd[1]: [/usr/lib/systemd/system/php-fpm.service:8] Executable path is not absolute, ignoring: ${exec_prefix}/sbin/php-fpm --nodaemonize --fpm-config ${prefix}/etc/php-fpm.confMar 07 11:31:07 node2 systemd[1]: php-fpm.service lacks both ExecStart= and ExecStop= setting. Refusing.Mar 07 11:31:15 node2 systemd[1]: [/usr/lib/systemd/system/php-fpm.service:7] Not an absolute path, ignoring: ${prefix}/var/run/php-fpm.pidMar 07 11:31:15 node2 systemd[1]: [/usr/lib/systemd/system/php-fpm.service:8] Executable path is not absolute, ignoring: ${exec_prefix}/sbin/php-fpm --nodaemonize --fpm-config ${prefix}/etc/php-fpm.confMar 07 11:31:15 node2 systemd[1]: php-fpm.service lacks both ExecStart= and ExecStop= setting. Refusing.Mar 07 11:31:35 node2 systemd[1]: [/usr/lib/systemd/system/php-fpm.service:7] Not an absolute path, ignoring: ${prefix}/var/run/php-fpm.pidMar 07 11:31:35 node2 systemd[1]: [/usr/lib/systemd/system/php-fpm.service:8] Executable path is not absolute, ignoring: ${exec_prefix}/sbin/php-fpm --nodaemonize --fpm-config ${prefix}/etc/php-fpm.confMar 07 11:31:35 node2 systemd[1]: php-fpm.service lacks both ExecStart= and ExecStop= setting. Refusing.Mar 07 11:31:42 node2 systemd[1]: [/usr/lib/systemd/system/php-fpm.service:7] Not an absolute path, ignoring: ${prefix}/var/run/php-fpm.pid</code></pre>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LAMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVS</title>
      <link href="/2017/11/28/LVS%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/11/28/LVS%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="一、LVS"><a href="#一、LVS" class="headerlink" title="一、LVS"></a>一、LVS</h1><h2 id="1、lvs（Linux-Virtual-Server）概念"><a href="#1、lvs（Linux-Virtual-Server）概念" class="headerlink" title="1、lvs（Linux Virtual Server）概念"></a>1、lvs（Linux Virtual Server）概念</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-22_104933.jpg" alt=""></p><p>将一组服务器通过高速的局域网地理分布的广域网相互连接，在他们前段有一个负载调度器（Load Balancer），将网络请求调度到真实的服务器上，客户访问集群系统提供的网络服务就像一台高性能、高可用的服务器一样。</p><p><strong>工作原理</strong></p><p>VS根据请求报文的目标IP、目标协议和端口将其调度转发至某RS，根据调度算法来挑选RS。</p><h2 id="2、lvs集群的特点"><a href="#2、lvs集群的特点" class="headerlink" title="2、lvs集群的特点"></a>2、lvs集群的特点</h2><ul><li><p>适用性，后端服务器可运行任何支持TCP/IP的操作系统</p></li><li><p>具有良好的伸缩性</p></li><li><p>可靠性</p></li></ul><h2 id="3、lvs集群类型"><a href="#3、lvs集群类型" class="headerlink" title="3、lvs集群类型"></a>3、lvs集群类型</h2><ul><li>LVS/NAT</li></ul><p>通过网络地址转换，调度器重写请求报文的目标地址，根据预设的调度算法，将请求分派给后端的真实服务器；真实服务器的响应报文通过调度器时，报文的源地址呗重写再返回给客户，完成整个负载调度过程。</p><ul><li>LVS/DR</li></ul><p>通过改写请求报文的MAC地址，将请求发送到真是服务器，而真实服务器将响应直接返回给客户；可极大地提高集群系统的伸缩性。不过LVS/DR模型要求调度器和诊室服务器都有一块网卡连在同一个物理网段上。</p><ul><li>LVS/TUN</li></ul><p>由于LVS/NAT请求和响应报文都必须经过调度器地址重写，当客户端越来越多时，调度器的处理能力将成为瓶颈。为了解决这个问题，调度器把请求报文通过IP隧道转发至真实服务器，而真实服务器将响应直接返回给客户，所以调度器至处理请求报文。</p><h2 id="4、负载调度算法"><a href="#4、负载调度算法" class="headerlink" title="4、负载调度算法"></a>4、负载调度算法</h2><p>###静态调度算法：根据其调度时是否考虑个RS 当前的负载状态</p><ul><li>RR（Round Robin）轮叫</li></ul><p>调度器通过“轮叫”调度算法将外部请求按顺序轮流分配到集群中的真实服务器上，它均等地对待每一台服务器，而不管服务器上的实际连接数和系统负载。</p><ul><li>WRR（Weighted Round Robin）加权轮叫</li></ul><p>调度器通过“加权轮叫”调度算法根据真实服务器的不同处理能力来调度访问请求。可以保证处理能力较强的服务器处理更多的访问流量。调度器可以自动问询真实服务器的负载情况，并动态的调整其权值。</p><ul><li>DH（Destination Hashing）目标地址散列</li></ul><p>根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到服务器，否则返回空。将发往同一个目标地址的请求始终转发至第一次挑中的RS，典型使用场景是正向代理缓存场景中的负载均衡，如：宽带运营商。</p><ul><li>SH（Source Hashing）源地址散列</li></ul><p>根据请求的源IP地址，作为散列键（Hask Key）从静态分配的散列表找出对应的服务器，若服务器时可用且未超载，将请求发送到服务器，否则返回空。也可以这样理解，实现session sticky，源IP地址Hash将来自于同一个IP地址的请求始终发往第一次挑中的RS，从而实现会话绑定。</p><h3 id="动态调度算法；根据每RS当前的负载及调度算法进行调度"><a href="#动态调度算法；根据每RS当前的负载及调度算法进行调度" class="headerlink" title="动态调度算法；根据每RS当前的负载及调度算法进行调度"></a>动态调度算法；根据每RS当前的负载及调度算法进行调度</h3><ul><li>LC（Lesat Connextions）最小连接</li></ul><p>将网络请求调度到已经建立的链接数最少的服务器上。如果集群系统的真实服务器具有相近的系统性能，采用LC可以较好地均衡负载</p><pre><code>overhead=activeconns*256+inactiveconns</code></pre><ul><li>WLC（Weighted Least Connections）加权最小连接</li></ul><p>在集群系统中的服务器性能差异较大的情况下，调度器采用WLC优化均衡性能，具有在较高权值的服务器将承受较大比例的活动连接负载。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。</p><pre><code>overhead=（activeconns*256+inactiveconns）/weight 如果第一次调度采用随机调度</code></pre><ul><li>LBLC（Locality-Based Least Connections）基于局部性的最少连接</li></ul><p>LBLC针对目标IP地址的负载均衡。根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器时可用的且没有超载，将请求发送到服务器；若服务器不存在，或该服务器超载且有服务器处于一半的工作负载，则用LBLC选择出一个可用的服务器，将请求发送到该服务器。</p><ul><li>LBLCR（Locality-Based Least Connections with Replication）带复制的基于局部性最少连接</li></ul><p>LBLCR要维护从一个目标IP 到一组服务器的映射；根据请求的目标IP地址找出该目标IP地址对应的服务器组。按“最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按最小连接原则从这个集群中选出一台服务器，将该服务器假如到服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</p><p>-SED（Shortest Expection Delay）初始化连接高权重优先</p><pre><code>overhead=(activeconns+1)256/weight</code></pre><ul><li>NQ（Never Queue）</li></ul><p>第一轮均匀分配，后续SED算法计算调度</p><h2 id="5、LVS集群通用结构体系"><a href="#5、LVS集群通用结构体系" class="headerlink" title="5、LVS集群通用结构体系"></a>5、LVS集群通用结构体系</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-22_114857.jpg" alt=""></p><p>如图所示LVS采用三层结构</p><p><strong>负载调度器</strong>：它是整个集群对外面的前段机，负责将客户的请求发送到一组服务器上执行，而客户认为服务时来自一个IP地址上的。</p><p><strong>服务器池</strong>：一组真正执行客户请求的服务器，执行的服务如http ftp等</p><p><strong>共享存储</strong>：为服务器池提供一个共享的存储区，使得服务器池拥有相同的内容，提供向同的服务。通常是数据库、网络文件系统或者分布式文件系统</p><p>##6、IPVS（IP Virtual Server）<br>是运行在LVS下的提供负载均衡功能的一种技术。IPVS软件实现了IP负载均衡技术：LVS/NAT 、LVS/TUN 、LVS/DR。</p><p>###工作机理<br>在基于IP负载调度技术中心，当一个TCP连接的初始SYN报文到达时，调度器就选择一台服务器，将报文转发给它。伺候通过查发报文的IP和TCP报文头地址，保证此连接的后继报文被转发到该服务器。这样，IPVS无法检查到请求的内容再选择服务器，这就要求后端的服务器组是提供相同的服务器，不管请求被发送到哪一台服务器，返回结果都应该是一样。 </p><p>PS：LVS分成了两个部分，一部分工作在内核空间的一个IPVS模块（工作在Netfilter框架的input链上），另一部分工作在用户空间的一个用来定义集群服务的一个工具ipvsadm，主要定义集群服务传送给工作在内核的IPVS模块。</p><h3 id="ipvsadm包构成"><a href="#ipvsadm包构成" class="headerlink" title="ipvsadm包构成"></a>ipvsadm包构成</h3><p>配置文件</p><pre><code>/etc/sysconfig/ipvsadm-config</code></pre><p>服务名称</p><pre><code>/usr/lib/systemd/system/ipvsadm.service</code></pre><p>管理工具</p><pre><code>/usr/sbin/ipvsadm/usr/sbin/ipvsadm-restore/usr/sbin/ipvsadm-save</code></pre><p><strong>ipvsadm命令</strong></p><p>管理集群服务</p><pre><code>ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]]</code></pre><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-A，–add-service</td><td>添加VS（Virtual Server）</td></tr><tr><td>-E,–edit-service</td><td>更改VS</td></tr><tr><td>-D，–delete-service</td><td>删除VS</td></tr><tr><td>-C,–clear</td><td>清空定义的所有内容</td></tr><tr><td>-R，–restore</td><td>重载VS表</td></tr><tr><td>-S,–save</td><td>保存VS规则</td></tr><tr><td>-t,–tcp-service</td><td>TCP协议的端口，VIP:TCP_PORT</td></tr><tr><td>-u, –udp-service</td><td>UDP协议的端口</td></tr><tr><td>-f, –fwmark-service</td><td>firemall mark标记，</td></tr><tr><td>-p, –persistent</td><td>持久连接，指定timeout，默认为360秒</td></tr><tr><td>-s, –scheduler scheduling-method</td><td>指定调度算法 </td></tr><tr><td>-Z,–zero</td><td>清空计数器</td></tr></tbody></table><p>管理集群上的RS</p><pre><code>ipvsadm -a|e -t|u|f service-address -r server-address [-g|i|m] [-w weight]</code></pre><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a, –add-server</td><td>将RS添加到VS</td></tr><tr><td>-e, –edit-server</td><td>编辑RS</td></tr><tr><td>-d, –delete-server</td><td>移除RS从VS</td></tr><tr><td>-r, –real-server server-address</td><td>指定RS服务器IP</td></tr><tr><td>-g, –gatewaying</td><td>使用网关（direct routing）</td></tr><tr><td>-i, –ipip</td><td>使用ipip封装（tunneling）</td></tr><tr><td>-m, –masquerading</td><td>使用伪装（NAT）</td></tr><tr><td>-w, –weight weight</td><td>指定权重</td></tr></tbody></table><p>查看</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-L，-l，–list</td><td>列出定义规则</td></tr><tr><td>–numeric，-n</td><td>以数字形式输出地址和端口号</td></tr><tr><td>–exact</td><td>扩展信息，精确值</td></tr><tr><td>–connection，-c</td><td>当前IPVS连接输出</td></tr><tr><td>–stats</td><td>统计信息</td></tr><tr><td>–rate</td><td>输出速率信息</td></tr></tbody></table><p>保存及重载规则</p><p><em>保存</em><br><strong>建议保存至/etc/sysconfig/ipvsadm</strong></p><p>ipvsadm-save &gt;/PATH/TO/IPVSADM_FILE</p><p>ipvsadm -S &gt; /PATH/TO/IPVSADM_FILE</p><p>systemctl stop ipvsadm.service</p><p><em>重载</em></p><p>ipvsadm-restore &lt; /PATH/FROM/IPVSADM_FILE</p><p>ipvsadm -R &lt; /PATH/FROM/IPVSADM_FILE</p><p>systemctl restart ipvsadm.service</p><h1 id="二、LVS集群类型"><a href="#二、LVS集群类型" class="headerlink" title="二、LVS集群类型"></a>二、LVS集群类型</h1><h2 id="1、lvs-nat模式"><a href="#1、lvs-nat模式" class="headerlink" title="1、lvs-nat模式"></a>1、lvs-nat模式</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-22_172746.jpg" alt=""></p><p>本质是多目标IP 的DNAT，通过将请求报文中的目标地址和目标端口修改为某跳出的RS的RIP和PORT实现转发。</p><p><img src="http://owatlfstl.bkt.clouddn.com/lvs-nat1.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/lvs-nat2.jpg" alt=""><br><strong>小结</strong></p><p>（1）RIP和DIP不一定在同一个IP网络,如果VS和RS中间是相连的路由器，RS的网关需指向路由器的网关；如果VS和RS中间是相连的是交换机，RS的网关要指向DIP。应该使用私网IP（也可以使用公网IP）</p><p>（2）请求报文和响应报文都必须经由Director 转发，Director容易成为系统瓶颈。</p><p>（3）支持端口映射，可以修改请求报文的目标端口</p><p>（4）VS必须是Linux系统，RS可以是任意OS系统</p><h2 id="2、lvs-dr模式"><a href="#2、lvs-dr模式" class="headerlink" title="2、lvs-dr模式"></a>2、lvs-dr模式</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-22_174525.jpg" alt=""></p><p>lvs-dr：Director Routing，直接路由，LVS默认模式应用最广泛，通过为请求报文重新封装一个MAC首部进行转发，源MAC是DIP所在的接口MAC，目标MAC是某挑选出的RS的RIP所在接口的MAC地址；源IP/PORT，以及目标IP/PORT均保持不变。</p><p><img src="http://owatlfstl.bkt.clouddn.com/lvs-dr1.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/lvs-dr2.jpg" alt=""></p><h3 id="lvs-dr模式，各主机上均需要配置VIP，解决地址冲突的方式有三种："><a href="#lvs-dr模式，各主机上均需要配置VIP，解决地址冲突的方式有三种：" class="headerlink" title="lvs-dr模式，各主机上均需要配置VIP，解决地址冲突的方式有三种："></a>lvs-dr模式，各主机上均需要配置VIP，解决地址冲突的方式有三种：</h3><ul><li>在前段网关做静态绑定，这种方法的弊端是如果后端OS坏掉，重新静态绑定</li><li><p>在各RS使用arptables</p><p>  arptables -A IN -d $VIP -j DROP</p><p>  arptables -A OUT -s $VIP -j mangle –mangle-ip-s $RIP</p></li><li><p>在各RS修改内核参数，来限制arp响应和通告的级别</p></li></ul><blockquote><p>限制响应级别：arp_ignore</p></blockquote><pre><code>0：默认值，表示可使用本地任意接口上配置的任意地址进行响应1：仅在请求的目标IP配置在本地主机的接收到请求报文的接口上时，才给予响应</code></pre><blockquote><p>限制通告级别：arp_announce</p></blockquote><pre><code>0：默认值，把本机所有接口的所有信息向每个接口的网络进行通告1：尽量避免将接口信息向非直接连接网络进行通告2：必须避免将接口信息向非本网络进行通告</code></pre><p><strong>小结</strong></p><p>（1）确保前段路由器将目标IP为VIP的请求报文发往Director。在前段网关做静态绑定VIP和DIrector的MAC地址</p><p>（2）RS的RIP可以使用私网地址，也可以使用公网地址；RIP的网关不能指向DIP，以确保响应报文不会经由Director。RIP与DIP可以不再同一个IP网络</p><p>（3）RS和Director如果中间是路由相连，要在同一个物理网络，逻辑上可以不再一个网段。路由器可以转发。</p><p>（4）请求报文要经由Director，但响应报文不经由Director，而由RS直接发往Client</p><p>（5）不支持端口映射</p><p>（6）RS可以使用大多数OS系统</p><p><strong>注意：RS必须配置VIP地址，如果不配置CIP接收到的响应报文不是自己目标的响应报文，拒收。</strong></p><h2 id="3、lvs-tun模式"><a href="#3、lvs-tun模式" class="headerlink" title="3、lvs-tun模式"></a>3、lvs-tun模式</h2><p>不修改请求报文的IP首部（源IP为CIP，目标IP为VIP），而在源IP报文之外再封装一个IP首部（源IP是DIP，目标IP是RIP），将报文发往挑选出的目标RS；RS直接响应给客户端（源IP是VIP，目标IP是CIP）。支持源距离通信。</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-22_174456.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/lvs-tun.jpg" alt=""></p><p><strong>小结</strong></p><p>（1）DIP、VIP、RIP都应该是公网地址，也可以是私网地址（如果拉的是专线）</p><p>（2）RS的网关不能指向DIP</p><p>（3）请求报文要经由DIrector，但响应报文不能经由Director</p><p>（4）不支持端口映射</p><p>（5）RS的OS 系统必须支持隧道功能</p><h1 id="三、Firewall-Mark"><a href="#三、Firewall-Mark" class="headerlink" title="三、Firewall Mark"></a>三、Firewall Mark</h1><p>借助于防火墙类分类报文，而后基于标记定义集群服务；可将多个不同应用使用同一个集群服务进行调度</p><p>步骤：</p><p>（1）在Director主机打标记：</p><pre><code>iptables -t mangle -A PREROUTING -d $vip -p $proto –m multiport --dports $port1,$port2,… -j MARK --set-mark NUMBER</code></pre><p>（2）在Director主机基于标记定义集群服务</p><pre><code>ipvsadm -A -f NUMBER [options]ipvsadm -a -f NUMBER -r RIP -m</code></pre><h1 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h1><p>session绑定：对共享同一组RS的多个集群服务，需要统一进行绑定，lvs中sh算法无法实现。</p><p>持久连接：实现无论使用任何调度算法，在一段时间内（默认360s），能够实现将来自同一个地址的请求始终发往同一个RS。</p><pre><code>ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]]</code></pre><p><strong>持久连接实现方式</strong></p><ul><li>每端口持久（PPC ）：每个端口对应定义为一个集群服务，每集群服务单独调度</li><li>每防火墙标记持久（PFWMC）:基于防火墙标记定义集群服务；可实现将多个端口上的应用同一调度，即所谓port affinity</li><li>每客户端持久（PCC）：基于0端口（表示所有服务）定义集群服务，即将客户端对所有应用的请求都调度至后端主机，必须定义为持久模式</li></ul><h1 id="LVS高可用性"><a href="#LVS高可用性" class="headerlink" title="LVS高可用性"></a>LVS高可用性</h1><p>如果Director不可用，整个系统将不可用，SPOF（单点故障）；如果RS不可用时，Director依然会调度请求到RS上。</p><p>解决方案：由Director对个RS健康状态进行检查，失败时禁用，成功时启用。</p><p>检查方式：</p><p>（1）网络层检测，icmp</p><p>（2）传输层检查：端口探测</p><p>（3）应用层检测：请求某关键资源</p><p>如果RS全不能使用时，back server，sorry server</p><h2 id="ldirector：监控远程服务和控制LVS"><a href="#ldirector：监控远程服务和控制LVS" class="headerlink" title="ldirector：监控远程服务和控制LVS"></a>ldirector：监控远程服务和控制LVS</h2><p>主配置文件</p><pre><code>/etc/ha.d/ldirectord.cf </code></pre><p>配置模版</p><pre><code> /usr/share/doc/ldirectord-3.9.6/ldirectord.cf </code></pre><p> 服务</p><pre><code> /usr/lib/systemd/system/ldirectord.service</code></pre><p> 主程序</p><pre><code>/usr/sbin/ldirectord  </code></pre><p>日志</p><pre><code>/var/log/ldirectord.log </code></pre><p>pid文件</p><pre><code>/var/run/ldirectord.ldirectord.pid </code></pre><p><strong>ldirectord配置文件</strong></p><p><code>[root@localhost~]#cp /usr/share/doc/ldirectord-3.9.5/ldirectord.cf /etc/ha.d/</code></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>checktimeout</td><td>判断RS出错的时间间隔</td></tr><tr><td>checkinterval</td><td>指定ldirectord在每次检查之间的间隔时间</td></tr><tr><td>fallback</td><td>当所有的RS不能工作时，web服务重定向的地址</td></tr><tr><td>autoreload</td><td>是否自动重载配置文件</td></tr><tr><td>logfile</td><td>指定ldirectord日志文件路径</td></tr><tr><td>quiescent（静态）</td><td>当选择no时，如果一个节点在checktimeout设置的时间周期内没有响应，ldirectord将会从LVS的路由表中移除RS，将终端现有的客户端连接，并是LVS丢掉所有的链接跟中记录和持续连接模板；如果选择yes，当某个RS失效时，ldirectord将失效节点的权值设置为0，新的链接不能到达，但是并不从LVS路由表清除此节点，同时连接跟踪记录和持久连接模板仍然保留在Director上。</td></tr><tr><td>virtual</td><td>指定虚拟的IP和端口号必须在行后面指定RS和端口号同时设置LVS工作模式</td></tr><tr><td>real</td><td>指定RS</td></tr><tr><td>service</td><td>指定服务的类型</td></tr><tr><td>request</td><td>ldirectord将根据指定的RS结合该选项给出的请求路径，发送访问请求，检查RS上的服务是否正常运行；确保这里给出的页面地址是可访问的，不然ldirectord会误从此节点已经失效，发生错误监控现象</td></tr><tr><td>receive</td><td>指定请求和应答字串</td></tr><tr><td>scheduler</td><td>指定调度算法</td></tr><tr><td>protocol</td><td>指定协议类型</td></tr><tr><td>checktype</td><td>指定ldirectord的检测类型，默认为negotiate</td></tr><tr><td>checkport</td><td>指定监控的端口号</td></tr><tr><td>virtualhost</td><td>虚拟服务器的名称</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lvs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVS实战</title>
      <link href="/2017/11/28/LVS%E5%AE%9E%E6%88%98/"/>
      <url>/2017/11/28/LVS%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>lvs-nat模型实现http负载集群（VS和RS之间直连）<br>-</p><p>（1）构建网络拓扑</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-22_194908.jpg" alt=""></p><p>（2）搭建网络环境</p><ul><li>配置路由器</li></ul><p><code>[root@VS~]#vim /etc/sysctl.conf</code> #开启路由转发功能</p><pre><code> 11 net.ipv4.ip_forward=1</code></pre><ul><li>RS1主机上添加路由规则</li></ul><p><code>[root@RS1~]#route add default gw 192.168.4.63</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-23_092728.jpg" alt=""></p><p>RS2主机上也是如上添加规则即可</p><ul><li>配置客户端</li></ul><p><code>[root@RS1~]#route add default gw 172.18.4.63</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-23_093225.jpg" alt=""></p><p><strong>切记：配置完以后一定要检测网络是否可以相互ping 通。</strong></p><p>（3）添加规则</p><p><code>[root@VS~]#ipvsadm -A -t 172.18.4.63:80 -s rr</code></p><p><code>[root@VS~]#ipvsadm -a -t 172.18.4.63:80 -r 192.168.4.64 -m</code></p><p><code>[root@VS~]#ipvsadm -a -t 172.18.4.63:80 -r 192.168.4.65 -m</code></p><p>（4）测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-23_094403.jpg" alt=""></p><p>lvs-nat模型实现http负载集群（VS和RS之间使用路由相连）<br>-</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-22_195357.jpg" alt=""></p><p>（1）搭建网络环境</p><ul><li>配置VS</li></ul><p><code>[root@VS~]#vim /etc/sysconfig/network-scripts/ifcfg-eth0</code></p><pre><code>  1 DEVICE=eth0  2 BOOTPROTO=none  3 ONBOOT=yes  4 IPADDR=172.18.4.63  5 PREFIX=16</code></pre><p><code>[root@VS~]#vim /etc/sysconfig/network-scripts/ifcfg-eth1</code></p><pre><code>  1 DEVICE=eth1  2 BOOTPROTO=none  3 ONBOOT=yes  4 IPADDR=192.168.4.63  5 PREFIX=24  6 GATEWAY=192.168.4.64</code></pre><ul><li>配置router2</li></ul><p><code>[root@route2~]#vim /etc/sysconfig/network-scripts/ifcfg-eth0</code></p><pre><code>  1 DEVICE=eth0  2 BOOTPROTO=static  3 ONBOOT=yes  4 IPADDR=192.168.4.64  5 PREFIX=24  6 GATEWAY=192.168.4.63</code></pre><p><code>[root@route2~]#vim /etc/sysconfig/network-scripts/ifcfg-eth1</code></p><pre><code>  1 DEVICE=eth1  2 BOOTPROTO=none  3 ONBOOT=yes  4 IPADDR=192.168.100.63  5 PREFIX=24</code></pre><ul><li>配置RS1和RS2</li></ul><p><code>[root@RS1~]#vim /etc/sysconfig/network-scripts/ifcfg-eth1</code></p><p>  1 DEVICE=eth1<br>  2 BOOTPROTO=none<br>  3 IPADDR=192.168.100.64<br>  4 PREFIX=24<br>  5 GATEWAY=192.168.100.63</p><p><code>[root@RS2~]#vim /etc/sysconfig/network-scripts/ifcfg-eth1</code></p><p>  1 DEVICE=eth1<br>  2 BOOTPROTO=none<br>  3 IPADDR=192.168.100.65<br>  4 PREFIX=24<br>  5 GATEWAY=192.168.100.63</p><p><strong>务必测试环境是否ping通。</strong></p><p>（2）添加规则</p><p><code>[root@VS~]#ipvsadm -A -t 172.18.4.63:80 -s rr</code><br><code>[root@VS~]#ipvsadm -a -t 172.18.4.63:80 -r 192.168.100.64 -m</code><br><code>[root@VS~]#ipvsadm -a -t 172.18.4.63:80 -r 192.168.100.65 -m</code></p><p><code>[root@VS~]#ipvsadm -ln</code>    #查看添加的规则</p><pre><code>IP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConnTCP  172.18.4.63:80 rr -&gt; 192.168.100.64:80            Masq    1      0          0          -&gt; 192.168.100.65:80            Masq    1      0          0     </code></pre><p>（3）测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-23_094403.jpg" alt=""></p><h2 id="lvs-nat模型实现https和http负载集群"><a href="#lvs-nat模型实现https和http负载集群" class="headerlink" title="lvs-nat模型实现https和http负载集群"></a>lvs-nat模型实现https和http负载集群</h2><p>以第二个环境为基础进行</p><p>（1）每天RS1上增加证书</p><p><code>[root@RS1~]#cd /etc/pki/tls/certs/</code></p><p><code>[root@RS1/etc/pki/tls/certs]#make httpd.crt</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-23_110305.jpg" alt=""></p><p><code>[root@RS1/etc/pki/tls/certs]#mv httpd.* /etc/httpd/conf.d/</code>    #将证书存放在此目录下</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-23_110639.jpg" alt=""></p><p>由于证书key是加密存在的，每次都要输入密码，为了方便对key文件解密</p><p><code>root@RS1/etc/httpd/conf.d]#openssl rsa -in httpd.key -out httpd.key</code></p><p><code>[root@RS1/etc/httpd/conf.d]#yum install -y mod_ssl</code>    #安装模块使其支持加密</p><blockquote><p>修改ssl.conf配置文件</p></blockquote><p><code>[root@RS1/etc/httpd/conf.d]#vim ssl.conf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-23_111056.jpg" alt=""></p><p>（2）测试本机是否可以正常访问</p><p><code>[root@RS1/etc/httpd/conf.d]#curl -k https://192.168.100.64</code></p><pre><code>RS1</code></pre><p>（3）在VS上添加规则</p><p><code>[root@VS~]#iptables -t mangle -A PREROUTING -d 172.18.4.63 -p tcp -m multiport --dports 80,443 -j MARK --set-mark 10</code></p><p><code>[root@VS~]#ipvsadm -A -f 10 -s rr</code></p><p><code>[root@VS~]#ipvsadm -a -f 10 -r 192.168.100.64 -m</code></p><p><code>[root@VS~]#ipvsadm -a -f 10 -r 192.168.100.65 -m</code></p><p><code>[root@VS~]#ipvsadm -ln</code></p><pre><code>IP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConnFWM  10 rr  -&gt; 192.168.100.64:0             Masq    1      0          0           -&gt; 192.168.100.65:0             Masq    1      0          0   </code></pre><p>（4）测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-23_114300.jpg" alt=""></p><h2 id="lvs-nat模型实现https负载集群"><a href="#lvs-nat模型实现https负载集群" class="headerlink" title="lvs-nat模型实现https负载集群"></a>lvs-nat模型实现https负载集群</h2><p>以第二个环境为基础进行</p><p>（1）在RS1和RS2上添加证书</p><p><code>[root@RS1~]#cd /etc/pki/tls/certs/</code></p><p><code>[root@RS1/etc/pki/tls/certs]#make httpd.crt</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-23_110305.jpg" alt=""></p><p><code>[root@RS1/etc/pki/tls/certs]#mv httpd.* /etc/httpd/conf.d/</code>    #将证书存放在此目录下</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-23_110639.jpg" alt=""></p><p>由于证书key是加密存在的，每次都要输入密码，为了方便对key文件解密</p><p><code>root@RS1/etc/httpd/conf.d]#openssl rsa -in httpd.key -out httpd.key</code></p><p><code>[root@RS1/etc/httpd/conf.d]#yum install -y mod_ssl</code>    #安装模块使其支持加密</p><blockquote><p>修改ssl.conf配置文件</p></blockquote><p><code>[root@RS1/etc/httpd/conf.d]#vim ssl.conf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-23_111056.jpg" alt=""></p><p>（2）测试本机是否可以正常访问</p><p><code>[root@RS1/etc/httpd/conf.d]#curl -k https://192.168.100.64</code></p><pre><code>RS1</code></pre><p>（3）VS添加规则</p><p><code>[root@VS~]#ipvsadm -A -t 172.18.4.63:443 -s rr</code><br><code>[root@VS~]#ipvsadm -a -t 172.18.4.63:443 -r 192.168.100.64:443 -m</code><br><code>[root@VS~]#ipvsadm -a -t 172.18.4.63:443 -r 192.168.100.65:443 -m</code><br><code>[root@VS~]#ipvsadm -ln</code></p><pre><code>IP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConnTCP  172.18.4.63:443 rr  -&gt; 192.168.100.64:443           Masq    1      0          0           -&gt; 192.168.100.65:443           Masq    1      0          0   </code></pre><p>（4）测试是否成功</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-23_111634.jpg" alt=""></p><p>lvs-dr模型实现http负载集群<br>-</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-23_162625.jpg" alt=""></p><p>（1）搭建网络环境</p><ul><li>路由器：</li></ul><p><code>[root@router/etc/sysconfig/network-scripts]#vim ifcfg-eth0</code></p><pre><code>  1 DEVICE=eth0  2 BOOTPROTO=none  3 ONBOOT=yes  4 IPADDR=172.18.4.61  5 PREFIX=24</code></pre><p><code>[root@router/etc/sysconfig/network-scripts]#vim ifcfg-eth1</code></p><pre><code>  1 DEVICE=eth1  2 BOOTPROTO=none  3 ONBOOT=yes  4 IPADDR=192.168.4.61  5 PREFIX=24</code></pre><ul><li>客户端</li></ul><p><code>[root@client/etc/sysconfig/network-scripts]#vim ifcfg-eth0</code></p><pre><code>  1 DEVICE=eth0  2 BOOTPROTO=none  3 ONBOOT=yes  4 IPADDR=172.18.4.55  5 PREFIX=24</code></pre><p><code>[root@client ~]#route add default gw 172.18.4.61</code></p><ul><li>VS</li></ul><p><code>[root@VS/etc/sysconfig/network-scripts]#vim ifcfg-eth0</code></p><pre><code>  1 DEVICE=eth0  2 BOOTPROTO=static  3 ONBOOT=yes  4 IPADDR=192.168.4.62  5 PREFIX=24  6 GATEWAY=192.168.4.61</code></pre><p><code>[root@VS/etc/sysconfig/network-scripts]#vim ifcfg-eth0:0</code></p><pre><code>  1 DEVICE=eth0:0  2 BOOTPROTO=none  3 ONBOOT=yes  4 IPADDR=192.168.4.63  5 PREFIX=24</code></pre><p>-RS1和RS2</p><p><code>[root@RS1/etc/sysconfig/network-scripts]#vim ifcfg-eth0</code></p><pre><code>  1 DEVICE=eth0  2 BOOTPROTO=none  3 ONBOOT=yes  4 IPADDR=192.168.4.64  5 PREFIX=24  6 GATEWAY=192.168.4.61</code></pre><p><code>[root@RS1/etc/sysconfig/network-scripts]#vim ifcfg-eth1</code></p><pre><code>  1 DEVICE=eth1  2 BOOTPROTO=none  3 ONBOOT=yes  4 IPADDR=192.168.4.63  5 PREFIX=32</code></pre><p>关闭arp广播</p><p><code>[root@RS1~]#echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore</code></p><p><code>[root@RS1~]#echo 1 &gt; /proc/sys/net/ipv4/conf/eth1/arp_ignore</code></p><p><code>[root@RS1~]#echo 1 &gt; /proc/sys/net/ipv4/conf/eth1/arp_announce</code></p><p><code>[root@RS1~]#echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_announce</code></p><p>RS2和RS1配置类似就不陈述</p><p><strong>注意：如果配置VIP地址在lo网卡上需要关闭如下选项</strong></p><pre><code>net.ipv4.conf.lo.arp_ignore = 1net.ipv4.conf.lo.arp_announce = 2net.ipv4.conf.all.arp_ignore = 1net.ipv4.conf.all.arp_announce = 2 </code></pre><p><strong>如果配置VIP地址在真实网卡需要关闭如下</strong></p><pre><code>net.ipv4.conf.ethN.arp_ignore = 1 net.ipv4.conf.ethN.arp_announce = 2 （N 为网卡接口）net.ipv4.conf.all.arp_ignore = 1 net.ipv4.conf.all.arp_announce = 2 </code></pre><p>（2）VS添加规则</p><p><code>[root@VS~]#ipvsadm -A -t 192.168.4.63:80 -s rr</code></p><p><code>[root@VS~]#ipvsadm -a -t 192.168.4.63:80 -r 192.168.4.64:80 -g</code></p><p><code>[root@VS~]#ipvsadm -a -t 192.168.4.63:80 -r 192.168.4.65:80 -g</code></p><p><code>[root@VS~]#ipvsadm -ln</code></p><pre><code>IP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConnTCP  192.168.4.63:80 rr  -&gt; 192.168.4.64:80              Route   1      0          0           -&gt; 192.168.4.65:80              Route   1      0          0  </code></pre><p>（3）在客户端测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-23_164638.jpg" alt=""></p><p>问题1：如果RS中VIP的子网掩码不是32结果怎么样呢？</p><blockquote><p>修改RS1和RS2VIP</p></blockquote><p><code>[root@RS1/etc/sysconfig/network-scripts]#vim ifcfg-eth1</code></p><pre><code>  1 DEVICE=eth1  2 BOOTPROTO=none  3 ONBOOT=yes  4 IPADDR=192.168.4.63  5 PREFIX=24</code></pre><blockquote><p>重启网络服务测试</p></blockquote><p><code>[root@RS1/etc/sysconfig/network-scripts]#systemctl restart network</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-23_164638.jpg" alt=""></p><p>小结<br>-</p><p>1、当客户端发起访问VIP 对应的域名的请求时，根据网络通信原理会产生ARP 广播，因为负载均衡器和真实的服务器在同一网络并且VIP设置在集群中的每个节点上，此时集群内的真实服务器会尝试回答来自客户端计算机的查找VIP的ARP广播，这就会产生问题，大家都说我是”VIP”。 为了达到负载均衡的目的，必须想法办让真实服务器忽略来自客户端计算机的ARP广播请求。所以要修改arp_igonre和arp_announce这两个内核参数</p><p>2、RS中VIP的子网掩码不一定要为255.255.255.255。但是通过查询资料可知，因为若干机器要使用同一个IP地址，用本身做广播地址和把子网掩码设置为255.255.255.255就不会造成IP地址冲突。</p><p>3、如果是这种框架：RShe Director必须在同一个物理网段中。</p><p>lvs-dr集群web服务<br>-</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-23_172008.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MHA+Keepalived+MySQL主从</title>
      <link href="/2017/11/28/MHA+Keepalived+MySQL%E4%B8%BB%E4%BB%8E/"/>
      <url>/2017/11/28/MHA+Keepalived+MySQL%E4%B8%BB%E4%BB%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="MHA-Keepalived-mysql主从"><a href="#MHA-Keepalived-mysql主从" class="headerlink" title="MHA+Keepalived+mysql主从"></a>MHA+Keepalived+mysql主从</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_213608.jpg" alt=""></p><table><thead><tr><th>主机名</th><th>mysql</th><th>keepalived</th><th>MHA</th><th>IP</th></tr></thead><tbody><tr><td>manager</td><td>—</td><td>—</td><td>master-0.56</td><td>192.168.4.64</td></tr><tr><td>master</td><td>mariadb-5.5.56</td><td>√</td><td>node-0.56</td><td>192.168.4.61</td></tr><tr><td>slave1</td><td>mariadb-5.5.56</td><td>√</td><td>node-0.56</td><td>192.168.4.62</td></tr><tr><td>slave2</td><td>mariadb-5.5.56</td><td>—</td><td>node-0.56</td><td>192.168.4.63</td></tr></tbody></table><h3 id="各节点时间同步"><a href="#各节点时间同步" class="headerlink" title="各节点时间同步"></a>各节点时间同步</h3><p><code>[root@manager~]#ntpdate 172.18.0.1</code></p><p><code>[root@manager~]#vim /etc/chrony.conf</code></p><pre><code>  server 172.18.0.1 iburst</code></pre><p><code>[root@manager~]#systemctl start chronyd.service</code></p><h3 id="各节点可通过主机名互相访问"><a href="#各节点可通过主机名互相访问" class="headerlink" title="各节点可通过主机名互相访问"></a>各节点可通过主机名互相访问</h3><p><code>[root@manager~]#vim /etc/hosts</code></p><pre><code>  192.168.4.64 manager  192.168.4.61 master  192.168.4.62 slave1  192.168.4.63 slave2</code></pre><h3 id="各节点基于无密钥交叉通信（基于同一密钥认证）"><a href="#各节点基于无密钥交叉通信（基于同一密钥认证）" class="headerlink" title="各节点基于无密钥交叉通信（基于同一密钥认证）"></a>各节点基于无密钥交叉通信（基于同一密钥认证）</h3><p><code>[root@manager~]#ssh-keygen -t rsa -P &#39;&#39;</code></p><p><code>[root@manager~]#ssh-copy-id -i /root/.ssh/id_rsa.pub manager</code></p><p><code>[root@manager~/.ssh]#scp authorized_keys id_rsa{,.pub} master:/root/.ssh</code></p><p><code>[root@manager~/.ssh]#scp authorized_keys id_rsa{,.pub} slave1:/root/.ssh</code></p><p><code>[root@manager~/.ssh]#scp authorized_keys id_rsa{,.pub} slave2:/root/.ssh</code></p><h3 id="确保每个节点iptables和seline关闭"><a href="#确保每个节点iptables和seline关闭" class="headerlink" title="确保每个节点iptables和seline关闭"></a>确保每个节点iptables和seline关闭</h3><h2 id="配置主从复制"><a href="#配置主从复制" class="headerlink" title="配置主从复制"></a>配置主从复制</h2><h3 id="master节点"><a href="#master节点" class="headerlink" title="master节点"></a>master节点</h3><p><code>[root@master~]#vim /etc/my.cnf.d/server.cnf</code></p><pre><code> [server] innodb_file_per_table = ON skip_name_resolve = ON max_connections = 2000 server_id = 1 relay_log = relay-log log_bin = master-log</code></pre><p><code>[root@master~]#systemctl start mariadb</code></p><h4 id="授权用户"><a href="#授权用户" class="headerlink" title="授权用户"></a>授权用户</h4><p><code>MariaDB [(none)]&gt; GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO joah@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39;;</code></p><p><code>MariaDB [(none)]&gt; FLUSH PRIVILEGES;</code></p><h4 id="查看二进制日志"><a href="#查看二进制日志" class="headerlink" title="查看二进制日志"></a>查看二进制日志</h4><pre><code>MariaDB [(none)]&gt; SHOW MASTER STATUS;+-------------------+----------+--------------+------------------+| File              | Position | Binlog_Do_DB | Binlog_Ignore_DB |+-------------------+----------+--------------+------------------+| master-log.000003 |      414 |              |                  |+-------------------+----------+--------------+------------------+1 row in set (0.00 sec)MariaDB [(none)]&gt; SHOW BINLOG EVENTS IN &#39;master-log.000003&#39;;+-------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------------------------------------+| Log_name          | Pos | Event_type  | Server_id | End_log_pos | Info                                                                                           |+-------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------------------------------------+| master-log.000003 |   4 | Format_desc |         1 |         245 | Server ver: 5.5.56-MariaDB, Binlog ver: 4                                                      || master-log.000003 | 245 | Query       |         1 |         414 | GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO joah@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39; |+-------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------------------------------------+</code></pre><h3 id="slave节点"><a href="#slave节点" class="headerlink" title="slave节点"></a>slave节点</h3><p><code>[root@slave1~]#vim /etc/my.cnf.d/server.cnf</code></p><pre><code> [server] innodb_file_per_table = ON  skip_name_resolve = ON  max_connections = 2000  server_id = 2 relay_log = relay-log log_bin = master-log relay_log_purge = 0 read_only = ON</code></pre><p><code>[root@slave2~]#vim /etc/my.cnf.d/server.cnf</code></p><pre><code> [server] innodb_file_per_table = ON  skip_name_resolve = ON  max_connections = 2000  server_id = 3  #此处注意一定不能相同 relay_log = relay-log log_bin = master-log relay_log_purge = 0 read_only = ON</code></pre><h4 id="修改master为自己的主"><a href="#修改master为自己的主" class="headerlink" title="修改master为自己的主"></a>修改master为自己的主</h4><p>为了以后从升为主节点以后有授权，因此从二进制日志245开始</p><p><code>MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_USER=&#39;joah&#39;,MASTER_HOST=&#39;192.168.4.61&#39;,MASTER_PASSWORD=&#39;centos&#39;,MASTER_LOG_FILE=&#39;master-log.000003&#39;,MASTER_LOG_POS=245;</code></p><p><code>MariaDB [(none)]&gt; SELECT User FROM mysql.user;</code></p><h5 id="查看是否已经同步成功"><a href="#查看是否已经同步成功" class="headerlink" title="查看是否已经同步成功"></a>查看是否已经同步成功</h5><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_192100.jpg" alt=""></p><p><code>MariaDB [(none)]&gt; FLUSH PRIVILEGES;</code></p><h4 id="在mariadb所有节点授权用户"><a href="#在mariadb所有节点授权用户" class="headerlink" title="在mariadb所有节点授权用户"></a>在mariadb所有节点授权用户</h4><p>此用户可在本地网络中又其他节点上远程访问。</p><p><code>MariaDB [(none)]&gt; GRANT ALL ON *.* TO mhaadmin@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39;;</code></p><h2 id="keepalived安装"><a href="#keepalived安装" class="headerlink" title="keepalived安装"></a>keepalived安装</h2><h3 id="master上安装keepalived"><a href="#master上安装keepalived" class="headerlink" title="master上安装keepalived"></a>master上安装keepalived</h3><p><code>[root@master~]#yum install -y keepalived</code></p><h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><p><code>[root@master/etc/keepalived]#cp keepalived.conf{,.bak}</code></p><p><code>[root@master/etc/keepalived]#vim keepalived.conf</code></p><pre><code>global_defs {  4    notification_email {  5      root@localhost  6    }  7    notification_email_from keepalived@localhost  8    smtp_server 127.0.0.1  9    smtp_connect_timeout 30 10    router_id master 11    vrrp_mcast_group4 224.0.100.100 12 } 13  14 vrrp_script chk_mysql { 15   script &quot;killall -0 mysqld &amp;&amp; exit 0 ||exit 1&quot; 16   interval 1 17   weight -30 18   fall 2 19   rise 1 20 } 21 vrrp_instance VI_1 { 22     state MASTER 23     interface eth0 24     virtual_router_id 4 25     priority 100 26     advert_int 1 27     authentication { 28         auth_type PASS 29         auth_pass 152369 30     } 31     virtual_ipaddress { 32         192.168.4.55 33     } 34     track_script { 35         chk_mysql 36     } 37 }</code></pre><h4 id="添加IP地址"><a href="#添加IP地址" class="headerlink" title="添加IP地址"></a>添加IP地址</h4><p><code>[root@master/etc/keepalived]#ip addr add 192.168.4.55/24 dev eth0</code></p><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><p><code>[root@master/etc/keepalived]#systemctl start keepalived</code></p><h3 id="slave1上安装keepalived"><a href="#slave1上安装keepalived" class="headerlink" title="slave1上安装keepalived"></a>slave1上安装keepalived</h3><p><code>[root@slave1~]#yum install -y keepalived</code></p><pre><code>  3 global_defs {  4    notification_email {  5      root@localhost  6    }  7    notification_email_from keepalived@localhost  8    smtp_server 127.0.0.1  9    smtp_connect_timeout 30 10    router_id slave1 11    vrrp_mcast_group4 224.0.100.100 12 } 13  14 vrrp_script chk_mysql { 15   script &quot;killall -0 mysqld &amp;&amp; exit 0 ||exit 1&quot; 16   interval 1 17   weight -30 18   fall 2 19   rise 1 20 } 21 vrrp_instance VI_1 { 22     state SLAVE 23     interface eth0 24     virtual_router_id 4 25     priority 80 26     advert_int 1 27     authentication { 28         auth_type PASS 29         auth_pass 152369 30     } 31     virtual_ipaddress { 32         chk_mysql33       }34  }</code></pre><h4 id="添加IP地址-1"><a href="#添加IP地址-1" class="headerlink" title="添加IP地址"></a>添加IP地址</h4><p><code>[root@slave1/etc/keepalived]#ip addr add 192.168.4.55/24 dev eth0</code></p><h4 id="启动服务-1"><a href="#启动服务-1" class="headerlink" title="启动服务"></a>启动服务</h4><h2 id="MHA搭建"><a href="#MHA搭建" class="headerlink" title="MHA搭建"></a>MHA搭建</h2><h3 id="Manager主机上安装"><a href="#Manager主机上安装" class="headerlink" title="Manager主机上安装"></a>Manager主机上安装</h3><p><code>[root@manager~]#yum install mha4mysql-manager-0.55-0.el6.noarch.rpm mha4mysql-node-0.56-0.el6.noarch.rpm</code></p><h3 id="mysql各节点上都安装"><a href="#mysql各节点上都安装" class="headerlink" title="mysql各节点上都安装"></a>mysql各节点上都安装</h3><p><code>[root@master~]#yum install mha4mysql-node-0.56-0.el6.noarch.rpm</code></p><p><strong>注意：CentOS7可以直接使用适用于el6的程序包；MHA manger和MHA node程序包的版本不强制要求一样。</strong></p><h3 id="初始化MHA"><a href="#初始化MHA" class="headerlink" title="初始化MHA"></a>初始化MHA</h3><p>manager节点需要为每个监控的master/slave集群提供一个专用的配置文件，并可以共享全局配置<code>/etc/masterha_default.cnf</code>。如果仅监控一个application，也可以直接通过application的配置来提供个服务器的默认配置信息。每个application的配置文件路径为自定义。</p><p><code>[root@manager~]#mkdir /etc/masterha/</code></p><p><code>[root@manager/etc/masterha]#vim app1.cnf</code></p><pre><code>[server default]    #全局配置user=mhaadminpassword=centosmanager_workdir=/data/masterha/app1 #这些目录会自动创建manager_log=/data/masterha/app1/manager.logremote_workdir=/data/masterha/app1ssh_user=root   #基于密钥的用户repl_user=joah  #授权主从复制用户repl_password=centosping_interval=1 #间隔时长[server1]hostname=192.168.4.61ssh_port=22candidate_master=1[server2]hostname=192.168.4.62ssh_port=22candidate_master=1[server3]hostname=192.168.4.63ssh_port=22no_master=1</code></pre><h4 id="检测各节点ssh互相配置是否成功"><a href="#检测各节点ssh互相配置是否成功" class="headerlink" title="检测各节点ssh互相配置是否成功"></a>检测各节点ssh互相配置是否成功</h4><p><code>[root@manager/etc/masterha]#masterha_check_ssh app1.cnf --conf=app1.cnf</code></p><h4 id="检查管理的mysql复制集群的连接配置参数是否成功"><a href="#检查管理的mysql复制集群的连接配置参数是否成功" class="headerlink" title="检查管理的mysql复制集群的连接配置参数是否成功"></a>检查管理的mysql复制集群的连接配置参数是否成功</h4><p><code>[root@manager/etc/masterha]#masterha_check_repl --conf=app1.conf</code></p><h4 id="启动MHA"><a href="#启动MHA" class="headerlink" title="启动MHA"></a>启动MHA</h4><p><code>[root@manager/etc/masterha]#masterha_manager --conf=app1.cnf</code></p><h4 id="启动成功后，查看master状态"><a href="#启动成功后，查看master状态" class="headerlink" title="启动成功后，查看master状态"></a>启动成功后，查看master状态</h4><p><code>[root@manager~]#masterha_check_status --conf=/etc/masterha/app1.cnf</code></p><pre><code>app1 (pid:38704) is running(0:PING_OK), master:192.168.4.61</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> keepalived，mha，mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MHA</title>
      <link href="/2017/11/28/MHA/"/>
      <url>/2017/11/28/MHA/</url>
      
        <content type="html"><![CDATA[<p>MHA<br>-<br>MHA（Master HA）是一款开源的mysql的高可用程序，为mysql主从复制架构提供了automating master failover功能。MHA在监控到master节点故障时，会提升其中拥有最新数据的slave节点成为新的master节点，在此期间，MHA会通过与其他从节点获取额外信息来避免一致性方面的问题。MHA还提供了master节点在线切换功能。</p><h3 id="MHA服务角色："><a href="#MHA服务角色：" class="headerlink" title="MHA服务角色："></a>MHA服务角色：</h3><ul><li>MHA manager：通常单独部署在一台独立机器上管理多个master/slave集群，每个master/slave称为一个application</li><li>MHA node：运行在每台mysql服务器，通过监控具备解析和清理logs功能的脚本来加快故障转移。</li></ul><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_181005.jpg" alt=""></p><h5 id="mysql复制集群中的master故障时，MHA转移"><a href="#mysql复制集群中的master故障时，MHA转移" class="headerlink" title="mysql复制集群中的master故障时，MHA转移"></a>mysql复制集群中的master故障时，MHA转移</h5><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_181018.jpg" alt=""></p><h3 id="MHA组件"><a href="#MHA组件" class="headerlink" title="MHA组件"></a>MHA组件</h3><ul><li><p>Manager节点</p><ul><li>masterha_check_ssh：MHA依赖的SSH环境监测工具</li><li>masterha_check_repl：mysql复制环境监测工具</li><li>masterha_manager：MHA服务主程序</li><li>masterha_check_status：MHA运行状态探测工具</li><li>masterha_master_monitor：mysql master节点可用性探测工具</li><li>masterha_master_switch：master节点切换工具</li><li>masterha_conf_host：添加或删除配置的节点</li><li>masterha_stop：关闭MHA服务的工具</li></ul></li><li><p>Node节点</p><ul><li>save_binary_logs：保存和复制master的二进制日志</li><li>apply_diff_relay_logs：识别差异的中继日志并应用于其他slave</li><li>purge——relay_logs：清除中继日志（不会阻塞SQL线程）</li></ul></li><li><p>自定义扩展</p><ul><li>secondary_check_script：通过多条网络路由检测master的可用性</li><li>master_ip_failover_script：更新application使用的masterip</li><li>shutdown_script：强制关闭master节点</li><li>report_script：发送报告</li><li>init_conf_load_script：加载初始配置参数</li><li>master_ip_online_change_script：更新master节点ip地址</li></ul></li></ul><p><strong>注意：MHA对mysql复制环境有特殊要求，各节点都要开启二进制日志及中继日志；各从节点必须显示启用其read-only属性；关闭relay_log_purege功能。</strong></p><p>MHA实现<br>-</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_183546.jpg" alt=""></p><h3 id="各节点时间同步"><a href="#各节点时间同步" class="headerlink" title="各节点时间同步"></a>各节点时间同步</h3><p><code>[root@manager~]#ntpdate 172.18.0.1</code></p><p><code>[root@manager~]#vim /etc/chrony.conf</code></p><pre><code>  server 172.18.0.1 iburst</code></pre><p><code>[root@manager~]#systemctl start chronyd.service</code></p><h3 id="各节点可通过主机名互相访问"><a href="#各节点可通过主机名互相访问" class="headerlink" title="各节点可通过主机名互相访问"></a>各节点可通过主机名互相访问</h3><p><code>[root@manager~]#vim /etc/hosts</code></p><pre><code>  192.168.4.64 manager  192.168.4.61 master  192.168.4.62 slave1  192.168.4.63 slave2</code></pre><h3 id="各节点基于无密钥交叉通信（基于同一密钥认证）"><a href="#各节点基于无密钥交叉通信（基于同一密钥认证）" class="headerlink" title="各节点基于无密钥交叉通信（基于同一密钥认证）"></a>各节点基于无密钥交叉通信（基于同一密钥认证）</h3><p><code>[root@manager~]#ssh-keygen -t rsa -P &#39;&#39;</code></p><p><code>[root@manager~]#ssh-copy-id -i /root/.ssh/id_rsa.pub manager</code></p><p><code>[root@manager~/.ssh]#scp authorized_keys id_rsa{,.pub} master:/root/.ssh</code></p><p><code>[root@manager~/.ssh]#scp authorized_keys id_rsa{,.pub} slave1:/root/.ssh</code></p><p><code>[root@manager~/.ssh]#scp authorized_keys id_rsa{,.pub} slave2:/root/.ssh</code></p><h3 id="确保每个节点iptables和seline关闭"><a href="#确保每个节点iptables和seline关闭" class="headerlink" title="确保每个节点iptables和seline关闭"></a>确保每个节点iptables和seline关闭</h3><h2 id="配置主从复制"><a href="#配置主从复制" class="headerlink" title="配置主从复制"></a>配置主从复制</h2><h3 id="master节点"><a href="#master节点" class="headerlink" title="master节点"></a>master节点</h3><p><code>[root@master~]#vim /etc/my.cnf.d/server.cnf</code></p><pre><code> [server] innodb_file_per_table = ON skip_name_resolve = ON max_connections = 2000 server_id = 1 relay_log = relay-log log_bin = master-log</code></pre><p><code>[root@master~]#systemctl start mariadb</code></p><h4 id="授权用户"><a href="#授权用户" class="headerlink" title="授权用户"></a>授权用户</h4><p><code>MariaDB [(none)]&gt; GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO joah@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39;;</code></p><p><code>MariaDB [(none)]&gt; FLUSH PRIVILEGES;</code></p><h4 id="查看二进制日志"><a href="#查看二进制日志" class="headerlink" title="查看二进制日志"></a>查看二进制日志</h4><pre><code>MariaDB [(none)]&gt; SHOW MASTER STATUS;+-------------------+----------+--------------+------------------+| File              | Position | Binlog_Do_DB | Binlog_Ignore_DB |+-------------------+----------+--------------+------------------+| master-log.000003 |      414 |              |                  |+-------------------+----------+--------------+------------------+1 row in set (0.00 sec)MariaDB [(none)]&gt; SHOW BINLOG EVENTS IN &#39;master-log.000003&#39;;+-------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------------------------------------+| Log_name          | Pos | Event_type  | Server_id | End_log_pos | Info                                                                                           |+-------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------------------------------------+| master-log.000003 |   4 | Format_desc |         1 |         245 | Server ver: 5.5.56-MariaDB, Binlog ver: 4                                                      || master-log.000003 | 245 | Query       |         1 |         414 | GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO joah@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39; |+-------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------------------------------------+</code></pre><h3 id="slave节点"><a href="#slave节点" class="headerlink" title="slave节点"></a>slave节点</h3><p><code>[root@slave1~]#vim /etc/my.cnf.d/server.cnf</code></p><pre><code> [server] innodb_file_per_table = ON  skip_name_resolve = ON  max_connections = 2000  server_id = 2 relay_log = relay-log log_bin = master-log relay_log_purge = 0 read_only = ON</code></pre><p><code>[root@slave2~]#vim /etc/my.cnf.d/server.cnf</code></p><pre><code> [server] innodb_file_per_table = ON  skip_name_resolve = ON  max_connections = 2000  server_id = 3  #此处注意一定不能相同 relay_log = relay-log log_bin = master-log relay_log_purge = 0 read_only = ON</code></pre><h4 id="修改master为自己的主"><a href="#修改master为自己的主" class="headerlink" title="修改master为自己的主"></a>修改master为自己的主</h4><p>为了以后从升为主节点以后有授权，因此从二进制日志245开始</p><p><code>MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_USER=&#39;joah&#39;,MASTER_HOST=&#39;192.168.4.61&#39;,MASTER_PASSWORD=&#39;centos&#39;,MASTER_LOG_FILE=&#39;master-log.000003&#39;,MASTER_LOG_POS=245;</code></p><p><code>MariaDB [(none)]&gt; SELECT User FROM mysql.user;</code></p><h5 id="查看是否已经同步成功"><a href="#查看是否已经同步成功" class="headerlink" title="查看是否已经同步成功"></a>查看是否已经同步成功</h5><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_192100.jpg" alt=""></p><p><code>MariaDB [(none)]&gt; FLUSH PRIVILEGES;</code></p><h4 id="在mariadb所有节点授权用户"><a href="#在mariadb所有节点授权用户" class="headerlink" title="在mariadb所有节点授权用户"></a>在mariadb所有节点授权用户</h4><p>此用户可在本地网络中又其他节点上远程访问。</p><p><code>MariaDB [(none)]&gt; GRANT ALL ON *.* TO mhaadmin@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39;;</code></p><h2 id="MHA搭建"><a href="#MHA搭建" class="headerlink" title="MHA搭建"></a>MHA搭建</h2><h3 id="Manager主机上安装"><a href="#Manager主机上安装" class="headerlink" title="Manager主机上安装"></a>Manager主机上安装</h3><p><code>[root@manager~]#yum install mha4mysql-manager-0.55-0.el6.noarch.rpm mha4mysql-node-0.56-0.el6.noarch.rpm</code></p><h3 id="mysql各节点上都安装"><a href="#mysql各节点上都安装" class="headerlink" title="mysql各节点上都安装"></a>mysql各节点上都安装</h3><p><code>[root@master~]#yum install mha4mysql-node-0.56-0.el6.noarch.rpm</code></p><p><strong>注意：CentOS7可以直接使用适用于el6的程序包；MHA manger和MHA node程序包的版本不强制要求一样。</strong></p><h3 id="初始化MHA"><a href="#初始化MHA" class="headerlink" title="初始化MHA"></a>初始化MHA</h3><p>manager节点需要为每个监控的master/slave集群提供一个专用的配置文件，并可以共享全局配置<code>/etc/masterha_default.cnf</code>。如果仅监控一个application，也可以直接通过application的配置来提供个服务器的默认配置信息。每个application的配置文件路径为自定义。</p><p><code>[root@manager~]#mkdir /etc/masterha/</code></p><p><code>[root@manager/etc/masterha]#vim app1.cnf</code></p><pre><code>[server default]    #全局配置user=mhaadminpassword=centosmanager_workdir=/data/masterha/app1 #这些目录会自动创建manager_log=/data/masterha/app1/manager.logremote_workdir=/data/masterha/app1ssh_user=root   #基于密钥的用户repl_user=joah  #授权主从复制用户repl_password=centosping_interval=1 #间隔时长[server1]hostname=192.168.4.61ssh_port=22candidate_master=1[server2]hostname=192.168.4.62ssh_port=22candidate_master=1[server3]hostname=192.168.4.63ssh_port=22no_master=1</code></pre><h4 id="检测各节点ssh互相配置是否成功"><a href="#检测各节点ssh互相配置是否成功" class="headerlink" title="检测各节点ssh互相配置是否成功"></a>检测各节点ssh互相配置是否成功</h4><p><code>[root@manager/etc/masterha]#masterha_check_ssh app1.cnf --conf=app1.cnf</code></p><h4 id="检查管理的mysql复制集群的连接配置参数是否成功"><a href="#检查管理的mysql复制集群的连接配置参数是否成功" class="headerlink" title="检查管理的mysql复制集群的连接配置参数是否成功"></a>检查管理的mysql复制集群的连接配置参数是否成功</h4><p><code>[root@manager/etc/masterha]#masterha_check_repl --conf=app1.conf</code></p><h4 id="启动MHA"><a href="#启动MHA" class="headerlink" title="启动MHA"></a>启动MHA</h4><p><code>[root@manager/etc/masterha]#masterha_manager --conf=app1.cnf</code></p><h4 id="启动成功后，查看master状态"><a href="#启动成功后，查看master状态" class="headerlink" title="启动成功后，查看master状态"></a>启动成功后，查看master状态</h4><p><code>[root@manager~]#masterha_check_status --conf=/etc/masterha/app1.cnf</code></p><pre><code>app1 (pid:38704) is running(0:PING_OK), master:192.168.4.61</code></pre><h3 id="测试故障转移"><a href="#测试故障转移" class="headerlink" title="测试故障转移"></a>测试故障转移</h3><p>假设master宕机</p><p><code>[root@master~]#systemctl stop mariadb.service</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_204016.jpg" alt=""></p><p>此时会检测到master  down，但是此时的MHA也会停止工作，如果要使其正常工作需要将master重新上线。</p><h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p><code>[root@manager/etc/masterha]#cat /data/masterha/app1/manager.log</code><br><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_204254.jpg" alt=""></p><p>通过查看日志，已经顺利转移到slave1节点上了。</p><h4 id="查看此时的状态"><a href="#查看此时的状态" class="headerlink" title="查看此时的状态"></a>查看此时的状态</h4><p><code>[root@manager/etc/masterha]#masterha_check_status --conf=app1.cnf</code></p><pre><code>app1 is stopped(2:NOT_RUNNING).</code></pre><h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><p>此时只能做从节点，需要加入从节点的配置信息</p><p><code>[root@master~]#vim /etc/my.cnf.d/server.cnf</code></p><pre><code>relay_log_purge = OFFread_only = ON</code></pre><p><code>[root@master~]#systemctl start mariadb.service</code>    </p><p><code>MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_USER=&#39;joah&#39;,MASTER_HOST=&#39;192.168.4.62&#39;,MASTER_PASSWORD=&#39;centos&#39;,MASTER_LOG_FILE=&#39;master-log.000003&#39;,MASTER_LOG_POS=395;</code></p><p><code>MariaDB [(none)]&gt; START SLAVE;</code></p><h3 id="manager再次检测"><a href="#manager再次检测" class="headerlink" title="manager再次检测"></a>manager再次检测</h3><p><code>[root@manager~]#nohup masterha_manager --conf=/etc/masterha/app1.cnf &amp;&gt; /data/masterha/app1/manager.log &amp;</code>  #后台运行</p><p><code>[root@manager~]#jobs</code></p><pre><code>[1]+  Running                 nohup masterha_manager --conf=/etc/masterha/app1.cnf &amp;&gt;/data/masterha/app1/manager.log &amp;</code></pre><p><strong>注意：如果主节点down必须进行重新设置。</strong></p><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>（1）提供额外的检测机制，以明对master的监控作出误判</p><p>（2）在master节点上提供虚拟ip地址向外提供服务，以名master节点转换时，客户端的请求无法正确送达。</p><p>（3）进行故障转移时对原有master节点执行STONITH操作以避免脑裂；可通过制定的shutdwon_script实现。</p><p>（4）必要时，进行在线master节点转换。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mha，mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MPM工作模式</title>
      <link href="/2017/11/28/MPM%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/11/28/MPM%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="MPM（MultiProcess-Modules-）工作模式"><a href="#MPM（MultiProcess-Modules-）工作模式" class="headerlink" title="MPM（MultiProcess Modules ）工作模式"></a>MPM（MultiProcess Modules ）工作模式</h2><blockquote><p>prefork</p></blockquote><p>多进程I/O模型，每个进程响应一个请求，默认模型一个主进程生成N个子进程，创建套接字，每个子进程响应一个请求；而主进程不响应请求，只负责管理接受请求。系统初始化时，预先生成多个空闲进程，等待请求，多大不超过1024个（由pam.limits.so控制，可使用ulimit -n # 设置）</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-29_093925.jpg" alt=""></p><blockquote><p>worker</p></blockquote><p>复用多进程I/O模型，多进程多线程。一个主进程生成m个子进程，每个子进程负责生产n个线程，每个线程响应一个请求，并发响应请求为m*n。</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-29_094437.jpg" alt=""></p><blockquote><p>event</p></blockquote><p>一个主进程生成m个子进程，每个进程直接响应n个请求；并发响应请求为m*n。event中有专门的线程来管理这些Keep-Alive类型的线程，当有真实请求时，将请求传递给服务线程，执行完毕后，又允许释放，增强了高并发场景下的处理请求能力。</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-29_094914.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dropbear</title>
      <link href="/2017/11/28/Dropbear/"/>
      <url>/2017/11/28/Dropbear/</url>
      
        <content type="html"><![CDATA[<h2 id="dropbear"><a href="#dropbear" class="headerlink" title="dropbear"></a>dropbear</h2><p>Dropbear是一个相对较小的SSH服务器和客户端。它运行在一个基于POSIX的各种平台。 Dropbear是开源软件，在麻省理工学院式的许可证。 Dropbear是特别有用的“嵌入”式的Linux（或其他Unix）系统，如无线路由器。  &lt;摘自：百度&gt;</p><h3 id="1、安装dropbear工具包"><a href="#1、安装dropbear工具包" class="headerlink" title="1、安装dropbear工具包"></a>1、安装dropbear工具包</h3><p>（a）从官网上下载dropbear源码包并安装有关编译的环境包组</p><p>（b）编译安装源码包</p><p><code>[root@centos7/usr/src]#tar xvf dropbear-2017.75.tar.bz2</code><br><code>[root@centos7/usr/src/dropbear-2017.75]#./configure</code><br><code>[root@centos7/usr/src/dropbear-2017.75]#make PROGRAMS=&quot;dropbear dbclient dropbearkey dropbearconvert scp&quot;</code><br><code>[root@centos7/usr/src/dropbear-2017.75]#make PROGRAMS=&quot;dropbear dbclient dropbearkey dropbearconvert scp&quot; install</code></p><p>（c）有关命令的存放位置</p><p><code>/usr/local/sbin</code>和<code>/usr/local/bin</code></p><p>（d）生成key存放的位置</p><pre><code>dss /etc/dropbear/dropbear_dss_host_keyrsa /etc/dropbear/dropbear_rsa_host_keyecdsa /etc/dropbear/dropbear_ecdsa_host_key</code></pre><p>（e）创建目录并生成密钥</p><p><code>[root@centos7/usr/local/sbin]#mkdir /etc/dropbear</code><br><code>[root@centos7/usr/local/bin]#dropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key -s 2048</code></p><pre><code>Generating key, this may take a while...Public key portion is:ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDCfn+syhEMRgkxQ1Y/8Hzu54aTv23hLKyiDOTNVAqpZD+kS63TOcD4r5wCQsARNhl4e0kKWz9CLl6y3cWPxO+BbxCcZ+Ue2HqGQO2vhltzD2voL5xuOOg50nv1nrMrudS3kIYkg3gmVhn0Z0nKntJFdbzihzbLU0c1MgstTscu0PpX7q9j2c0mUHuYFqTmj2X4AJB0qjj8VZs93KTn3YyzVBph7mub8FQkS+fLjMvzan66+GjAtafeR+ezoFP6NAC7BuVaHaKoUNyP/myZgA3wkM4LL8OuoSk3uJia5ZDzDEsUNcHsmwaDVlJDGbjMRx+Djoafj9JNE7su+TmLMl2z root@centos7Fingerprint: md5 bf:3b:0a:85:94:85:e1:af:91:74:14:d3:e2:0c:6e:d0</code></pre><p>（f）启动dropbear<br>dropbear选项</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-F</td><td>Don’t fork into background前台执行</td></tr><tr><td>-E</td><td>Log to stderr rather than syslog输出信息在屏幕上</td></tr><tr><td>-p [address:]port</td><td>Listen on specified tcp port (and optionally address),up to 10 can be specified(default port is 22 if none specified)</td></tr></tbody></table><p><code>[root@centos7/usr/local/bin]#dropbear -p 2222 -F -E</code></p><p>（g）使用dbclinet远程连接</p><p><code>[root@centos6/usr/local/bin]#dbclient 192.168.159.139</code></p><p>（h）拷贝文件</p><p><code>[root@centos6/usr/local/bin]#scp /etc/fstab 192.168.159.139:/</code></p><pre><code>/usr/bin/dbclient: No such file or directorylost connection</code></pre><p>此时连接会报错，说我们没有/usr/bin/dbclient</p><p><code>[root@centos6/usr/local/bin]#hash</code><br>通过hash命令查看确实是使用我们刚刚创建的路径程序，所有解决此问题创建一个软连接即可。</p><p><code>[root@centos6/usr/local/bin]#ln -sv /usr/local/bin/dbclient /usr/bin/dbclient</code></p><pre><code>`/usr/bin/dbclient&#39; -&gt; `/usr/local/bin/dbclient&#39;</code></pre><p><code>[root@centos6/usr/local/bin]#scp /etc/fstab 192.168.159.139:/</code></p>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dropbear </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FTP简单介绍</title>
      <link href="/2017/11/28/FTP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/11/28/FTP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="一、FTP"><a href="#一、FTP" class="headerlink" title="一、FTP"></a>一、FTP</h1><h2 id="1、FTP介绍"><a href="#1、FTP介绍" class="headerlink" title="1、FTP介绍"></a>1、FTP介绍</h2><p>用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。”下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。</p><h2 id="2、FTP的工作模式"><a href="#2、FTP的工作模式" class="headerlink" title="2、FTP的工作模式"></a>2、FTP的工作模式</h2><h3 id="（1）主动模式"><a href="#（1）主动模式" class="headerlink" title="（1）主动模式"></a>（1）主动模式</h3><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-13_092716.jpg" alt=""></p><ul><li>Client（PORT/TCP）向Server（22/TCP）发送连接请求，建立三次握手</li><li>Client告知Server数据连接端口为PORT+1</li><li>Server（20/TCP）主动向Client发送连接请求，建立数据通信。</li></ul><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-13_101242.jpg" alt=""><br><img src="http://owatlfstl.bkt.clouddn.com/2017-10-13_104528.jpg" alt=""></p><h3 id="（2）被动模式"><a href="#（2）被动模式" class="headerlink" title="（2）被动模式"></a>（2）被动模式</h3><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-13_093317.jpg" alt=""></p><ul><li>Client（PORT/TCP）和Server建立三次握手</li><li>Client向Server发起PASSIVE请求</li><li>Server告知Client数据端口</li><li>Client（PORT+1/TCP）再次向Server发送数据连接请求</li></ul><p>这里需要注意一下，Server数据端口需要计算得出来的一个随机端口号</p><p>示例：</p><pre><code>192,168,4,60,140,28服务器数据端口为：140*256+28=35868即此端口为数据连接端口</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-13_101242.jpg" alt=""><br>TCP三次握手过程<br><img src="http://owatlfstl.bkt.clouddn.com/2017-10-13_103610.jpg" alt=""><br>被动模式下通信过程，产生随机端口通信。</p><h2 id="3、FTP服务状态码"><a href="#3、FTP服务状态码" class="headerlink" title="3、FTP服务状态码"></a>3、FTP服务状态码</h2><table><thead><tr><th>状态码</th><th>说明</th></tr></thead><tbody><tr><td>1XX</td><td>信息</td></tr><tr><td>2XX</td><td>成功类响应码</td></tr><tr><td>3XX</td><td>提示需进一步提供补充类信息的状态码</td></tr><tr><td>4XX</td><td>客户端错误</td></tr><tr><td>5XX</td><td>服务器端错误</td></tr></tbody></table><h2 id="4、FTP服务用户认证方式"><a href="#4、FTP服务用户认证方式" class="headerlink" title="4、FTP服务用户认证方式"></a>4、FTP服务用户认证方式</h2><ul><li>匿名用户：ftp，anonymous，对应linux用户为ftp</li></ul><p>匿名用户映射为ftp用户共享资源位置:<code>/var/ftp/pub</code></p><ul><li>系统用户：linux用户，用户/etc/passwd,密码/etc/shadow</li></ul><p>系统用户通过ftp访问的资源的位置：用户自己的家目录</p><ul><li>虚拟用户：特定服务的专用用户，独立于用户/密码的文件;仅用于访问某特定功能的资源</li></ul><p>虚拟用户通过ftp访问资源的位置：给虚拟用户指定的映射成系统用户的家目录</p><h1 id="二、vsftpd服务"><a href="#二、vsftpd服务" class="headerlink" title="二、vsftpd服务"></a>二、vsftpd服务</h1><h2 id="1、vsftpd服务配置文件"><a href="#1、vsftpd服务配置文件" class="headerlink" title="1、vsftpd服务配置文件"></a>1、vsftpd服务配置文件</h2><p>用户认证配置文件</p><pre><code>/etc/pam.d/vsftpd</code></pre><p>服务脚本</p><pre><code>/usr/lib/systemd/system/vsftpd.service (CentOS 7)/etc/rc.d/init.d/vsftpd</code></pre><p>配置文件</p><pre><code>/etc/vsftpd/vsftpd.conf</code></pre><h2 id="2、主配置文件-etc-vsftpd-vsftpd-conf"><a href="#2、主配置文件-etc-vsftpd-vsftpd-conf" class="headerlink" title="2、主配置文件/etc/vsftpd/vsftpd.conf"></a>2、主配置文件<code>/etc/vsftpd/vsftpd.conf</code></h2><ul><li><p>匿名了用户配置</p><p>  anonymous_enable    是否启用匿名用户<br>  anon_upload_enable  是否允许匿名用户上传<br>  anon_mkdir_write_enable 是否允许匿名用户创建目录<br>  anon_other_write_enable 是否允许匿名用户删除目录</p></li><li><p>系统用户配置</p><p>  local_enable    是否开启系统用户<br>  write_enable    是否允许创建、删除文件<br>  local_mask      控制本地上传文件权限<br>  chroot_local_user   锁定所有用户在家目录中<br>  chroot_list_enable  运行列表中的用户切换为家目录<br>  chroot_list_file    指定用户文件存放位置<br>  dirmessage_enable   在指定目录下创建.message文件提示用户登录信息<br>  local_root  非匿名了用户登录所有目录<br>  guest_enable    所有系统用户都映射成guest用户<br>  guest_username  指定guest用户，一定要与guest_enable使用<br>  nopriv_user vsftpd指定用户身份运行</p></li></ul><ul><li><p>日志</p><p>  xferlog_enable  是否开启传输日志<br>  xferlog_std_format 是否开启标准格式<br>  xferlog_file    指定存放日志文件<br>  dual_log_enable 使用vsftpd日志格式，默认不启用<br>  vsftpd_log_fiel=/var/log/vsftpd.log 可自动生成</p></li><li><p>改变上传文件的所有者</p><p>  chown_uploads   是否开启改变上传并修改所有者<br>  chown_username  设置修改为who</p></li><li><p>欢迎信息</p><p>ftpd_banner     设置欢迎信息</p></li><li><p>vsftpd使用pam完成认证使用的pam配置文件</p><p>  pam_service_name</p></li><li><p>是否启用控制用户登录的列表文件</p><p>  userlist_enable 是否启用用户列表<br>  userlist_deny   是否允许这个文件中的用户可以登录</p></li><li><p>连接限制</p><p>  max_client  最大并发连接数<br>  max_per_ip  每个IP可同时发起的并发请求数</p></li><li><p>传输速率</p><p>  anon_max_rate   匿名用户最大传输率，单位为字节/秒<br>  local_max_rate  本地用户最大传输速率</p></li></ul><p>-主动模式端口</p><pre><code>connect_from_port_20    主动模式端口为20ftp_data_port   指定主动模式端口此处注意：一定不能把connect_from_port设置为NO</code></pre><ul><li><p>被动模式端口</p><p>  pasv_min_port   被动模式最小端口，0为随机端口<br>  pasv_max_port   被动模式最大端口</p></li><li><p>是否使用当地时间，即系统时间</p><p>  use_localtime</p></li><li><p>连接时间</p><p>  connect_timeout 主动模式数据连接超时时长<br>  accept_timeout  被动模式数据连接超时时长<br>  data_connection_timeout 数据无数据传输超时时长<br>  idle_session_timeout    无命令超时时长<br>-优先以文本传输</p><p>  ascii_upload_enable 是否开启文本传输<br>  ascii_download_enable</p></li></ul><p><strong>注意：vsftpd默认不允许直接修改根目录权限。</strong></p><h2 id="3、CentOS-6如何使vsftpd以非独立服务方式运行"><a href="#3、CentOS-6如何使vsftpd以非独立服务方式运行" class="headerlink" title="3、CentOS 6如何使vsftpd以非独立服务方式运行"></a>3、CentOS 6如何使vsftpd以非独立服务方式运行</h2><p>（1）修改<code>/etc/vsftpd/vsftpd.conf</code></p><pre><code>listen=NO   将此项设置为NO ，即关闭自己监听</code></pre><p>（2）安装xinetd服务</p><p><code>[root@localhost ~]# yum install -y  xinetd</code></p><p>（3）复制模板并修改启动xinetd服务</p><p><code>[root@localhost xinetd.d]# cp rsync vsftpd</code><br><code>[root@localhost xinetd.d]# vim vsftpd</code></p><pre><code>    service vsftpd  #修改服务名称{        disable = no    是否开启        flags           = IPv6        socket_type     = stream        wait            = no        user            = root        server          = /usr/sbin/vsftpd        server_args     = --daemon        log_on_failure  += USERID}</code></pre><p><code>[root@localhost xinetd.d]# service xinetd restart</code></p><p>（4）验证是否成为非独立服务</p><p><code>[root@localhost xinetd.d]# ss -tnl</code></p><pre><code>LISTEN     0      64                            :::21                           :::*      users:((&quot;xinetd&quot;,48493,5))</code></pre><h2 id="4、实现基于SSL的FTPS"><a href="#4、实现基于SSL的FTPS" class="headerlink" title="4、实现基于SSL的FTPS"></a>4、实现基于SSL的FTPS</h2><p>（1）确认是否支持ssl</p><p><code>[root@localhost ~]# ldd</code>which vsftpd<code>|grep ssl</code></p><pre><code>libssl.so.10 =&gt; /usr/lib64/libssl.so.10 (0x00007f56e8de8000)</code></pre><p>（2）创建证书</p><p><code>[root@localhost/etc/pki/tls/certs]#make vsftpd.pem</code><br><code>[root@localhost/etc/pki/tls/certs]#openssl x509 -in vsftpd.pem -noout -text</code>   #查看证书内容<br><code>[root@localhost/etc/pki/tls/certs]#mv vsftpd.pem /etc/vsftpd/</code> #将证书移动至此目录下方便管理</p><p>（3）配置vsftpd服务支持SSL</p><p><code>[root@localhost~]#vim /etc/vsftpd/vsftpd.conf</code> #在文件下追击如下几行</p><pre><code>128 ssl_enable=YES      #是否开启SSL129 allow_anon_ssl=NO   #是否允许匿名用户支持SSL130 force_local_logins_ssl=YES  #本地用户登录加密131 force_local_data_ssl=YES    #本地用户数据传输加密132 rsa_cert_file=/etc/vsftpd/vsftpd.pem    #证书存放的位置</code></pre><p>（4）测试是否使用加密传输</p><p><code>[root@localhost ~]# ftp 192.168.4.60</code></p><pre><code>Connected to 192.168.4.60 (192.168.4.60).220 (vsFTPd 3.0.2)Name (192.168.4.60:root): wang530 Non-anonymous sessions must use encryption. #禁止匿名用户登录Login failed.421 Service not available, remote server has closed connection</code></pre><p>使用Fileilla工具测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-13_150204.jpg" alt=""><br><img src="http://owatlfstl.bkt.clouddn.com/2017-10-13_145228.jpg" alt=""></p><h1 id="三、vsftpd虚拟用户"><a href="#三、vsftpd虚拟用户" class="headerlink" title="三、vsftpd虚拟用户"></a>三、vsftpd虚拟用户</h1><h2 id="1、虚拟用户介绍"><a href="#1、虚拟用户介绍" class="headerlink" title="1、虚拟用户介绍"></a>1、虚拟用户介绍</h2><p>所有虚拟用户会被统一映射为一个指定的系统账号，访问的共享位置即此系统账号的目录；</p><p>每个虚拟用户可被赋予不同的访问权限，通过匿名用户的权限控制参数进行指定；</p><p>##2、虚拟用户账号的存储方式</p><ul><li><p>文本存储：编辑文本文件，此文件需要被编码为hash格式</p><p>  格式：奇数行为账户，偶数行为密码</p></li></ul><p>不过需要对此文件加密，使用的工具为db_load</p><pre><code>db_load -T -t hash -f Filename.txt  Filename.db    -T  转换    -t  指定类型    -f  指定文件</code></pre><ul><li>存储在关系型数据库表中，可以实现查询数据库完成用户认证</li></ul><p>#四、实现不同方式存储的方式</p><p>##1、基于文本文件存储<br>（1）创建用户并写入一个文本文件中</p><p><code>[root@localhost/etc/vsftpd]#vim vusers</code></p><pre><code>  1 joah  2 123456  3 wang  4 123456</code></pre><p>（2）创建用户数据库文件</p><p><code>[root@localhost/etc/vsftpd]#db_load -T -t hash -f vusers vusers.db</code><br><code>[root@localhost/etc/vsftpd]#chmod 600 vusers.db</code>   #修改文件权限</p><p>（3）创建用户和访问的目录<br><code>[root@localhost~]#useradd -s /sbin/nologin -d /app/ftproot vuser</code><br><code>[root@localhost~]#chmod +rx /app/ftproot/</code><br><code>[root@localhost~]#chmod -w /app/ftproot/</code>  #由于CentOS 7 上不允许系统用户直接修改家目录所有需要去掉此权限<br><code>[root@localhost~]#mkdir /app/ftproot/upload</code><br><code>[root@localhost~]#setfacl -m u:vuser:rwx /app/ftproot/upload/</code></p><p>（4）创建pam配置文件</p><p><code>[root@localhost~]#ls /usr/lib64/security/ |grep userdb</code>    #查看是否已有此模块</p><pre><code>pam_userdb.so</code></pre><p><code>[root@localhost/etc/pam.d]#vim vsftpd.db</code></p><pre><code>1 auth required pam_userdb.so db=/etc/vsftpd/vusers   2 account required pam_userdb.so db=/etc/vsftpd/vusers</code></pre><p>（5）创建虚拟用户独立的配置文件</p><p><code>[root@localhost/etc/vsftpd]#mkdir vdocs</code><br><code>[root@localhost/etc/vsftpd]#cd vdocs/</code><br><code>[root@localhost/etc/vsftpd/vdocs]#vim wang</code><br><code>[root@localhost/etc/vsftpd/vdocs]#vim joah</code></p><pre><code>  1 anon_upload_enable=YES  2 anon_mkdir_write_enable=YES  3 anon_other_write_enable=YES</code></pre><p><strong>注意：默认不创建用户文件，只有下载权限。</strong></p><p>（6）修改<code>/etc/vsftpd/vsftpd.conf</code>文件</p><pre><code>133 guest_enable=YES    #所有系统用户映射为guest用户134 guest_username=vuser    #指定guest用户135 pam_service_name=vsftpd.db  #pam服务的名称136 user_config_dir=/etc/vsftpd/vdocs   #文本文件用户的配置文件所在位置</code></pre><p>（7）测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-13_155311.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-13_155412.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ftp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL半同步复制</title>
      <link href="/2017/11/28/MySQL%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6/"/>
      <url>/2017/11/28/MySQL%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>mysql半同步复制<br>-</p><p>半同步复制是基于异步复制基础之上进行的。从Slave节点中选取一个节点进行半同步复制，当master节点提交一个事物将受到阻塞，直到得知一个已开启半同步复制功能的Slave同步完成之后返回ack包，master才会向用户返回事物提交。</p><h3 id="1、半同步流程图："><a href="#1、半同步流程图：" class="headerlink" title="1、半同步流程图："></a>1、半同步流程图：</h3><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_100926.jpg" alt=""></p><h3 id="2、半同步潜在的问题"><a href="#2、半同步潜在的问题" class="headerlink" title="2、半同步潜在的问题"></a>2、半同步潜在的问题</h3><p>当master down时，有可能半同步复制没有完成，并没有提交给客户；切换到Slave时，数据有可能和master的数据不一致，此时需要使用binlog恢复</p><h3 id="3、半同步复制概念"><a href="#3、半同步复制概念" class="headerlink" title="3、半同步复制概念"></a>3、半同步复制概念</h3><p>（1）当slave节点连接到master时，能够查看是否处于半连接同步复制的机制；如果只有开启一侧，它依然为异步复制。</p><p>（2）当master节点开启半同步复制的功能时，至少有一个Slave节点开启此功能。</p><p>###4、mysql插件</p><p>####查询插件存放的位置：</p><blockquote><blockquote><p>MariaDB [(none)]&gt; SHOW VARIABLES LIKE ‘plugin_dir’;<br>+—————+————————–+<br>| Variable_name | Value                    |<br>+—————+————————–+<br>| plugin_dir    | /usr/lib64/mysql/plugin/ |<br>+—————+————————–+</p></blockquote></blockquote><h3 id="安装插件："><a href="#安装插件：" class="headerlink" title="安装插件："></a>安装插件：</h3><p>格式：</p><pre><code>INSTALL PLUGIN plugin_name SONAME &#39;shared_library_name&#39;；</code></pre><h4 id="卸载插件"><a href="#卸载插件" class="headerlink" title="卸载插件"></a>卸载插件</h4><p>格式：</p><pre><code>UNINSTALL PLUGIN plg_name；</code></pre><h4 id="查看当前已经安装的插件"><a href="#查看当前已经安装的插件" class="headerlink" title="查看当前已经安装的插件"></a>查看当前已经安装的插件</h4><p>格式：</p><pre><code>SHOW PLUGINS;</code></pre><h4 id="查看插件的详细信息"><a href="#查看插件的详细信息" class="headerlink" title="查看插件的详细信息"></a>查看插件的详细信息</h4><p>格式：</p><pre><code>SELECT * FROM information_schema.plugins WHERE PLUGIN_NAME=&#39;plg-name&#39;;  </code></pre><h2 id="半同步复制实现"><a href="#半同步复制实现" class="headerlink" title="半同步复制实现"></a>半同步复制实现</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_102548.jpg" alt=""></p><h4 id="前提："><a href="#前提：" class="headerlink" title="前提："></a>前提：</h4><blockquote><p>master和slave时间同步</p></blockquote><p><code>[root@master~]#ntpdate 172.18.0.1</code></p><p><code>[root@master~]#vim /etc/chrony.conf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_103434.jpg" alt=""></p><p><code>[root@master~]#systemctl start chronyd.service</code></p><h5 id="slave步骤同上"><a href="#slave步骤同上" class="headerlink" title="slave步骤同上"></a>slave步骤同上</h5><blockquote><p>确保关闭了iptables和selinux功能</p></blockquote><h3 id="配置主从复制"><a href="#配置主从复制" class="headerlink" title="配置主从复制"></a>配置主从复制</h3><h4 id="master-配置："><a href="#master-配置：" class="headerlink" title="master 配置："></a>master 配置：</h4><blockquote><p>修改配置文件</p></blockquote><p><code>[root@master~]#vim /etc/my.cnf.d/server.cnf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_105608.jpg" alt=""></p><blockquote><p>授权用户</p><blockquote><p>MariaDB [(none)]&gt; GRANT REPLICATION SLAVE,REPLICATION CLIENT ON <em>.</em> TO ‘joah’@’192.168.4.%’ IDENTIFIED BY ‘123456’;</p><p>MariaDB [(none)]&gt; FLUSH PRIVILEGES;</p></blockquote><p>查看二进制日志</p><blockquote><p>MariaDB [(none)]&gt; SHOW MASTER STATUS;</p><p>MariaDB [(none)]&gt; SHOW BINLOG EVENTS IN ‘log-bin.000001’;</p></blockquote></blockquote><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_111012.jpg" alt=""></p><h4 id="slave配置"><a href="#slave配置" class="headerlink" title="slave配置"></a>slave配置</h4><blockquote><p>修改配置文件<br><code>[root@slave1~]#vim /etc/my.cnf.d/server.cnf</code></p></blockquote><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_110211.jpg" alt=""></p><h5 id="slave1和slave2配置相同，不过需要修改下server-id"><a href="#slave1和slave2配置相同，不过需要修改下server-id" class="headerlink" title="slave1和slave2配置相同，不过需要修改下server_id"></a>slave1和slave2配置相同，不过需要修改下<code>server_id</code></h5><blockquote><p>修改主节点</p><blockquote><p>MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_USER=’joah’,MASTER_HOST=’192.168.4.61’,MASTER_PASSWORD=’123456’,MASTER_LOG_FILE=’log-bin.000001’,MASTER_LOG_POS=245;</p><p>MariaDB [(none)]&gt; START SLAVE;</p><p>MariaDB [(none)]&gt; SHOW SLAVE STATUS\G;</p></blockquote></blockquote><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_111947.jpg" alt=""></p><h3 id="实现半同步复制"><a href="#实现半同步复制" class="headerlink" title="实现半同步复制"></a>实现半同步复制</h3><h4 id="master节点配置"><a href="#master节点配置" class="headerlink" title="master节点配置"></a>master节点配置</h4><blockquote><p>安装semisync插件</p><blockquote><p>MariaDB [(none)]&gt; INSTALL PLUGIN rpl_semi_sync_master SONAME  ‘semisync_master’;</p></blockquote><p>查看变量</p><blockquote><p>MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES LIKE ‘rpl_semi%’;<br>+————————————+——-+<br>| Variable_name                      | Value |<br>+————————————+——-+<br>| rpl_semi_sync_master_enabled       | OFF   |<br>| rpl_semi_sync_master_timeout       | 10000 |<br>| rpl_semi_sync_master_trace_level   | 32    |<br>| rpl_semi_sync_master_wait_no_slave | ON    |<br>+————————————+——-+</p></blockquote><p>启动此插件功能</p><blockquote><p>MariaDB [(none)]&gt; SET GLOBAL rpl_semi_sync_master_enabled=ON;</p></blockquote><p>显示状态</p><blockquote><p>MariaDB [(none)]&gt; SHOW GLOBAL STATUS LIKE ‘%rpl%’;</p></blockquote></blockquote><h4 id="Slave1-配置"><a href="#Slave1-配置" class="headerlink" title="Slave1 配置"></a>Slave1 配置</h4><blockquote><p>安装插件</p><blockquote><p>MariaDB [(none)]&gt; INSTALL PLUGIN rpl_semi_sync_slave SONAME ‘semisync_slave’;</p></blockquote><p>查看semi变量</p><blockquote><p>MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES LIKE ‘%rpl_semi%’;<br>+———————————+——-+<br>| Variable_name                   | Value |<br>+———————————+——-+<br>| rpl_semi_sync_slave_enabled     | OFF   |<br>| rpl_semi_sync_slave_trace_level | 32    |<br>+———————————+——-+</p></blockquote><p>启动semi功能</p><blockquote><p>MariaDB [(none)]&gt; SET @@global.rpl_semi_sync_slave_enabled=ON;<br>重启IO线程，如果不重启当执行时会超时<br>MariaDB [(none)]&gt; STOP SLAVE IO_THREAD;</p><p>MariaDB [(none)]&gt; START SLAVE IO_THREAD;</p></blockquote></blockquote><h3 id="查看master上的状态"><a href="#查看master上的状态" class="headerlink" title="查看master上的状态"></a>查看master上的状态</h3><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_115505.jpg" alt=""></p><h4 id="选项介绍"><a href="#选项介绍" class="headerlink" title="选项介绍"></a>选项介绍</h4><pre><code>rpl_semi_sync_master_enabled 是否开启半同步rpl_semi_sync_master_timeout 超时时长rpl_semi_sync_slave_enable slave是否开启半同步rpl_semi_sync_master_clients 查看有多少个slave开启半同步rpl_semi_sync_master_status 查看master是否正在运行rpl_semi_sync_master_no_tx 查看有多少事物没有用半同步复制的机制进行复制rpl_semi_sync_master_yes_tx 查看有多少事物是通过半同步复制机制成功复制rpl_semi_sync_slave_status 查看slave是否正常运行</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL双主模式</title>
      <link href="/2017/11/28/MySQL%E5%8F%8C%E4%B8%BB%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/11/28/MySQL%E5%8F%8C%E4%B8%BB%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="双主模式"><a href="#双主模式" class="headerlink" title="双主模式"></a>双主模式</h2><p>互为主从：两个节点各自都要开启binlog和relay log</p><pre><code>（1）数据不一致（2）自动增长ID     定义一个节点使用奇数ID        auto_increment_offset=1        auto_increment_increment=2    另外一个节点使用偶数ID        auto_increment_offset=2        auto_increment_increment=2</code></pre><p>前提：</p><pre><code>（1）server_id必须要使用不同值（2）均启用binlog和relay log（3）存在自动增长ID的表，为了使得ID不相冲突，需要定义其自动增长方式（4）都授权复制权限的用户账号（5）各把对方指定为主节点</code></pre><p>复制时应该注意的问题：</p><ul><li><p>1、从服务器设定为“只读”</p><p>  在从服务器启动read_only，但仅对非SUPER权限用户有效</p><p>  组织所有用户：</p><pre><code>  FLUSH TABLES WITH READ LOCK;</code></pre></li><li><p>2、尽量确保复制时的事物安全</p><p>  在master节点启用参数</p><pre><code>  sync_binlog = ON  如果用到的是InnoDB存储引擎：      innodb_flush_logs_at_trx_commit=ON      innodb_support_xa=ON</code></pre></li><li>3、从服务器意外终止时尽量避免自动复制线程</li><li><p>4、从节点：设置参数</p><p>  sync_master_info = ON<br>  sync_relay_log_info = ON</p></li></ul><p><strong>实战：</strong></p><p>在node1进行如下配置</p><p><code>[root@node1~]#vim /etc/my.cnf.d/server.cnf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_213027.jpg" alt=""></p><p>在node2节点进行如下配置</p><p><code>[root@node2~]#vim /etc/my.cnf.d/server.cnf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_214231.jpg" alt=""></p><p><code>[root@node1~]#systemctl start mariadb</code></p><p><code>[root@node2~]#systemctl start mariadb</code></p><p>在node1和node2相互授权</p><pre><code>GRANT REPLICATION CLIENT,REPLICATION SLAVE ON *.* TO &#39;joah&#39;@&#39;192.168.4.62&#39; IDENTIFIED BY &#39;123456&#39;;GRANT REPLICATION CLIENT,REPLICATION SLAVE ON *.* TO &#39;joah&#39;@&#39;192.168.4.61&#39; IDENTIFIED BY &#39;123456&#39;;</code></pre><p>在node1和node2指定master</p><pre><code>MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_HOST=&#39;192.168.4.62&#39;,MASTER_USER=&#39;joah&#39;,MASTER_PASSWORD=&#39;123456&#39;,MASTER_LOG_FILE=&#39;master-log.000003&#39;,MASTER_LOG_POS=422;MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_HOST=&#39;192.168.4.61&#39;,MASTER_USER=&#39;joah&#39;,MASTER_PASSWORD=&#39;123456&#39;,MASTER_LOG_FILE=&#39;master-log.000003&#39;,MASTER_LOG_POS=245;</code></pre><p>在node1和node2启动从服务器</p><pre><code>MariaDB [(none)]&gt; SHOW SLAVE STATUS\G;MariaDB [(none)]&gt; START SLAVE IO_THREAD,SQL_THREAD;</code></pre><p><strong>测试</strong></p><pre><code>MariaDB [(none)]&gt; SHOW SLAVE STATUS\G;</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_214617.jpg" alt=""></p><p>如果出现上述红框中yes字样就成功</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主从复制读写分离</title>
      <link href="/2017/11/28/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/2017/11/28/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="mysql主从复制读写分离"><a href="#mysql主从复制读写分离" class="headerlink" title="mysql主从复制读写分离"></a>mysql主从复制读写分离</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_150846.jpg" alt=""></p><h3 id="master和slave时间同步"><a href="#master和slave时间同步" class="headerlink" title="master和slave时间同步"></a>master和slave时间同步</h3><p><code>[root@master~]#ntpdate 172.18.0.1</code></p><p><code>[root@master~]#vim /etc/chrony.conf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_103434.jpg" alt=""></p><p><code>[root@master~]#systemctl start chronyd.service</code></p><h5 id="slave步骤同上"><a href="#slave步骤同上" class="headerlink" title="slave步骤同上"></a>slave步骤同上</h5><blockquote><p>确保关闭了iptables和selinux功能</p></blockquote><p>##配置主从复制</p><h4 id="master-配置："><a href="#master-配置：" class="headerlink" title="master 配置："></a>master 配置：</h4><blockquote><p>修改配置文件</p></blockquote><p><code>[root@master~]#vim /etc/my.cnf.d/server.cnf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_105608.jpg" alt=""></p><blockquote><p>授权用户</p><blockquote><p>MariaDB [(none)]&gt; GRANT REPLICATION SLAVE,REPLICATION CLIENT ON <em>.</em> TO ‘joah’@’192.168.4.%’ IDENTIFIED BY ‘123456’;</p><p>MariaDB [(none)]&gt; FLUSH PRIVILEGES;</p></blockquote><p>查看二进制日志</p><blockquote><p>MariaDB [(none)]&gt; SHOW MASTER STATUS;</p><p>MariaDB [(none)]&gt; SHOW BINLOG EVENTS IN ‘log-bin.000001’;</p></blockquote></blockquote><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_111012.jpg" alt=""></p><h4 id="slave配置"><a href="#slave配置" class="headerlink" title="slave配置"></a>slave配置</h4><blockquote><p>修改配置文件<br><code>[root@slave1~]#vim /etc/my.cnf.d/server.cnf</code></p></blockquote><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_110211.jpg" alt=""></p><h5 id="slave1和slave2配置相同，不过需要修改下server-id"><a href="#slave1和slave2配置相同，不过需要修改下server-id" class="headerlink" title="slave1和slave2配置相同，不过需要修改下server_id"></a>slave1和slave2配置相同，不过需要修改下<code>server_id</code></h5><blockquote><p>修改主节点</p><blockquote><p>MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_USER=’joah’,MASTER_HOST=’192.168.4.61’,MASTER_PASSWORD=’123456’,MASTER_LOG_FILE=’log-bin.000001’,MASTER_LOG_POS=245;</p><p>MariaDB [(none)]&gt; START SLAVE;</p><p>MariaDB [(none)]&gt; SHOW SLAVE STATUS\G;</p></blockquote></blockquote><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_111947.jpg" alt=""></p><h2 id="实现半同步复制"><a href="#实现半同步复制" class="headerlink" title="实现半同步复制"></a>实现半同步复制</h2><h4 id="master节点配置"><a href="#master节点配置" class="headerlink" title="master节点配置"></a>master节点配置</h4><blockquote><p>安装semisync插件</p><blockquote><p>MariaDB [(none)]&gt; INSTALL PLUGIN rpl_semi_sync_master SONAME  ‘semisync_master’;</p></blockquote><p>查看变量</p><blockquote><p>MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES LIKE ‘rpl_semi%’;<br>+————————————+——-+<br>| Variable_name                      | Value |<br>+————————————+——-+<br>| rpl_semi_sync_master_enabled       | OFF   |<br>| rpl_semi_sync_master_timeout       | 10000 |<br>| rpl_semi_sync_master_trace_level   | 32    |<br>| rpl_semi_sync_master_wait_no_slave | ON    |<br>+————————————+——-+</p></blockquote><p>启动此插件功能</p><blockquote><p>MariaDB [(none)]&gt; SET GLOBAL rpl_semi_sync_master_enabled=ON;</p></blockquote><p>显示状态</p><blockquote><p>MariaDB [(none)]&gt; SHOW GLOBAL STATUS LIKE ‘%rpl%’;</p></blockquote></blockquote><h4 id="Slave1-配置"><a href="#Slave1-配置" class="headerlink" title="Slave1 配置"></a>Slave1 配置</h4><blockquote><p>安装插件</p><blockquote><p>MariaDB [(none)]&gt; INSTALL PLUGIN rpl_semi_sync_slave SONAME ‘semisync_slave’;</p></blockquote><p>查看semi变量</p><blockquote><p>MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES LIKE ‘%rpl_semi%’;<br>+———————————+——-+<br>| Variable_name                   | Value |<br>+———————————+——-+<br>| rpl_semi_sync_slave_enabled     | OFF   |<br>| rpl_semi_sync_slave_trace_level | 32    |<br>+———————————+——-+</p></blockquote><p>启动semi功能</p><blockquote><p>MariaDB [(none)]&gt; SET @@global.rpl_semi_sync_slave_enabled=ON;<br>重启IO线程，如果不重启当执行时会超时<br>MariaDB [(none)]&gt; STOP SLAVE IO_THREAD;</p><p>MariaDB [(none)]&gt; START SLAVE IO_THREAD;</p></blockquote></blockquote><h2 id="proxysql"><a href="#proxysql" class="headerlink" title="proxysql"></a>proxysql</h2><p><a href="http://www.proxysql.com/" target="_blank" rel="noopener">http://www.proxysql.com/</a>   下载地址</p><p>###安装proxysql</p><p><code>[root@proxysql~]#yum install proxysql-1.4.3-1-centos7.x86_64.rpm</code></p><p>###修改配置文件<code>/etc/proxysql.cnf</code><br><code>[root@proxysql~]#cp /etc/proxysql.cnf{,.bak}</code></p><p><code>[root@proxysql~]#vim /etc/proxysql.cnf</code></p><pre><code>datadir=&quot;/var/lib/proxysql&quot; #存放数据地址 10  11 admin_variables= 12 { 13         admin_credentials=&quot;admin:123456&quot; 14         mysql_ifaces=&quot;127.0.0.1:6032;/tmp/proxysql_admin.sock&quot;  #为了安全可见仅在本地使用 15 } 16  17 mysql_variables= 18 { 19         threads=4 20         max_connections=2048 21         default_query_delay=0 22         default_query_timeout=36000000 23         have_compress=true 24         poll_timeout=2000 25         interfaces=&quot;0.0.0.0:3306;/tmp/proxysql.sock&quot; 26 #       interfaces=&quot;0.0.0.0:6033&quot; 27         default_schema=&quot;information_schema&quot; 28         stacksize=1048576 29         server_version=&quot;5.5.30&quot; 30         connect_timeout_server=3000 31         monitor_username=&quot;joah&quot; 32         monitor_password=&quot;joah&quot; 33         monitor_history=600000 34         monitor_connect_interval=60000 35         monitor_ping_interval=10000 36         monitor_read_only_interval=1500 37         monitor_read_only_timeout=500 38         ping_interval_server_msec=120000 39         ping_timeout_server=500 40         commands_stats=true 41         sessions_sort=true 42         connect_retries_on_failure=10 43 } 44  45  46 # defines all the MySQL servers 47 mysql_servers = 48 ( 49         { 50                 address = &quot;192.168.4.61&quot; 51                 port = 3306 52                 hostgroup = 0 53                 status = &quot;ONLINE&quot; 54                 weight = 1 55                 compression = 0 56         }, 57         { 58                 address = &quot;192.168.4.62&quot; 59                 port = 3306 60                 hostgroup = 1 61                 status = &quot;ONLINE&quot; 62                 weight = 1 63                 compression = 0 64         }, 65         { 66                 address = &quot;192.168.4.63&quot; 67                 port = 3306 68                 hostgroup = 1 69                 status = &quot;ONLINE&quot; 70                 weight = 1 71                 compression = 0 72         } 73 ) 74  75 # defines all the MySQL users 76 mysql_users: 77 ( 78         { 79                 username = &quot;joah&quot; 80                 password = &quot;123456&quot; 81                 default_hostgroup = 0 82                 max_connections=1000 83                 default_schema=&quot;hellodb&quot; 84                 active = 1 85         } 86 ) 87  88 #defines MySQL Query Rules 89 mysql_query_rules: 90 ( 91 ) 92  93 scheduler= 94 ( 95 ) 96  97  98 mysql_replication_hostgroups= 99 (100        {101                 writer_hostgroup=0102                 reader_hostgroup=1103                 comment=&quot;joah mysql&quot;104         }105 )</code></pre><p><strong>注意：配置文件中{}如果没有后续内容没有逗号。</strong></p><h3 id="本地管理"><a href="#本地管理" class="headerlink" title="本地管理"></a>本地管理</h3><p><code>[root@proxysql~]#mysql -S /tmp/proxysql_admin.sock -uadmin -p123456</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-14_155255.jpg" alt=""></p><h3 id="测试是否能支持读写分离"><a href="#测试是否能支持读写分离" class="headerlink" title="测试是否能支持读写分离"></a>测试是否能支持读写分离</h3><h4 id="授权在上述文件中设定的mysql-user"><a href="#授权在上述文件中设定的mysql-user" class="headerlink" title="授权在上述文件中设定的mysql_user"></a>授权在上述文件中设定的mysql_user</h4><blockquote><blockquote><p>MariaDB [hellodb]&gt; GRANT ALL ON <em>.</em> TO ‘joah’@’192.168.4.%’ IDENTIFIED BY ‘123456’;</p></blockquote></blockquote><p><code>[root@proxysql~]#mysql -ujoah -p -h192.168.4.64</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基于证书连接</title>
      <link href="/2017/11/28/MySQL%E5%9F%BA%E4%BA%8E%E8%AF%81%E4%B9%A6%E8%BF%9E%E6%8E%A5/"/>
      <url>/2017/11/28/MySQL%E5%9F%BA%E4%BA%8E%E8%AF%81%E4%B9%A6%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="基于证书连接"><a href="#基于证书连接" class="headerlink" title="基于证书连接"></a>基于证书连接</h2><blockquote><p>搭建私有CA</p></blockquote><p><code>[root@CA/etc/pki/CA]#echo 01 &gt; serial</code></p><p><code>[root@CA/etc/pki/CA]#touch index.txt</code></p><p><code>[root@CA/etc/pki/CA]#(umask 077;openssl genrsa -out private/cakey.pem 2048)</code>   #创建key文件</p><p><code>[root@CA/etc/pki/CA]#openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days 3650</code> #创建自签证书</p><blockquote><p>mysql创建证书文件</p></blockquote><p><code>[root@mysql~]#yum insatll -y mariadb-server</code></p><p>查看是否支持ssl</p><pre><code>MariaDB [(none)]&gt; SHOW VARIABLES LIKE &#39;%ssl%&#39;;+---------------+----------+| Variable_name | Value    |+---------------+----------+| have_openssl  | DISABLED |    #这里是支持ssl的没有启动而已| have_ssl      | DISABLED || ssl_ca        |          || ssl_capath    |          || ssl_cert      |          || ssl_cipher    |          || ssl_key       |          |+---------------+----------+</code></pre><p><code>[root@mysql/etc/my.cnf.d]#mkdir ssl</code></p><p><code>[root@mysql/etc/my.cnf.d/ssl]#(umask 077;openssl genrsa -out mysqlsrv.key 2048)</code>   #生成key文件</p><p><code>[root@mysql/etc/my.cnf.d/ssl]#openssl req -new -key mysqlsrv.key -out mysqlsrv.csr</code>   #生成证书请求文件</p><pre><code>You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &#39;.&#39;, the field will be left blank.-----Country Name (2 letter code) [XX]:CNState or Province Name (full name) []:zhengzhouLocality Name (eg, city) [Default City]:henanOrganization Name (eg, company) [Default Company Ltd]:testOrganizational Unit Name (eg, section) []:opsCommon Name (eg, your name or your server&#39;s hostname) []:www.test.comEmail Address []:Please enter the following &#39;extra&#39; attributesto be sent with your certificate requestA challenge password []:An optional company name []:</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-09_185634.jpg" alt=""></p><p><strong>注意：这里填写的内容需和CA认证中心对应</strong></p><p><code>[root@mysql/etc/my.cnf.d/ssl]#scp mysqlsrv.csr 192.168.4.63:/etc/pki/CA/newcerts/</code> #将请求认证证书发送给认证中心</p><p>认证中心对请求证书签署</p><p><code>[root@CA/etc/pki/CA]#openssl ca -in newcerts/mysqlsrv.csr -out newcerts/mysqlsrv.crt -days 365</code></p><p>将ca证书和认证证书发送到myql客户端</p><p><code>[root@CA/etc/pki/CA/newcerts]#scp mysqlsrv.crt ../cacert.pem 192.168.4.62:/etc/my.cnf.d/ssl</code></p><p>修改刚刚生成文件的权限（因为mysql是以mysql用户运行的，如果您是别的用户修改别的用户即可）</p><p><code>[root@mysql/etc/my.cnf.d/ssl]#chown mysql.mysql *</code></p><p>修改my.cnf配置文件</p><p><code>[root@mysql~]#vim /etc/my.cnf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-09_190256.jpg" alt=""></p><p>重启服务测试</p><p><code>[root@mysql~]#systemctl restart mariadb</code></p><pre><code>MariaDB [(none)]&gt; SHOW VARIABLES LIKE &#39;%ssl%&#39;;+---------------+--------------------------------+| Variable_name | Value                          |+---------------+--------------------------------+| have_openssl  | YES                            |  #此时支持ssl功能了 | have_ssl      | YES                            || ssl_ca        | /etc/my.cnf.d/ssl/cacert.pem   || ssl_capath    |                                || ssl_cert      | /etc/my.cnf.d/ssl/mysqlsrv.crt || ssl_cipher    |                                || ssl_key       | /etc/my.cnf.d/ssl/mysqlsrv.key |+---------------+--------------------------------+7 rows in set (0.00 sec)</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-09_190642.jpg" alt=""></p><blockquote><p>客户端配置</p></blockquote><p><code>[root@client~]#mkdir .mysql/ssl -pv</code>   #基于安全考虑使用隐藏目录</p><p><code>[root@client~/.mysql/ssl]#(umask 077;openssl genrsa -out mysqlcli.key 2048)</code></p><p><code>[root@client~/.mysql/ssl]#openssl req -new -key mysqlcli.key -out mysqlcli.csr</code></p><p>将请求认证文件发送到CA认证中心</p><p><code>[root@client~/.mysql/ssl]#scp mysqlcli.csr 192.168.4.63:/etc/pki/CA/newcerts/</code></p><p>认证中心对此请求证书签署</p><p><code>[root@CA/etc/pki/CA/newcerts]#openssl ca -in mysqlcli.csr -out mysqlcli.crt -days 365</code></p><p><code>[root@CA/etc/pki/CA/newcerts]#scp mysqlcli.crt ../cacert.pem 192.168.4.61:/root/.mysql/ssl</code>    #将签署证书和ca证书发送给客户端</p><p>修改配置文件</p><p><code>[root@client~]#vim /etc/my.cnf</code></p><pre><code> 11 ssl-ca=/data/ssl/cacert.pem 12 ssl-key=/data/ssl/s.key 13 ssl-cert=/data/ssl/s.crt</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-09_191533.jpg" alt=""></p><blockquote><p>测试</p></blockquote><pre><code>MariaDB [(none)]&gt; GRANT ALL ON *.* to &#39;joah&#39;@&#39;192.168.4.61&#39; IDENTIFIED BY &#39;123456&#39; REQUIRE ssl; #授权某个用户</code></pre><p><code>[root@client~]#mysql -ujoah -p -h192.168.4.62 --ssl</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-10_090345.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础一</title>
      <link href="/2017/11/28/MySQL%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
      <url>/2017/11/28/MySQL%E5%9F%BA%E7%A1%80%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。</p><h3 id="2、mariadb"><a href="#2、mariadb" class="headerlink" title="2、mariadb"></a>2、mariadb</h3><p><img src="http://owatlfstl.bkt.clouddn.com/0dd7912397dda1447af0caafb0b7d0a20cf48636.jpg" alt=""><br>MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。在存储引擎方面，使用XtraDB（英语：XtraDB）来代替MySQL的InnoDB。 MariaDB由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入Oracle的手中。MariaDB名称来自Michael Widenius的女儿Maria的名字。</p><h3 id="3、如何使用二进制安装mariadb呢？"><a href="#3、如何使用二进制安装mariadb呢？" class="headerlink" title="3、如何使用二进制安装mariadb呢？"></a>3、如何使用二进制安装mariadb呢？</h3><p>之前我们讲过使用源码编译安装DNS，其实编译安装的过程都是大同小异的，但是源码编译安装会耗费我们很多的时间，是不是如果有人把源码编译好我们直接使用该如何呢？但是这种方式有一个缺点不能自己定制自己的需求，如果你想只针对自己的需求安装那就只能使用源码编译安装了。下面我们就来看看二进制如何安装mariadb</p><blockquote><p>先从官网下载二进制包</p></blockquote><p><a href="https://downloads.mariadb.org/mariadb/10.2.8/" target="_blank" rel="noopener">https://downloads.mariadb.org/mariadb/10.2.8/</a><br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-25_142801.png" alt=""></p><blockquote><p>创建mysql用户</p></blockquote><p><code>[root@localhost mysql]# useradd -r -m -d /app/testdata -s /sbin/nologin mysql</code></p><blockquote><p>解压指定目录并创建软连接</p></blockquote><p><code>[root@localhost ~]# tar xvf mariadb-10.2.8-linux-x86_64.tar.gz -C /usr/local</code></p><p><code>[root@localhost local]# ln -sv mariadb-10.2.8-linux-x86_64/ mysql</code>     #创建软连接</p><blockquote><p>准备配置文件</p></blockquote><p><code>[root@localhost mysql]# mkdir /etc/mysql</code>  #创建目录</p><p><code>[root@localhost mysql]# cp support-files/my-large.cnf /etc/mysql/my.cnf</code>   #复制模板文件</p><p><code>[root@localhost mysql]# cd /etc/mysql/</code></p><p><code>[root@localhost mysql]# vim my.cnf</code>   #修改配置文件</p><pre><code>[mysqld]datadir         = /app/testdatainnodb_file_per_table = onskip-name_resolve = onport            = 3306socket          = /tmp/mysql.sockskip-external-lockingkey_buffer_size = 256Mmax_allowed_packet = 1Mtable_open_cache = 256sort_buffer_size = 1Mread_buffer_size = 1Mread_rnd_buffer_size = 4Mmyisam_sort_buffer_size = 64Mthread_cache_size = 8query_cache_size= 16M</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-25_144839.png" alt=""></p><blockquote><p>现在我们已经把主配置文件创建好了，但是如果现在启动的话，会出现下面情况</p></blockquote><p><code>[root@localhost~]#service mysqld start</code></p><pre><code>Redirecting to /bin/systemctl start mysqld.serviceFailed to start mysqld.service: Unit not found.</code></pre><p>我们还没有创建启动脚本呢！！！</p><p><code>[root@localhost mysql]# cp support-files/mysql.server /etc/rc.d/init.d/mysqld</code>   #将启动脚本复制到启动脚本目录下</p><p><code>[root@localhost mysql]# chkconfig --add mysqld</code>    #添加服务</p><blockquote><p>创建数据库文件</p></blockquote><p><code>[root@localhost/usr/local/mysql]#./scripts/mysql_install_db --datadir=/app/testdata --user=mysql</code>  #初始化数据库，但是这里需要注意的是这个执行文件必须在文件父目录上执行。</p><blockquote><p>这是我们尝试去启动mysqld，看看是否可以启动</p></blockquote><p><code>[root@localhost/usr/local/mysql]#service mysqld start</code></p><p>出错啦，出错啦，是什么原因呢？使我们的日志文件没有创建导致，现在我们去解决这个问题。</p><p><code>[root@localhost/usr/local/mysql]#journalctl -xe</code>   #查看日志</p><pre><code>Sep 25 15:07:28 localhost.localdomain mysqld[3756]: Starting MySQL.170925 15:07:28 mysqld_safe Logging to &#39;/var/log/mariadb/mariadb.log&#39;.</code></pre><p>如何解决这个问题呢？</p><p><code>[root@localhost/usr/local/mysql]#mkdir /var/log/mariadb</code>   </p><p><code>[root@localhost/usr/local/mysql]#touch /var/log/mariadb/mariadb.log</code>   #创建日志文件</p><p><code>[root@localhost/usr/local/mysql]#setfacl -R -m u:mysql:rwx /var/log/mariadb/</code>  #设置权限</p><p>现在我们来再尝试启动，看看能不能成功呢？</p><p><code>[root@localhost/usr/local/mysql]#service mysqld start</code></p><pre><code>Starting mysqld (via systemctl):                           [  OK  ]</code></pre><blockquote><p>高兴，终于启动了，那让我们来尽情的享用吧？</p><p>初始化数据库</p></blockquote><p><code>[root@localhost/usr/local/mysql]#/usr/local/mysql/bin/mysql_secure_installation</code></p><pre><code>NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&#39;ll need the currentpassword for the root user.  If you&#39;ve just installed MariaDB, andyou haven&#39;t set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none):   #输入现在的密码，新创建的密码为空，直接回车OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] Y  #询问是否为root创建密码New password:   #输入密码Re-enter new password: Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem.  This is intended only for testing, and to make the installationgo a bit smoother.  You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] Y     #是否移除匿名用户 ... Success!Normally, root should only be allowed to connect from &#39;localhost&#39;.  Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] Y   #是否远程root 登录 ... Success!By default, MariaDB comes with a database named &#39;test&#39; that anyone canaccess.  This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] N  #是否移除test数据库 ... skipping.Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] Y    #是否立即生效 ... Success!Cleaning up...All done!  If you&#39;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB!</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-25_151756.png" alt=""></p><p>咦，有出错了，先哭会，再解决；这个原因是我们没有设置mysql路径，那么我们来设置下喽。</p><p><code>[root@localhost/usr/local/mysql]#vim /etc/profile.d/mysql.sh</code>  #写路径</p><pre><code>export PATH=/usr/local/mysql/bin:$PATH</code></pre><p><code>[root@localhost/usr/local/mysql]#source /etc/profile.d/mysql.sh</code>  #使其生效。</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-25_152238.png" alt=""></p><p>如果您出现上图所示内容，说明你已经成功，来给自己鼓个掌。</p><hr><p>安装过程中有没有注意到，为什么我们要创建/etc/mysql/目录来创建配置文件呢？</p><p>在mysql中配置文件查找次序：后面的会覆盖前面的配置文件</p><p>/etc/my.cnf–&gt;/etc/mysql/my.cnf–&gt;–default-extra-file=/PATH/TO/CONF_FILE–&gt;/.my.cnf</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>创建两张表一个学生基本信息如ID、姓名、性别、年龄。另一张表为学生的成绩ID、姓名、成绩</p><p><code>MariaDB [student]&gt; CREATE TABLE information(ID TINYINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,name VARCHAR(20) NOT NULL,age TINYINT UNSIGNED)</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-25_155147.png" alt=""></p><p><code>MariaDB [student]&gt; CREATE TABLE score (ID TINYINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,name VARCHAR(20) NOT NULL , scores INT NOT NULL);</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-25_155325.png" alt=""></p><h2 id="授权用户"><a href="#授权用户" class="headerlink" title="授权用户"></a>授权用户</h2><p><code>MariaDB [mysql]&gt; SELECT user,host,password FROM user;</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-25_155817.png" alt=""></p><p>如何给创建用户并添加密码呢？</p><p><code>MariaDB [(none)]&gt; CREATE USER &#39;li&#39;@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;123456&#39;;</code></p><p><code>MariaDB [(none)]&gt; CREATE USER &#39;wang&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</code></p><p>如何更改口令呢？</p><p><code>MariaDB [(none)]&gt; UPDATE mysql.user SET PASSWORD = PASSWORD(&#39;123456&#39;) WHERE USER = &#39;li&#39;;</code></p><p><code>MariaDB [(none)]&gt; SET PASSWORD FOR &#39;li&#39;@&#39;192.168.4.%&#39; = PASSWORD(&#39;123456&#39;);</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-25_160947.png" alt=""></p><p>在一台主机上远程登录，可以登了，但是看不到数据库</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-25_161506.png" alt=""></p><p>那么如何才可以使其使用呢？那必须授权此用户操作。</p><p><code>MariaDB [(none)]&gt; GRANT SELECT,DELETE ON student.* TO &#39;li&#39;@&#39;192.168.4.%&#39;;</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-25_164953.png" alt=""></p><p><code>MariaDB [(none)]&gt; REVOKE ALL ON student.* FROM &#39;li&#39;@&#39;192.168.4.%&#39;;</code>    #当有一天这个人离职了，需要收回特权。</p><p>**注意：mariadb服务进程启动时会读取mysql库中的所有授权表至内存中。</p><blockquote><p>(1)GRANT或REVOKE等执行权限操作会保存于系统表汇总，mariadb的服务进程通常自动重读授权表，使其生效。<br>（2）对于不能够或不能及时重读授权表的命令，可手动让mariadb的服务进行重复授权表。<code>FLUSH PRIVILEGES</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基于SSL实现主从复制</title>
      <link href="/2017/11/28/MySQL%E5%9F%BA%E4%BA%8ESSL%E5%AE%9E%E7%8E%B0%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2017/11/28/MySQL%E5%9F%BA%E4%BA%8ESSL%E5%AE%9E%E7%8E%B0%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="mysql数据库基于SSL实现主从复制"><a href="#mysql数据库基于SSL实现主从复制" class="headerlink" title="mysql数据库基于SSL实现主从复制"></a>mysql数据库基于SSL实现主从复制</h2><p>实验环境：</p><p>node1:192.168.4.61</p><p>node2:192.168.4.62</p><p>CA：192.168.4.63</p><h3 id="node1和node2时间同步"><a href="#node1和node2时间同步" class="headerlink" title="node1和node2时间同步"></a>node1和node2时间同步</h3><p><code>[root@node1~]#ntpdate 172.18.0.1</code></p><p><code>[root@node2~]#ntpdate 172.18.0.1</code></p><p><code>[root@node1~]#vim /etc/chrony.conf</code>   #node1和node2操作一样</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_184716.jpg" alt=""></p><p><code>[root@node1~]#systemctl start chronyd.service</code> #启动服务</p><h3 id="node1和node2基于key连接"><a href="#node1和node2基于key连接" class="headerlink" title="node1和node2基于key连接"></a>node1和node2基于key连接</h3><p><code>[root@node1~]#ssh-keygen</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-12_100027.jpg" alt=""></p><p><code>[root@node1~]#ssh-copy-id -i /root/.ssh/id_rsa.pub 192.168.4.62</code>   #将公钥复制到node2上</p><p>node2操作和node1操作相同。</p><h3 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改hosts文件</h3><p>node1和node2配置相同</p><p><code>[root@node1~]#vim /etc/hosts</code></p><pre><code>  3 192.168.4.61 node1 4 192.168.4.62 node2</code></pre><h3 id="确保关闭iptables和selinux"><a href="#确保关闭iptables和selinux" class="headerlink" title="确保关闭iptables和selinux"></a>确保关闭iptables和selinux</h3><h3 id="node1和node2安装mariadb数据库"><a href="#node1和node2安装mariadb数据库" class="headerlink" title="node1和node2安装mariadb数据库"></a>node1和node2安装mariadb数据库</h3><p><code>[root@node1~]#yum install -y mariadb-server</code></p><p><code>[root@node2~]#yum install -y mariadb-server</code></p><h3 id="配置node1为主服务器"><a href="#配置node1为主服务器" class="headerlink" title="配置node1为主服务器"></a>配置node1为主服务器</h3><p><code>[root@node1~]#vim /etc/my.cnf.d/server.cnf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-12_102328.jpg" alt=""></p><p><code>[root@node1~]#systemctl start mariadb</code> #启动mariadb服务</p><pre><code>MariaDB [(none)]&gt; GRANT REPLICATION CLIENT,REPLICATION SLAVE ON *.* TO &#39;joah&#39;@&#39;192.168.4.62&#39; IDENTIFIED BY &#39;123456&#39;;  #对用户授权</code></pre><h5 id="查看是否开启二进制日志"><a href="#查看是否开启二进制日志" class="headerlink" title="查看是否开启二进制日志"></a>查看是否开启二进制日志</h5><pre><code>MariaDB [(none)]&gt; SHOW VARIABLES LIKE &#39;%log%bin%&#39;;</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-12_103625.jpg" alt=""></p><h5 id="在node1上二进制日志状态信息"><a href="#在node1上二进制日志状态信息" class="headerlink" title="在node1上二进制日志状态信息"></a>在node1上二进制日志状态信息</h5><pre><code>MariaDB [(none)]&gt; SHOW MASTER STATUS;</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-12_103831.jpg" alt=""></p><h3 id="配置node2从服务器"><a href="#配置node2从服务器" class="headerlink" title="配置node2从服务器"></a>配置node2从服务器</h3><p><code>[root@node2~]#vim /etc/my.cnf.d/server.cnf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-12_103127.jpg" alt=""></p><p><code>[root@node2~]#systemctl start mariadb</code> #启动mariadb服务</p><pre><code>MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_HOST=&#39;192.168.4.61&#39;,MASTER_USER=&#39;joah&#39;,MASTER_PASSWORD=&#39;123456&#39;,MASTER_LOG_FILE=&#39;master-log.000003&#39;,MASTER_LOG_POS=417;   #设置连接主服务器</code></pre><h5 id="启动从服务器"><a href="#启动从服务器" class="headerlink" title="启动从服务器"></a>启动从服务器</h5><pre><code>MariaDB [(none)]&gt; START SLAVE;</code></pre><h5 id="启动IO线程和SQL线程"><a href="#启动IO线程和SQL线程" class="headerlink" title="启动IO线程和SQL线程"></a>启动IO线程和SQL线程</h5><pre><code>MariaDB [(none)]&gt; START SLAVE IO_THREAD,SQL_THREAD;</code></pre><h5 id="查看从服务器状态"><a href="#查看从服务器状态" class="headerlink" title="查看从服务器状态"></a>查看从服务器状态</h5><pre><code>MariaDB [(none)]&gt; START SLAVE IO_THREAD,SQL_THREAD;</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-12_104235.jpg" alt=""></p><p>######如果出现图中红框中的信息说明已经启动成功。</p><p>#####测试是否已经实现主从复制</p><p><img src="http://owatlfstl.bkt.clouddn.com/MYSQL8.gif" alt=""></p><h2 id="实现SSL功能"><a href="#实现SSL功能" class="headerlink" title="实现SSL功能"></a>实现SSL功能</h2><h3 id="搭建CA服务器"><a href="#搭建CA服务器" class="headerlink" title="搭建CA服务器"></a>搭建CA服务器</h3><p><code>[root@CA/etc/pki/CA]#touch index.txt</code></p><p><code>[root@CA/etc/pki/CA]#echo 01 &gt; serial</code></p><h5 id="生成key文件"><a href="#生成key文件" class="headerlink" title="生成key文件"></a>生成key文件</h5><p><code>[root@CA/etc/pki/CA]#(umask 077;openssl genrsa -out private/cakey.pem 2048)</code>   </p><h5 id="生成自签证书"><a href="#生成自签证书" class="headerlink" title="生成自签证书"></a>生成自签证书</h5><p><code>[root@CA/etc/pki/CA]#openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days 3650</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-12_105240.jpg" alt=""></p><h3 id="node1生成证书"><a href="#node1生成证书" class="headerlink" title="node1生成证书"></a>node1生成证书</h3><p><code>[root@node1~]#mkdir /etc/mysql/ssl -pv</code></p><p><code>[root@node1~]#chown mysql.mysql /etc/mysql/ssl/ -R</code></p><p><code>[root@node1/etc/mysql/ssl]#(umask 077;openssl genrsa -out master.key 2048)</code><br><code>[root@node1/etc/mysql/ssl]#openssl req -new -key master.key -out master.csr</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-12_105731.jpg" alt=""></p><p><code>[root@node1/etc/mysql/ssl]#scp master.csr 192.168.4.63:/etc/pki/CA/newcerts/</code></p><p><code>[root@CA/etc/pki/CA/newcerts]#openssl ca -in master.csr -out master.crt -days 365</code></p><p><code>[root@CA/etc/pki/CA/newcerts]#scp master.crt ../cacert.pem 192.168.4.61:/etc/mysql/ssl</code></p><p><code>[root@node1~]#vim /etc/my.cnf.d/server.cnf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-12_110431.jpg" alt=""></p><p><code>[root@node1~]#systemctl restart mariadb</code></p><h5 id="查看是否开启SSL功能"><a href="#查看是否开启SSL功能" class="headerlink" title="查看是否开启SSL功能"></a>查看是否开启SSL功能</h5><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-12_112330.jpg" alt=""></p><h3 id="node2生成证书"><a href="#node2生成证书" class="headerlink" title="node2生成证书"></a>node2生成证书</h3><p><code>[root@node2~]#mkdir /etc/mysql/ssl -pv</code></p><p><code>[root@node2~]#chown mysql.mysql /etc/mysql/ssl/ -R</code></p><p><code>[root@node2/etc/mysql/ssl]#(umask 077;openssl genrsa -out slave.key 2048)</code></p><p><code>[root@node2/etc/mysql/ssl]#openssl req -new -key slave.key -out slave.csr</code></p><p><code>[root@node2/etc/mysql/ssl]#scp slave.csr 192.168.4.63:/etc/pki/CA/newcerts</code></p><p><code>[root@CA/etc/pki/CA/newcerts]#openssl ca -in slave.csr -out slave.crt -days 365</code></p><p><code>[root@CA/etc/pki/CA/newcerts]#scp slave.crt ../cacert.pem 192.168.4.62:/etc/mysql/ssl</code></p><p><code>[root@node2/etc/mysql/ssl]#vim /etc/my.cnf.d/server.cnf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-12_111654.jpg" alt=""></p><h5 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h5><p><code>[root@node2/etc/mysql/ssl]#systemctl restart mariadb</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-12_112637.jpg" alt=""></p><h3 id="基于SSL连接"><a href="#基于SSL连接" class="headerlink" title="基于SSL连接"></a>基于SSL连接</h3><h4 id="node1授权"><a href="#node1授权" class="headerlink" title="node1授权"></a>node1授权</h4><pre><code>MariaDB [(none)]&gt; GRANT REPLICATION CLIENT,REPLICATION SLAVE ON *.* TO &#39;joah&#39;@&#39;192.168.4.62&#39; IDENTIFIED BY &#39;123456&#39; REQUIRE SSL;</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><code>[root@node2~]#mysql -ujoah -p123456 -h192.168.4.61 --ssl</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-12_115615.jpg" alt=""></p><h4 id="node2连接主服务器以ssl复制"><a href="#node2连接主服务器以ssl复制" class="headerlink" title="node2连接主服务器以ssl复制"></a>node2连接主服务器以ssl复制</h4><pre><code>MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_HOST=&#39;192.168.4.61&#39;,MASTER_USER=&#39;joah&#39;,MASTER_PASSWORD=&#39;123456&#39;,MASTER_LOG_FILE=&#39;master-log.000008&#39;,MASTER_LOG_POS=429,MASTER_SSL=1,MASTER_SSL_CA=&#39;/etc/mysql/ssl/cacert.pem&#39;,MASTER_SSL_CERT=&#39;/etc/mysql/ssl/slave.crt&#39;,MASTER_SSL_KEY=&#39;/etc/mysql/ssl/slave.key&#39;;MariaDB [(none)]&gt; START SLAVE;  #启动从服务器MariaDB [(none)]&gt; SHOW SLAVE STATUS\G;</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-12_120029.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/MYSQL9.gif" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>（1）如果你已经正确的添加了证书，但是启动以后还是没有启动SSL功能，有可能没有权限</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-12_114037.jpg" alt=""></p><p><code>[root@node2~]#chown mysql.mysql -R /etc/mysql/ssl</code></p><p>（2）如果出现图片中的问题，停止slave即可</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-12_113938.jpg" alt=""></p><p>（3）每一个过程中都需要验证是否成功然后进行下面的操作。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL备份与恢复</title>
      <link href="/2017/11/28/MySQL%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
      <url>/2017/11/28/MySQL%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="mysql备份和恢复（数据）："><a href="#mysql备份和恢复（数据）：" class="headerlink" title="mysql备份和恢复（数据）："></a>mysql备份和恢复（数据）：</h2><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>存储的数据副本；原始数据：持续改变。</p><h4 id="备份原因："><a href="#备份原因：" class="headerlink" title="备份原因："></a>备份原因：</h4><p>灾难恢复：硬件故障（冗余）、软件故障（bug）、自然灾害、黑客攻击、误操作等等。</p><h4 id="备份时应注意事项"><a href="#备份时应注意事项" class="headerlink" title="备份时应注意事项"></a>备份时应注意事项</h4><ul><li>能容忍最多丢失多少数据</li><li>恢复数据需要在多长时间内完成</li><li>需要恢复哪些数据</li></ul><h4 id="备份类型"><a href="#备份类型" class="headerlink" title="备份类型"></a>备份类型</h4><ul><li><p>备份的数据集的范围：</p><p>  完全备份：整个数据集<br>  部分备份：数据集的一部分，比如部分表等</p></li><li><p>全量备份、增量备份、差异备份：</p><p>  完成备份：整个数据集、文件等<br>  增量备份：仅备份自上一次完全备份或增量备份以来变量的那部分数据<br>  差异备份：仅备份自上一次完成备份以来的那部分数据</p></li><li><p>物理备份、逻辑备份：</p><p>  物理备份：复制数据文件进行的备份<br>  逻辑备份：从数据库导出数据另存在一个或多个文件</p></li></ul><p>根据数据服务是否在线：</p><pre><code>热备：读写操作均可进行的状态下所做的备份温备：可读但不可写状态下进行的备份冷备：读写操作不可进行的状态下所做的备份</code></pre><h4 id="备份需要考虑因素："><a href="#备份需要考虑因素：" class="headerlink" title="备份需要考虑因素："></a>备份需要考虑因素：</h4><p>锁定资源多长时间？</p><p>备份过程的时长？</p><p>备份时的服务器负载？</p><p>恢复过程的时长？</p><h4 id="备份策略："><a href="#备份策略：" class="headerlink" title="备份策略："></a>备份策略：</h4><ul><li>全量+差异+binlogs</li><li>全量+增量+binlogs</li></ul><h4 id="备份内容："><a href="#备份内容：" class="headerlink" title="备份内容："></a>备份内容：</h4><ul><li>数据</li><li>二进制日志、InnoDB的事物日志</li><li>代码（存储过程、存储函数、触发器、时间调度器）</li><li>服务器的配置文件</li></ul><h4 id="备份工具："><a href="#备份工具：" class="headerlink" title="备份工具："></a>备份工具：</h4><ul><li>mysqldump  </li></ul><p>mysql服务自带的备份工具；逻辑备份工具</p><pre><code>InnoDB:支持热备、温备、冷备MyISAM：支持温备、冷备；备份时要锁定表</code></pre><h4 id="mysqldump命令"><a href="#mysqldump命令" class="headerlink" title="mysqldump命令"></a>mysqldump命令</h4><p>使用格式：</p><pre><code>mysqldump [OPTIONS] database [tables]   备份单库，可以只备份其中一部分表（部分备份）OR     mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...]  备份多库OR     mysqldump [OPTIONS] --all-databases [OPTIONS]   备份所有库</code></pre><p>选项：</p><pre><code>-x，--lock-all-tables：锁定所有库的所有表，读锁-l，--lock-talbes：锁定指定库所有表--single-transaction：创建一个事物，基于快照执行备份-R，--routines：备份指定库的存储过程和存储函数--triggers：备份指定库的触发器-E，--events：备份事务--master-data[=#]        1 ：记录为CHANGE MASTER TO语句，此语句不被注释        2：记录为CHANGE MASTER TO 语句，此语句被注释--flush-logs：锁定表完成后，即进行日志刷新操作</code></pre><p><strong>示例：</strong></p><blockquote><p>只备份某个库某张表</p></blockquote><p><code>[root@client~]#mysqldump -uroot -h 192.168.4.62 -p --databases  hellodb --tables classes</code></p><blockquote><p>只备份某个库的多张表</p></blockquote><p><code>[root@client~]#mysqldump -uroot -h 192.168.4.62 -p --databases  hellodb --tables classes coc</code></p><blockquote><p>备份多个库</p></blockquote><p><code>[root@client~]#mysqldump -uroot -h 192.168.4.62 -p --databases  hellodb mysql</code></p><blockquote><p>备份所有库</p></blockquote><p><code>[root@client~]#mysqldump -uroot -p -h192.168.4.62 --all-databases</code></p><blockquote><p>备份时锁定指定库的所有表</p></blockquote><p><code>[root@client~]#mysqldump -uroot -p -h192.168.4.62 --databases hellodb -l</code></p><blockquote><p>备份创建一个事物并锁定指定库所有表</p></blockquote><p><code>[root@client~]#mysqldump -uroot -p -h192.168.4.62 --databases hellodb -l --single-transaction</code></p><blockquote><p>如果锁定某个时间点如何做？</p></blockquote><p><code>[root@client~]#mysqldump -uroot -p -h192.168.4.62 --databases hellodb --tables classes -l --single-transaction --master-data=2 --triggers -E  &gt;test.sqll</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_101948.jpg" alt=""></p><p>这样我们就可以支持从哪个binlog日志中回复并从那个点回复</p><p><strong>实战：</strong></p><p>将一个数据库复制然后恢复，如何操作？</p><p>（1）在远程主机上dump</p><p><code>[root@client~]#mysqldump -uroot -p -h192.168.4.62 --all-databases --master-data=2 --triggers -E  --single-transaction -R --flush-logs &gt;test.sql</code> </p><p>如果有远程存储服务器可以存储到此服务器上。</p><p>（2）模拟数据库奔溃</p><p><code>[root@mysql~]#systemctl stop mariadb</code></p><p><code>[root@mysql~]#rm -rf /var/lib/mysql/</code></p><p>（3）恢复数据库</p><p><code>[root@client~]#scp test.sql 192.168.4.62:root</code> #将备份文件拷贝到mysql服务器上</p><p>创建数据库存放位置</p><p><code>[root@mysql~]#mkdir /var/lib/mysql</code></p><p><code>[root@mysql~]#chown mysql.mysql /var/lib/mysql</code>    #修改所有者所属组</p><p>先关闭此会话binlog日志功能</p><pre><code>MariaDB [(none)]&gt; SET @@session.sql_log_bin=OFF；MariaDB [(none)]&gt; SELECT @@session.sql_log_bin      #查询是否关闭</code></pre><p>导入文件</p><p><code>[root@mysql~]#mysql &lt; test.sql</code></p><p>查看此时时从哪个时间点记录的</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_105541.jpg" alt=""></p><p>使用binlog日志恢复此后的内容</p><p><code>[root@mysql/app/data/binlog]#mysqlbinlog master-log.000001 -j 245 &gt; /tmp/testbin.sql</code></p><p>这里防止到tmp目录下，对所用用户都可以访问，如果您想放到别的目录下，如果使用下面操作需对mysql用户授权</p><pre><code>MariaDB [(none)]&gt; \. /tmp/testbin.sql 导入数据库MariaDB [hellodb]&gt; SHOW DATABASES;+--------------------+| Database           |+--------------------+| information_schema || hellodb            || mysql              || performance_schema || test               |+--------------------+5 rows in set (0.01 sec)</code></pre><p>至此已经完成恢复</p><blockquote><p>开启binlog日志功能</p></blockquote><pre><code>MariaDB [hellodb]&gt; SET @@session.sql_log_bin=ON;</code></pre><ul><li>cp/tar</li></ul><p>基于lvm，快照（请求一个全局锁），之后立即释放锁，达到几乎热备的效果，物理备份</p><p><strong>注意：不能仅备份数据；同时备份事物日志；并且要求数据文件和事物日志位于同一个逻辑卷。</strong></p><p><strong>实战：</strong></p><blockquote><p>创建逻辑卷</p></blockquote><p><code>[root@localhost~]#fdisk /dev/sdb</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_112640.jpg" alt=""></p><p>同步磁盘</p><p><code>[root@localhost~]#partprobe /dev/sdb</code></p><p>创建物理卷</p><p><code>[root@localhost~]#pvcreate /dev/sdb{1,2}</code></p><p><code>[root@localhost~]#pvdisplay</code></p><p>创建卷组</p><p><code>[root@localhost~]#vgcreate mysqldisk /dev/sdb{1,2}</code></p><p><code>[root@localhost~]#vgdisplay</code></p><p>创建逻辑卷</p><p><code>[root@localhost~]#lvcreate -L 15 -n mysqlv mysqldisk /dev/sdb{1,2}</code></p><p><code>[root@localhost~]#lvdisplay</code></p><p>格式化</p><p><code>[root@localhost~]#mke2fs -t ext4 /dev/mysqldisk/mysqlv</code></p><p>挂载</p><p><code>[root@localhost~]#mkdir /data/mysql</code></p><p><code>[root@localhost~]#mount /dev/mysqldisk/mysqlv /data/mysql/</code></p><blockquote><p>修改mysql数据和日志存放位置</p></blockquote><p><code>[root@localhost~]#chown mysql.mysql /data/mysql/</code></p><p><code>[root@localhost~]#vim /etc/my.cnf</code><br><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_150127.jpg" alt=""></p><p><code>[root@localhost~]#vim /etc/my.cnf.d/server.cnf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_150333.jpg" alt=""></p><blockquote><p>请求锁定所有表</p></blockquote><pre><code>MariaDB [hellodb]&gt; FLUSH TABLES WITH READ LOCK;</code></pre><blockquote><p>查看二进制日志</p></blockquote><pre><code>MariaDB [hellodb]&gt; FLUSH LOGS;MariaDB [hellodb]&gt; SHOW MASTER STATUS;</code></pre><blockquote><p>创建快照卷</p></blockquote><p><code>[root@localhost~]#lvcreate -L 2G -s -p r -n mysql /dev/mysqldisk/mysqlv</code></p><blockquote><p>释放锁</p></blockquote><pre><code>MariaDB [hellodb]&gt; UNLOCK TABLES;</code></pre><blockquote><p>挂载快照，并执行备份，备份完后删除快照卷</p></blockquote><p>创建临时挂载点并挂载快照</p><p><code>[root@localhost~]#mkdir /test</code></p><p><code>[root@localhost~]#mount /dev/mysqldisk/mysnap /test/</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_155635.jpg" alt=""></p><p>如果有远程存储可以将内容存储到远程服务器上</p><p><code>[root@localhost~]#mkdir /backup/mysql -pv</code> #创建一个备份目录</p><p><code>[root@localhost~]#cp -a /test/* /backup/mysql</code></p><p>卸载挂载点并删除快照</p><p><code>[root@localhost~]#umount /test/</code></p><p><code>[root@localhost~]#lvremove /dev/mysqldisk/mysnap</code></p><blockquote><p>周期性备份二进制日志并将文件放置到远程存储服务器上</p></blockquote><p><code>[root@localhost/data/mysql]#mysqlbinlog master-log.000003 &gt; test.sql</code>  </p><blockquote><p>如果库被删除如何恢复？</p></blockquote><p><code>[root@localhost~]#rm -rf /data/mysql/*</code></p><p><code>[root@localhost~]#cp /backup/mysql/* /data/mysql/ -a</code></p><p><code>[root@localhost~]#mysql &lt; test.sql</code></p><p>至此数据库就恢复完成了。</p><p>如果需要将文件压缩打包传送到远程服务器，可以使用如下命令：</p><p><code>[root@localhost~]#tar cvf mysql.tar /backup/mysql/*</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL日志</title>
      <link href="/2017/11/28/MySQL%E6%97%A5%E5%BF%97/"/>
      <url>/2017/11/28/MySQL%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>##mysql日志</p><h3 id="mysql日志分类"><a href="#mysql日志分类" class="headerlink" title="mysql日志分类"></a>mysql日志分类</h3><ul><li>查询日志：general_log</li><li>慢查询日志：log_slow_queries</li><li>错误日志：log_error，log_warnings</li><li>二进制日志：binlog</li><li>中继日志：relay_log</li><li>事物日志：innodb_log</li></ul><h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>记录查询语句日志存储位置：</p><pre><code>文件：file表：table（mysql.general_log）</code></pre><p>选项：</p><pre><code>general_log={ON|OFF}：是否开启日志查询功能general_log_file=HOSTNAME.log：如果日志以文件存储，此时指定存放日志的文件；并且日志文件名称以主机名.log命名log_output={FILE|TABLE|NONE}：指定日志输出的格式</code></pre><p><strong>注意：查询日志一般不建议开启。</strong></p><p><strong>示例：</strong></p><blockquote><p>基于file存储</p></blockquote><h4 id="查看mysql是否开启日志存储功能"><a href="#查看mysql是否开启日志存储功能" class="headerlink" title="查看mysql是否开启日志存储功能"></a>查看mysql是否开启日志存储功能</h4><pre><code>MariaDB [(none)]&gt; SHOW VARIABLES LIKE &#39;general_log%&#39;;</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-10_192945.jpg" alt=""></p><h4 id="开启日志存储功能并以file存储"><a href="#开启日志存储功能并以file存储" class="headerlink" title="开启日志存储功能并以file存储"></a>开启日志存储功能并以file存储</h4><pre><code>MariaDB [(none)]&gt; SHOW VARIABLES LIKE &#39;log_output&#39;; #查看以日志存储以什么形式存储</code></pre><p>如果没有以file格式存储则通过如下方式开启即可</p><pre><code>MariaDB [hellodb]&gt; SET @@global.log_output=FILE;</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-10_193324.jpg" alt=""></p><pre><code>MariaDB [(none)]&gt; SET @@global.general_log=ON;  #开启查询日志存储功能</code></pre><blockquote><p>测试是否我们执行操作时记录日志中</p></blockquote><pre><code>MariaDB [hellodb]&gt; INSERT INTO students (StuID,Name,Age,Gender,ClassID,TeacherID) VALUES (26,&quot;xiao li&quot;,25,&quot;F&quot;,5,24);</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-10_195347.jpg" alt=""></p><blockquote><p>基于table存储查询日志</p></blockquote><h4 id="设置为以table存储"><a href="#设置为以table存储" class="headerlink" title="设置为以table存储"></a>设置为以table存储</h4><pre><code>MariaDB [hellodb]&gt; SET @@global.log_output=&quot;TABLE&quot;; MariaDB [hellodb]&gt; SHOW VARIABLES LIKE &#39;log_output&#39;;    #查询是否设置成功+---------------+-------+| Variable_name | Value |+---------------+-------+| log_output    | TABLE |+---------------+-------+</code></pre><h4 id="测试是否已经启动table记录查询日志"><a href="#测试是否已经启动table记录查询日志" class="headerlink" title="测试是否已经启动table记录查询日志"></a>测试是否已经启动table记录查询日志</h4><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-10_200114.jpg" alt=""></p><pre><code>event_time：时间发生时间user_host：用户和主机thread_id：线程IDserver_id：服务IDcommand_type：命令类型argument：参数</code></pre><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>慢查询：运行时间超出指定时长的查询</p><p>选项：</p><pre><code>long_query_time：慢查询等待时长log_slow_queries={ON|OFF}：日志是否开启慢查询功能slow_query_log={ON|OFF}：是否开启慢查询功能slow_query_log_file：慢查询文件log_output={FILE|TABLE|NONE}：慢查询类型log_slow_filter=admin,filesort,filesort_on_disk,full_join,full_scan,query_cache,query_cache_miss,tmp_table,tmp_table_on_disk 慢查询过滤log_slow_rate_limit：慢查询速率限制log_slow_verbosity</code></pre><p>查看默认值</p><pre><code>MariaDB [mysql]&gt; SHOW VARIABLES LIKE &#39;long_query_time&#39;;+-----------------+-----------+| Variable_name   | Value     |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+</code></pre><p>存储位置</p><pre><code>文件：FILE表：TABLE,mysql.slog_log</code></pre><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志记录如下几类信息：</p><pre><code>（1）mysqld启动和关闭过程中输出的信息（2）mysqld运行中产生的错误信息（3）event scheduler运行时产生的信息，相当于周期性计划（4）主从复制架构中，从服务器复制线程启动时产生的日志</code></pre><p>选项：</p><pre><code>log_error=/var/log/mariadb/mariadb.log|log  #是否开启错误日志log_warnings={ON|OFF}：是否开启警告日志</code></pre><p><strong>示例：</strong></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-10_202724.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-10_202858.jpg" alt=""></p><p><strong>建议：开启错误日志功能，方便以后排错</strong></p><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>用于记录引起数据改变或存在引起数据改变的潜在可能性的语句（STATEMENT）或改变后的结果（ROW）,也可能是二者混合。</p><p>作用：实现重放，恢复到某个时间点。</p><p>选项：</p><pre><code>binlog_format={STATEMENT|ROW|MIXED} #二进制日志格式log_bin=/PATH/TO/BIN_LOG_FILE   定义二进制日志存放位置session.sql_log_bin={ON|OFF}：控制某回话中的”写“操作语句是否会被记录于日志文件中max_binlog_size 二进制文件最大容量sync_binlog={1|0}：是否同步到磁盘中，binlogs先缓冲在内存中，不会立即写入磁盘中，开启此选项是否直接写入磁盘中。</code></pre><p>查看二进制日志文件中的事件语法：</p><pre><code>SHOW BINLOG EVENTS     [IN &#39;log_name&#39;] [FROM pos] [LIMIT [offset,] row_count]</code></pre><p><strong>示例：</strong></p><blockquote><p>创建二进制日志存放位置</p></blockquote><p><code>[root@mysql~]#mkdir /app/data/binlog -pv</code></p><p><code>[root@mysql~]#chown -R mysql.mysql /app/data/binlog/</code>  #对mysql用户赋予权限</p><blockquote><p>修改服务端配置文件启动二进制日志功能</p></blockquote><p><code>[root@mysql~]#vim /etc/my.cnf.d/server.cnf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-10_210609.jpg" alt=""></p><p><strong>注意：二进制文件自动会加后缀</strong></p><blockquote><p>重启mysql服务</p></blockquote><p><code>[root@mysql~]#systemctl restart mariadb</code></p><blockquote><p>查看是否启动二进制功能</p></blockquote><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-10_210958.jpg" alt=""></p><blockquote><p>测试是否已经可以使用二进制日志功能</p></blockquote><p>执行一些语句</p><pre><code>MariaDB [hellodb]&gt; SELECT * FROM courses;</code></pre><p>查看是否生成二进制文件</p><p><code>[root@mysql/app/data/binlog]#ls</code></p><pre><code>master-log.000001  master-log.index</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-10_211309.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-10_211815.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-10_212021.jpg" alt=""></p><blockquote><p>查看二进制内容方法</p></blockquote><p><code>[root@mysql/app/data/binlog]#mysqlbinlog master-log.000001</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-10_212302.jpg" alt=""></p><pre><code>事件的起始位置：# at NUMBER事件发生的日期时间：#171110 21:07:44事件发生的服务器ID：server id 1 事件的结束位置： end_log_pos 427事件的类型：Query事件发生时所在服务器执行此时间的线程ID：thread_id=2语句的时间戳与将其写入二进制日志文件中的时间差：exec_time=0错误代码：error_code=0设定时间发生的时间戳：SET TIMESTAMP=1510320590/*!*/;   事件内容</code></pre><h3 id="中继日志："><a href="#中继日志：" class="headerlink" title="中继日志："></a>中继日志：</h3><p>从服务器上记录下来从主服务器的二进制日志文件同步过来的事件</p><h3 id="事物日志："><a href="#事物日志：" class="headerlink" title="事物日志："></a>事物日志：</h3><p>事物型存储引擎innodb用于保证事物特性的日志文件</p><p><strong>注意：如果我们使用二进制日志回放，建议关闭此时会话记录二进制日志。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主从复制</title>
      <link href="/2017/11/28/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2017/11/28/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="实战："><a href="#实战：" class="headerlink" title="实战："></a>实战：</h2><p>实现主从复制</p><p>node1为主，node2为从</p><h3 id="在node1操作"><a href="#在node1操作" class="headerlink" title="在node1操作"></a>在node1操作</h3><p><code>[root@node1~]#vim /etc/my.cnf.d/server.cnf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_205828.jpg" alt=""></p><p><code>[root@node1~]#systemctl start mariadb</code></p><h3 id="在node2操作"><a href="#在node2操作" class="headerlink" title="在node2操作"></a>在node2操作</h3><p><code>[root@node2~]#vim /etc/my.cnf.d/server.cnf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_210220.jpg" alt=""></p><p><code>[root@node2~]#systemctl start mariadb</code> </p><p>在node1进行授权</p><pre><code>MariaDB [(none)]&gt; GRANT REPLICATION CLIENT,REPLICATION SLAVE ON *.* TO &#39;joah&#39;@&#39;192.168.4.62&#39; IDENTIFIED BY &#39;123456&#39;;</code></pre><p>在node2</p><pre><code>MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_HOST=&#39;192.168.4.61&#39;,MASTER_USER=&#39;joah&#39;,MASTER_PASSWORD=&#39;123456&#39;,MASTER_LOG_FILE=&#39;master-log.000004&#39;,MASTER_LOG_POS=417;MariaDB [(none)]&gt; START SLAVE;  #启动从服务器MariaDB [(none)]&gt; SHOW SLAVE STATUS\G;  #查看从服务器状态</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_211409.jpg" alt=""></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><code>[root@node1~]#mysql &lt; hellodb.sql</code></p><p>在node1中查看</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_211603.jpg" alt=""></p><p>在node2中查看</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_211603.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL工作方式</title>
      <link href="/2017/11/28/MySQL%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/"/>
      <url>/2017/11/28/MySQL%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-08_194038.jpg" alt=""></p><p>##1、mysql读取配置文件次序</p><p>###my_print_defaults<br>display options from option files</p><p>使用方法：</p><pre><code>my_print_defaults [options] option_group ...</code></pre><p>选项：</p><pre><code>--defaults-file=file_name   #修改默认读取的配置文件--defaults-extra-file=path  #在读取的默认配置文件之外再加载一个文件</code></pre><p><code>[root@localhost~]#my_print_defaults --version</code> #打印出信息</p><p>Default options are read from the following files in the given order 读取多出的多个配置文件，而且以指定的次序进行:</p><pre><code>/etc/mysql/my.cnf /etc/my.cnf ~/.my.cnf </code></pre><p>不同的配置文件中出现同一个参数且拥有不同值时，后读取配置文件中的参数将为最终生效值。<br>-</p><p>##2、mysqld服务器程序工作特性</p><p>###服务器变量类型</p><p><strong>全局（global）：</strong>对所有会话生效；所有的会话在建立时都从全局继承，但继承完成后每个会话独立维护自己会话级变量；修改时需要管理权限。</p><p><strong>会话（session）：</strong>仅对当前会话有效；修改此变量即可生效并且不需要有管理权限。</p><p>####修改变量的方法：</p><p><strong>动态修改：</strong>会话级别，并且立即生效；全局级别，新建立的会话有效，对此前已经连接的会话无效。</p><p><strong>静态修改：</strong>修改配置文件，或修改传递给mysqld的选项的值，重启后生效。</p><p>#####上述的修改访问不能永久保存，如果需要永久保存需要写入配置文件中；并且重启服务才能生效。</p><p>注意：并非所有的变量都支持动态修改。<br>-</p><p>####查看服务器变量的方法</p><p>（1）方法一</p><pre><code>mysql&gt; SHOW [GLOBAL | SESSION] VARIABLES [LIKE &#39;pattern&#39; | WHERE expr]</code></pre><p>（2）方法二</p><pre><code>mysql&gt; SELECT@@{GLOBAL|SESSION}.VARIABLE_NAME</code></pre><p><strong>示例：</strong></p><pre><code>MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES\G;  #显示所有全局变量MariaDB [(none)]&gt; SHOW SESSION VARIABLES\G; #显示所有会话变量MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES LIKE &#39;innodb_file_per_table&#39;;   #显示某个全局变量的信息+-----------------------+-------+| Variable_name         | Value |+-----------------------+-------+| innodb_file_per_table | OFF   |+-----------------------+-------+MariaDB [(none)]&gt; SHOW SESSION VARIABLES LIKE &#39;wait_timeout&#39;;   #查看某个会话变量信息+---------------+-------+| Variable_name | Value |+---------------+-------+| wait_timeout  | 28800 |+---------------+-------+MariaDB [(none)]&gt; SELECT @@SESSION.tx_isolation;    #查看会话隔离级别+------------------------+| @@SESSION.tx_isolation |+------------------------+| REPEATABLE-READ        |+------------------------+MariaDB [(none)]&gt; SELECT @@GLOBAL.tx_isolation; #查看全局隔离级别+-----------------------+| @@GLOBAL.tx_isolation |+-----------------------+| REPEATABLE-READ       |+-----------------------+</code></pre><p>###运行时修改变量值操作方法</p><p>使用格式：</p><pre><code>SET variable_assignment [, variable_assignment] ...</code></pre><p>variable_assignment:</p><pre><code>  user_var_name = expr| [GLOBAL | SESSION] system_var_name = expr| [@@global. | @@session. | @@]system_var_name = expr</code></pre><p><strong>示例：</strong></p><pre><code>MariaDB [(none)]&gt; SET @@SESSION.autocommit=0;   #设置会话变量MariaDB [(none)]&gt; SET SESSION autocommit=0 ;MariaDB [(none)]&gt; SELECT @@SESSION.autocommit;+----------------------+| @@SESSION.autocommit |+----------------------+|                    0 |+----------------------+</code></pre><p>注意：GOLBAL值的修改要求用户拥有管理权限。<br>-</p><p>####参看数据库服务器状态信息</p><p>mysql&gt; SHOW GLOBA|[SESSION] STATUS [LIKE clause];</p><p><strong>示例：</strong></p><pre><code>MariaDB [(none)]&gt; SHOW GLOBAL STATUS;   #显示全局状态信息MariaDB [(none)]&gt; SHOW SESSION STATUS;  #显示当前会话状态信息MariaDB [(none)]&gt; SHOW SESSION STATUS LIKE &#39;Uptime&#39;;  #显示当前会话某个状态信息</code></pre><p>数据库实现并发控制<br>-</p><p>####类类型：<br>读锁：共享锁，可被多个读操作共享</p><p>写锁：排他锁，独占锁</p><p>####锁粒度：<br>表锁：在表级别施加的锁，并发性降低</p><p>行锁：在行级别施加锁，并发性较高；维持所状态的成本较大</p><p>####锁类别：</p><p>显示锁：用户手动请求的锁</p><p>隐式锁：存储引擎自行根据需要施加的锁</p><p><strong>示例：显示所使用</strong></p><p><img src="http://owatlfstl.bkt.clouddn.com/MYSQL.gif" alt=""></p><p>如图所示，如果设置为read，不能进行写操作</p><p>撤销所以后写进入了</p><p><img src="http://owatlfstl.bkt.clouddn.com/MYSQL1.gif" alt=""></p><p>将表设置为write测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/MYSQL2.gif" alt=""></p><p><strong>小结：</strong></p><p>如果将表设置为read状态，可以在另外一个终端读，但是写不进去；如果将表设置为write状态，在另外一个终端读不行，写也不行。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="/2017/11/28/MySQL%E7%B4%A2%E5%BC%95/"/>
      <url>/2017/11/28/MySQL%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="mysql索引"><a href="#mysql索引" class="headerlink" title="mysql索引"></a>mysql索引</h2><p>提取索引的创建在的表上字段中的数据，构建出一个独特的数据结构。</p><h4 id="索引的作用"><a href="#索引的作用" class="headerlink" title="索引的作用"></a>索引的作用</h4><p>加速查询操作；副作用：降低些操作性能</p><pre><code>表中数据子集：把表中某个或某些字段的数据提取出来另存为一个特定数据结构组织的数据。    某个字段或某些字段：WHERE子句中用到的字段</code></pre><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><p><strong>B+ TREE</strong><br>顺序存储，每一个叶子节点到根节点的距离相同；左前缀索引，适用于范围类型的数据查询</p><h5 id="使用域B-TREE索引查询类型：全键值、键值范围或键前缀"><a href="#使用域B-TREE索引查询类型：全键值、键值范围或键前缀" class="headerlink" title="使用域B+ TREE索引查询类型：全键值、键值范围或键前缀"></a>使用域B+ TREE索引查询类型：全键值、键值范围或键前缀</h5><pre><code>全值匹配：精确匹配某个值    WHERE COLUMN = &#39;VALUE&#39;;匹配左前缀：只精确匹配开头的部分    WHERE COLUMN LIKE &#39;PREFIX%&#39;匹配范围值：    精确匹配某一列，范围匹配另一列    只用访问索引的查询：覆盖索引        index（NAME）        SELECT NAME FROM students WHERE NAME LIKE &#39;L%&#39;;</code></pre><h4 id="不使用B-TREE索引"><a href="#不使用B-TREE索引" class="headerlink" title="不使用B+ TREE索引"></a>不使用B+ TREE索引</h4><pre><code>如果查询条件不是从最左侧开始，索引无效    index（age，fname）    WHERE fname=‘jerry’;    WHERE age &gt;30 AND fname=’smith&#39;;不能跳过索引中的某列    index（name，age，gender）        WHERE name=&#39;block&#39; and age &gt;30;        WHERE name=&#39;block&#39; and gender=&#39;F&#39;;如果查询中的某个列时为范围查询，那么其右侧的列都无法再使用索引优化查询。    WHERE age&gt;30 AND fname=&#39;smith&#39;;</code></pre><p><strong>hash索引</strong><br>基于哈希表实现，特别适用于值的精确匹配查询。</p><h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><pre><code>只支持等值比较实现，例如=、IN(),&lt;=&gt;</code></pre><h4 id="不使用场景"><a href="#不使用场景" class="headerlink" title="不使用场景"></a>不使用场景</h4><pre><code>所有非精确值查询，mysql仅对memory存储引擎支持显示的hash索引</code></pre><h3 id="索引优点"><a href="#索引优点" class="headerlink" title="索引优点"></a>索引优点</h3><pre><code>降低需要扫描的数据量，减少IO次数；可以帮助避免排序操作，避免使用临时表帮助将随机IO转为顺序IO</code></pre><h3 id="高性能索引策略："><a href="#高性能索引策略：" class="headerlink" title="高性能索引策略："></a>高性能索引策略：</h3><ul><li><p>在WHERE中独立使用列，尽量避免其参与运算</p><pre><code>WHERE age+2 &gt; 23</code></pre></li><li><p>左前缀索引：索引构建于字段的最左侧的多少个字符，要通过索引选择性来评估</p><p>  索引选择性：不重复的索引值和数据表的记录总数的比值</p></li><li><p>多列索引</p><p>  AND连接的多个查询条件更适合使用多列索引，而非多个单间索引</p></li><li><p>选择合适的索引列次序：选择性更高的放左侧</p></li></ul><p><strong>示例：</strong></p><pre><code>MariaDB [student]&gt; CREATE INDEX age ON students(age);   #创建索引MariaDB [student]&gt; SHOW INDEX FROM students;    #查看索引MariaDB [student]&gt; CREATE INDEX age_and_name ON students(age,name); #创建组合索引MariaDB [student]&gt; EXPLAIN SELECT name,age FROM students WHERE age &gt; (SELECT avg(age) FROM students);+------+-------------+----------+-------+------------------+--------------+---------+------+------+--------------------------+| id   | select_type | table    | type  | possible_keys    | key          | key_len | ref  | rows | Extra                    |+------+-------------+----------+-------+------------------+--------------+---------+------+------+--------------------------+|    1 | PRIMARY     | students | index | age,age_and_name | age_and_name | 38      | NULL | 2897 | Using where; Using index ||    2 | SUBQUERY    | students | index | NULL             | age          | 5       | NULL | 2897 | Using index              |+------+-------------+----------+-------+------------------+--------------+---------+------+------+--------------------------+从上述可以看出通过使用index查询</code></pre><h2 id="EXPLAIN来分析索引有效性"><a href="#EXPLAIN来分析索引有效性" class="headerlink" title="EXPLAIN来分析索引有效性"></a>EXPLAIN来分析索引有效性</h2><p>使用格式：</p><pre><code>EXPLAIN [explain_type] SELECT select_options</code></pre><p>输出格式信息分析：</p><pre><code>    id：当前查询语句中，第个SELECT 语句的编号        注意：联合查询的分析结果会出现一个额外的匿名临时表    select_type：查询类型        简单查询：SIMPLE        复杂查询：            简单子查询：SUBQUERY            用于FROM中的子查询：DERIVED             联合查询中的第一个查询：PRIMARY            联合查询中的第一个查询之后的其他查询：UNION            联合查询生成的临时表：UNION RESULT      table：查询针对的表    type：关联类型，或称为访问类型，即mysql如何取查询表中的行        ALL ：全表扫描        index：根据索引的顺序进行的全表扫描；但同时如果EXTRA列出现了“Using index”表示使用了覆盖索引        range：有范围限制地根据索引实现范围扫描；扫描位置始于索引中的某一项，结束语另一项        ref：根据索引返回的表中匹配到某单个值的所有行（匹配给定值的行不止一个）        eq_ref：根据索引返回的表中匹配到某单个值的单一行，仅返回一个行，但需要与某个额外的参考值比较，而不是常熟        const，systemc：与某个常数比较，且只返回一行    possible_keys：查询中可能会用到的索引    key：查询中使用的索引    key_len：查询中用到的索引长度    ref：在利用key字段所显示的索引完成查询操作时所引用的列或常量值    rows：mysql估计出的为找到所有的目标而需要读取的行数    Extra：额外信息        Using index：使用了覆盖索引进行的查询        Using where：拿到数据后还要再次进行过滤        Using temporary：使用了临时表以完成查询        Using filesort：对结果使用了一个外部索引排序</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL引擎</title>
      <link href="/2017/11/28/MySQL%E5%BC%95%E6%93%8E/"/>
      <url>/2017/11/28/MySQL%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="ACID测试"><a href="#ACID测试" class="headerlink" title="ACID测试"></a>ACID测试</h2><ul><li>A：AUTOMICITY ，原子性；整个事物中的所有操作要么全部成功执行，要么全部失败后回滚</li><li>C：CONSISTENY,一致性；数据库总是应该从一个一致性状态转为另一个一致性状态</li><li>I：ISOLATION：隔离性；一个数据所作出的操作在提交之前，是否能为其它事物可见；出于保证并发操作之目的，隔离有多种级别</li><li>D：DURABILITY 持久性；事物一旦提交，其所作出的修改会永久保存</li></ul><h2 id="事物隔离级别"><a href="#事物隔离级别" class="headerlink" title="事物隔离级别"></a>事物隔离级别</h2><ul><li>READ-UNCOMMITTED：读未提交–&gt;脏读</li></ul><p><img src="http://owatlfstl.bkt.clouddn.com/MYSQL3.gif" alt=""></p><ul><li>READ-COMMITTED：读提交–&gt;不可重复读</li></ul><p><img src="http://owatlfstl.bkt.clouddn.com/MYSQL4.gif" alt=""></p><ul><li>REPEATABLE-READ：可重复读–&gt;幻读</li></ul><p><img src="http://owatlfstl.bkt.clouddn.com/MYSQL6.gif" alt=""></p><ul><li>SERIALIZABLE：串行化</li></ul><h3 id="手动控制事物"><a href="#手动控制事物" class="headerlink" title="手动控制事物"></a>手动控制事物</h3><p>启动：START TRANSACTION</p><p>提交：COMMIT</p><p>回滚：ROLLBACK</p><pre><code>事物支持savepoints：    SAVEPOINT identifier    ROLLBACK [work] TO [SAVEPOINT] identifier    RELEASE SAVEPOINT identifier</code></pre><p>查看InnoDB存储引擎的状态信息</p><pre><code>MariaDB [class]&gt; SHOW ENGINE innodb STATUS\G;</code></pre><p>mysql服务器引擎<br>-</p><p>存储引擎：也称为“表类型”，表级别概念，不建议咋同一个库中的表上使用不同的ENGINE。</p><p>查看数据库服务器支持的引擎</p><pre><code>MariaDB [(none)]&gt; SHOW ENGINES\G;MariaDB [(none)]&gt; SHOW ENGINE INNODB STATUS\G;  #显示INNODB引擎状态</code></pre><p>常见的引擎</p><pre><code>MyISAM, Aria, InnoDB, MRG_MYISAM, CSV, BLACKHOLE, MEMORY, PERFORMANCE_SCHEMA, ARCHIVE, FEDERATED</code></pre><p>InnoDB和MyISAM引擎的区别<br>-</p><p><strong>InnoDB</strong></p><p>Percon-XtraDB，支持事物，支持级别锁，支持外键</p><ul><li><p>数据存储在“表空间（tables space）”中：</p><pre><code>  （1）所有数据库中所有类型为InnoDB的表的数据和索引存储于同一个表空间中；      表空间文件：datadir定义的目录中      文件：ibdata1，ibdata2...</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-08_210733.jpg" alt=""></p><pre><code>  （2）innodb_file_per_table=ON这个选项添加到配置文件中意味着每张表使用单独的表空间文件；每张表的数据文件（数据和索引，存储于数据库目录）存储在自己专用的表空间文件中，并存储于数据库目录下：tb1_name.ibd  表结构定义：在数据库目录，tb1——name.frm</code></pre></li></ul><p><code>[root@localhost~]#vim /etc/my.cnf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-08_211255.jpg" alt=""></p><p><code>[root@localhost~]#systemctl start mariadb.service</code> #重启服务</p><pre><code>MariaDB [students]&gt; CREATE TABLE student (ID INT,NAME VARCHAR(30)); #创建一张表</code></pre><p><code>[root@localhost/var/lib/mysql/students]#ls</code></p><pre><code>db.opt  student.frm  student.ibd</code></pre><ul><li>事务性存储引擎，适合对事物要求较高的场景中；但较适用于处理大量短期事物</li><li>基于MVCC（Mutli Version Concurrency Control）  支持高并发；</li><li><p>支持四个隔离级别，默认级别为REPEATALBE-READ;间隙锁以防止幻读</p><p>  MariaDB [students]&gt; SHOW SESSION VARIABLES LIKE ‘tx_isolation’;<br>  +—————+—————–+<br>  | Variable_name | Value           |<br>  +—————+—————–+<br>  | tx_isolation  | REPEATABLE-READ |<br>  +—————+—————–+</p><p>   MariaDB [students]&gt; SELECT @@GLOBAL.tx_isolation;<br>  +———————–+<br>  | @@GLOBAL.tx_isolation |<br>  +———————–+<br>  | REPEATABLE-READ       |<br>  +———————–+</p></li></ul><ul><li>使用聚集所以（主键索引）</li><li>支持“自适应Hash索引”</li><li>锁粒度：行级锁，间隙锁</li></ul><p><strong>小结：</strong></p><pre><code>数据存储：表空间并发：MVCC，间隙锁，行级锁索引：聚集索引、辅助索引性能：预读操作、内存数据缓冲、自适应Hash索引、插入操作缓存区备份：支持热备</code></pre><p><strong>MyISAM</strong></p><ul><li>支持全文索引、压缩、空间函数（GIS）</li><li>不支持事物</li><li>锁粒度：表级锁</li><li>崩溃无法保证表安全恢复</li></ul><p>使用场景：只读或读多写少的场景、较小的表（以保证崩溃后恢复的时间较短）</p><p>文件：每个表有三个文件，存储于数据库目录中</p><pre><code>tb1_name.frm：表格式定义tb1_name.MYD：数据文件tb1_name.MYI：索引文件</code></pre><p><strong>示例：</strong></p><pre><code>MariaDB [students]&gt; CREATE DATABASE class;MariaDB [class]&gt; CREATE TABLE classes (ID INT ,number INT) ENGINE MyISAM;   #创建表并指定引擎</code></pre><p><code>[root@localhost/var/lib/mysql/class]#ls</code></p><pre><code>classes.frm  classes.MYD  classes.MYI  class.frm  class.ibd  db.opt</code></pre><p>特性：</p><pre><code>加锁和并发：表级锁修复：手动或自动修复、但可能会丢失数据索引：非聚集索引延迟索引更新表压缩</code></pre><h3 id="其他的存储引擎"><a href="#其他的存储引擎" class="headerlink" title="其他的存储引擎"></a>其他的存储引擎</h3><pre><code>CSV：将CSV文件（以逗号分隔字段的文本文件）作为mysql表文件MRG_MYISAM：将多个MyISAM表合并成虚拟表BLANCKHOLE：类似于/dev/null，不真正存储数据MEMORY：内存存储引擎，支持hash索引，表级锁，常用于临时表FEDERATED：用于访问其他远程mysql服务器上表的存储引擎接口</code></pre><h3 id="mariadb额外支持很多中引擎："><a href="#mariadb额外支持很多中引擎：" class="headerlink" title="mariadb额外支持很多中引擎："></a>mariadb额外支持很多中引擎：</h3><pre><code>OQGraph、SphinxSE、TokuDB、Cassandra、CONNECT、SQUENCE、..</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL表分区</title>
      <link href="/2017/11/28/MySQL%E8%A1%A8%E5%88%86%E5%8C%BA/"/>
      <url>/2017/11/28/MySQL%E8%A1%A8%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL表分区"><a href="#MySQL表分区" class="headerlink" title="MySQL表分区"></a>MySQL表分区</h2><h3 id="MySQL表分区有两种切分方法："><a href="#MySQL表分区有两种切分方法：" class="headerlink" title="MySQL表分区有两种切分方法："></a>MySQL表分区有两种切分方法：</h3><ul><li>垂直切分：切库，把一个库中的多个表分组后放置于不同的物理服务器上。</li><li>水平切分：切表，分散其行至多个表中存放（table partitions）。</li></ul><h4 id="partition-options"><a href="#partition-options" class="headerlink" title="partition_options:"></a>partition_options:</h4><pre><code>PARTITION BY    { [LINEAR] HASH(expr)    | [LINEAR] KEY(column_list)    | RANGE{(expr) | COLUMNS(column_list)}    | LIST{(expr) | COLUMNS(column_list)} }[PARTITIONS num][SUBPARTITION BY    { [LINEAR] HASH(expr)    | [LINEAR] KEY(column_list) }  [SUBPARTITIONS num]][(partition_definition [, partition_definition] ...)]</code></pre><h4 id="partition-definition"><a href="#partition-definition" class="headerlink" title="partition_definition:"></a>partition_definition:</h4><pre><code>PARTITION partition_name    [VALUES         {LESS THAN {(expr | value_list) | MAXVALUE}         |         IN (value_list)}]    [[STORAGE] ENGINE [=] engine_name]    [COMMENT [=] &#39;comment_text&#39; ]    [DATA DIRECTORY [=] &#39;data_dir&#39;]    [INDEX DIRECTORY [=] &#39;index_dir&#39;]    [MAX_ROWS [=] max_number_of_rows]    [MIN_ROWS [=] min_number_of_rows]    [TABLESPACE [=] tablespace_name]    [NODEGROUP [=] node_group_id]    [(subpartition_definition [, subpartition_definition] ...)]</code></pre><h3 id="分区类型："><a href="#分区类型：" class="headerlink" title="分区类型："></a>分区类型：</h3><ul><li>range：通过将数据划分为不同的范围</li><li>hash ：通过对表的一个或多个列hash key 计算，最后通过这个hash码不同的数值对应的数据区域进行分区</li><li>列:根据列进行划分</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL用户管理</title>
      <link href="/2017/11/28/MySQL%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
      <url>/2017/11/28/MySQL%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="1、新建普通用户"><a href="#1、新建普通用户" class="headerlink" title="1、新建普通用户"></a>1、新建普通用户</h3><p>（1）使用CREATE USER语句创建新用户</p><p>使用格式：</p><pre><code>CREATE USER  &#39;user&#39;@&#39;host&#39; [IDENTIFIED BY [PASSWORD] &#39;password&#39;] [,&#39;user&#39;@&#39;host&#39; [IDENTIFIED BY [PASSWORD] &#39;password&#39;]...]    user：新建用户    host：主机名    IDENTIFIED BY 设置用户密码</code></pre><p><strong>示例：</strong></p><pre><code>MariaDB [(none)]&gt; CREATE USER test@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;在mysql.user表中会插入一行记录MariaDB [(none)]&gt; SELECT user,host,password FROM mysql.user;+------+-----------------------+-------------------------------------------+| user | host                  | password                                  |+------+-----------------------+-------------------------------------------+| root | localhost             |                                           || root | localhost.localdomain |                                           || root | 127.0.0.1             |                                           || root | ::1                   |                                           ||      | localhost             |                                           ||      | localhost.localdomain |                                           || test | localhost             | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |+------+-----------------------+-------------------------------------------+</code></pre><p>（2）在musql.user表中INSERT用户</p><pre><code>MariaDB [(none)]&gt; INSERT INTO mysql.user (user,host,password) VALUES (&quot;testA&quot;,&quot;192.168.4.60&quot;,PASSWORD(&#39;123456&#39;));执行完INSERT之后，要使用如下命令生效。MariaDB [(none)]&gt; FLUSH PRIVILEGES;</code></pre><p>（3）使用GRANT创建用户</p><p>使用格式：</p><pre><code>GRANT priv_type ON database.table TO user[IDENTIFIED BY [PASSWORD] &#39;password&#39;] [,user [IDENTIFIED BY [PASSWORD] &#39;password&#39;]...]    priv_type：授予的权限    database.table：权限的范围    user：新建用户    IDENTIFIED BY 设置密码</code></pre><p><strong>示例：</strong></p><pre><code>MariaDB [(none)]&gt; GRANT SELECT ON *.* TO testB@&#39;192.168.4.60&#39; IDENTIFIED BY &#39;123456&#39;;</code></pre><h3 id="2、重命名"><a href="#2、重命名" class="headerlink" title="2、重命名"></a>2、重命名</h3><p>使用格式：</p><pre><code>RENAME USER old_user TO new_user[, old_user TO new_user] ...</code></pre><p><strong>示例：</strong></p><pre><code>MariaDB [(none)]&gt; RENAME USER testA@&#39;192.168.4.60&#39; TO testC@&#39;192.168.4.60&#39;;</code></pre><h3 id="3、删除用户"><a href="#3、删除用户" class="headerlink" title="3、删除用户"></a>3、删除用户</h3><p>使用格式：</p><pre><code>DROP USER &#39;user&#39;@&#39;host&#39; [, &#39;user&#39;@&#39;host&#39;] ...</code></pre><p><strong>示例：</strong></p><pre><code>MariaDB [class]&gt; DROP USER testC@&#39;192.168.4.60&#39;;</code></pre><h3 id="4、修改用户密码"><a href="#4、修改用户密码" class="headerlink" title="4、修改用户密码"></a>4、修改用户密码</h3><p>（1）使用mysqladmin命令修改密码</p><p>使用格式：</p><pre><code>mysqladmin -uUSERNAME -hHOST -p  password &#39;NEW_PASS&#39;</code></pre><p><strong>示例：</strong></p><p><code>[root@localhost~]#mysqladmin -uroot -p password</code></p><pre><code>Enter password: New password: Confirm new password: </code></pre><p><code>[root@localhost~]#mysqladmin -utest -p  password &#39;testabd&#39;</code></p><pre><code>Enter password: mysqladmin: Can&#39;t turn off logging; error: &#39;Access denied; you need (at least one of) the SUPER privilege(s) for this operation&#39;</code></pre><p><em>修改普通用户需要超级管理权限</em></p><p>（2）修改mysql.user表</p><p>使用格式：</p><pre><code>UPDATE mysql.user SET Password=PASSWORD(&#39;cleartext password&#39;)  WHERE User=&#39;USERNAME&#39; AND Host=&#39;HOST&#39;;</code></pre><p><strong>示例：</strong></p><pre><code>MariaDB [(none)]&gt; UPDATE mysql.user SET PASSWORD=PASSWORD(&#39;testabcd&#39;) WHERE User=&#39;test&#39;;</code></pre><p>（3）使用SET语句修改密码</p><p>使用格式：</p><pre><code>SET PASSWORD [FOR &#39;user&#39;@&#39;host&#39;] = PASSWORD(&#39;cleartext password&#39;);</code></pre><p>示例：</p><pre><code>MariaDB [(none)]&gt; SET PASSWORD FOR test@&#39;localhost&#39;=PASSWORD(&#39;testabcd&#39;);</code></pre><p>（4）GRANT语句修改普通用户密码</p><p><strong>示例：</strong></p><pre><code>MariaDB [(none)]&gt; GRANT SELECT ON *.* TO &#39;test&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</code></pre><h3 id="5、忘记管理员密码如何解决？"><a href="#5、忘记管理员密码如何解决？" class="headerlink" title="5、忘记管理员密码如何解决？"></a>5、忘记管理员密码如何解决？</h3><p>（1）先确保mysql服务停止</p><p><code>[root@localhost~]#systemctl stop mariadb.service</code></p><p>（2）确保其他用户连接不到mysql服务</p><p>（3）修改启动配置文件</p><p><code>[root@localhost~]#vim /usr/lib/systemd/system/mariadb.service</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-09_110934.jpg" alt=""></p><p>（4）启动服务并修改密码</p><p><code>[root@localhost~]#systemctl restart mariadb.service</code></p><pre><code>MariaDB [(none)]&gt; UPDATE mysql.user SET PASSWORD=PASSWORD(&#39;123456&#39;) WHERE user=&#39;root&#39;;</code></pre><p>（5）修改更改文件</p><p><code>[root@localhost~]#systemctl stop mariadb.service</code></p><p><code>[root@localhost~]#vim /usr/lib/systemd/system/mariadb.service</code> 删除刚添加的参数</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-09_111354.jpg" alt=""></p><p>（6）重启服务测试</p><p><code>[root@localhost~]#systemctl restart mariadb.service</code></p><p><code>[root@localhost~]#mysql -uroot -p</code></p><pre><code>Enter password: Welcome to the MariaDB monitor.  Commands end with ; or \g.Your MariaDB connection id is 3Server version: 5.5.56-MariaDB MariaDB Server</code></pre><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>使用格式：</p><pre><code>GRANT  priv_type [(column_list)] [, priv_type [(column_list)]] ...            ON [object_type] priv_level            TO user_specification [, user_specification] ...            [REQUIRE {NONE | ssl_option [[AND] ssl_option] ...}]            [WITH with_option ...]    priv_type：表示权限类型    column_list：设置列    user：设置用户    password：用户密码    WITH关键字后面带有一个或多个with_option参数        GRANT OPTION：被授权用户可以使用的参数            MAX_QUERIES_PER_HOUR count：设置每小时允许执行的count查询            MAX_UPDATES_PER_HOUR count：设置每小时count更新            MAX_CONNECTIONS_PER_HOUR count：设置每小时可以建立count连接            MAX_USER_CONNECTIONS count：设置单个用户可以同时具有count连接数</code></pre><p><strong>示例：</strong></p><pre><code>MariaDB [class]&gt; GRANT SELECT(number) ON class.class TO &#39;test&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</code></pre><h3 id="查看授权"><a href="#查看授权" class="headerlink" title="查看授权"></a>查看授权</h3><p>使用格式：</p><pre><code>SHOW GRANTS [FOR &#39;user&#39;@&#39;host&#39;]</code></pre><p><strong>示例：</strong></p><pre><code>MariaDB [class]&gt; SHOW GRANTS FOR test@&#39;localhost&#39;\G;*************************** 1. row ***************************Grants for test@localhost: GRANT SELECT ON *.* TO &#39;test&#39;@&#39;localhost&#39; IDENTIFIED BY PASSWORD &#39;*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9&#39;*************************** 2. row ***************************Grants for test@localhost: GRANT SELECT (number) ON `class`.`class` TO &#39;test&#39;@&#39;localhost&#39;MariaDB [class]&gt; SHOW GRANTS ;  #默认查询root的权限</code></pre><h3 id="取消授权"><a href="#取消授权" class="headerlink" title="取消授权"></a>取消授权</h3><p>使用格式</p><pre><code>REVOKE  priv_type [(column_list)][, priv_type [(column_list)]] ...            ON [object_type] priv_level            FROM  &#39;user&#39;@&#39;host&#39; [,  &#39;user&#39;@&#39;host&#39;] ...</code></pre><p><strong>示例：</strong></p><pre><code>MariaDB [class]&gt; REVOKE SELECT(number) ON class.class FROM test@&#39;localhost&#39;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NFS</title>
      <link href="/2017/11/28/NFS/"/>
      <url>/2017/11/28/NFS/</url>
      
        <content type="html"><![CDATA[<h1 id="一、NFS介绍"><a href="#一、NFS介绍" class="headerlink" title="一、NFS介绍"></a>一、NFS介绍</h1><h2 id="1、NFS简介"><a href="#1、NFS简介" class="headerlink" title="1、NFS简介"></a>1、NFS简介</h2><p>NFS （Network File System，网络文件系统），通过网络让不同的机器、不同的操作系统能够彼此分享个别的数据，让应用程序在客户端通过网络访问位于服务器磁盘中的数据，是在类Unix系统间实现磁盘文件共享的一种方法。<br>NFS 的基本原则是“容许不同的客户端及服务端通过一组RPC分享相同的文件系统”，它是独立于操作系统，允许不同硬件及操作系统的系统共同进行文件的分享。</p><p>NFS在文件传送或信息传送过程中依赖于RPC协议。RPC， (Remote Procedure Call，远程过程调用）是能使客户端执行其他系统中程序的一种机制，RPC采用C/S模式。NFS本身是没有提供信息传输的协议和功能的，但NFS却能让我们通过网络进行资料的分享，这是因为NFS使用了一些其它的传输协议。而这些传输协议用到这个RPC功能的。可以说NFS本身就是使用RPC的一个程序；或者说NFS也是一个RPC SERVER，所以只要用到NFS的地方都要启动RPC服务，不论是NFS SERVER或者NFS CLIENT。这样SERVER和CLIENT才能通过RPC来实现PROGRAM PORT的对应。可以这么理解RPC和NFS的关系：NFS是一个文件系统，而RPC是负责负责信息的传输。</p><p><strong>注意：RPC服务启动之后才能启动nfs服务，因为nfs服务要到RPC注册端口号。</strong></p><h2 id="2、NFS工作机理"><a href="#2、NFS工作机理" class="headerlink" title="2、NFS工作机理"></a>2、NFS工作机理</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-15_112927.jpg" alt=""></p><p>（1）客户端向NFS服务器发送资源请求时，客户端RPC服务通过网络向NFS服务器的RPC（111端口）服务发出资源请求。</p><p>（2）NFS服务器的RPC端口获取到服务器端nfs服务注册端口，通知客户端RPC服务器</p><p>（3）客户端收取到正确的端口之后，直接与服务端的nfs服务建立通信。</p><p>（4）服务器nfs服务接受到请求资源之后本地响应读取本地磁盘中的内容，然后返回至客户端这样就完成一次存取操作。</p><h2 id="3、NFS优势"><a href="#3、NFS优势" class="headerlink" title="3、NFS优势"></a>3、NFS优势</h2><p>（1）节省本地存储空间</p><p>（2）用户不需要再网络中的每个机器上都建有home目录</p><h2 id="4、NFS版本对比"><a href="#4、NFS版本对比" class="headerlink" title="4、NFS版本对比"></a>4、NFS版本对比</h2><p>|<br>|NFS v2|NFS v3|NFS v4<br>|只支持32位文件传输，最大文件数为4G |支持64位传输|CentOS 7 默认使用NFS v4，实现伪根挂载，辅助服务不需要，完全支持kerberos<br>|文件传输尺寸限制在8K |没有文件尺寸限制||<br>|无|v3增加和完善了许多错误和成功信息的返回，对于服务器的设置和管理能带来很大好处|改进了INTERENT上的存取和执行效能在协议中增强了安全方面的特性<br>|只提供了对UDP协议的支持，在一些高要求的网络环境中又很大限制|增加了对TCP传输协议的支持，有更好的I/O性能|只支持TCP传输，通过一个安全的带内系统，协商在服务器和客户端之间使用的安全性类型使用字符串而不是整数俩表示用户和组标识符</p><h2 id="5、NFS服务主要进程"><a href="#5、NFS服务主要进程" class="headerlink" title="5、NFS服务主要进程"></a>5、NFS服务主要进程</h2><p>rpm.nfsd 最主要的NFS进程，管理客户端是否可登陆，登入者ID的判断。监听在2049端口</p><p>rpc.mount 主要功能管理NFS的文件系统。当客户端通过rpc.nfsd登入主机后，使用NFS服务器提供的文件之前，还会经过文件使用权限的认证程序。读取<code>/etc/exports</code>配置文件来对比客户端的权限；如果权限认证通过，客户端就可以使用NFS提供的文件了。</p><p>rpc.lockd 管理文件锁，避免同时写错</p><p>rpc.statd 检查文件一致性，可修复文件</p><h2 id="6、NFS配置文件"><a href="#6、NFS配置文件" class="headerlink" title="6、NFS配置文件"></a>6、NFS配置文件</h2><p>软件包名：nfs-utils</p><p>配置文件</p><pre><code>/etc/exports.d和/etc/exports</code></pre><p>配置NFS使用固定端口</p><pre><code>RQUOTAD_PORT LOCKD_TCPPORTLOCKD_UDPPORTMOUNTD_PORTSTATD_PORT  rpc.statd监听端口STATD_OUTGONING_PORT outgoing设置端口</code></pre><p>锁配置文件</p><pre><code>/etc/modprobe.d/lockd.conf</code></pre><p>nfs服务启动配置文件</p><pre><code>/etc/sysconfig/nfs</code></pre><p>命令配置文件</p><pre><code>/sbin/mount.nfs/sbin/mount.nfs4/sbin/osd_login/sbin/rpc.statd/sbin/umount.nfs/sbin/umount.nfs4</code></pre><h2 id="7、-etc-exports配置文件"><a href="#7、-etc-exports配置文件" class="headerlink" title="7、/etc/exports配置文件"></a>7、<code>/etc/exports</code>配置文件</h2><p>格式</p><p>   /DIR(共享的文件或目录) 主机1（opts） 主机2（opts）</p><p>主机格式：</p><pre><code>单个主机：IPv4 IPv6 FQDNIP network：两种掩码格式均支持    0.0.0.0/24    0.0.0.0/255.0.0.0wildcards:主机名通配，例如*.localhost.comnetgroups:NIS域主机组，@group_nameanonymous：表示使用*通配所有客户端</code></pre><p>ops：</p><pre><code>secure：使用了1024以下的TCP/IP端口实现NFS的连接。insecure：允许客户端从大于1024的TCP/IP端口实现NFS连接。rw：允许NFS客户机进行读写访问ro：允许NFS客户机进行只读访问async：异步，数据变化后不立即写磁盘，可以改进性能no_wdelay：关闭写延时；如果设置了async，NFS会忽略这个选项nohide：如果将一个目录挂载到另外一个目录上，那么原来的目录通常就被隐藏起来，这个选项禁用这种行为。hide：隐藏原来目录中的内容no_stbtree_check：关闭子树检查；子树检查会执行一些不想忽略的安全性检查。默认启用子树检查mp（mountpoint=path）：NFS要求挂载所导出的目录no_auth_nlm：NFS守护进程不要对加锁请求进行认证。默认为auth_nlm或secure_locksfsid=num|root|uuid：NFS需要识别每个文件系统。crossmnt：这个选项类似于nohide，使得客户端能访问挂载目录下的文件。例如如果B目录挂载A目录上，设置crossmnt在A目录上不被隐藏。</code></pre><h2 id="用户映射"><a href="#用户映射" class="headerlink" title="用户映射"></a>用户映射</h2><p>通过NFS中的用户映射，可以将伪或实际用户和组的表示赋给一个正在对NFS卷进行操作的用户，这个NFS用户具有映射所允许的用户和组的许可权限。对NFS卷使用一个通过的用户/组可以提供一定的安全性和灵活性。</p><p>在使用NFS挂载的文件系统上的文件时，用于的访问通常都会受到限制，都是以匿名用户的身份对文件进行访问的，这些用户缺省的情况下对这些文件只有只读权限。NFS允许指定访问远程文件用户通过用户标识号和组标识号，可以禁用正常的squash行为</p><pre><code>用户映射选项root_squash：将root用户及所属组映射为匿名用户或用户组，默认选项no_root_squash：允许root用户访问挂载NFS卷all_squash：对于公共访问的NFS卷时非常有用的，它会限制所有的UID和GID，只使用匿名用户（nfsnobody）访问NFS卷anonuid：将远程访问的所有用户都映射为匿名用户，并制定该用户为本地用户（UID=NUM）anongid：将远程用户的所有用户组都映射为匿名用户组账户，并指定该匿名用户组账户为本地用户组账户（GID=NUM）</code></pre><h3 id="客户端NFS挂载选项"><a href="#客户端NFS挂载选项" class="headerlink" title="客户端NFS挂载选项"></a>客户端NFS挂载选项</h3><pre><code>fg：前台挂载bg：后台挂载hard：持续请求soft：非持续请求rsize：从服务器中读取的字节数wsize：写入服务器的字节数，默认为1024，如果使用比较高的值，可以提高传输速度_netdev：网络设备挂载，如果检测到网络自动挂载</code></pre><h2 id="8、管理命令"><a href="#8、管理命令" class="headerlink" title="8、管理命令"></a>8、管理命令</h2><p>（1）exportfs 管理当前NFS共享文件系统列表</p><pre><code>-a 打开或取消所有目录共享-o 指定一列共享选项-i  忽略`/etc/exports`文件，从而只是用默认的和命令行指定的选项-r 重新读共享所有目录。它是/etc/exportfs和/var/lib/nfs/xtab同步。-u 取消一个或多个目录共享-v 输出详细信息</code></pre><p>（2）showmount 查询mountd守护进程，以显示NFS服务器加载的信息</p><pre><code>-d 仅显示以被NFS客户端加载的目录-e 显示NFS服务器上的所有共享目录</code></pre><p>（3）rpcinfo 显示portmap的有关信息</p><pre><code>-p 列出所有host用portmap注册的RPC程序，如果没有指定host，就查找本机上RPC程序-u RPC调用host程序program的version版本，并报告是否接受到相应-t TCP RPC调用host程序program的version版本，并报告是否接收到响应-n 根据-t或者-u，使用编号为port的端口，而不是portmap指定的端口-d 将程序program的version版本从本机的RPC注册表中删除。注意只用root权限的用户才可以使用此选项。-s 查看RPC注册程序</code></pre><p>（4）mount.nfs 挂载NFS</p><pre><code>-r 只读挂载-w 读写挂载-f 假挂载，不实际调用mount-n 不更新/etc/mtab </code></pre><h1 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h1><h2 id="1、基本挂载并分享"><a href="#1、基本挂载并分享" class="headerlink" title="1、基本挂载并分享"></a>1、基本挂载并分享</h2><p>（1）CentOS 7 共享目录/app/testnfs</p><p><code>[root@localhost/app]#vim /etc/exports</code></p><pre><code> 1 /app/testnfs    192.168.4.132</code></pre><p>（2）使用命令exportfs重读</p><p><code>[root@localhost/app]#exportfs -r</code></p><p>（3）CentOS 6使用showmount命令查看</p><p><code>[root@localhost/app]#showmount -e 192.168.4.60</code></p><p>（4）挂载</p><p><code>[root@localhost ~]# mount -t nfs 192.168.4.60:/app/testnfs /mnt/nfs/</code></p><p>如果不NFS服务器中挂载不添加任何选项，默认为</p><pre><code>ro,sync,wdelay,hide,no_subtree_check,sec=sys,secure,root_squash,no_all_squash</code></pre><p>如果客户对文件有写权限，但是此目录NFS设为只要只读权限，所以对NFS写不进去文件或创建目录等等操作。如果需要这种操作需要确保文件对此目录是否有写权限，并且NFS共享时是否设置了读写权限；只有两者同时具备才可以写操作。</p><p>这时我们开启NFS共享文件的权限</p><p><code>[root@localhost/app]#chmod 777 /app/testnfs</code></p><p>再次写去测试即可创建</p><h2 id="2、实现NFS伪根"><a href="#2、实现NFS伪根" class="headerlink" title="2、实现NFS伪根"></a>2、实现NFS伪根</h2><p>（1）创建一个目录并在目录下在创建目录</p><p><code>[root@localhost/app/testnfs]#mkdir nfs1</code><br><code>[root@localhost/app/testnfs]#mkdir nfs2</code></p><p>（2）配置共享文件</p><p><code>[root@localhost/app/testnfs]#vim /etc/exports</code></p><pre><code>1 /app/testnfs    192.168.4.132(rw,fsid=0,crossmnt)2 /app/testnfs/nfs1       192.168.4.132(rw,root_squash)3 /app/testnfs/nfs2       192.168.4.132(ro)</code></pre><p><code>[root@localhost/app/testnfs]#exportfs -v</code></p><pre><code>/app/testnfs      192.168.4.132(rw,sync,wdelay,hide,crossmnt,no_subtree_check,fsid=0,sec=sys,secure,root_squash,no_all_squash)/app/testnfs/nfs1        192.168.4.132(rw,sync,wdelay,hide,no_subtree_check,sec=sys,secure,root_squash,no_all_squash)/app/testnfs/nfs2        192.168.4.132(ro,sync,wdelay,hide,no_subtree_check,sec=sys,secure,root_squash,no_all_squash)</code></pre><p> 我们也可以通过 <code>/var/lib/nfs/etab</code>   </p><p><code>[root@localhost/app/testnfs]#cat /var/lib/nfs/etab</code></p><pre><code>/app/testnfs/nfs2    192.168.4.132(ro,sync,wdelay,hide,nocrossmnt,secure,root_squash,no_all_squash,no_subtree_check,secure_locks,acl,no_pnfs,anonuid=65534,anongid=65534,sec=sys,secure,root_squash,no_all_squash)/app/testnfs/nfs1    192.168.4.132(rw,sync,wdelay,hide,nocrossmnt,secure,root_squash,no_all_squash,no_subtree_check,secure_locks,acl,no_pnfs,anonuid=65534,anongid=65534,sec=sys,secure,root_squash,no_all_squash)/app/testnfs    192.168.4.132(rw,sync,wdelay,hide,crossmnt,secure,root_squash,no_all_squash,no_subtree_check,secure_locks,acl,no_pnfs,fsid=0,anonuid=65534,anongid=65534,sec=sys,secure,root_squash,no_all_squash)    </code></pre><p>（3）测试</p><p><code>[root@localhost ~]# showmount -e 192.168.4.60</code></p><p><code>[root@localhost ~]# mount -t nfs 192.168.4.60:/ /mnt/nfs/</code></p><p><code>[root@localhost nfs1]# touch nfs.txt</code></p><p><code>[root@localhost nfs1]# ll</code></p><pre><code>-rw-r--r--. 1 nfsnobody nfsnobody 0 Oct 15  2017 nfs.txt</code></pre><p>此时我们看创建文件的所有者及所属组都为nfsnobody，这里就验证了我们刚刚前面提到的root用户映射为匿名用户nfsnobody。</p><p><code>[joah@localhost nfs1]$ ll</code></p><pre><code>-rw-rw-r--. 1 joah      joah      0 Oct 15  2017 nfs2.txt-rw-r--r--. 1 nfsnobody nfsnobody 0 Oct 15  2017 nfs.txt</code></pre><p>通过上述查看非系统账号创建的文件的所有者及所属组为自己本身。</p><p>此时我们在NFS服务器上查看文件</p><p><code>[root@localhost/app/testnfs/nfs1]#ll</code></p><pre><code>-rw-rw-r--. 1       500       500 0 Oct 15 23:45 nfs2.txt-rw-r--r--. 1 nfsnobody nfsnobody 0 Oct 15 23:42 nfs.txt</code></pre><p>在客户端创建的文件在NFS服务器上的所有者和所属组都为500。而客户端joah的所有者和所属组的id也为500，这也验证了上述说明的用户映射。如果服务器500这个id号被占用如何处理？</p><p><code>[root@localhost/app/testnfs/nfs1]#ll</code></p><pre><code>-rw-rw-r--. 1 li              500 0 Oct 15 23:45 nfs2.txt</code></pre><p>此时所有者不一样了。这样有时就会出现问题。</p><p><strong>关于权限</strong></p><p>（1）客户端连接时候，对普通用户检查</p><pre><code>a、如果明确设定了普通用户被压榨，那么此时客户端用户的身份转换为指定用户b、如果没有明确指定，那么此时用户身份被压榨成nfsnobody</code></pre><p>（2）客户端连接时，对root的检查</p><pre><code>a、如果设置no_root_squash，此时root用户身份被压榨成NFS服务器上的rootb、如果设置了all_squash、anonuid、anongid，此时root的身份被压榨为指定用户c、如果没有明确指定，root被压榨为nfsnobodyd、如果同时指定no_root_squash和all_squash用户将被压榨为nfsnobody；如果设置了anonuid、anongid将被压榨为指定用户与组</code></pre><h1 id="四、自动挂载"><a href="#四、自动挂载" class="headerlink" title="四、自动挂载"></a>四、自动挂载</h1><h2 id="1、auto简介"><a href="#1、auto简介" class="headerlink" title="1、auto简介"></a>1、auto简介</h2><p>Autofs与Mount/Umount的不同之处在于，它是一种看守程序。如果它检测到用户正试图访问一个尚未挂接的文件系统，它就会自动检测该文件系统，如果存在，那么Autofs会自动将其挂接。另一方面，如果它检测到某个已挂接的文件系统在一段时间内没有被使用，那么Autofs会自动将其卸载。因此一旦运行了Autofs后，用户就不再需要手动完成文件系统的挂接和卸载。</p><h2 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h2><p>主配置文件</p><pre><code>/etc/autos.conf</code></pre><p>配置挂载文件</p><pre><code>/etc/auto.master</code></pre><h2 id="3、autofs挂载方式"><a href="#3、autofs挂载方式" class="headerlink" title="3、autofs挂载方式"></a>3、autofs挂载方式</h2><p>（1）相对路径法</p><p><code>/etc/auto.master</code>配置格式</p><pre><code>DIRNAME     子配置文件</code></pre><p>子配置文件格式</p><pre><code>BASENAME    需要挂载的文件等</code></pre><p>示例 ：</p><p><code>[root@localhost ~]# vim /etc/auto.master</code></p><pre><code>/mnt    /etc/auto.nfs</code></pre><p><code>[root@localhost ~]# vim /etc/auto.nfs</code></p><pre><code>nfs     -fstype=nfs     192.168.4.60:/</code></pre><p>重启服务测试即可</p><p><code>[root@localhost ~]# cd /mnt/nfs/</code><br><code>[root@localhost nfs]# ls</code></p><pre><code>fstab  nfs1  nfs2</code></pre><p>（2）绝对路径法</p><p><code>/etc/auto.master</code>配置格式</p><pre><code>/-      子配置文件</code></pre><p>子配置文件格式</p><pre><code>挂载点路径   被挂载文件等</code></pre><p>示例：</p><p><code>[root@localhost ~]# vim /etc/auto.master</code></p><pre><code>/-    /etc/auto.nfs</code></pre><p><code>[root@localhost ~]# vim /etc/auto.nfs</code></p><pre><code>/mnt/nfs     -fstype=nfs     192.168.4.60:/</code></pre><p>重启服务测试即可</p><p><code>[root@localhost ~]# cd /mnt/nfs/</code><br><code>[root@localhost nfs]# ls</code></p><pre><code>fstab  nfs1  nfs2</code></pre><p><strong>注意：如果父目录不存在时，会自动创建。使用绝对路径不会隐藏原来目录下目录中的内容。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
          <category> NFS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BIND</title>
      <link href="/2017/11/28/BIND/"/>
      <url>/2017/11/28/BIND/</url>
      
        <content type="html"><![CDATA[<h2 id="一、DNS"><a href="#一、DNS" class="headerlink" title="一、DNS"></a>一、DNS</h2><h3 id="1、DNS概念"><a href="#1、DNS概念" class="headerlink" title="1、DNS概念"></a>1、DNS概念</h3><p>DNS（Domain Name System，域名系统）是互联网的一项服务。它将域名和IP地址相互映射的一个分布式数据库，能够使人方便地访问互联网。</p><h3 id="2、使用的端口"><a href="#2、使用的端口" class="headerlink" title="2、使用的端口"></a>2、使用的端口</h3><p>（1）53/TCP  53/UDP</p><p>（2）不同协议的端口作用是什么呢？</p><pre><code>53/UDP:提供客户端查询功能53/TCP和53/UDP:实现dns主从复制功能</code></pre><h3 id="3、DNS域名"><a href="#3、DNS域名" class="headerlink" title="3、DNS域名"></a>3、DNS域名</h3><p>开头我们述说DNS是分布式数据库，想必大家猜到了DNS是层级结构的。<br><img src="http://owatlfstl.bkt.clouddn.com/q.jpg" alt=""></p><p>从图中可以看出DNS的层级结构</p><p>（1）根域（Top Level Domain，tld）</p><p>（2）顶级域</p><pre><code>（a）组织域， com，org，gov，mil等（b）国家域，cn，ca，hk，tw等（c）反向域，arpa</code></pre><p>（3）二级域<br>    …</p><h3 id="4、DNS服务器类型"><a href="#4、DNS服务器类型" class="headerlink" title="4、DNS服务器类型"></a>4、DNS服务器类型</h3><p>（1）主DNS服务器</p><pre><code>作用：管理和维护负责解析的域内解析库的服务器</code></pre><p>。<br>（2）从DNS服务器</p><pre><code>作用：从主服务器或从服务器“复制”（区域间传输）解析库副本。这里我们需要注意一下，区域传输分为两种（a）完全传输（axfr）：传送整个解析库；（b）增量传输（ixfr）：传递解析库变化的内容；</code></pre><p>是不是大家想，主从DNS服务器时如何工作的呢？</p><pre><code>有两种工作机制“PUSH”和“PULL”。当主DNS服务器配置文件中序列号发生递增，重新DNS服务；主DNS服务器会主动向从DNS服务器同步信息；这个过程称为&#39;PUSH&#39;。如果区域传输终端，没有同步成功，从服务器会根据配置文件中的”retry“指定的时间重新尝试同步信息，这个过程称为“PULL”。</code></pre><h3 id="5、DNS解析"><a href="#5、DNS解析" class="headerlink" title="5、DNS解析"></a>5、DNS解析</h3><p>DNS解析分为两种</p><pre><code>（a）正向解析：FQDN--&gt;IP（b）反向解析:  IP--&gt;FQDN</code></pre><p><strong>注意：正向解析是两个不同的名称空间，是两个不同的解析树，如果为子域则写DNS服务IP。</strong></p><p>DNS查询类型：</p><pre><code>（a）递归查询（b）迭代查询</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-19_214603.png" alt=""></p><p>一次完整的DNS查询请求的过程：Client–&gt;host文件–&gt;DNS server Local Cache –&gt;DNS server（recursion）–&gt;Server Cache–&gt;Iteration（迭代）–&gt;Root–&gt;TLD–&gt;二级域名–&gt;…</p><h3 id="6、DNS资源类型"><a href="#6、DNS资源类型" class="headerlink" title="6、DNS资源类型"></a>6、DNS资源类型</h3><p>区域解析库由众多的RR（resource record）组成。存在不同的类型：A,AAAA,SOA,CNAME,MX,PTR,NS。</p><p>资源记录的格式：</p><pre><code>NAME    [TTL]    IN     RR_TYPE     VALUE</code></pre><p>下面有几点需要注意的：</p><p>（a）$TTL变量，全局继承此处的缓存周期，默认单位为秒。</p><p>（b）@代替<code>/etc/named.rfc1912.zones</code>配置的ZONE_NAME.</p><p>（c）同一个名字可以通过多条记录定义多个不同的值，此时DNS服务器会以轮询方式进行相应。</p><p>（d）同一个值可能有多个不同定义的名字；通过多个不同的名字指向同一个值进行定义。此仅表示通过多个不同的名字可以找到同一个主机。</p><h4 id="（1）SOA：Start-Of-Authority，起始授权记录。"><a href="#（1）SOA：Start-Of-Authority，起始授权记录。" class="headerlink" title="（1）SOA：Start Of Authority，起始授权记录。"></a>（1）SOA：Start Of Authority，起始授权记录。</h4><p>value的构成：</p><p>（a）当前区域的主DNS服务器的   FQDN，也可以使用<code>/etc/named.rfc1912.zones</code>配置的ZONE_NAME。</p><p>（b）当前区域管理员的邮箱地址，但地址中不能使用”@“，一般使用“.”替代。因为在配置文件中“@”表示特殊含义<br>。</p><p>（c）主从服务区域传输相关定义以及否定的答案的同一TTL。</p><pre><code>@       IN SOA  @ rname.invalid. (                                    0       ; serial    #解析库序列号，主服务器解析库变化时，递增，最长只能为十位数组成，一般为了方便管理这样管理“当前日期+版本号”                                    1D      ; refresh   #刷新时间，从服务器从主服务器请求同步解析库的时间                                    1H      ; retry     #重试时间，从服务器从主DNS服务器请求失败时，再次尝试的时间                                    1W      ; expire    #过期时长，从服务器联系不到主服务器时，多久后停止服务                                    3H )    ; minimum   #错误解析存活时长</code></pre><p><strong>注意：一个区域解析库只能有且仅有一个SOA记录，必须位于解析库的第一条记录。</strong></p><h4 id="（2）NS，Name-Server-，名称服务"><a href="#（2）NS，Name-Server-，名称服务" class="headerlink" title="（2）NS，Name Server ，名称服务"></a>（2）NS，Name Server ，名称服务</h4><p>value：当前区域的某DNS服务器名称</p><p><strong>注意：</strong></p><p>（a）相邻的两个资源记录的NAME相同时，后续可省略。</p><p>（b）任何一个NS记录后面的服务器名字，都应该在后续有一个A记录。</p><h4 id="（3）MX，Mail-eXchange，邮件转换"><a href="#（3）MX，Mail-eXchange，邮件转换" class="headerlink" title="（3）MX，Mail eXchange，邮件转换"></a>（3）MX，Mail eXchange，邮件转换</h4><p>value：当前区域的某邮件服务器的主机名</p><p><strong>注意：</strong></p><p>（1）在一个区域内可以有多个MX记录,但是每个MX记录前应该有一个数字（0-99），表示服务器的优先级，数字越小优先级越高。</p><p>（2）任何一个MX记录后应该有一个A记录。</p><h4 id="（4）A-记录"><a href="#（4）A-记录" class="headerlink" title="（4）A 记录"></a>（4）A 记录</h4><p>value：主机名对应的IP地址</p><p>对于A记录有以下几种定义格式:</p><p>(a)可以使用FQDN</p><p>(b)可以使用泛域名 *.ZONE_NAME,这种方式的好处是避免用户写错名称时给错误答案，将错误答案指向某特性的地址。</p><p>(c)如果一个网段中地址不确定可以是使用 $GGENERATE #-# NAME$       后面对应的地址也是，网段加$</p><pre><code>示例：$GENERATE 100-150 host$     IN    A  192.168.4.$</code></pre><h4 id="5-AAAA记录"><a href="#5-AAAA记录" class="headerlink" title="(5)AAAA记录"></a>(5)AAAA记录</h4><h4 id="6-PTR-PoinTeR-IP，反向域名解析"><a href="#6-PTR-PoinTeR-IP，反向域名解析" class="headerlink" title="(6)PTR PoinTeR  IP，反向域名解析"></a>(6)PTR PoinTeR  IP，反向域名解析</h4><pre><code>格式：IP   PTR     FQDN完整格式：135.4.168.192-in.adder.arpa    IN PTR dns1如果192.168.4为网络地址，可以这样写 135  IN PTR DNS1</code></pre><p><strong>注意:主机地址要反着写。</strong></p><h4 id="（7）CNAME-别名"><a href="#（7）CNAME-别名" class="headerlink" title="（7）CNAME 别名"></a>（7）CNAME 别名</h4><p>有时候我们访问一个网站是www主机不一定是真正的主机。有可能使用了这种别名机制</p><pre><code>示例： www IN CNAME    websrv</code></pre><p>我们在访问一个网址时，有可能为如下地址<code>www.test.server.com</code>对整个地址来说真正的，test为server的子域。server为com的子域。n那么父域如何对子域进行授权呢？</p><p>子域授权：每个域的名称服务器，都是通过父域服务器在解析库进行授权。</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-19_193850.png" alt=""></p><p>如图所述：想必大家多DNS的名称，过程有了一定的了解，下面通过看上面这张图，可以看出子域与父域的管理。通过观察图中，一个zone可有多个RR组成。可以粗略的看出DNS的容错功能，实现负载的作用。父域通过委派子域进行管理。</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-19_194012.png" alt=""></p><p>如图所示：DNS是工作在内核中的，用户是没有办法直接管理DNS服务，那要如何管理DNS服务呢？前人想出了Bind进行管理DNS服务。这样用户通过用户空间借助于Bind管理工具或配置文件就可以管理DNS服务了。</p><h2 id="二、编译安装bind"><a href="#二、编译安装bind" class="headerlink" title="二、编译安装bind"></a>二、编译安装bind</h2><blockquote><p>（1）下载源码包</p></blockquote><p><a href="https://www.isc.org/downloads/" target="_blank" rel="noopener">https://www.isc.org/downloads/</a></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-22_110742.png" alt=""></p><blockquote><p>（2）解压缩源码包</p></blockquote><pre><code>[root@localhost~]#mv bind-9.10.6.tar.gz /usr/src/[root@localhost~]#cd /usr/src/[root@localhost/usr/src]#tar xvf bind-9.10.6.tar.gz </code></pre><blockquote><p>（3）来我们先看看bind包原来有没有安装脚本呢？</p></blockquote><pre><code>[root@localhost ~]# rpm -q --scripts bind</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-22_094626.png" alt=""><br>从图中我们可以看出，安装前需要自己创建用户，那么我们来创建一个用户吧</p><pre><code>[root@localhost/usr/src/bind-9.10.6]#useradd -r -d /var/named -s /sbin/nologin -m named #这里由于是系统用户，如果不加“-m”的话，是不能创建家目录的，切记！！！</code></pre><blockquote><p>（4）我们接下来看看如何安装bind</p></blockquote><pre><code>[root@localhost/usr/src/bind-9.10.6]#cat README</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-22_093021.png" alt=""></p><p>如果直接向定制bind程序，显然这样做是不能满足我们的需求的，我们可以使用如下操作定制我们bind程序</p><pre><code>[root@localhost/usr/src/bind-9.10.6]#./configure --help</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-22_093256.png" alt=""><br>如上图所示，这里只是截取部分图，这里可以选择我们要安装的包位置，启用或关闭某些功能，实现定制bind，相信很多第一次编译的像我这样的人来说认真研究一种程序源码安装过程，基本可以掌握别的源码包的安装。</p><pre><code>[root@localhost/usr/src/bind-9.10.6]#./configure --prefix=/app/bind10 --sysconfdir=/etc/bind10 </code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-22_093607.png" alt=""></p><p>来来看看，我说什么了，当出现这是不是不知道如何操作，没有人家说的很清楚了，没有gcc，那该如何解决呢？那么我们来安装一个开发包来解决这个问题</p><pre><code>[root@localhost/usr/src/bind-9.10.6]#yum groupinstall -y &quot;development tools&quot;</code></pre><p>那我们再来尝试一次，看看这次会出现什么幺蛾子。</p><pre><code>[root@localhost/usr/src/bind-9.10.6]#./configure --prefix=/app/bind10 --sysconfdir=/etc/bind10 </code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-22_094017.png" alt=""></p><p>看看我说什么来着，这次又出错啦，为什么呢？它提示我们说没有openssl程序，如果想依赖这个程序，可以安装openssl-devel；一般源码包遇到的情况，都安装相对的开发包即可。</p><p>那我们再来测试一次，看看还会出现什么情况呢？</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-22_094342.png" alt=""></p><p>当当当，哈哈，竟然成功啦   ；不过这只是成功了一部分，如果想继续成功那就实行下面步骤吧</p><blockquote><p>（5）进行编译安装</p></blockquote><pre><code>[root@localhost/usr/src/bind-9.10.6]#make ;make install  make 的作用是开始进行源代码编译，以及一些功能的提供，这些功能由他的 Makefile 设置文件提供相关的功能； make install 一般表示进行安装，相当于创建软连接，创建目录等等一些操作。</code></pre><blockquote><p>（6）这样安装的话是没有命令PATH和man帮助的，那如何实现呢？</p></blockquote><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-22_100032.png" alt=""></p><pre><code>[root@localhost~]#vim /etc/profile.d/env.sh[root@localhost~]#source !$source /etc/profile.d/env.sh</code></pre><p>export PATH=/app/bind10/bin:/app/bind10/sbin:$PATH</p><pre><code>[root@localhost~]#vim /etc/man_db.conf</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-22_101009.png" alt=""></p><blockquote><p>（7）刚刚在（2）比步骤是不是看看还有安装后脚本呀，对的你没有看错，那么我们来进行安装后脚本需要的操作。安装后脚本需要我们使用命令rndc-confgen创建相当于”暗号“，创建了暗号才能访问，那么我们就看看如何创建暗号呢？</p></blockquote><pre><code>[root@localhost~]#rndc-confgen -r /dev/urandom &gt; /etc/bind10/rndc.conf  #如果不重定向只能在终端上显示，写不到文件中</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-22_101550.png" alt=""></p><p>不过我们现在还没有主配置文件named.conf文件，怎么办呢？那就手动创建一个喽</p><pre><code>[root@localhost~]#vim /etc/bind10/named.conf</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-22_101931.png" alt=""><br>不过刚刚我们了解到bind程序运行者是named用户，但是我们来看看这个文件所有者和所属组是who</p><pre><code>[root@localhost~]#ll /etc/bind10/named.conf -rw-r--r--. 1 root root 200 Sep 22 10:19 /etc/bind10/named.conf[root@localhost~]#chgrp named /etc/bind10/named.conf    #修改所属组[root@localhost/etc/bind10]#chgrp named bind10/ -R  #修改文件都为named所属组</code></pre><blockquote><p>（8）不过DNS中解析当然需要根啦那么我们就创建一个喽</p></blockquote><pre><code>[root@localhost named]# scp named.ca 192.168.4.152:/var/named/  #从远程主机上拷贝一个[root@localhost/var]#chgrp named named/ -R  #修改权限</code></pre><p><code>[root@localhost~]#vim /etc/bind10/named.conf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-22_103158.png" alt=""></p><pre><code>[root@localhost/var/named]#vim test.com.zone    #编辑测试域</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-22_103607.png" alt=""></p><pre><code>[root@localhost/var/named]#chgrp named test.com.zone    #修改权限</code></pre><blockquote><p>（9）那我们接下来尝试着看看能不能起来服务</p></blockquote><pre><code>[root@localhost~]#named -u named -g -f -d 3[root@localhost~]#ss -tnul</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-22_104322.png" alt=""></p><p>端口53/tcp 53/udp 953/tcp 已经处于监听状态，说明启动已经成功</p><blockquote><p>（10）我们尝试看看可以解析么？</p></blockquote><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-22_110558.png" alt=""></p><p>那么接下来测测我们dns的性能如何喽</p><blockquote><p>对压力测试工具编译安装</p></blockquote><pre><code>[root@localhost ~]# cd /usr/src/bind-9.10.6/contrib/queryperf   #切换至源码包位置[root@localhost/usr/src/bind-9.10.6/contrib/queryperf]#./configure #进行编译[root@localhost/usr/src/bind-9.10.6/contrib/queryperf]#make[root@localhost/usr/src/bind-9.10.6/contrib/queryperf]#cp queryperf /app/bind10/bin/    #将程序复制到bind执行程序的目录下</code></pre><blockquote><p>创建一个测试文本</p></blockquote><pre><code>[root@localhost~]#vim test</code></pre><blockquote><p>测试</p></blockquote><pre><code>[root@localhost~]#queryperf -d test -s 127.0.0.1</code></pre><h2 id="三、实现管理DNS"><a href="#三、实现管理DNS" class="headerlink" title="三、实现管理DNS"></a>三、实现管理DNS</h2><h3 id="1、bind安装包"><a href="#1、bind安装包" class="headerlink" title="1、bind安装包"></a>1、bind安装包</h3><pre><code>bind-libs.x86_64             #库包           bind-libs-lite.x86_64       #     bind-license.noarch        #认证包bind-utils.x86_64            #提供对dns服务器的测试工具程序bind-chroot                     #为bind提供一个伪装的根目录以增强安全性</code></pre><h3 id="2、Bind配置文件"><a href="#2、Bind配置文件" class="headerlink" title="2、Bind配置文件"></a>2、Bind配置文件</h3><p>服务脚本    <code>/etc/rc.d/init.d/named</code>和<code>/usr/lib/systemcd/system/named.service</code></p><p>主配置文件<code>/etc/named.conf</code> <code>/etc/named/rfc1912.zones</code></p><p>存放根服务器地址 <code>/var/named/name.ca</code></p><p>解析库文件 <code>/var/named/ZONE_NAME_ZONE</code></p><p><strong>注意：</strong></p><p>（1）一台物理服务器可同时为多个区域提供解析。</p><p>（2）必须要有根文件：name.ca。</p><p>（3）应该有两个实现localhost和本地回环的解析库。</p><p>主配置文件<code>/etc/namd.conf</code></p><pre><code>// named.conf//// Provided by Red Hat bind package to configure the ISC BIND named(8) DNS// server as a caching only nameserver (as a localhost DNS resolver only).//// See /usr/share/doc/bind*/sample/ for example named configuration files.  #这个文件是一个参考例子//// See the BIND Administrator&#39;s Reference Manual (ARM) for details about the// configuration located in /usr/share/doc/bind-{version}/Bv9ARM.htmloptions {                                       #全局设置        listen-on port 53 { 127.0.0.1; };   #IPv4监听的端口和IP地址        listen-on-v6 port 53 { ::1; };         #IPv6监听的端口        directory       &quot;/var/named&quot;;       #zone配置文件存放目录        dump-file       &quot;/var/named/data/cache_dump.db&quot;;    #下载缓存数据库        statistics-file &quot;/var/named/data/named_stats.txt&quot;;      #静态文件        memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;        allow-query     { localhost; };     #允许询问        /*          - If you are building an AUTHORITATIVE DNS server, do NOT enable recursion.         - If you are building a RECURSIVE (caching) DNS server, you need to enable            recursion.            control to limit queries to your legitimate users. Failing to do so will           cause your server to become part of large scale DNS amplification            attacks. Implementing BCP38 within your network would greatly           reduce such attack surface         */        recursion yes;  #是否递归查询        dnssec-enable yes;      #是否支持DNSSEC开关        dnssec-validation yes;  #是否进行DNSSEC确认开关        /* Path to ISC DLV key */        bindkeys-file &quot;/etc/named.iscdlv.key&quot;;        managed-keys-directory &quot;/var/named/dynamic&quot;;        pid-file &quot;/run/named/named.pid&quot;;        session-keyfile &quot;/run/named/session.key&quot;;};logging {                           #日志信息        channel default_debug {                file &quot;data/named.run&quot;;  #存放的文件位置                severity dynamic;       #工作模式        };};zone &quot;.&quot; IN {                       #根域        type hint;                      #zone类型        file &quot;named.ca&quot;;            #文件名称};include &quot;/etc/named.rfc1912.zones&quot;; include &quot;/etc/named.root.key&quot;;</code></pre><p><strong>建议一般不要在这个文件中配置zone，可以在<code>/etc/named.rfc1912.zones</code>文件下进行配置。</strong></p><p><code>/var/named/named.localhost</code>   文件</p><pre><code>$TTL 1D@    IN SOA    @ rname.invalid. (                    0    ; serial                    1D    ; refresh                    1H    ; retry                    1W    ; expire                    3H )    ; minimum    NS    @    A    127.0.0.1    AAAA    ::1</code></pre><p>一般这个文件作为一个模板文件进行zone的配置。</p><h3 id="3、DNS转发服务器"><a href="#3、DNS转发服务器" class="headerlink" title="3、DNS转发服务器"></a>3、DNS转发服务器</h3><p> （1）全局转发：对非本机所负责区域的请求，全转发给指定的服务器。</p><pre><code>options{    forward  first|only；    forwarders { IP; };}；</code></pre><p>（2）特定区域转发：仅转发对特定区域的请求，比全局转发优先级高。</p><pre><code>zone &quot;ZONE_NAME&quot; IN {    tyep    forward;    forward first|only;    forwarders { IP; }};</code></pre><h3 id="4、从DNS服务器"><a href="#4、从DNS服务器" class="headerlink" title="4、从DNS服务器"></a>4、从DNS服务器</h3><p>（1）应该为一台独立的名称服务器</p><p>（2）主服务器区域解析文件中必须有一条NS记录指向从DNS服务器</p><p>（3）从服务器只需要定义区域，而无须提供解析库；解析库文件应该放置于<code>/var/named/slaves</code>目录下。</p><p>（4）主服务器得允许从服务器区域传送</p><p>（5）主从服务器的时间应该保持一致</p><p>（6）Bind程序版本应该保持一致；如果不一致，建议主服务器低，从服务器高。</p><p>（7）修改网卡配置文件<code>/etc/sysconfig/network-scripts-ifcfg-INTERFACE</code>,添加DNS记录。</p><h3 id="5、允许动态更新"><a href="#5、允许动态更新" class="headerlink" title="5、允许动态更新"></a>5、允许动态更新</h3><p>如果想启用此功能，可以在<code>/etc/named.rfc1912.zones</code>文件中定义之。</p>]]></content>
      
      
      <categories>
          
          <category> 服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BIND，DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP</title>
      <link href="/2017/11/28/PHP%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/"/>
      <url>/2017/11/28/PHP%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="CGI和FastCGI"><a href="#CGI和FastCGI" class="headerlink" title="CGI和FastCGI"></a>CGI和FastCGI</h2><h3 id="1、CGI"><a href="#1、CGI" class="headerlink" title="1、CGI"></a>1、CGI</h3><p>CGI（Common Gateway Interface，通用网关接口），HTTP服务器与你的货其他机器上的程序进行交谈的工具，其程序一般运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。</p><h3 id="2、FastCGI"><a href="#2、FastCGI" class="headerlink" title="2、FastCGI"></a>2、FastCGI</h3><p>FastCGI像是一个常驻型的CGI，它可以一直执行，只要激活后，不会每次都要花费时间去fork一次。</p><p><strong>工作原理</strong></p><p>（1）Web Server启动时载入FastCGI进程管理器（IIS ISAPI或Apache Module)</p><p>（2）FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web Server的连接。</p><p>（3）当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。 Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。</p><p>（4）FastCGI 子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时， 请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。</p><h3 id="3、php-fpm和FastCGI"><a href="#3、php-fpm和FastCGI" class="headerlink" title="3、php-fpm和FastCGI"></a>3、php-fpm和FastCGI</h3><h4 id="（1）两者之间有何联系"><a href="#（1）两者之间有何联系" class="headerlink" title="（1）两者之间有何联系"></a>（1）两者之间有何联系</h4><p>php的解析器是php-cgi，只能解析请求，返回结果，不会对进程管理；为了能调用php-cgi进程程序，php-fpm就诞生了。</p><p>#####在CentOS 6 中：</p><p>PHP-5.3.2之前，默认不支持fpm机制，需要自行打补丁并编译安装；</p><p>httpd-2.2：默认不支持fcgi协议，需要自行编译此模块；</p><p>为了能在CentOS 6 中支持此功能，编译安装http和php即可。</p><h5 id="在CentOS-7中："><a href="#在CentOS-7中：" class="headerlink" title="在CentOS 7中："></a>在CentOS 7中：</h5><p>httpd-2.4：rpm包默认编译支持了fcgi模块</p><p>php-fpm包：专用于将php运行于fpm模式</p><h4 id="（2）配置文件"><a href="#（2）配置文件" class="headerlink" title="（2）配置文件"></a>（2）配置文件</h4><p>这里在CentOS7中对php-fpm配置文件进行讲解</p><p><code>[root@localhost~]#yum install -y php-fpm</code>  #直接使用yum源安装即可</p><p>主配置文件：</p><pre><code>/etc/php-fpm.conf  和 /etc/php-fpm.d/*.conf</code></pre><p>选项介绍：</p><pre><code>pm = static(固定数量的子进程)|dynamic（以动态模式管理）pm.max_children  最大子进程pm.start_servers 初始化时开启的子进程pm.min_spare_servers 最小空闲子进程pm.max_spare_servers 最大空闲子进程pm.max_requests 每个子进程最大请求数量php_value[session.save_handler]     设置类型php_value[session.save_path]  文件的存储位置</code></pre><p>为了确保运行php-fpm进程的用户对session目录有读写权限</p><pre><code>mkdir /var/lib/php/sessionchown apache.apache /var/lib/php/session</code></pre><p>如果想支持远程主机：修改配置文件<code>/etc/php-fpm.d/www.conf</code></p><pre><code>listen  格式：    ip.add.re.ss:port    portlisten.allowed_clients  允许远程who连接，默认anylisten.backlog  等待队列的长度，-1表示无限制</code></pre><h3 id="（3）使http支持php-fpm"><a href="#（3）使http支持php-fpm" class="headerlink" title="（3）使http支持php-fpm"></a>（3）使http支持php-fpm</h3><p>确认httpd程序是否已经加载了<code>proxy_fcgi_module</code></p><p><code>[root@localhost/etc/php-fpm.d]#httpd -M |grep fcgi</code>    #必须加载了这个模块才能支持php-fpm</p><h5 id="进行配置"><a href="#进行配置" class="headerlink" title="进行配置"></a>进行配置</h5><p><code>[root@localhost/etc/httpd/conf.d]#vim fastcgi.conf</code></p><pre><code>   DirectoryIndex index.php #设置默认索引文件   ProxyRequests off    #是否开启正向代理   ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/var/www/html/$1    #路径匹配 </code></pre><p><code>[root@localhost/etc/httpd/conf.d]#ss -tnl</code> #查看端口是否开启</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-11_191546.jpg" alt=""></p><p>下面我们来测试下性能如何？</p><p><code>[root@localhost/etc/httpd/conf.d]#ab -c 10 -n 100 http://192.168.4.60/wordpress/</code>  #测试我们在CentOS 7 搭建的博客<br><img src="http://owatlfstl.bkt.clouddn.com/2017-10-11_191913.jpg" alt=""></p><p>独立运行的php跟模块方式运行的php的性能略有提升。</p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx模块</title>
      <link href="/2017/11/28/Nginx%E6%A8%A1%E5%9D%97/"/>
      <url>/2017/11/28/Nginx%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="一、ngx-http-fastcgi-module"><a href="#一、ngx-http-fastcgi-module" class="headerlink" title="一、ngx_http_fastcgi_module"></a>一、ngx_http_fastcgi_module</h2><p>转发请求到FastCGI服务器，不支持php模块方式</p><p>（1）fastcgi_pass address</p><p>address 为后端的fastcgi server的地址可用</p><pre><code>Syntax:    fastcgi_pass address;Default:    —Context:    location, if in location</code></pre><p>（2）fastcgi_index name</p><p>fastcgi默认的主页资源</p><pre><code>Syntax:    fastcgi_index name;Default:    —Context:    http, server, location</code></pre><p>示例</p><pre><code>fastcgi_index index.php</code></pre><p>（3）fastcgi_param parameter value [if_not_empty]</p><p>设置传递给fastcgi服务器的参数值，可以是文本，变量或组合</p><pre><code>Syntax:    fastcgi_param parameter value [if_not_empty];Default:    —Context:    http, server, location</code></pre><p>示例：</p><p>a、在php-fpm服务器上开启以下几行</p><pre><code>pm.status_path = /statusping.path = /pingping.response = pong</code></pre><p>b、在前端nginx服务器上进行如下配置</p><pre><code>location ~*\.php${    fastcgi_pass 192.168.4.60:9000;    fastcgi_index index.php;    fastcgi_param SCRIPT_FILENAME /app/websit/php$fascgi_script_name;    include fastcgi_params;    或者    include fastcgi.conf    或者直接修改fastcgi.conf配置文件不写fastcgi_param指令}</code></pre><p>通过/pm_status和/ping来获取fpm server状态信息</p><pre><code>location ~^/(pm_status/ping)${    fastcgi_pass 192.168.4.60:9000    fastcgi_param SCRIPT_FILENAME $fastcgi_script_name;    include fascgi.conf}</code></pre><p>（4）fastcgi_cache_path path </p><p>[levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time]</p><p>定义fastcgi缓存</p><pre><code>Syntax:    fastcgi_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time];Default:    —Context:    httpmax_size：磁盘path路径中用于缓存数据的缓存空间上限levels=levels：缓存目录的层级数量，以及每以及的目录数量keys_zone=name：size k/v映射的内存空间的名称及大小inactive：非活动时长</code></pre><p>（5）fastcgi_cache zone|off</p><p>调用指定的缓存空间来缓存数据</p><pre><code>Syntax:    fastcgi_cache zone | off;Default:    fastcgi_cache off;Context:    http, server, location</code></pre><p>（6）fastcgi_cache_key  string</p><p>定义用作缓存向的key的字符串</p><p>示例：</p><pre><code>fastcgi_cache_key $request_uri;</code></pre><p>（7）fastcgi_cache_methods GET|HEAD|POST</p><p>为哪些请求方法使用缓存</p><pre><code>Syntax:    fastcgi_cache_methods GET | HEAD | POST ...;Default:    fastcgi_cache_methods GET HEAD;Context:    http, server, location</code></pre><p>（8）fastcgi_cache_min_uses number</p><p>缓存空间中的缓存项在inactive定义的非活动时间至少要被访问到此处所指定的次数方可悲认作为活动项</p><pre><code>Syntax:    fastcgi_cache_min_uses number;Default:    fastcgi_cache_min_uses 1;Context:    http, server, location</code></pre><p>（9）fastcgi_keep_conn on|off</p><p>收到后端服务器响应 后，fastcgi服务器是否关闭连接，建议启用长连接</p><pre><code>Syntax:    fastcgi_keep_conn on | off;Default:    fastcgi_keep_conn off;Context:    http, server, location</code></pre><p>（10）fastcgi_cache_valid [code…]time</p><p>不同的响应码各自的缓存时长</p><pre><code>Syntax:    fastcgi_cache_valid [code ...] time;Default:    —Context:    http, server, location</code></pre><p>示例：</p><pre><code>fastcgi_cache_vaild 200 302 10mhttp {     fastcgi_cache_path /var/cache/nginx fcgi_cache levels=1:2:1 keys_zone=fcgicache:20m inactive=120s;     server {         location ~* \.php$ {                fastcgi_cache fcgicache;                 fastcgi_cache_key $request_uri;                 fastcgi_cache_valid 200 302 10m;                 fastcgi_cache_valid 301 1h;                 fastcgi_cache_valid any 1m;         }    }}</code></pre><h2 id="二、ngx-http-proxy-module"><a href="#二、ngx-http-proxy-module" class="headerlink" title="二、ngx_http_proxy_module"></a>二、ngx_http_proxy_module</h2><p>（1）proxy_pass URL</p><pre><code>Syntax:    proxy_pass URL;Default:    —Context:    location, if in location, limit_exceptproxy_pass http://localhost:8000/uri/;</code></pre><h4 id="proxy-pass后面的路径不带URI时，其会将location的URI传递给后端主机"><a href="#proxy-pass后面的路径不带URI时，其会将location的URI传递给后端主机" class="headerlink" title="proxy_pass后面的路径不带URI时，其会将location的URI传递给后端主机"></a>proxy_pass后面的路径不带URI时，其会将location的URI传递给后端主机</h4><p>即：</p><pre><code>server {    server_name www.test.com;     location /URI/ {          proxy_pass http://host[:port]; 最后没有/     }}</code></pre><p><a href="http://www.test.com/URI--&gt;http://host[:port]/URI" target="_blank" rel="noopener">http://www.test.com/URI--&gt;http://host[:port]/URI</a></p><p>如果<a href="http://host[:port]/URI是这样的会会提供location中的URI替换" target="_blank" rel="noopener">http://host[:port]/URI是这样的会会提供location中的URI替换</a></p><pre><code>server {    server_name HOSTNAME;     location /uri/ {     proxy_pass http://host/new_uri/;     }  }</code></pre><p><a href="http://HOSTNAME/uri/" target="_blank" rel="noopener">http://HOSTNAME/uri/</a> –&gt; <a href="http://host/new_uri/" target="_blank" rel="noopener">http://host/new_uri/</a></p><h4 id="如果location定义其URI时使用了正则表达式，则proxy-pass之后必须不能使用URI；即http-host-port-后面不能带“-”。"><a href="#如果location定义其URI时使用了正则表达式，则proxy-pass之后必须不能使用URI；即http-host-port-后面不能带“-”。" class="headerlink" title="如果location定义其URI时使用了正则表达式，则proxy_pass之后必须不能使用URI；即http://host/[:port]后面不能带“/”。"></a>如果location定义其URI时使用了正则表达式，则proxy_pass之后必须不能使用URI；即<a href="http://host/[:port]后面不能带“/”。" target="_blank" rel="noopener">http://host/[:port]后面不能带“/”。</a></h4><p>（2）proxy_set_header filed value</p><p>设定发往后端主机的请求报文的请求首部的值</p><pre><code>Syntax:    proxy_set_header field value;Default:    proxy_set_header Host $proxy_host;            proxy_set_header Connection close;Context:    http, server, location</code></pre><p>示例：</p><pre><code>proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</code></pre><p>如果需要修改日志格式：在nginx.conf配置文件中修改日志格式</p><pre><code>logfromat %{X-Real-IP} ...此处为proxy_set_header定义的变量</code></pre><p>（3）proxy_cache_path</p><p>定义可用于proxy功能的缓存</p><pre><code>Syntax:    proxy_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time];Default:    —Context:    httppath 缓存路径level 级别</code></pre><p>示例：</p><pre><code>proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;</code></pre><p>（4）proxy_cache zone|off </p><p>指明调用的缓存，或关闭缓存机制</p><pre><code>Syntax:    proxy_cache zone | off;Default:    proxy_cache off;Context:    http, server, location</code></pre><p>（5）proxy_cache_key string</p><p>缓存中用于“键”的内容</p><pre><code>Syntax:    proxy_cache_key string;Default:    proxy_cache_key $scheme$proxy_host$request_uri;Context:    http, server, location</code></pre><p><strong>示例：</strong></p><pre><code>proxy_cache_key &quot;$host$request_uri $cookie_user&quot;;</code></pre><p>（6）proxy_cache_valid [code…] time</p><p>定义对特定响应码的响应内容的缓存时长</p><pre><code>Syntax:    proxy_cache_valid [code ...] time;Default:    —Context:    http, server, location</code></pre><p><strong>示例：</strong></p><pre><code>首先在nginx.conf配置文件中定义http{    proxy_cache_path /var/cache/nginx/proxy_cache levels=1:1:1 keys_zone=proxycache:20m inactive=120s max_size=1g;    server{        proxy_cache proxycache;        proxy_cache_key $request_uri;        proxy_cache_valid 200 302 301 1h        proxy_cache_vaild any 1m;    }}</code></pre><p>（7）proxy_cache_use_stale</p><p>在被代理的后端服务器出现那种情况下，可以直接使用过期缓存响应客户端</p><pre><code>Syntax:    proxy_cache_use_stale error | timeout | invalid_header | updating | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | off ...;Default:    proxy_cache_use_stale off;Context:    http, server, location</code></pre><p>（8）proxy_cache_methods </p><p>对哪些客户端请求方法对应的响应进行缓存</p><pre><code>Syntax:    proxy_cache_methods GET | HEAD | POST ...;Default:    proxy_cache_methods GET HEAD;Context:    http, server, location</code></pre><p>（9）proxy_hide_header field</p><p>用于隐藏后端服务器特定的响应首部</p><pre><code>Syntax:    proxy_hide_header field;Default:    —Context:    http, server, location</code></pre><p>By default, nginx does not pass the header fields“Date”, “Server”, “X-Pad”, and “X-Accel-…” from theresponse of a proxied server to a client.</p><p>（10）proxy_connect_timeout time</p><p>定义域后端服务器建立连接超时时长，如果超时会出现502错误</p><pre><code>Syntax:    proxy_connect_timeout time;Default:    proxy_connect_timeout 60s;Context:    http, server, location</code></pre><p>（11）proxy_send_timeout time</p><p>把请求发送给后端服务器的超时时长</p><pre><code>Syntax:    proxy_send_timeout time;Default:    proxy_send_timeout 60s;Context:    http, server, location</code></pre><p>（12）proxy_read_timeout time</p><p>等待祸端服务器发送响应报文的超时时长</p><pre><code>Syntax:    proxy_read_timeout time;Default:    proxy_read_timeout 60s;Context:    http, server, location</code></pre><h2 id="三、ngx-http-upstream-module"><a href="#三、ngx-http-upstream-module" class="headerlink" title="三、ngx_http_upstream_module"></a>三、ngx_http_upstream_module</h2><p>用于将多个服务器定义成服务器组，而由proxy_pass，fastcgi_pass等指令进行引用。</p><p>（1）upstream name {…}</p><p>定义后端服务器组，会引入一个新的上下文，默认调度算法为wrr。</p><pre><code>Syntax:    upstream name { ... }Default:    —Context:    stream</code></pre><p>示例：</p><pre><code>upstream websrvs{        server 192.168.4.60:80 weight=2        server 192.168.4.61:81 weight=1        server 192.168.4.62:82 weight=3}</code></pre><p>upstream模块的负载均衡算法主要有三种：论调（round-robin）、ip哈希（ip_hash）和最少连接（least_conn）</p><p>（2）server address [parameters]</p><p>在upstream上下文中server成员，以及相关的参数</p><pre><code>Syntax:    server address [parameters];Default:    —Context:    upstream</code></pre><p>address表示格式</p><pre><code>unix：/PATH/TO/SOME_SOCK_FILEIP[:PORT]HOSTNAME[:PORT]</code></pre><p>parameters</p><pre><code>weight=number 权重，默认为1max_conns 连接后端服务器最大并发活动连接数max_fails=number 失败尝试最大次数；超出此处指定的次数时，server将被标记为不可用，默认为1backup 将服务器为“备用”，即所有服务器不可用时才启用down：标记位不可用，配合ip_hash使用，使用灰度发布（部分上线）；可以实现打补丁，维护等</code></pre><p>（3）ip_hash</p><p>源地址hash调度方法，如果是同一个机器调度到同一个RS上</p><p>（4）least_conn</p><p>最少连接调度算法，当server拥有不同权重时，其为wlc，当所有后端主机连接数相同时，则使用wrr，适用于长连接。</p><p>（5）hash key [consistent]</p><p>基于指定的key的hash表来实现对请求的调度，此处key可以直接文本、变量或者二者结合</p><p>作用：将请求分类，同一类请求或将发往同一个upstream server，使用consistent参数，将使用kerama一致性hash算法；适用于后端是cache服务器时使用。</p><pre><code>hash $request_uri consistent 如果使用相同的uri将发往同一台服务器上hash $remote_addr 和ip_hash作用类似</code></pre><p>（6）keepalive N</p><p>为每个worker进程保留的空闲的长连接数量，可节约nginx端口，并减少连接管理的消耗</p><p>（7）health_check [parameters]</p><p>健康状态检测机制，</p><pre><code>Syntax:    health_check [parameters];Default:    —Context:    location</code></pre><p>常用参数：</p><pre><code>interval=time 检测的频率，默认为5秒fails=number 判断服务器不可用的失败检测次数，默认为1次passes=number 判断服务器可用的失败检测次数，默认为1次uri=uri 做健康状态检测测试的目标uri，默认为“/”match=NAME：健康状态检测的结果评估调用此处指定的match配置快 </code></pre><p><strong>此指令只对nginx plus 有效</strong></p><p>（8）match name {…}</p><p>对backend server 做健康性检测时，定义其结果判断机制，</p><pre><code>Syntax:    match name { ... }Default:    —Context:    http</code></pre><p>常用参数：</p><pre><code>status code[code...] 期望的响应状态码header HEADER[operator value]：期望存在响应首部，也可对期望的响应首部的值基于比较操作符和值进行比较body；期望响应报文的主体部分应该有的内容。</code></pre><p>示例：</p><pre><code># status is 200, content type is &quot;text/html&quot;,# and body contains &quot;Welcome to nginx!&quot;match welcome {    status 200;    header Content-Type = text/html;    body ~ &quot;Welcome to nginx!&quot;;}# status is not one of 301, 302, 303, or 307, and header does not have &quot;Refresh:&quot;match not_redirect {    status ! 301-303 307;    header ! Refresh;}# status ok and not in maintenance modematch server_ok {    status 200-399;    body !~ &quot;maintenance mode&quot;;}</code></pre><h2 id="ngx-stream-core-module"><a href="#ngx-stream-core-module" class="headerlink" title="ngx_stream_core_module"></a>ngx_stream_core_module</h2><p>模拟反代基于TCP或UDP的服务连接，即工作于传输层的反代或调度器</p><p>（1）stream{…}</p><p>定义stream相关的服务</p><p>示例：</p><pre><code>upstream telnetsrvs {    server 192.168.4.60:23;    server 192.168.4.61:23;    least_conn;}server{    listen 192.168.4.55:23;    proxy_pass telnetsrvs;   }</code></pre><h2 id="ngx-stream-proxy-module"><a href="#ngx-stream-proxy-module" class="headerlink" title="ngx_stream_proxy_module"></a>ngx_stream_proxy_module</h2><p>实现代理基于TCP\UDP,UNIX-domain sockets数据流</p><p>（1）proxy_pass address</p><p>指定后端服务器地址</p><p>（2）proxy_timeout timeout</p><p>无数据传输时，保持连接状态的超时时长；默认为10m</p><p>（3）proxy_connect_timeout time</p><p>设置nginx与被代理的服务器尝试建立连接的超时时长，默认为60s</p><p>示例：</p><pre><code>stream {    upstream telnetsrvs{        server 192.168.4.60:23;        server 192.168.4.61:23;        hash $remote_addr consistent    }    server{        listen 192.168.4.55:2323;        proxy_pass telnetsrvs;        proxy_timeout 60s;        proxy_connect_timeout 10s;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AIDE</title>
      <link href="/2017/11/28/AIDE/"/>
      <url>/2017/11/28/AIDE/</url>
      
        <content type="html"><![CDATA[<h2 id="一、AIDE"><a href="#一、AIDE" class="headerlink" title="一、AIDE"></a>一、AIDE</h2><p>当一个入侵者进入了你的系统并且种植了木马，通常会想办法来隐蔽这个木马（除了木马自身的一些隐蔽特性外，他会尽量给你检查系统的过程设置障碍），通常入侵者会修改一些文件，比如管理员通常用ps -aux来查看系统进程，那么入侵者很可能用自己经过修改的ps程序来替换掉你系统上的ps程序，以使用ps命令查不到正在运行的木马程序。如果入侵者发现管理员正在运行crontab作业，也有可能替换掉crontab程序等等。所以由此可以看出对于系统文件或是关键文件的检查是很必要的。目前就系统完整性检查的工具用的比较多的有两款：Tripwire和AIDE，前者是一款商业软件，后者是一款免费的但功能也很强大的工具。</p><h3 id="1、AIDE-概念"><a href="#1、AIDE-概念" class="headerlink" title="1、AIDE 概念"></a>1、AIDE 概念</h3><p>AIDE(Adevanced Intrusion Detection Environment)高级入侵检测环境)是一个入侵检测工具，主要用途是检查文件的完整性，审计计算机上的那些文件被更改过了。</p><h3 id="2、工作机制"><a href="#2、工作机制" class="headerlink" title="2、工作机制"></a>2、工作机制</h3><p>AIDE能够构造一个指定文件的数据库，它使用aide.conf作为其配置文件。AIDE数据库能够保存文件的各种属性，包括：权限(permission)、索引节点序号(inode number)、所属用户(user)、所属用户组(group)、文件大小、最后修改时间(mtime)、创建时间(ctime)、最后访问时间(atime)、增加的大小以及连接数。AIDE还能够使用下列算法：sha1、md5、rmd160、tiger，以密文形式建立每个文件的校验码或散列号。</p><p><strong>建议：这个数据库不应该保存那些经常变动的文件信息，例如：日志文件、邮件、/proc文件系统、用户起始目录以及临时目录。</strong></p><h2 id="二、AIDE使用介绍"><a href="#二、AIDE使用介绍" class="headerlink" title="二、AIDE使用介绍"></a>二、AIDE使用介绍</h2><h3 id="1、安装AIDE包"><a href="#1、安装AIDE包" class="headerlink" title="1、安装AIDE包"></a>1、安装AIDE包</h3><p><code>[root@centos6~]#yum install -y aide</code></p><h3 id="2、AIDE的配置文件"><a href="#2、AIDE的配置文件" class="headerlink" title="2、AIDE的配置文件"></a>2、AIDE的配置文件</h3><p><code>/etc/aide.conf</code></p><p> The location of the database to be read. aide检查是从下面的文件中读取<br>database=<code>/var/lib/aide/aide.db.gz</code></p><p>The location of the database to be written.aide更新数据库是写到下面文件中<br>database_out=<code>/var/lib/aide/aide.db.new.gz</code></p><table><thead><tr><th>设定选项</th><th>解释</th></tr></thead><tbody><tr><td>p</td><td>permissions</td></tr><tr><td>i</td><td>inode</td></tr><tr><td>n</td><td>number of links</td></tr><tr><td>u</td><td>user</td></tr><tr><td>g</td><td>group</td></tr><tr><td>s</td><td>size</td></tr><tr><td>b</td><td>block count</td></tr><tr><td>m</td><td>mtime</td></tr><tr><td>a</td><td>atime</td></tr><tr><td>c</td><td>ctime</td></tr><tr><td>S</td><td>check for growing size</td></tr><tr><td>acl</td><td>Access Control Lists</td></tr><tr><td>selinux</td><td>SELinux security context</td></tr><tr><td>xattrs</td><td>Extended file attributes</td></tr><tr><td>md5</td><td>md5 checksum</td></tr><tr><td>sha1</td><td>sha1 checksum</td></tr><tr><td>sha256</td><td>sha256 checksum</td></tr><tr><td>sha512</td><td>sha512 checksum</td></tr><tr><td>rmd160</td><td>rmd160 checksum</td></tr><tr><td>tiger</td><td>tiger checksum</td></tr></tbody></table><p>定义检测属性时可以组合定义，相当于alias作用。</p><h3 id="3、aide命令介绍"><a href="#3、aide命令介绍" class="headerlink" title="3、aide命令介绍"></a>3、aide命令介绍</h3><table><thead><tr><th>选项</th><th>解释</th></tr></thead><tbody><tr><td>-i，–init</td><td>初始化数据库</td></tr><tr><td>-C，–check</td><td>检查数据库</td></tr><tr><td>-u，–update</td><td>更新数据库</td></tr></tbody></table><p>初始化数据库：</p><p><code>[root@centos6~]#aide --init</code></p><p>查看<code>/var/lib/aide/</code>目录下是否生成数据库</p><p>检查数据库时，必须把命令该为<code>aide.db.gz</code>才能检查数据库。</p><p><code>[root@centos6/var/lib/aide]#mv aide.db.new.gz aide.db.gz</code><br><code>[root@centos6~]#aide -C</code></p><p>更新数据库</p><p><code>[root@centos6~]#aide -u</code></p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AIDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAM</title>
      <link href="/2017/11/28/PAM/"/>
      <url>/2017/11/28/PAM/</url>
      
        <content type="html"><![CDATA[<h2 id="PAM认证"><a href="#PAM认证" class="headerlink" title="PAM认证"></a>PAM认证</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>   PAM （Pluggable Authentication Modules）可插入认证模块是一套共享库,使本地系统管理员可以随意选择程序的认证方式.。提供了对所有服务进行认证的中央机制，适用于login，远程登录（telnet，rlogin,fsh,ftp，点对点协议（ppp）），su等应用程序中。系统管理员通过PAM配置文件来指定不同应用程序的不同认证策略；应用程序开发者通过在服务程序中使用PAM API来实现对认证方法的调用；而PAM服务模块的开发者则利用PAM SPI来编写模块，主要调用一些函数，将不同的认证机制加入到系统中；PAM接口库则读取配置文件，将应用和相应PAM服务模块联系起来。</p><h3 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h3><p>模块存放位置<code>/lib64/security/</code></p><p>环境相关的配置<code>/etc/security/</code> 模块通过读取配置文件完成用户对系统资源的使用控制</p><p>主配置文件<code>/etc/pam.conf</code> 默认不存在</p><p>文档 /usr/share/doc/pam-*;man -k pam_   查看所有pam的说明</p><p><strong>注意：如果/etc/pam.d/和/etc/pam.conf两个文件同时存在，则只有/etc/pam.d/*下的文件起效。</strong></p><h3 id="3、认证原理"><a href="#3、认证原理" class="headerlink" title="3、认证原理"></a>3、认证原理</h3><p>PAM一般遵循的顺序：server–&gt;PAM（配置文件）–&gt;pam.*so；PAM认证首先要确定哪一项服务，然后加载相应PAM的配置文件（/etc/pam.d）,最后调用认证文件（/lib64/security/）进行认证。</p><h3 id="4、passwd程序PAM认证机制过程"><a href="#4、passwd程序PAM认证机制过程" class="headerlink" title="4、passwd程序PAM认证机制过程"></a>4、passwd程序PAM认证机制过程</h3><p>（1）用户执行/usr/bin/passwd程序，并输入密码；</p><p>（2）passwd开始呼叫PAM模块，PAM模块会搜寻passwd程序的PAM相关设定文件，这个设定文件在<code>/etc/pam.d/</code>目录下与之程序同名的文件。即PAM会搜寻<code>/etc/pam.d/passwd</code></p><p>（3）经由<code>/etc/pam.d/passwd</code>设定的文件数据取用PAM所提供的相关模块来进行验证；</p><p>（4）将验证结果回传给passwd程序，而passwd这个程序会根据PAM回传的结果决定下一个动作。</p><h3 id="5、-etc-pam-d-目录下文件格式"><a href="#5、-etc-pam-d-目录下文件格式" class="headerlink" title="5、/etc/pam.d/目录下文件格式"></a>5、/etc/pam.d/目录下文件格式</h3><p>|<br>|type|control|module-path|argument|</p><p>（1）type类型</p><table><thead><tr><th>type</th><th>解释</th></tr></thead><tbody><tr><td>Auth</td><td>账号的认证和授权</td></tr><tr><td>Account</td><td>与账号管理相关的非认证类的功能</td></tr><tr><td>Password</td><td>用户修改密码复杂度检查机制等功能</td></tr><tr><td>Session</td><td>用户获取之前或使用服务完成之后需要进行的一些附加操作，如打开或关闭数据的信息，监视目录等</td></tr><tr><td>-type</td><td>表示因为缺失而不能加载的模块将不记录在系统日志，对于不总是安装在系统上的模块有用</td></tr></tbody></table><p>（2）control PAM库如何处理与该服务相关的PAM模块成功或失败情况</p><table><thead><tr><th>control</th><th>解释</th></tr></thead><tbody><tr><td>required</td><td>一票否决，表示本模块必须返回成功才能通过认证，但是如果该模块返回失败，失败结果也不会立即通知用户，而是要等到同一type类型全部执行完毕再将放回给应用程序。即为必要条件</td></tr><tr><td>requisite</td><td>一票否决，该模块必须返回成功才能通过认证，但是一旦该模块返回失败，将不再执行同一type内的任何模块，而是直接将控制权返回给应用程序。即一个必要条件</td></tr><tr><td>sufficient</td><td>一票通过权，表明本模块返回成功则通过身份认证的要求，不必再执行同一type内的其他模块，但是如果本模块返回失败可忽略，即充分条件</td></tr><tr><td>optional</td><td>表明本模块为可选的，它的成功与否不会对身份认证起关键作用，其返回值一般被忽略</td></tr><tr><td>include</td><td>调用其他的配置文件中定义的配置信息</td></tr></tbody></table><p>还有另外一种方式：使用一个或多个“status=action”<br>    status：检查结果的返回值<br>    action：采取行为ok，done，die，bad，ignore，reset</p><table><thead><tr><th>action</th><th>解释</th></tr></thead><tbody><tr><td>ok</td><td>模块通过，继续检查</td></tr><tr><td>done</td><td>模块通过，返回最后检查给应用</td></tr><tr><td>bad</td><td>结果失败，继续检查</td></tr><tr><td>die</td><td>结果失败，返回失败结果给应用</td></tr><tr><td>ingore</td><td>结果忽略，不影响最后结果</td></tr><tr><td>reset</td><td>忽略已经得到的结果</td></tr></tbody></table><p>（3）modules-path</p><p>相对路径:/lib64/security目录下的模块可使用的相对路径；如pam_shells.so<br>绝对路径：如果编译安装以后模块存放的位置</p><p><strong>建议：将来修改PAM文件时，备用一个ssh连接窗口，以免我们误操作。</strong></p><p>（4）argument 用来给该模块传递参数</p><h3 id="6、常用pam模块"><a href="#6、常用pam模块" class="headerlink" title="6、常用pam模块"></a>6、常用pam模块</h3><p>1、pam_shells：检查有效shell 会调用文件/etc/shells</p><p><strong>示例</strong></p><p>（a）先创建用户指定其bash为/bin/csh</p><p><code>[root@centos6~]#useradd -s /bin/bash wang</code></p><p>（b）在CentOS6上修改/etc/shells和/etc/pam.d/su文件</p><p>在认证前添加</p><pre><code>auth       required     pam_shells.so</code></pre><p>（c）在CnetOS6使用wang账户登录</p><p><code>[root@localhostsecurity]#su - wang</code></p><pre><code>Password: su: incorrect password</code></pre><p>但是此时使用ssh还可以连接</p><p><code>[root@localhostpam.d]#ssh wang@192.168.4.131</code></p><pre><code>wang@192.168.4.131&#39;s password: Last login: Thu Sep 14 13:42:35 2017 from 192.168.4.131</code></pre><p>如果我们想彻底禁止wang登录把/etc/pam.d/su 和/etc/pam.d/sshd两个文件在auth前天添加如下一行：</p><pre><code>auth       required     pam_shells.so</code></pre><p>（d）如果让wang登录删除上述设置即可。</p><p>2、pam_securetty.so：只允许root用户在/etc/securetty列出的安全终端上登录</p><p><strong>示例</strong></p><p>允许telnet使用root登录</p><p>方法一：</p><p>修改配置文件<code>/etc/pam.d/remote</code>配置文件</p><pre><code>#auth required pam_securetty.so</code></pre><p>方法二：</p><p>直接修改<code>/etc/securetty</code>添加所需要登录的终端；如果连接的终端使用完毕后，后续的连接将不会执行。</p><p>3、pam_nologin.so：如果/etc/nologin文件存在，将导致非root用户不能登录</p><p>作用机理：如果用户shell是/etc/nologin时，当该用户登录时，会显示/etc/nologin.txt文件内容，并拒绝登录。</p><p>file=/PATH/TO/SOMEFILE</p><p><strong>示例</strong></p><p>修改配置文件login文件添加入下面一行：</p><pre><code>auth       required     pam_nologin.so</code></pre><p>在CentOS7使用wang登录</p><p><code>[root@centos7~]#ssh wang@192.168.4.131</code></p><pre><code>wang@192.168.4.131&#39;s password: Connection closed by 192.168.4.131</code></pre><p>如果想给非root用户提示信息可以编辑文件<code>/etc/pam.d/nologin</code></p><pre><code>account    required     pam_nologin.so file=/etc/nologin.txt</code></pre><p>4、pam_limits.so：在用户级别对其可使用的资源的限制</p><p>（1）配置文件</p><pre><code>/etc/security/limits.conf/etc/security/limits.d/*.conf</code></pre><p>（2）格式</p><p>|<br>|domain|type|item|value|</p><p>（a）domain 应用于哪些对象</p><pre><code>username 单个用户@group 组内所有用户</code></pre><p>（b）type类型</p><pre><code>soft软限制，普通用户可以自己修改；如果出现会有警告信息hard硬限制，只有root能设定，且通过kernel强制生效-：两者同时设定</code></pre><p> （c）item 限制资源</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>core</td><td>limits the core file size (KB)</td></tr><tr><td>data</td><td>max data size (KB)</td></tr><tr><td>fsize</td><td>maximum filesize (KB)</td></tr><tr><td>memlock</td><td>max locked-in-memory address space (KB)</td></tr><tr><td>nofile</td><td>max number of open file descriptors</td></tr><tr><td>rss</td><td>max resident set size (KB)</td></tr><tr><td>stack</td><td>max stack size (KB)</td></tr><tr><td>cpu</td><td>max CPU time (MIN)</td></tr><tr><td>nproc</td><td>max number of processes</td></tr><tr><td>as</td><td>address space limit (KB)</td></tr><tr><td>maxlogins</td><td>max number of logins for this user</td></tr><tr><td>maxsyslogins</td><td>max number of logins on the system</td></tr><tr><td>priority</td><td>the priority to run user process with</td></tr><tr><td>locks</td><td>max number of file locks the user can hold</td></tr><tr><td>sigpending</td><td>max number of pending signals</td></tr><tr><td>msgqueue</td><td>max memory used by POSIX message queues (bytes)</td></tr><tr><td>nice</td><td>max nice priority allowed to raise to values: [-20, 19]</td></tr><tr><td>rtprio</td><td>max realtime priority</td></tr></tbody></table><p>（4）value 指定具体值</p><p>ulimit命令的使用</p><table><thead><tr><th>选项</th><th>解释</th></tr></thead><tbody><tr><td>-a</td><td>列出所有设定值</td></tr><tr><td>-n</td><td>最多打开的文件描述符个数</td></tr><tr><td>-u</td><td>最大用户进程数</td></tr><tr><td>-S</td><td>使用’SOFT’资源限制</td></tr><tr><td>-H</td><td>使用‘HARD’资源限制</td></tr></tbody></table><p>5、pam_time.so</p><p>（1）格式：</p><pre><code>services; ttys ；users； times </code></pre><p>（2）services 服务程序名称</p><p>（3）ttys 登录的终端  可是使用*</p><p>（4）users 用户</p><p>（5）times </p><pre><code>格式：day/time-rangeMo Tu We Th Fr Sa Su Wk Wd AlMoMo = no day MoWk = all weekdays bar Monday 所有的工作日但是除了星期一AllFr 所有添但是除了星期五time-range：格式：HHMM如果开始时间小于结束时间，系统假设到了第二天。可是使用模式  “&amp;” “ |”“ ！” </code></pre><p><strong>示例</strong></p><ul><li>禁止用户上班时间使用ssh服务</li></ul><p>编辑/etc/security/time.conf添加如下一行：</p><pre><code>sshd;*;centos;Wk</code></pre><p>编辑/etc/pam.d/sshd添加如下一行：</p><pre><code>auth       required     pam_time_so</code></pre><p>了解pam_group.so模块</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PXE</title>
      <link href="/2017/11/28/PXE/"/>
      <url>/2017/11/28/PXE/</url>
      
        <content type="html"><![CDATA[<h2 id="一、PXE"><a href="#一、PXE" class="headerlink" title="一、PXE"></a>一、PXE</h2><h3 id="1、pxe概念"><a href="#1、pxe概念" class="headerlink" title="1、pxe概念"></a>1、pxe概念</h3><p>PXE(preboot execute environment，预启动执行环境)是由Intel公司开发的最新技术，工作于Client/Server的网络模式，支持工作站通过网络从远端服务器下载映像，并由此支持通过网络启动操作系统，在启动过程中，终端要求服务器分配IP地址，再用TFTP（trivial file transfer protocol）或MTFTP(multicast trivial file transfer protocol)协议下载一个启动软件包到本机内存中执行，由这个启动软件包完成终端（客户端）基本软件设置，从而引导预先安装在服务器中的终端操作系统。PXE可以引导多种操作系统，如：Windows95/98/2000/windows2003/windows2008/winXP/win7/win8,linux系列系统等。</p><h3 id="2、pxe的工作原理"><a href="#2、pxe的工作原理" class="headerlink" title="2、pxe的工作原理"></a>2、pxe的工作原理</h3><p>（1）Client向PXE Server上的DHCP发送IP地址请求消息，</p><p>（2）DHCP检测Client是否合法（主要是检测Client的网卡MAC地址），如果合法则返回Client的IP地址，同时将启动文件pxelinux.0的位置信息一并传送给Client</p><p>（3）Client向PXE Server上的TFTP发送获取pxelinux.0请求消息，TFTP接收到消息之后再向Client发送pxelinux.0大小信息，试探Client是否满意，当TFTP收到Client发回的同意大小信息之后，正式向Client发送pxelinux.0</p><p>（4）Client执行接收到的pxelinux.0文件</p><p>（5）Client向TFTP Server发送针对本机的配置信息文件（在 TFTP 服务的pxelinux.cfg目录下），TFTP将配置文件发回Client，继而Client根据配置文件执行后续操作。</p><p>（6）Client向TFTP发送Linux内核请求信息，TFTP接收到消息之后将内核文件发送给Client</p><p>（7）Client向TFTP发送根文件请求信息，TFTP接收到消息之后返回Linux根文件系统</p><p>（8）Client启动Linux内核</p><p>（9）Client下载安装源文件，读取自动化安装脚本<br><img src="http://owatlfstl.bkt.clouddn.com/timg.jpg" alt=""></p><h3 id="3、PXE依赖的服务、软件包及文件"><a href="#3、PXE依赖的服务、软件包及文件" class="headerlink" title="3、PXE依赖的服务、软件包及文件"></a>3、PXE依赖的服务、软件包及文件</h3><h4 id="（1）dhcp服务"><a href="#（1）dhcp服务" class="headerlink" title="（1）dhcp服务"></a>（1）dhcp服务</h4><p>如果不理解dhcp请查看<a href="http://merit.blog.51cto.com/10757694/1966078" target="_blank" rel="noopener">http://merit.blog.51cto.com/10757694/1966078</a></p><h4 id="（2）tftp服务"><a href="#（2）tftp服务" class="headerlink" title="（2）tftp服务"></a>（2）tftp服务</h4><p>（a）tftp的安装包</p><pre><code>tftp 客户端，tftp-server服务端</code></pre><p>（b）端口号为69/UDP</p><p>（c）配置为文件</p><p>/etc/xinetd.d/tftp</p><pre><code>service tftp{        socket_type             = dgram        protocol                = udp        wait                    = yes        user                    = root        server                  = /usr/sbin/in.tftpd        server_args             = -s /var/lib/tftpboot        disable                 = yes   #此选项是否开启tftp服务        per_source              = 11        cps                     = 100 2        flags                   = IPv4}</code></pre><p>（d）如何 CentOS 7如何启动此服务？<br><code>[root@localhost ~]# yum install -y tftp-server</code></p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>直接修改配置文件<br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-17_190343.png" alt=""><br><code>[root@localhost ~]# systemctl start tftp</code>  #启动服务<br><code>[root@localhost ~]# ss -unl</code>   #查看端口是否启动<br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-17_190608.png" alt=""></p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>直接启动服务并设置开机自动启动<br><code>[root@localhost ~]# systemctl start tftp</code><br><code>[root@localhost ~]# systemctl enable tftp</code></p><h4 id="（3）syslinux包"><a href="#（3）syslinux包" class="headerlink" title="（3）syslinux包"></a>（3）syslinux包</h4><p>（a）概念</p><p>syslinux是一个功能强大的引导加载程序，而且兼容各种介质。它的目的是简化首次安装Linux的时间，并建立修护或其它特殊用途的启动盘。它的安装很简单，一旦安装syslinux好之后，sysLinux启动盘就可以引导各种基于DOS的工具，以及MS-DOS/Windows或者任何其它操作系统。不仅支持采用BIOS结构的主板，而且从6.0版也开始支持采用EFI结构的新型主板。<br>（b）文件介绍</p><p>|<br>|后缀名|解释|<br>|none or other|Linux内核映像|<br>|.0|PXE 启动引导程序(NBP)<br>|.bin|“光盘引导扇区”<br>|.bs|“磁盘引导扇区”<br>|.bss|“磁盘引导扇区”，<br>|.c32|COM32映像文件<br>|.cbt|COMBOOT映像文件<br>|.com|COMBOOT映像文件<br>|.img|磁盘映像文件<br>|.ima|软盘映像文件</p><p>制作PXE常使用的文件menu.c32、pxelinux.0。</p><h4 id="（4）kickstart文件"><a href="#（4）kickstart文件" class="headerlink" title="（4）kickstart文件"></a>（4）kickstart文件</h4><p>如果不理解怎么配置kickstart文件，请查看<a href="http://merit.blog.51cto.com/10757694/1966072" target="_blank" rel="noopener">http://merit.blog.51cto.com/10757694/1966072</a></p><p>##二、PXE自动化安装CentOS 7<br>在进行操作之前确保iptables服务时关闭的，selinux是禁用的。</p><p>（a）配置yum源和ks文件<br><code>[root@localhost ~]# yum install -y vsftpd</code> #安装vsftpd服务<br><code>[root@localhost ~]# systemctl enable vsftpd</code>   #设置为开机启动<br><code>[root@localhost ~]# systemctl start vsftpd</code>    启动服务<br><code>[root@localhost ~]# cd /var/ftp/pub/</code><br><code>[root@localhost ~]# mkdir centos/7 -pv</code>    #创建目录<br><code>[root@localhost ~]# mount /dev/sr0 centos/7</code>   #挂载光盘<br><code>[root@localhost pub]# rz</code> 将ks文件上传至当前目录<br>具体的可以参考<a href="http://merit.blog.51cto.com/10757694/1966072" target="_blank" rel="noopener">http://merit.blog.51cto.com/10757694/1966072</a><br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-17_213759.png" alt=""></p><p>（b）安装syslinux包<br><code>[root@localhost ~]# yum install -y syslinux</code><br>（c）按装tftp服务，并将配置文件复制<br><code>[root@localhost ~]# yum install -y tftp-server</code>    #安装tftp服务包<br><code>[root@localhost ~]# cd /var/lib/tftpboot/</code><br><code>[root@localhost tftpboot]# cp /usr/share/syslinux/{pxelinux.0,menu.c32} .</code>     #将pxelinux.0和menu.c32复制到当前目录下<br><code>[root@localhost tftpboot]# cp /media/cdrom/isolinux/{vmlinuz,initrd.img} .</code>        #将内核文件和虚拟文件系统复制到当前目录下<br><code>[root@localhost tftpboot]# mkdir pxelinux.cfg</code><br><code>[root@localhost tftpboot]# cp /media/cdrom/isolinux/isolinux.cfg pxelinux.cfg/default</code>     #将isolinux.cfg文件复制到pxelinux.cfg目录下并改名为default<br><code>[root@localhost tftpboot]# tree</code>   #目录结构</p><pre><code>.├── initrd.img├── menu.c32├── pxelinux.0├── pxelinux.cfg│   └── default└── vmlinuz1 directory, 5 files</code></pre><p><code>[root@localhost tftpboot]# vim pxelinux.cfg/default</code>编辑default配置文件</p><pre><code>default menu.c32timeout 600menu title CentOS 7 PXE Installlabel desktop  menu label ^desktop  kernel vmlinuz  append initrd=initrd.img ks=ftp://192.168.4.51/pub/ks7.cfgmenu end</code></pre><p>（d）新建一台虚拟机，测试</p><h2 id="三、PXE自动化CentOS-6"><a href="#三、PXE自动化CentOS-6" class="headerlink" title="三、PXE自动化CentOS 6"></a>三、PXE自动化CentOS 6</h2><p>（1）准备yum源和ks6.cfg<code>`[root@centos6~]#yum install -y httpd</code>  #安装httpd服务<br><code>[root@centos6/var/www/html]#mkdir centos/6 -pv</code><br><code>[root@centos6/var/www/html]#mkdir ksdir/</code><br><code>[root@centos6/var/www/html]#mount /dev/sr0 centos/6/</code>      #挂载光盘<br><code>[root@centos6/var/www/html]#cp ks6.cfg ksdir/</code> #复制ks文件并修改</p><pre><code>#version=DEVEL# System authorization informationauth --enableshadow --passalgo=sha512# Use ftp/http installation mediaurl --url=ftp://192.168.4.137/centos/6# Use graphical installgraphical# Run the Setup Agent on first bootfirstboot --enableignoredisk --only-use=sda# Keyboard layoutskeyboard --vckeymap=us --xlayouts=&#39;us&#39;# System languagelang en_US.UTF-8# Network informationnetwork  --bootproto=dhcp --device=ens33 --onboot=on --ipv6=auto network  --hostname=localhost.localdomain# Root password# System servicesservices --disabled=&quot;chronyd&quot;# System timezonetimezone Asia/Shanghai# X Window System configuration informationxconfig  --startxonboot# System bootloader configurationbootloader --append=&quot; crashkernel=auto&quot; --location=mbr --boot-drive=sdazerombr# Partition clearing informationclearpart --allpart /boot --fstype=&quot;xfs&quot; --ondisk=sda --size=1024part swap --fstype=&quot;swap&quot; --ondisk=sda --size=2048part / --fstype=&quot;xfs&quot; --ondisk=sda --size=50000part /app --fstype=&quot;xfs&quot; --ondisk=sda --size=50000%packages@^gnome-desktop-environment@base@core@desktop-debugging@dial-up@directory-client@fonts@gnome-desktop@guest-agents@guest-desktop-agents@input-methods@internet-browser@java-platform@multimedia@network-file-system-client@networkmanager-submodules@print-client@x11kexec-toolsautofslftpdhcpvsftpd%end%post#Create repomkdir /media/cdrommkdir /etc/yum.repos.d/bakmv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bakcat &gt; /etc/yum.repos.d/base &lt;&lt;EOF[base]name=centos 6baseurl=file:///media/cdromgpgcheck=0enabled=1EOFcat &gt;&gt; /etc/fstab &lt;&lt; EOF/dev/sr0        /media/cdrom    iso9660 defaults 0 0cat &gt;&gt; /root/.bashrc &lt;&lt; EOFalias cdnet=&quot;cd /etc/sysconfig/network-scripts/&quot;EOFcat &gt;&gt; /etc/profile.d/env.shexport PS1=&#39;\[\e[31m\][\u@\h\w]\$\[\e[0m\]&#39;EOF%end</code></pre><p><code>[root@centos6/var/www/html]#service httpd start</code>   #启动http服务<br>（2）安装syslinux-nonlinux包<br><code>[root@centos6/var/www/html]#yum install -y syslinux-nonlinux</code><br>（3）安装tfpt服务并复制文件<br><code>[root@centos6/var/www/html]#cd /var/lib/tftpboot/</code><br><code>[root@centos6/var/lib/tftpboot]#cp /usr/share/syslinux/{pxelinux.0,menu.c32} .</code>    #将菜单需要的文件复制到当前目录<br><code>[root@centos6/var/lib/tftpboot]#cp /media/cdrom/isolinux/{vmlinuz,initrd.img} .</code>   #复制内核文件和虚拟文件系统到当前目录下<br><code>[root@centos6/var/lib/tftpboot]#mkdir pxelinux.cfg</code><br><code>[root@centos6/var/lib/tftpboot]#cp /media/cdrom/isolinux/isolinux.cfg pxelinux.cfg/default</code>    #复制菜单显示内容文件<br><code>[root@centos6/var/lib/tftpboot]#vim pxelinux.cfg/default</code>  #修改default文件<br>    default menu.c32</p><pre><code>#prompt 1timeout 600menu title  PXE Install CentOS 6label desktop  menu label ^desktop  menu default  kernel vmlinuz  append initrd=initrd.img ks=http://192.168.4.137/ksdir/ks6.cfgmenu end</code></pre><p>（4）安装dhcp服务并配置<br><code>[root@centos6~]#yum install -y dhcpd</code><br><code>[root@centos6~]#cp /usr/share/doc/dhcp-4.1.1/dhcpd.conf.sample /etc/dhcp/dhcpd.con</code><br><code>[root@centos6~]#vim /etc/dhcp/dhcpd.conf</code><br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-17_223216.png" alt=""><br><code>[root@centos6~]#service dhcpd start</code>   #启动http服务<br>（5）新建一台虚拟机，查看是否可以成功</p><p>四、如何使用PXE能支持CentOS 6和CentOS 7的安装<br>（a）前几步骤都和上述安装过程类似<br>（b）修改配置文件<br>`[root@centos6~]#vim /var/lib/tftpboot/pxelinux.cfg/default</p><pre><code>default menu.c32timeout 600menu title CentOS Linux  PXE Installlabel centos7  menu label Auto Install CentOS Linux ^7  kernel centos7/vmlinuz  append initrd=centos7/initrd.img ks=http://192.168.4.135/ksdir/ks7-1.cfglabel centos6  menu label Auto Install CentOS Linux ^6  kernel centos6/vmlinuz  append initrd=centos6/initrd.img ks=http://192.168.4.135/ksdir/ks6-1.cfglabel manual7  menu label ^Manual Install CentOS Linux 7  kernel centos7/vmlinuz  append initrd=centos7/initrd.img inst.repo=http://192.168.4.135/centos/7label manual6  menu label Manual ^Install CentOS Linux 6  kernel centos6/vmlinuz  append initrd=centos6/initrd.img inst.repo=http://192.168.4.135/centos/6menu end</code></pre><p>（c）新建虚拟机测试</p>]]></content>
      
      
      <categories>
          
          <category> 自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PXE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis简单介绍</title>
      <link href="/2017/11/28/Redis%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/11/28/Redis%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Redis"><a href="#一、Redis" class="headerlink" title="一、Redis"></a>一、Redis</h1><h2 id="1、Redis简介"><a href="#1、Redis简介" class="headerlink" title="1、Redis简介"></a>1、Redis简介</h2><p>Redis是一个开源的内存数据结构存储，用作数据库，缓存和消息代理。支持数据结构：字符串、列表（数组）、hahses（关联数据）、集合、有序集合、位图、hyperloglogs、空间索引。支持内建的复制，Lua 脚本，LRU算法、事物、持久存储、高可用。基于内存的高性能key-value数据库。</p><h2 id="2、Redis优势"><a href="#2、Redis优势" class="headerlink" title="2、Redis优势"></a>2、Redis优势</h2><ul><li>性能极高</li><li>丰富的数据类型</li><li>原子性</li><li>丰富的特性</li></ul><h2 id="3、Redis安装"><a href="#3、Redis安装" class="headerlink" title="3、Redis安装"></a>3、Redis安装</h2><p><code>[root@node1~]#yum install -y redis</code></p><p><strong>安装时会安装jemalloc（支持并存存储）</strong></p><h3 id="（1）程序文件"><a href="#（1）程序文件" class="headerlink" title="（1）程序文件"></a>（1）程序文件</h3><pre><code>配置文件：/etc/redis.conf主程序：/usr/bin/redis-serverUnit File ：/usr/lib/systemd/system/redis.service数据目录：/var/lib/redis监控配置文件：/etc/redis-sentinel.conf</code></pre><h3 id="（2）-etc-redis-conf文件详解"><a href="#（2）-etc-redis-conf文件详解" class="headerlink" title="（2）/etc/redis.conf文件详解"></a>（2）<code>/etc/redis.conf</code>文件详解</h3><p><code>[root@node1~]#grep &#39;###&#39; /etc/redis.conf</code></p><ul><li>INCLUDES    包括其他文件配置</li></ul><ul><li><p>NETWORK     网络配置项</p><p>  bind IP 监听地址，一般为本地对外通信的地址，多个地址使用空格分隔。0.0.0.0表示监听所有地址<br>  port PORT 监听的端口<br>  protected-mode 是否启用受保护模式</p><pre><code>  如果bind和port其中一个没有设定就启用保护模式</code></pre><p>  tcp-backlog tcp级的后援队列长度<br>  unixsocket unix套接字<br>  tcp-keepalived 保持连接时长<br>  timeout 连接的超时时长</p></li><li><p>GENERAL     基本配置项</p><p>  daemonize 是否启用守护进程<br>  supervised<br>  loglevel 日志级别<br>  pidfile pid文件<br>  logfile 日志文件<br>  databases 设定数据库数量，默认为16个，每个数据库的名字均为正数，从0开始标号，默认操作的数据库为0</p></li></ul><ul><li>SNAPSHOTTING    快照配置项</li></ul><p>按事先定制的策略，周期性地将数据从内存同步至磁盘；数据文件默认为dump.rdb</p><pre><code>客户端显示使用SAVE或BGSAVE命令手动自动快照保存机制    SAVE：同步，即在主线程中保存快照，此时会阻塞所有客户端请求    BGSAVE：异步，backgroud（后台）进行save 定义保存策略    表示三个策略满足其中任意一个均会触发SNAPSHOTTING操作；900s内至少有一个key变化，300s内至少有10个key变化；60s内至少有1w个key变化stop-writes-on-bgsave-error dump操作出现错误时，是否禁止新的写入操作请求rdbcompression 是否启用压缩功能rdbchecksum 是否检验dbfilename 文件名称dir 定义保存文件的路径，通常不再默认位置下存放</code></pre><ul><li><p>REPLICATION     复制相关的配置项</p><p>  slave-serve-stale-data 是否使用过期数据响应用户<br>  slave-read-only 设置从为只读<br>  repl-diskless-sync 复制是否无磁盘的复制</p><pre><code>  新的从节点或某较长时间未能与主节点进行同步的从节点重新与主节点通信，需要做“full synchronization”，此时其同步方式：      （1）Disk-backend：主节点新创建快照文件与磁盘中，而后将其发送给从节点      （2）Diskless：主节点新创建快照后直接通过网络套接字文件发送给从节点；为了实现并行复制，通常需要在复制启动前延迟一个时间段。</code></pre><p>  repl-diskless-sync-delay 启用无磁盘延迟时间<br>  repl-ping-slave-eriod 探测冲节点是否存活<br>  repl-timeout 超时时长<br>  repl-disable-tcp-nodelay 延迟tcp连接，通常关闭此功能<br>  repl-backlog-size 队列的长度<br>  slave-priority 从的优先级</p><pre><code>  复制集群中，主节点故障时，sentinel应用场景中的主节点选举时使用的优先；数字越小优先级越高，但0表示不参与选举</code></pre><p>  min-slaves-to-rewrite 主节点仅允许其能够通信的从节点数量大于等于此处的值时接受些操作<br>  min-slaves-max-log 从节点延迟时长超出此处指定的时长时，主节点会拒绝写入操作。</p></li></ul><ul><li><p>SECURITY    安全相关的配置项</p><p>  requirepass <password> 设定密码<br>  rename-command <command> <new_cmnd_name>    主从复制不建议修改；在AOD或Replication环境中，不推荐使用</new_cmnd_name></password></p></li><li><p>LIMITS  limit相关的配置项</p><p>  maxclients 最大并发连接数<br>  maxmemory <bytes> 最大的内存空间<br>  maxmemory-policy noeviction 定义淘汰机制</bytes></p><pre><code>  volatile-lru 对设定过期期限的key淘汰  allkey-lru 有无过期都在淘汰序列中  volatile-random 对设定过期期限自由淘汰  allkeys-random 对有无过期期限的都自由淘汰  volatile-ttl 移除最接近淘汰期限的key  noevication 不过期任何key，只返回错误</code></pre><p>  maxmemory-samples 淘汰算法运行时的采样本书</p></li></ul><ul><li>APPEND ONLY MODE  </li></ul><p>记录每次写操作至指定的文件尾部实现的持久化；当redis重启时，可通过重新执行文件中的命令在内存中重建出数据库</p><p>BGREWRITEAOD：AOF文件重写</p><pre><code>不会读取正在使用AOF文件，而是通过将内存中的数据以命令的方式保存至临时文件中，完成之后替换原来的AOF文件appendonly 是否开启追加文件appendfilename 定义名称appendfsync 定义同步时间    no redis不执行主动同步操作，而是OS内核进行    always 只要发生写就同步    everysec 每秒同步no-appendfsync-on-rewrite 是否在后台执行aof重写期间不调用fsync，默认为no，表示调用auto-aof-rewrite-percentage     自动重写的百分比auto-aof-rewrite-min-size   自动重写的最小大小    上述两个条件同时满足时，方会触发重写AOF，与上次AOF文件大小相比，其增长量超过100%，且大小不少于64MBauto-load-truncated 自动加载截断</code></pre><p><strong>注意：</strong></p><pre><code>RDB与AOF同时启用：    （1）BGSAVE和BGREWRITEAOF不会同时进行    （2）Redis服务器启动时用持久化的数据文件恢复数据，会优先使用AOF</code></pre><ul><li>LUA SCRIPTING  Lua脚本</li></ul><ul><li>REDIS CLUSTER      集群相关的配置项</li></ul><pre><code>cluster-enabled 是否开启集群功能cluster-config-file 集群节点集群信息配置文件，每个节点都有一个，由redis生成和更新，配置时避免名称冲突cluster-node-timeout 集群节点互联超时的预支，单位毫秒cluster-slave-validity-factor 进行故障转移时，slave会申请成为master，有时slave会和master失联很久数据较旧，这样的slave不应该成为master。这个配置用来判断slave是否和master失联时间过后长。</code></pre><ul><li><p>SLOW LOG   SlowLog相关的配置项</p><p>  slowlog-log-slower-than<br>  slowlog-max-len slowlog记录的日志最大条目</p></li><li><p>LATENCY MONITOR </p></li></ul><ul><li>EVENT NOTIFICATION   </li></ul><ul><li><p>ADVANCED CONFIG    高级配置项</p><p>  hash-max-ziplist-entries<br>  hash-max-ziplist-value</p><pre><code>  设置ziplist的键数量最大值，每个值的最大空间</code></pre><p>  client-output-buffer-limit normal<br>  client-output-buffer-limit slave<br>  client-output-buffer-limit pubsub</p><pre><code>  &lt;hard-limit&gt; &lt;soft-limit&gt; &lt;soft-limit seconds&gt;</code></pre><p>##注意：持久机制本身不能取代备份；应该制定备份策略，对redis库定期备份。##</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache分析和日志管理工具</title>
      <link href="/2017/11/28/Apache%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%92%8C%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/2017/11/28/Apache%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%92%8C%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="一、cronolog"><a href="#一、cronolog" class="headerlink" title="一、cronolog"></a>一、cronolog</h1><p>cronolog 是一个简单的过滤程序，读取日志文件条目从标准输入和输出的每个条目并写入指定的日志文件的文件名模板和当前的日期和时间。cronolog 旨在和一个Web服务器一起使用，如Apache，分割访问日志为每天或每月的日志。</p><h2 id="1、cronolog特点"><a href="#1、cronolog特点" class="headerlink" title="1、cronolog特点"></a>1、cronolog特点</h2><p>cronolog主要和web服务器配置使用，特别是apache服务器；apache默认日志文件是不分割的，因此如果我们要查找某天的内容会浏览一个整体文件去寻找，显然降低了我们的工作效率。cronolog可以将日志文件按时间分隔，易于管理和分析。</p><p><a href="https://directory.fsf.org/wiki/Cronolog" target="_blank" rel="noopener">https://directory.fsf.org/wiki/Cronolog</a> 官网，不过点击下载跳转至别的页面了….</p><p><strong>注意：在进行日志前首先更新下系统时间，以免当我们分析日志时，日志记录的时间是错误的。</strong></p><p><code>[root@localhost~]#yum install -y ntpdate</code><br><code>[root@localhost~]#ntpdate 172.18.0.1</code>  #更新时间指令</p><h2 id="2、源码安装cronolog"><a href="#2、源码安装cronolog" class="headerlink" title="2、源码安装cronolog"></a>2、源码安装cronolog</h2><p>（1）编译前先准备好编译环境</p><p><code>[root@localhost/usr/local/src/cronolog-1.6.2]#yum groupinstall -y &quot;development tools&quot;</code></p><p>（2）编译安装</p><p><code>[root@localhost/usr/local/src/cronolog-1.6.2]#./configure</code></p><p><code>[root@localhost/usr/local/src/cronolog-1.6.2]#make &amp;&amp; make install</code></p><p><code>[root@localhost~]#which cronolog</code></p><pre><code>/usr/local/sbin/cronolog    #查看命令路径</code></pre><h2 id="3、cronolog命令"><a href="#3、cronolog命令" class="headerlink" title="3、cronolog命令"></a>3、cronolog命令</h2><p><code>[root@localhost~]#cronolog -h</code></p><p>格式：</p><pre><code>usage: cronolog [OPTIONS] logfile-spec</code></pre><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-H NAME,   –hardlink=NAME</td><td>maintain a hard link from NAME to current log</td></tr><tr><td>-S NAME,   –symlink=NAME</td><td>maintain a symbolic link from NAME to current log</td></tr><tr><td>-P NAME,   –prev-symlink=NAME</td><td>maintain a symbolic link from NAME to previous log</td></tr><tr><td>-l NAME,   –link=NAME</td><td>same as -S/–symlink</td></tr><tr><td>-h,        –help</td><td>print this help, then exit</td></tr><tr><td>-p PERIOD, –period=PERIOD</td><td>set the rotation period explicitly</td></tr><tr><td>-d DELAY,  –delay=DELAY</td><td>set the rotation period delay</td></tr><tr><td>-o,        –once-only</td><td>create single output log from template (not rotated)</td></tr><tr><td>-x FILE,   –debug=FILE</td><td>write debug messages to FILE ( or to standard error if FILE is “-“)</td></tr><tr><td>-a,        –american</td><td>American date formats</td></tr><tr><td>-e,        –european</td><td>European date formats (default)</td></tr><tr><td>-s,    –start-time=TIME</td><td>starting time</td></tr><tr><td>-z TZ, –time-zone=TZ</td><td>use TZ for timezone</td></tr><tr><td>-V,      –version</td><td>print version number, then exit</td></tr></tbody></table><p><strong>注意：</strong><br><strong>cronolog一般采取管道的方式工作。</strong></p><h2 id="4、cronolog格式定义"><a href="#4、cronolog格式定义" class="headerlink" title="4、cronolog格式定义"></a>4、cronolog格式定义</h2><p>时间定义：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>H</td><td>小时（00..23）</td></tr><tr><td>I</td><td>小时(01..12)</td></tr><tr><td>p</td><td>该locale下的AM或PM标识</td></tr><tr><td>M</td><td>分钟(00..59)</td></tr><tr><td>S</td><td>秒 (00..61, which allows for leap seconds)</td></tr><tr><td>X</td><td>该locale下时间表示符(e.g.: “15:12:47”)</td></tr><tr><td>Z</td><td>时区。若时区不能确定，则无意义</td></tr><tr><td>a</td><td>该locale下的工作日简名(e.g.: Sun..Sat)</td></tr><tr><td>A</td><td>该locale下的工作日全名(e.g.: Sunday ..  Satur-ay)</td></tr><tr><td>b</td><td>该locale下的月份简称(e.g.: Jan .. Dec)</td></tr><tr><td>B</td><td>该locale下的月份全称(e.g.:  January .. December)</td></tr><tr><td>c</td><td>该locale下的日期和时间(e.g.: “Sun Dec 15  14:12:47 GMT 1996”)</td></tr><tr><td>d</td><td>当月中的天数 (01 .. 31)</td></tr><tr><td>j</td><td>当年中的天数 (001 .. 366)</td></tr><tr><td>m</td><td>月数 (01 .. 12)</td></tr><tr><td>U</td><td>当年中的星期数，以周日作为一周开始,其中第一周为首个含星期天的星期(00..53)</td></tr><tr><td>W</td><td>当年中的星期数，以星期一作为一周的开始,其中第一周为首个含星期天的星期(00..53)</td></tr><tr><td>w</td><td>工作日数(0 .. 6, 0表示星期天)</td></tr><tr><td>x</td><td>该locale下的日期表示(e.g. “13/04/97”)</td></tr><tr><td>y</td><td>两位数的年份(00 .. 99)</td></tr><tr><td>Y</td><td>四位数的年份(1970 .. 2038)</td></tr></tbody></table><h2 id="5、cronolog结合apache使用"><a href="#5、cronolog结合apache使用" class="headerlink" title="5、cronolog结合apache使用"></a>5、cronolog结合apache使用</h2><h3 id="编辑配置文件，也可以单独定义某个虚拟主机的日志"><a href="#编辑配置文件，也可以单独定义某个虚拟主机的日志" class="headerlink" title="编辑配置文件，也可以单独定义某个虚拟主机的日志"></a>编辑配置文件，也可以单独定义某个虚拟主机的日志</h3><p><code>[root@localhost~]#vim /etc/httpd/conf/httpd.conf</code> </p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-25_184434.jpg" alt=""></p><h3 id="重启服务并测试"><a href="#重启服务并测试" class="headerlink" title="重启服务并测试"></a>重启服务并测试</h3><p><code>[root@localhost~]#ab -c 10 -n 1000 http://www.test.com/</code></p><h3 id="查看是否生成日志文件"><a href="#查看是否生成日志文件" class="headerlink" title="查看是否生成日志文件"></a>查看是否生成日志文件</h3><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-25_185010.jpg" alt=""></p><h1 id="二、AWstat工具"><a href="#二、AWstat工具" class="headerlink" title="二、AWstat工具"></a>二、AWstat工具</h1><p>Awstats是一个免费非常简洁而且强大有个性的网站日志分析工具。</p><h2 id="1、AWstat优势"><a href="#1、AWstat优势" class="headerlink" title="1、AWstat优势"></a>1、AWstat优势</h2><p>（1）界面友好：可以根据浏览器直接调用相关语言界面</p><p>（2）基于perl：解决了跨平台问题；分析日志直接支持apache格式</p><p>（3）效率比较高</p><p>（4）配置、定制方便</p><p>（5）提供了很多扩展参数统计功能</p><h3 id="2、AWstat运行原理"><a href="#2、AWstat运行原理" class="headerlink" title="2、AWstat运行原理"></a>2、AWstat运行原理</h3><p>apache将访问情况记录到日志中，AWstats每次执行更新时读取这些日志，分析日志数据；将结果存储到数据库中（纯文本）。最后AWstats提供一个cgi程序通过web页面显示数据库中所统计的数据。</p><h3 id="3、源码编译安装AWstat"><a href="#3、源码编译安装AWstat" class="headerlink" title="3、源码编译安装AWstat"></a>3、源码编译安装AWstat</h3><p>下载地址：<a href="http://www.awstats.org/#DOWNLOAD" target="_blank" rel="noopener">http://www.awstats.org/#DOWNLOAD</a></p><p>（1）源码编译安装AWstat</p><p><code>[root@localhost/usr/local]#tar xf awstats-7.6.tar.gz</code></p><p><code>[root@localhost/usr/local]#mv awstats-7.6 awstats</code></p><p><code>[root@localhost/usr/local]#cd awstats/</code></p><p><strong>注意：此处需在<code>/usr/local</code>目录下安装</strong></p><p>（2）修改文件权限</p><p><code>[root@localhost/usr/local/awstats]#chmod -R +x tools/*</code></p><p><code>[root@localhost/usr/local/awstats]#chmod -R +x wwwroot/cgi-bin/*</code></p><p><code>[root@localhost/usr/local/awstats]#chown -R root.root /usr/local/awstats</code></p><p>由于上传文件是不是以root身份，否则后面*.pl将无法运行。</p><p>（3）创建所需目录</p><p><code>[root@localhost/usr/local/awstats]#mkdir /etc/awstats</code> #存放站点日志分析的配置文件</p><p>（4）生成AWstats配置文件</p><p><code>[root@localhost/usr/local/awstats/tools]#./awstats_configure.pl</code></p><pre><code>----- AWStats awstats_configure 1.0 (build 20140126) (c) Laurent Destailleur -----This tool will help you to configure AWStats to analyze statistics forone web server. You can try to use it to let it do all that is possiblein AWStats setup, however following the step by step manual setupdocumentation (docs/index.html) is often a better idea. Above all if:- You are not an administrator user,- You want to analyze downloaded log files without web server,- You want to analyze mail or ftp log files instead of web log files,- You need to analyze load balanced servers log files,- You want to &#39;understand&#39; all possible ways to use AWStats...Read the AWStats documentation (docs/index.html).-----&gt; Running OS detected: Linux, BSD or Unix-----&gt; Check for web server installEnter full config file path of your Web server.Example: /etc/httpd/httpd.confExample: /usr/local/apache2/conf/httpd.confExample: c:\Program files\apache group\apache\conf\httpd.confConfig file path (&#39;none&#39; to skip web server setup):&gt; /etc/httpd/conf/httpd.conf- This file does not exists.Config file path (&#39;none&#39; to skip web server setup):&gt; /etc/httpd/conf/httpd.conf      #输入web服务配置文件的地址，如果是Nginx输入“none”-----&gt; Check and complete web server config file &#39;/etc/httpd/conf/httpd.conf&#39;  Add &#39;Alias /awstatsclasses &quot;/usr/local/awstats/wwwroot/classes/&quot;&#39;  Add &#39;Alias /awstatscss &quot;/usr/local/awstats/wwwroot/css/&quot;&#39;  Add &#39;Alias /awstatsicons &quot;/usr/local/awstats/wwwroot/icon/&quot;&#39;  Add &#39;ScriptAlias /awstats/ &quot;/usr/local/awstats/wwwroot/cgi-bin/&quot;&#39;  Add &#39;&lt;Directory&gt;&#39; directive  AWStats directives added to Apache config file.-----&gt; Update model config file &#39;/usr/local/awstats/wwwroot/cgi-bin/awstats.model.conf&#39;  File awstats.model.conf updated.-----&gt; Need to create a new config file ?Do you want me to build a new AWStats config/profilefile (required if first install) [y/N] ? y  #是否创建一个新的配置文件-----&gt; Define config file name to createWhat is the name of your web site or profile analysis ?Example: www.mysite.comExample: demoYour web site, virtual server or profile name:&gt; www.test.com   #网站域名名称-----&gt; Define config file pathIn which directory do you plan to store your config file(s) ?Default: /etc/awstatsDirectory path to store config file(s) (Enter for default):      &gt;     #配置文件存放在哪个位置，这里选择默认即可；回车-----&gt; Create config file &#39;/etc/awstats/awstats.www.test.com.conf&#39; Config file /etc/awstats/awstats.www.test.com.conf created.-----&gt; Restart Web server with &#39;/sbin/service httpd restart&#39;Redirecting to /bin/systemctl restart httpd.service-----&gt; Add update process inside a schedulerSorry, configure.pl does not support automatic add to cron yet.You can do it manually by adding the following command to your cron:/usr/local/awstats/wwwroot/cgi-bin/awstats.pl -update -config=www.test.comOr if you have several config files and prefer having only one command:/usr/local/awstats/tools/awstats_updateall.pl nowPress ENTER to continue...                   #提示不能自动加入crontab任务，需要稍后自己添加，回车即可A SIMPLE config file has been created: /etc/awstats/awstats.www.test.com.confYou should have a look inside to check and change manually main parameters.You can then manually update your statistics for &#39;www.test.com&#39; with command:&gt; perl awstats.pl -update -config=www.test.comYou can also read your statistics for &#39;www.test.com&#39; with URL:&gt; http://localhost/awstats/awstats.pl?config=www.test.comPress ENTER to finish...  #提示配置文件创建完成，回车即可</code></pre><p>（5）修改刚生成的配置文件</p><p><code>[root@localhost/etc/awstats]#vim awstats.www.test.com.conf</code></p><pre><code>50 LogFile=&quot;/var/log/httpd/access_log&quot;    此选项的位置必须和http位置一致 156 SiteDomain=&quot;www.test.com&quot;此选项设置站点域名 171 HostAliases=&quot;test.com www.test.com 127.0.0.1 localhost&quot;此选项设置主机别名 220 DirData=&quot;/var/lib/awstats&quot;此选项设置存放日志数据的位置</code></pre><p>（6）修改httpd.conf文件</p><p><code>[root@localhost/etc/awstats]#vim /etc/httpd/conf/httpd.conf</code></p><h4 id="如果apache是2-2版本如下格式"><a href="#如果apache是2-2版本如下格式" class="headerlink" title="如果apache是2.2版本如下格式"></a>如果apache是2.2版本如下格式</h4><pre><code>366 &lt;Directory &quot;/usr/local/awstats/wwwroot&quot;&gt;367     Options None368     AllowOverride None369     Order allow,deny370     Allow from all371 &lt;/Directory&gt;</code></pre><h4 id="如果apache是2-4版本如下格式"><a href="#如果apache是2-4版本如下格式" class="headerlink" title="如果apache是2.4版本如下格式"></a>如果apache是2.4版本如下格式</h4><pre><code>366 &lt;Directory &quot;/usr/local/awstats/wwwroot&quot;&gt;367     Options None368     AllowOverride None369     Require all granted         370 &lt;/Directory&gt;</code></pre><p>上述根据自己的实际情况进行修改</p><p>（7）重启http服务</p><p><code>[root@localhost~]#systemctl restart httpd</code></p><p>（8）创建存放日志数据信息目录</p><p><code>[root@localhost/usr/local/awstats]#mkdir /var/lib/awstats</code> </p><p><code>[root@localhost~]#chmod 755 /var/lib/awstats/</code>#修改权限</p><p>（9）更新awstats数据库</p><p>语法：</p><pre><code>Syntax: awstats.pl -config=virtualhostname [options]</code></pre><p><strong>注意：</strong></p><ul><li>配置文件 (awstats.virtualhostname.conf or awstats.conf) 必须在<code>/etc/awstats</code>,<code>/usr/local/etc/awstats</code>, <code>/etc</code> 或 same directory than awstats.pl script file.</li><li>如果AWSTATS_FORCE_CONFIG环境变量被定义，AWstat将使用定义环境变量作为配置值。</li></ul><p><code>[root@localhost~]#/usr/local/awstats/wwwroot/cgi-bin/awstats.pl -update -config=www.test.com</code></p><pre><code>Create/Update database for config &quot;/etc/awstats/awstats.www.test.com.conf&quot; by AWStats version 7.6 (build 20161204)From data in log file &quot;/var/log/httpd/access_log&quot;...Phase 1 : First bypass old records, searching new record...Searching new records from beginning of log file...Jumped lines in file: 0Parsed lines in file: 0 Found 0 dropped records, Found 0 comments, Found 0 blank records, Found 0 corrupted records, Found 0 old records, Found 0 new qualified records.</code></pre><p>（10）测试</p><p><a href="http://192.168.4.65/awstats/awstats.pl?config=www.test.com" target="_blank" rel="noopener">http://192.168.4.65/awstats/awstats.pl?config=www.test.com</a></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-25_195954.jpg" alt=""></p><p><strong>小结：</strong></p><p>（1）AWstats数据库不能及时更新，如果想定时更新可以写计划任务。</p><p>（2）安装过程中可能会访问时出现403错误，可能是权限不够，看看<code>/var/lib/awstat1</code>目录权限</p><p>（3）AWstat工作时基于apache日志工作的，配置文件的日志目录与apache中的日志路径相同</p><p>（4）在生成配置文件时必须在<code>/usr/local/awstat</code>目录下创建，否则会报错找不到路径</p><p>如果配置多站点监控？<br>-</p><p>和上述配置的过程一样。</p><p><code>[root@localhost/usr/local/awstats/tools]#ls /etc/awstats/</code></p><pre><code>awstats.www.test2.com.conf  awstats.www.test.com.conf</code></pre><h1 id="三、ASstats扩展"><a href="#三、ASstats扩展" class="headerlink" title="三、ASstats扩展"></a>三、ASstats扩展</h1><h2 id="1、ASstats默认是不显示访客的国家的，若果需要可以添加插件"><a href="#1、ASstats默认是不显示访客的国家的，若果需要可以添加插件" class="headerlink" title="1、ASstats默认是不显示访客的国家的，若果需要可以添加插件"></a>1、ASstats默认是不显示访客的国家的，若果需要可以添加插件</h2><p><a href="http://geolite.maxmind.com/download/geoip/database" target="_blank" rel="noopener">http://geolite.maxmind.com/download/geoip/database</a>  下载地址</p><p>GeoIP 是国家数据</p><p>GeoLiteCity 是城市数据</p><p>GeoIPASNum 是组织数据</p><p>（1）安装过程</p><p><code>[root@localhost~]#gunzip GeoIP.dat.gz</code></p><p><code>[root@localhost~]#gunzip GeoLiteCity.dat.gz</code></p><p><code>[root@localhost~]#mkdir /var/GeoIP</code></p><p><code>[root@localhost~]#mv  Geo* /var/GeoIP</code></p><p><code>[root@localhost~]#cd /var/GeoIP</code></p><p><code>[root@localhost/var/GerIP/GeoIP-1.4.8]#tar xf GeoIP-1.4.8.tar.gz</code></p><h3 id="编译安装GeoIP"><a href="#编译安装GeoIP" class="headerlink" title="编译安装GeoIP"></a>编译安装GeoIP</h3><p><code>[root@localhost/var/GerIP/GeoIP-1.4.8]#yum install -y zlib-devel</code></p><p><code>[root@localhost/var/GerIP/GeoIP-1.4.8]#./configure ;make &amp;&amp; make  install</code></p><h3 id="编译安装Geo-IP"><a href="#编译安装Geo-IP" class="headerlink" title="编译安装Geo-IP"></a>编译安装Geo-IP</h3><p><code>[root@localhost/var/geoip/Geo-IP-1.40]#yum install perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker</code></p><p><code>[root@localhost/var/geoip/Geo-IP-1.40]#perl Makefile.PL LIBS=&#39;-L/usr/local/lib&#39;</code></p><p><code>[root@localhost/var/geoip/Geo-IP-1.40]#make &amp;&amp; make install</code></p><h3 id="修改AWstats配置文件"><a href="#修改AWstats配置文件" class="headerlink" title="修改AWstats配置文件"></a>修改AWstats配置文件</h3><p><code>[root@localhost/var/geoip-city]#vim /etc/awstats/awstats.www.test.com.conf</code></p><pre><code>1460 LoadPlugin=&quot;geoip GEOIP_STANDARD /var/geoip/GeoIP.dat&quot;1466 LoadPlugin=&quot;geoip_org_maxmind GEOIP_STANDARD /var/genip/GeoIPOrg.dat&quot;1479 LoadPlugin=&quot;geoip_city_maxmind GEOIP_STANDARD /var/geoip/GeoIPCity.dat&quot;</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>（2）中文乱码问题</p><p><code>[root@localhost~]#vim /etc/awstats/awstats.www.test.com.conf</code></p><pre><code>#LoadPlugin=&quot;decodeutfkeys&quot; #1300 行LoadPlugin=&quot;decodeutfkeys&quot;</code></pre><p>不过修改编码以后还会出错缺少perl的URI模块，下面是解决方法：</p><p><code>[root@localhost/usr/local/src]#tar xf URI-1.60.tar.gz</code> </p><p><code>[root@localhost/usr/local/src]#cd URI-1.60/</code></p><p><code>[root@localhost/usr/local/src/URI-1.60]#perl Makefile.PL</code></p><p><code>[root@localhost/usr/local/src/URI-1.60]#make &amp;&amp; make install</code></p><p><strong>小结：</strong></p><p>显示国家扩展模块安装时有顺序的</p><pre><code>GeoIP C库--&gt;Geo-IP perl库</code></pre>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cronlog </tag>
            
            <tag> AWstat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx指令</title>
      <link href="/2017/11/28/Nginx%E6%8C%87%E4%BB%A4/"/>
      <url>/2017/11/28/Nginx%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx配置指令"><a href="#Nginx配置指令" class="headerlink" title="Nginx配置指令"></a>Nginx配置指令</h2><p>参考： <a href="https://nginx.org/en/docs/" target="_blank" rel="noopener">https://nginx.org/en/docs/</a><br>-</p><p><strong>事前注意：配置Nginx和配置Apache不一定，Nginx必须要在指定的部分添加指令，否则会报错。</strong></p><h1 id="正常运行必备指令"><a href="#正常运行必备指令" class="headerlink" title="正常运行必备指令"></a>正常运行必备指令</h1><p>（1）user</p><p>指定worker进程的运行身份，如果组不指定，默认和用户名同名。</p><pre><code>Syntax:    user user [group];Default:    user nobody nobody;  这里需要注意下如果系统中默认有nginx账户，不会使用nobody账户运行。Context:    main   规定只能在main定义此指令</code></pre><p>（2）pid /PATH/TO/PID_FILE</p><p>指定存储nginx主进程PID的文件路径</p><pre><code>Syntax:    pid file;Default:    pid nginx.pid;Context:    main</code></pre><p>（3）include file |mask</p><p>指明包含进来的其他配置文件片段</p><pre><code>Syntax:    include file | mask;Default:    —Context:    any</code></pre><p>（4）load_module file</p><p>指明加载模块的路径</p><p>模块加载配置文件：<code>/usr/share/nginx/modules/*.conf</code></p><p>指明要装载的动态模块路径：<code>/usr/lib64/nginx/modules</code></p><pre><code>Syntax:    load_module file;Default:    —Context:    mainThis directive appeared in version 1.9.11. 此指令在1.9.11版本中才有</code></pre><h1 id="性能优化相关指令"><a href="#性能优化相关指令" class="headerlink" title="性能优化相关指令"></a>性能优化相关指令</h1><p>（1）worker_process number|auto</p><p>worker进程的数量，通常应该设置为小于或等于当前主机CPU的物理核心数</p><pre><code>Syntax:    worker_processes number | auto;Default:    worker_processes 1;Context:    main</code></pre><p>（2）worker_cpu_affinity auto [cpumask] </p><p>指定运行在哪些CPU上</p><pre><code>Syntax:    worker_cpu_affinity cpumask ...;worker_cpu_affinity auto [cpumask];Default:    —Context:    main</code></pre><p>示例：</p><pre><code>worker_processes    4;worker_cpu_affinity 0001 0010 0100 1000;</code></pre><p>查看工作在哪颗CPU的命令</p><pre><code>ps axo pid,cmd,psr,ni |grep nginx</code></pre><p>（3）worker_priority number</p><p>指定worker进程nice值，设置worker进程优先级[-20,20]，不过正常的话nice值为[-20，19]</p><pre><code>Syntax:    worker_priority number;Default:    worker_priority 0;Context:    main</code></pre><p>（4）worker_rlimit_nofile number</p><p>worker进程所能够打开的文件数量上限</p><pre><code>Syntax:    worker_rlimit_nofile number;Default:    —Context:    main</code></pre><h1 id="事件驱动相关指令："><a href="#事件驱动相关指令：" class="headerlink" title="事件驱动相关指令："></a>事件驱动相关指令：</h1><p>（1）worker_connections number</p><p>每个worker进程所能够打开的最大并发连接数量</p><pre><code>Syntax:    worker_connections number;Default:    worker_connections 512;Context:    events</code></pre><p>（2）use method</p><p>指明并发连接请求的处理方法，默认自动选择最优方法，默认使用epoll</p><pre><code>Syntax:    use method;Default:    —Context:    events</code></pre><p>（3）accept_mutex on|off</p><p>互斥处理新的连接请求方法</p><pre><code>on：指由各个worker轮流处理新的请求off：指每个新请求的到达都会通知所有的worker进程，但只有一个进程可获得连接，造成“惊群”，影响性能，默认为onSyntax:    accept_mutex on | off;Default:    accept_mutex on;Context:    events</code></pre><h1 id="调试和定位问题"><a href="#调试和定位问题" class="headerlink" title="调试和定位问题"></a>调试和定位问题</h1><p>（1）daemon on|off</p><p>是否以守护进程方式运行nginx，默认为守护进程方式</p><pre><code>Syntax:    daemon on | off;Default:   daemon on;Context:    main</code></pre><p>（2）master_process on|off</p><p>是否以master/worker模型运行nginx；默认为on</p><pre><code>Syntax:    master_process on | off;Default:   master_process on;Context:    main</code></pre><p>（3）error_log file [level]</p><p>错误日志文件及其级别；出于调试需要可设置为debug；如果要是用debug，需要在编译使用“–with-debug”选项</p><pre><code>Syntax:    error_log file [level];Default:    error_log logs/error.log error;Context:    main, http, mail, stream, server, locationstderr：发送到标准错误syslog：server-address[,parameter=values]：发送到syslog memory： size内存level:debug|info|notice|warn|error|crit|alter|emerg</code></pre><p>（4）time_resolution</p><p>计时器解析度；降低此值，可减少gettimeofday（）系统调用的次数</p><pre><code>Syntax:    resolver_timeout time;Default:    resolver_timeout 30s;Context:    mail, server</code></pre><h1 id="http协议的相关指令"><a href="#http协议的相关指令" class="headerlink" title="http协议的相关指令"></a>http协议的相关指令</h1><p>（1）server{…}</p><p>配置一个虚拟主机</p><p>（2）listen PORT|address[:port]|unix:/PATH/TO/SOCKET_FILE</p><p>listen address[:port] [default_server] [ssl] [http2 | spdy] [backlog=number] [rcvbuf=size] [sndbuf=size]</p><pre><code>Default:  listen *:80 | *:8000;Context:    serverdefault_server：设置为默认虚拟主机ssl ：限制仅能够通过ssl连接提供服务backlog=number：超过并发连接数后，新请求进入后院队列的长度rcvbuf=size：接受缓冲区大小sndbuf=size发送缓冲区大小</code></pre><p>示例：</p><pre><code>listen 127.0.0.1:8000;listen 127.0.0.1;listen 8000;listen localhost:8000;</code></pre><p><strong>注意：</strong></p><ul><li><p>（1）基于port</p><p>  listen PORT；指令监听在不同的端口</p></li><li><p>（2）基于IP的虚拟主机</p><p>  listen IP:PORT；IP地址不同</p></li><li><p>（3）基于hostname </p><p>  server_name FQDN:指令指向不同的主机名</p></li></ul><p><strong>listen只能放在server端中</strong></p><p>（3）server_name name …;</p><p>指定虚拟主机的主机名称，可跟多个由空白字符分隔的字符串</p><pre><code>Syntax:    server_name name ...;Default:    server_name &quot;&quot;;Context:    server</code></pre><p>server_name支持“*”通配任意长度的任意字符</p><p>示例：</p><pre><code>server_name *.test.com</code></pre><p>server_name支持“~”起始的字符做正则表达式匹配；此方法会消耗性能</p><pre><code>server_name ~^www\d+.test\.com$\d表示[0-9]</code></pre><h3 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h3><ul><li>（1）首先是字符串精确匹配,www.test.com</li><li>（2）左侧<em>通配符  \</em>.test.com</li><li>（3）右侧<em>通配符 www.test.\</em></li><li>（4）正则表达式  ~^www\d+.test.com$</li><li>（5）default_server</li></ul><p>（4）tcp_nodelay on|off</p><p>在keepalived模式下的连接是否启用tcp_nodelay</p><pre><code>Syntax:    tcp_nodelay on | off;Default:    tcp_nodelay on;Context:    http, server, locationoff：延迟发送，合并多个请求后再发送on：不延迟发送</code></pre><p>（5）sendfile on|off</p><p>是否启用sendfile功能，在内核封装报文直接发送</p><pre><code>Syntax:    sendfile on | off;Default:    sendfile off;Context:    http, server, location, if in location</code></pre><p>（6）server_tokens on|off|build|string</p><p>是否在响应报文的server首部显示nginx版本</p><pre><code>Syntax:    server_tokens on | off | build | string;Default:    server_tokens on;Context:    http, server, location</code></pre><h2 id="定义路径相关指令"><a href="#定义路径相关指令" class="headerlink" title="定义路径相关指令"></a>定义路径相关指令</h2><p>（1）root </p><p>设置web资源的路径映射；用于指明请求的URL所对应的文档的目录路径</p><pre><code>Syntax:    root path;Default:    root html;Context:    http, server, location, if in location</code></pre><p>示例：</p><pre><code>location /i/ {                root /data/w3;}</code></pre><p>（2）location [ = | ~ | ~* | ^~ ] uri { … }</p><p>在一个server中location配置段可存在多个，用于实现从URI到文件系统的路径映射；nginx会根据用户请求的URI来检查定义的所有location，并找出一个最佳匹配，而后应用其配置</p><pre><code>Syntax:    location [ = | ~ | ~* | ^~ ] uri { ... }location @name { ... }Default:    —Context:    server, location^~：对URI的最左边部分做匹配检查，不区分字符大小写~：对URI做正则表达式做模式匹配，区分字符大小写~*：对URI做正则表达式模式匹配，不区分字符大小写不带符号：匹配起始于URI的所有URI</code></pre><h4 id="匹配优先级从左到右降低"><a href="#匹配优先级从左到右降低" class="headerlink" title="匹配优先级从左到右降低"></a>匹配优先级从左到右降低</h4><pre><code>=  ^~  ~   ~* 不带符号</code></pre><p>示例：</p><pre><code>location = / {    [ configuration A ]}location / {    [ configuration B ]}location /documents/ {    [ configuration C ]}location ^~ /images/ {    [ configuration D ]}location ~* \.(gif|jpg|jpeg)$ {    [ configuration E ]}</code></pre><p>（2）alias path</p><p>路径别名，文档映射的另一种机制；仅能用于location上下文</p><pre><code>Syntax:    alias path;Default:    —Context:    location</code></pre><h3 id="alias和root指令的区别"><a href="#alias和root指令的区别" class="headerlink" title="alias和root指令的区别"></a>alias和root指令的区别</h3><p>（a）root指令给定的路径对应于localtion中的URI左侧的</p><p>（b）alias指令给定的路径对应于localtion中的URI右侧</p><p>示例：</p><pre><code>http://www.test.com/bbs/index.htmllocation /bbs/ {                 alias /web/forum/;}   --&gt; /web/forum/index.html location /bbs/ {                root /web/forum/;}   --&gt; /web/forum/bbs/index.html</code></pre><p>（3）index file </p><p>指定默认网页资源；ngx_http_index_module模块提供</p><pre><code>Syntax:    index file ...;Default:   index index.html;Context:    http, server, location</code></pre><p>（4）error_page code …[=[response]] URI</p><p>定义错误页，以指定的响应码状态进行响应</p><pre><code>Syntax:    error_page code ... [=[response]] uri;Default:    —Context:    http, server, location, if in location</code></pre><p>示例：</p><pre><code>error_page 404 /404.htmlerror_page 404 =200 /404.html</code></pre><p>（5）try_files files … URI</p><p>按顺序检查文件是否存在，返回对一个找到的文件或文件夹（结尾加斜线表示文件夹）；如果所有的文件或文件夹都找不到，会进行一个内部重定向到最后一个参数，只有最后一个参数可以引起一个内部重定向，之前的参数只设置内部URI的指向；最后一个参数是回退URI且必须存在，否则会出现内部500错误</p><pre><code>Syntax:    try_files file ... uri;try_files file ... =code;Default:    —Context:    server, location</code></pre><p>示例：</p><pre><code>location /images/ {             try_files $uri /images/default.gif;}location / {            try_files $uri $uri/index.html $uri.html =404;}</code></pre><h3 id="定义客户端请求的指令"><a href="#定义客户端请求的指令" class="headerlink" title="定义客户端请求的指令"></a>定义客户端请求的指令</h3><p>（1）keepalive_timeout timeout [header_timeout]</p><p>设置保持连接时长超时时长，0表示禁止长连接，默认为75秒</p><pre><code>Syntax:    keepalive_timeout timeout [header_timeout];Default:    keepalive_timeout 75s;Context:    http, server, location</code></pre><p>（2）keepalive——request number</p><p>在一次长连接上所允许请求的资源最大数量</p><pre><code>Syntax:    keepalive_requests number;Default:    keepalive_requests 100;Context:    http, server, location</code></pre><p>（3）keepalive——disable none|browser</p><p>对哪种浏览器禁用长连接</p><pre><code>Syntax:    keepalive_disable none | browser ...;Default:    keepalive_disable msie6;Context:    http, server, location</code></pre><p>（4）send_timeout time</p><p>向客户端发送响应报文的超时时长，此处是指两次写操作之间的间隔时长，而非整个过程的传输时长</p><pre><code>Syntax:    send_timeout time;Default:    send_timeout 60s;Context:    http, server, location</code></pre><p>（5）client_body_buffer_size size</p><p>用于接受每个客户端请求报文的body部分的缓冲区大小；默认为16k，超出此大小时，将其暂存到磁盘上由client_body_temp_path指令所定义的位置，仅能应用于上传</p><pre><code>Syntax:    client_body_buffer_size size;Default:    client_body_buffer_size 8k|16k;Context:    http, server, location</code></pre><p>（6）client_body_temp_path path [level 1 [level2 [level3]]]</p><p>设定用于存储客户端请求报文的body部分的临时存储路径及子目录结构和数量</p><pre><code>目录名为16进制的数字client_body_temp_path /var/tmp/client_body 1 2 21 :1级目录占1位16进制即2^4=16个目录 0-f2:2级目录占2位16进制，即2^8=256个目录 00-ff2:3级目录占2位16进制，即2^8=256个目录 00-ff</code></pre><h3 id="对客户端进行限制的相关指令"><a href="#对客户端进行限制的相关指令" class="headerlink" title="对客户端进行限制的相关指令"></a>对客户端进行限制的相关指令</h3><p>（1）limit_rate rate</p><p>限制响应给客户端的传输速率，单位为bytes/second，默认为0表示无限制</p><pre><code>Syntax:    limit_rate rate;Default:    limit_rate 0;Context:    http, server, location, if in location</code></pre><p>（2）limit_except method …{…}，</p><p>限制客户端使用除了制定的请求方法之外的其他方法</p><pre><code>Syntax:    limit_except method ... { ... }Default:    —Context:    location</code></pre><p>method： GET, HEAD, POST, PUT, DELETE, MKCOL, COPY, MOVE, OPTIONS, PROPFIND, PROPPATCH, LOCK, UNLOCK, or PATCH.</p><p>示例：</p><pre><code>limit_expect GET {    allow 192.168.4.0./24;    deny all;}</code></pre><h3 id="文件操作优化指令"><a href="#文件操作优化指令" class="headerlink" title="文件操作优化指令"></a>文件操作优化指令</h3><p>（1）aio on|off|threads[=pool]</p><p>是否开启aio功能</p><pre><code>Syntax:    aio on | off | threads[=pool];Default:    aio off;Context:    http, server, locationThis directive appeared in version 0.8.11.0.8.11版本以后才可以支持</code></pre><p>（2）directio size|off</p><p>是否同步写磁盘，而非写缓存，在linux 主机启用O_DIRECT标记，则文件大于等于给定大小时使用</p><pre><code>Syntax:    directio size | off;Default:    directio off;Context:    http, server, locationThis directive appeared in version 0.7.7.</code></pre><p>示例：</p><pre><code>directio 4m 当文件大于或者等于4m开始同步磁盘</code></pre><p>（3）open_file_cache off</p><p>open_file_cache max=N[inactive=time]</p><pre><code>Syntax:    open_file_cache off;open_file_cache max=N [inactive=time];Default:    open_file_cache off;Context:    http, server, location</code></pre><p>nginx可以缓存以下三种信息：</p><p>a、文件元数据：文件FD、文件大小和最近一次的修改时间</p><p>b、打开的目录结构</p><p>c、没有找到的或者没有权限访问的文件的相关信息</p><p>max=N：可缓存的缓存项上限；达到上限后会使用LRU算法实现管理；</p><p>inactive=time：缓存项的非活动时长，在此处指令的时长内未被命中的或者命中次数少于open_file_cache_min_uses指令指定的次数的缓存项；即非活动项将被删除</p><p>（4）open_file_cache_errors on|off</p><p>是否缓存查找时文件发生错误的文件一类的信息</p><pre><code>Syntax:    open_file_cache_errors on | off;Default:    open_file_cache_errors off;Context:    http, server, location</code></pre><p>（5）open_file_cache_min_uses number</p><p>open_file_cache指令的inactive参数指定的时长内，至少被命中此处指令的次数方可被归类为活动项</p><pre><code>Syntax:    open_file_cache_min_uses number;Default:    open_file_cache_min_uses 1;Context:    http, server, location</code></pre><p>（6）open_file_cache_valid time</p><p>缓存项有效检查频率</p><pre><code>Syntax:    open_file_cache_valid time;Default:    open_file_cache_valid 60s;Context:    http, server, location</code></pre><h2 id="ngx-http-access-module-实现基于IP访问控制功能"><a href="#ngx-http-access-module-实现基于IP访问控制功能" class="headerlink" title="ngx_http_access_module 实现基于IP访问控制功能"></a>ngx_http_access_module 实现基于IP访问控制功能</h2><p>（1）allow address|CIDR|unix：|all</p><p>指定允许访问的IP</p><p>（2）deny address | CIDR | unix: | all;</p><p>指定不能访问的IP</p><p>Syntax:    allow/deny address | CIDR | unix: | all;<br>Default:    —<br>Context:    http, server, location, limit_except</p><p><strong>注意：检查规则为自上而下检查，一旦匹配，将生效；建议条件严格的放置前面。</strong></p><p>示例：</p><pre><code>location / {deny 192.168.1.1; allow 192.168.1.0/24;allow 10.1.1.0/16; allow 2001:0db8::/32; deny all;}   </code></pre><h2 id="ngx-http-auth-basic-module实现基于用户的访问控制，使用basic机制进行用户认证"><a href="#ngx-http-auth-basic-module实现基于用户的访问控制，使用basic机制进行用户认证" class="headerlink" title="ngx_http_auth_basic_module实现基于用户的访问控制，使用basic机制进行用户认证"></a>ngx_http_auth_basic_module实现基于用户的访问控制，使用basic机制进行用户认证</h2><p>（1）auth_basic string|off</p><p>是否可以认证功能或string</p><pre><code>Syntax:    auth_basic string | off;Default:    auth_basic off;Context:    http, server, location, limit_except</code></pre><p>（2）auth_basic_user_file filename</p><p>认证文件的位置</p><pre><code>Syntax:    auth_basic_user_file file;Default:    —Context:    http, server, location, limit_except</code></pre><p>用户口令方式：</p><p>a、明文文本</p><p>格式：</p><pre><code>name:password:comment</code></pre><p>b、加密文本：需要htpasswd工具实现，由httpd_tools安装包提供</p><p>格式：</p><pre><code>USERNAMEPASSWORD</code></pre><h2 id="ngx-http-stub-stastus-module-用于输出nginx基本状态信息"><a href="#ngx-http-stub-stastus-module-用于输出nginx基本状态信息" class="headerlink" title="ngx_http_stub_stastus_module 用于输出nginx基本状态信息"></a>ngx_http_stub_stastus_module 用于输出nginx基本状态信息</h2><p>stub_status</p><pre><code>Syntax:    stub_status;Default:    —Context:    server, location</code></pre><p>示例：</p><pre><code>location /status {    stub_status;    allow 192.168.4.0/24;    deny all;}</code></pre><p><strong>显示信息解释：</strong></p><pre><code>active connection ：当前状态，活动状态的连接数accepts：统计总值，已经接受的客户端请求的总数handled：统计总值，已经处理完成的客户端请求的总数requests：统计总值，客户端发来的总的请求数reading：当前状态，正在读取客户端的请求报文的链接数writing：当前状态，正在向客户端响应报文过程中的连接数waiting：当前状态，正在等待客户端发出请求的空闲连接数</code></pre><h2 id="ngx-http-log-module指定日志格式记录请求"><a href="#ngx-http-log-module指定日志格式记录请求" class="headerlink" title="ngx_http_log_module指定日志格式记录请求"></a>ngx_http_log_module指定日志格式记录请求</h2><p>（1）log_format name string …</p><p>nginx核心模块及其他模块内嵌的变量</p><pre><code>Syntax:    log_format name [escape=default|json] string ...;Default:    log_format combined &quot;...&quot;;Context:    http</code></pre><p>（2）    access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]]</p><p>access_log off; 是否开启日志功能</p><p>访问日志文件路径，格式及相关的配置</p><pre><code>buffer=size 定义缓存区大小gzip 定义日志压缩级别flush 定义刷新时间</code></pre><p>示例：</p><pre><code>log_format compression &#39;$remote_addr - $remote_user [$time_local] &#39;                   &#39;&quot;$request&quot; $status $bytes_sent &#39;                   &#39;&quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$gzip_ratio&quot;&#39;;access_log /spool/logs/nginx-access.log compression buffer=32k;</code></pre><p><strong>注意：为了使用压缩工作，必须安装zlib 库</strong></p><p>（3）open_log_file_cache max=N[inactive=time][valid=time]</p><p>open_log_file_cache off；是否开启日志缓存</p><pre><code>max：缓存的最大文件描述符数量min_uses：在inactive指定的时长内访问大于等于此值认为活动项inactive：非活动时长valid：验证缓存中各缓存是否为活动项的时间间隔Syntax:    open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];open_log_file_cache off;Default:    open_log_file_cache off;Context:    http, server, location</code></pre><h2 id="ngx-http-gzip-module使用gzip方法压缩响应数据，可以节约带宽"><a href="#ngx-http-gzip-module使用gzip方法压缩响应数据，可以节约带宽" class="headerlink" title="ngx_http_gzip_module使用gzip方法压缩响应数据，可以节约带宽"></a>ngx_http_gzip_module使用gzip方法压缩响应数据，可以节约带宽</h2><p>（1）gzip on|off</p><p>是否启用gizp压缩</p><pre><code>Syntax:    gzip on | off;Default:    gzip off;Context:    http, server, location, if in location</code></pre><p>（2）gzip_comp_level level</p><p>指定压缩比  范围1-9</p><pre><code>Syntax:    gzip_comp_level level;Default:    gzip_comp_level 1;Context:    http, server, location</code></pre><p>（3）gzip_disable regex …</p><p>匹配到客户端浏览器不执行压缩</p><pre><code>Syntax:    gzip_disable regex ...;Default:    —Context:    http, server, location</code></pre><p>（4）gzip_min_length length</p><p>启用压缩功能的响应报文大小阈值</p><pre><code>Syntax:    gzip_min_length length;Default:    gzip_min_length 20;Context:    http, server, location</code></pre><p>（5）gzip_http_version 1.0|1.1</p><p>设定启用压缩功能时，协议的最小版本</p><pre><code>Syntax:    gzip_http_version 1.0 | 1.1;Default:    gzip_http_version 1.1;Context:    http, server, location</code></pre><p>（6）gzip_buffers number size</p><p>支持实现压缩功能时缓冲区数量及每个缓存区的大小</p><pre><code>Syntax:    gzip_buffers number size;Default:    gzip_buffers 32 4k|16 8k;Context:    http, server, location</code></pre><p>（7）gzip_type mime_type</p><p>指明仅对哪些类型的资源执行压缩操作；默认为test/html,不用再次指定，否则会报错。</p><pre><code>Syntax:    gzip_types mime-type ...;Default:    gzip_types text/html;Context:    http, server, location</code></pre><p>（8）gzip_vary on|off</p><p>如果启用压缩，是否在响应报文首部添加“vary:Accept_Encoding”</p><pre><code>Syntax:    gzip_vary on | off;Default:    gzip_vary off;Context:    http, server, location</code></pre><p>（9）    gzip_proxied off | expired | no-cache | no-store | private | no_last_modified | no_etag | auth | any …</p><pre><code>Syntax:    gzip_proxied off | expired | no-cache | no-store | private | no_last_modified | no_etag | auth | any ...;Default:    gzip_proxied off;Context:    http, server, location</code></pre><p>nginx对于代理服务器请求的响应报文，在何种情况下启用压缩功能</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>off</td><td>对于被代理的请求不启用压缩</td></tr><tr><td>expired，no-cache,no-store，private</td><td>对代理服务器请求的响应报文首部Cache-Control值任何一个，启用压缩功能</td></tr></tbody></table><p>示例：</p><pre><code>gzip            on;gzip_min_length 1000;gzip_proxied    expired no-cache no-store private auth;gzip_types      text/plain application/xml;</code></pre><h2 id="ngx-http-ssl-module"><a href="#ngx-http-ssl-module" class="headerlink" title="ngx_http_ssl_module"></a>ngx_http_ssl_module</h2><p>（1）ssl on|off</p><p>是否启用https protocol，建议用listen指令代替</p><pre><code>listen 443 sslSyntax:    ssl on | off;Default:    ssl off;Context:    http, server</code></pre><p>（2）ssl_certificate file</p><p>当前虚拟机使用证书文件路径</p><pre><code>Syntax:    ssl_certificate file;Default:    —Context:    http, server</code></pre><p>（3）ssl_certificate_key file</p><p>当前虚拟机使用证书的私钥文件</p><pre><code>Syntax:    ssl_certificate_key file;Default:    —Context:    http, server</code></pre><p>（4）ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3</p><p>支持ssl协议版本</p><pre><code>Syntax:    ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3];Default:    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;Context:    http, server</code></pre><p>（5）ssl_session_cache off|none|[builtin[:sieze]][shared:name:size]</p><p>是否开启ssl会话缓存</p><pre><code>none：相当于干跑builtin[:size]：使用openssl内建缓存，为每个worker进程私有；[shared:name:size]：在各worker之间使用一个共享缓存Syntax:    ssl_session_cache off | none | [builtin[:size]] [shared:name:size];Default:    ssl_session_cache none;Context:    http, server</code></pre><p>（6）ssl_session_timeout time</p><p>客户端连接可以服用ssl session cache中缓存的ssl参数有效市场</p><pre><code>Syntax:    ssl_session_timeout time;Default:    ssl_session_timeout 5m;Context:    http, server</code></pre><p>示例：</p><pre><code>server {    listen 443 ssl;    server_name www.test.com;     root /vhosts/ssl/htdocs;    ssl_certificate /etc/nginx/ssl/nginx.crt;     ssl_certificate_key /etc/nginx/ssl/nginx.key;    ssl_session_cache  shared:sslcache:20m;     ssl_session_timeout 10m;}</code></pre><p>查看证书</p><pre><code>openssl s_client -connect www.test.com/443</code></pre><p><strong>注意：可以为每个FQDN提供不同的证书，这是在apache中不能实现的</strong></p><pre><code>server {    listen 443 ssl;    server_name www.test.com;     root /vhosts/ssl/htdocs;    ssl_certificate /etc/nginx/ssl/nginx.crt;     ssl_certificate_key /etc/nginx/ssl/nginx.key;    ssl_session_cache  shared:sslcache:20m;     ssl_session_timeout 10m;}server {    listen 443 ssl;    server_name www.test2.com;     root /vhosts/ssl/htdocs;    ssl_certificate /etc/nginx/ssl/nginx2.crt;     ssl_certificate_key /etc/nginx/ssl/ngin2x.key;    ssl_session_cache  shared:sslcache:20m;     ssl_session_timeout 10m;}server {    listen 443 ssl;    server_name www.test2.com;     root /vhosts/ssl/htdocs;    ssl_certificate /etc/nginx/ssl/nginx3.crt;     ssl_certificate_key /etc/nginx/ssl/nginx3.key;    ssl_session_cache  shared:sslcache:20m;     ssl_session_timeout 10m;}</code></pre><h2 id="ngx-http-rewrite-module"><a href="#ngx-http-rewrite-module" class="headerlink" title="ngx_http_rewrite_module"></a>ngx_http_rewrite_module</h2><p>将用户请求URI基于PCRE regex所描述的模式进行检查，而完成重定向替换</p><p>（1）rewrite regex replacement[flag]</p><p>将用户的请求的URI基于regex所描述的模式进行检查，匹配到时将其替换为replacement指定新的URI</p><pre><code>Syntax:    rewrite regex replacement [flag];Default:    —Context:    server, location, if</code></pre><p>[flag]所表示的标志位用于控制此循环机制</p><pre><code>last：重写完成后停止对当前URI在当前location中后续的其他重写操作，而后对新的URI启动新一轮重写检查；提前重启新一轮循环break：重写完成后停止对当前URI在当前location中后续的其他重写操作，而直接跳转至重写规则之后的其他配置；结束循环，建议在location中使用redirect：临时重定向，重写完成之后以临时重定向后生成新的URI给客户端，由客户端重新发起新的；不能以http://huo https://开头，使用相对路径，状态码为302permanent：重写完成之后以永久重定向方式直接返回重写后生成新的URI给客户端，由客户端重新发起新请求：状态码为301</code></pre><p>上述中last和break是在服务器内部做跳转；redirect和permanent是客户端做跳转</p><p>（2）return </p><pre><code>Syntax:    return code [text];               return code URL;               return URL;Default:    —Context:    server, location, if</code></pre><p>停止处理，并返回客户端指定的响应码</p><p>（3）rewrite_log on|log</p><p>是否开启重写日志，发送至error_log</p><pre><code>Syntax:    rewrite_log on | off;Default:    rewrite_log off;Context:    http, server, location, if</code></pre><p>（4）set $variable value</p><p>用户自定义变量</p><p><strong>注意：变量定义和调用都要以$开头</strong></p><pre><code>Syntax:    set $variable value;Default:    —Context:    server, location, if</code></pre><p>（5）if(condition){…}</p><p>引入新的上下文，条件满足时，执行配置块中的配置指令</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>==</td><td>相同</td></tr><tr><td>！=</td><td>不相同</td></tr><tr><td>~</td><td>模式匹配，区分字符大小写</td></tr><tr><td>~*</td><td>模式匹配，不区分大小写</td></tr><tr><td>！~ 和 !~*</td><td>上述两种的否定</td></tr></tbody></table><p>文件及目录存在性判断</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-e，！-e</td><td>存在，不存在</td></tr><tr><td>-f，！-f</td><td>是否为文件</td></tr><tr><td>-d，！-d</td><td>是否为目录</td></tr><tr><td>-x，！-x</td><td>是否可执行</td></tr></tbody></table><p>####注意：如果在同一级配置块中存在多个rewrite规则，那么会自上而下逐个检查，被某条件规则替换完成后，会重新一轮的替换检查。隐含有循环机制，但不超过10次，如果超过10此，提示500响应码</p><p>示例：</p><pre><code>location /admin {        return 403 “Not Found”;}location /admin {        return 403 http://www.baidu.com;}location /admin {        return http://www.baidu.com;}</code></pre><h2 id="ngx-http-referer-module"><a href="#ngx-http-referer-module" class="headerlink" title="ngx_http_referer_module"></a>ngx_http_referer_module</h2><p>（1）valid_referers none|blocked|server_names|string …</p><p>定义referer首部的合法可用值，不能匹配的将是非法值</p><pre><code>Syntax:    valid_referers none | blocked | server_names | string ...;Default:    —Context:    server, location</code></pre><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>none</td><td>请求报文首部没有referer首部</td></tr><tr><td>blocked</td><td>请求报文有referer首部，但无有效值，前段可能被代理服务器删除</td></tr><tr><td>server_names</td><td>参数，其可以有值作为主机名或主机名模式</td></tr><tr><td>arbitrary_string</td><td>任意字符串，但可使用*做通配符</td></tr><tr><td>regular experssion</td><td>被指定的正则表达式模式匹配的字符串，要使用~开头</td></tr></tbody></table><p>示例：</p><pre><code>valid_referers none blocked server_names           *.example.com example.* www.example.org/galleries/           ~\.google\.;</code></pre><h2 id="ngx-http-headers-module"><a href="#ngx-http-headers-module" class="headerlink" title="ngx_http_headers_module"></a>ngx_http_headers_module</h2><p>由代理服务器响应给客户端的响应报文添加自定义首部，或修改指定首部的值</p><p>（1）add_header name value [always]</p><p>添加自定义首部</p><pre><code>Syntax:    add_header name value [always];Default:    —Context:    http, server, location, if in location</code></pre><p>（2）add_tralier name value [always]</p><p>添加自定义响应信息的尾部</p><pre><code>Syntax:    add_trailer name value [always];Default:    —Context:    http, server, location, if in location</code></pre><p>示例：</p><pre><code>add_header X-Via    $server_addr;add_header X-Cache $upstream_cache_status; add_header X-Accel $server_name;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis主从复制</title>
      <link href="/2017/11/28/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2017/11/28/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="redis主从复制"><a href="#redis主从复制" class="headerlink" title="redis主从复制"></a>redis主从复制</h1><p>一个master可以有多个slave主机，支持链式复制；master以非阻塞方式同步数据值slave主机。</p><p>修改方式：</p><pre><code>redis-cli&gt; SLAVEOF &lt;MASTER_IP&gt; &lt;MASTER_PORT&gt;redis-cli&gt; CONFIG SET masterauth &lt;PASSWORD&gt;</code></pre><table><thead><tr><th>节点</th><th>IP</th><th>角色</th></tr></thead><tbody><tr><td>node1</td><td>192.168.4.61</td><td>master</td></tr><tr><td>node2</td><td>192.168.4.62</td><td>slave</td></tr><tr><td>node3</td><td>192.168.4.63</td><td>slave</td></tr></tbody></table><h3 id="同步时间"><a href="#同步时间" class="headerlink" title="同步时间"></a>同步时间</h3><h3 id="基于主机名访问"><a href="#基于主机名访问" class="headerlink" title="基于主机名访问"></a>基于主机名访问</h3><h3 id="确保firewalld和selinux是否关闭"><a href="#确保firewalld和selinux是否关闭" class="headerlink" title="确保firewalld和selinux是否关闭"></a>确保firewalld和selinux是否关闭</h3><h3 id="三个节点上都安装redis"><a href="#三个节点上都安装redis" class="headerlink" title="三个节点上都安装redis"></a>三个节点上都安装redis</h3><p><code>[root@node1~]#yum install -y redis</code><br><code>[root@node1~]#systemctl start redis.service</code></p><h3 id="node1进行配置"><a href="#node1进行配置" class="headerlink" title="node1进行配置"></a>node1进行配置</h3><p><code>[root@node1~]#vim /etc/redis.conf</code></p><pre><code>bind 0.0.0.0requirepass centos</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-16_204858.jpg" alt=""></p><h3 id="node2和node3配置"><a href="#node2和node3配置" class="headerlink" title="node2和node3配置"></a>node2和node3配置</h3><p>node2以第一种方式配置<br>-<br><code>[root@node2~]#vim /etc/redis.conf</code></p><pre><code>bind 0.0.0.0requirepass centosslaveof 192.168.4.61 6379masterauth centosslave-priority 90</code></pre><p><code>[root@node2~]#systemctl start redis</code><br><img src="http://owatlfstl.bkt.clouddn.com/2017-11-16_210145.jpg" alt=""></p><p>node3以第二种方式配置<br>-</p><pre><code>127.0.0.1:6379&gt; CONFIG GET slaveof  #查看salveof的值1) &quot;slaveof&quot;2) &quot;&quot;127.0.0.1:6379&gt; SLAVEOF 192.168.4.61 6379   #设定slaveof的值OK127.0.0.1:6379&gt; CONFIG GET slaveof1) &quot;slaveof&quot;2) &quot;192.168.4.61 6379&quot;127.0.0.1:6379&gt; CONFIG SET masterauth centosOK127.0.0.1:6379&gt; CONFIG SET requirepass centosOK127.0.0.1:6379&gt; CONFIG GET slave-read-only(error) NOAUTH Authentication required.127.0.0.1:6379&gt; AUTH centosOK127.0.0.1:6379&gt; CONFIG GET slave-read-only1) &quot;slave-read-only&quot;2) &quot;yes&quot;127.0.0.1:6379&gt; CONFIG REWRITEOK</code></pre><h3 id="在node1上查看"><a href="#在node1上查看" class="headerlink" title="在node1上查看"></a>在node1上查看</h3><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-16_210811.jpg" alt=""></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="http://owatlfstl.bkt.clouddn.com/redis01.gif" alt=""></p><h1 id="sentinel"><a href="#sentinel" class="headerlink" title="sentinel"></a>sentinel</h1><p>主要完成三个功能：监控、通知、自动故障转移</p><h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><pre><code>port 指定端口sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; 设定监控    &lt;quorum&gt; 表示sentinel集群的quorum机制，即至少quorum个sentinel节点同时判定主节点故障，才认为其真的故障        s_down：subjectively down        o_down：objectively downsentinel auth-pass &lt;master-name&gt; &lt;password&gt;  连接主节点的密码sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; 指定failover过程中，能够被sentinel并行配置的从节点的数量sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt; sentinel必须在此指定的时长内完成故障转移操作，否则，将视为故障转移操作失败sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; 通知脚本，此脚本被自动传递多个参数</code></pre><p>命令：</p><pre><code>redis-cli -h SENTINEL_HOST -p SENTINEL_PORT redis-cli &gt;     SENTINEL masters    SENTINEL slaves &lt;MASTER_NAME&gt;    SENTINEL failover &lt;MASTER_NAME&gt;    SENTINEL get-master-addr-by-name &lt;MASTER_NAME&gt;</code></pre><p><strong>注意：在集群中每个节点都要配置并启动sentinel服务。</strong></p><p>###</p><p>在刚刚三个集群中配置</p><p><code>[root@node1~]#vim /etc/redis-sentinel.conf</code></p><pre><code>bind 0.0.0.0sentinel monitor mymaster 192.168.4.61 6379 2sentinel auth-pass mymaster centos</code></pre><p><code>systemctl start redis-sentinel.service</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-16_214852.jpg" alt=""><br>查看此时的主节点</p><p><code>[root@node1~]#systemctl stop redis.service</code> down掉主节点</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-16_215205.jpg" alt=""></p><p>如果故障点修改成功需要上线，进行如下操作：</p><p><code>[root@node1~]#vim /etc/redis.conf</code></p><pre><code>slaveof 192.168.4.62 6379masterauth centosslave-priority 70</code></pre><p><code>[root@node1~]#systemctl start redis.service</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-16_215712.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL语法</title>
      <link href="/2017/11/28/SQL%E8%AF%AD%E6%B3%95/"/>
      <url>/2017/11/28/SQL%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>结构化查询语言(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。<br>结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。</p><h3 id="2、RDBMS术语"><a href="#2、RDBMS术语" class="headerlink" title="2、RDBMS术语"></a>2、RDBMS术语</h3><ul><li>数据库：数据库是一些关联表的集合。</li><li>数据表：表示数据的矩阵。在一个数据库中的表开起来像一个简单的电子表格。</li><li>列（column）：一列包含了相同的数据，又称为属性，字段。</li><li>行（row）：是一组相关的数据，又称为一条记录record。</li><li>域（domain）：属性的取值范围。</li><li>主键（Primary Key）：一个或多个字段的组合，填入的数据必须能在本表中唯一表示本行；必须<em>提供数据</em>，即<strong>NOT NULL</strong>。一个表中<strong>有且只有一个主键</strong>。</li><li>唯一键：一个或多个字段的组合，填入的数据必须能在本表中唯一表示本行；<strong>允许为NULL</strong>。一个表中可以存在多个。</li><li>外键（foreign key）：一个表中的某字段可填入的数据取决于另一个表中的主键或唯一键已有的数据。即用于关联两个表。</li><li>检查（check）：字段在一定范围内。</li><li>索引：将表中的一个或多个字段中的数据复制一份另存，并且这些需要按特定次序排序存储。相当于我们一个书前面的目录作用。</li><li>复合件：两个或多个字段组成，相当于主键的作用。<br><img src="http://owatlfstl.bkt.clouddn.com/Relational_model_concepts.png" alt=""></li></ul><p>SQL处理过程<br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-24_210233.png" alt=""></p><h3 id="3数据表类型"><a href="#3数据表类型" class="headerlink" title="3数据表类型"></a>3数据表类型</h3><p>数值型</p><table><thead><tr><th>类型</th><th>大小(字节)</th><th>范围（有符号）</th><th>范围（UNSIGNED）</th><th>用途</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128,127</td><td>0,255</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768,32767</td><td>大整数值</td></tr><tr><td>MEDINUMINT</td><td>3</td><td>-8388608,8388607</td><td>0,16777215</td><td>大整数值</td></tr><tr><td>INT或INTEGER</td><td>4</td><td>-2^4,2^4-1</td><td>0,2^4*2</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8</td><td>-2^8,2^8-1</td><td>0,2^8*2</td><td>极大整数值</td></tr><tr><td>FLOAT（m,d）</td><td>4</td><td></td><td></td><td>单精度，浮点数值</td></tr><tr><td>DOUBLE(m,d)</td><td>8</td><td></td><td></td><td>多精度浮点数值</td></tr><tr><td>DECIMAL</td><td></td><td></td><td></td><td>小数值</td></tr></tbody></table><blockquote><p>DECIMAL的解释：Decimal(n,m)表示数值中共有n位数，其中整数n-m位，小数m位。例：decimal(10,6)，数值中共有10位数，其中整数占4位，小数占6位。</p></blockquote><p>日期和时间类型</p><table><thead><tr><th>类型</th><th>大小（字节）</th><th>范围</th><th>格式</th><th>用途</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01/9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>-838:59:59/838:59:59</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>1901/2155</td><td>YYYY</td><td>年份</td></tr><tr><td>DATETIME</td><td>8</td><td></td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:00/2037年某时</td><td>YYYYMMDDHHMMSS</td><td>时间戳</td></tr></tbody></table><p>若一个字段定义为timestamp，这个字段的时间数据随其他字段修改的时候自动更新，这个数据的字段可以存放这条记录最后被修改的时间。</p><p>字符串类型</p><table><thead><tr><th>类型</th><th>大小(字节)</th><th>用途</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0-65535</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255</td><td>不超过255个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0-255</td><td>短文本字符串，可变长度</td></tr><tr><td>BLOB(binary large object</td><td>0-65535</td><td>二进制形式的长文本数据，可变长度</td></tr><tr><td>TEXT</td><td>0-65535</td><td>场文本数据可变长度</td></tr><tr><td>MEDIUMBLOB</td><td>0,2^24-1</td><td>二进制中等长度文本数据，可变长度</td></tr><tr><td>BINARY（M）</td><td>0，M</td><td>固定长度，可存二进制或字符，</td></tr><tr><td>VARBINARY(M)</td><td>0，M</td><td>可变长度，可存二进制或字符</td></tr></tbody></table><blockquote><p>char和varchar区别</p></blockquote><ul><li>char(n)若存入字符数小于n，则以空格补充其后，查询之时再将空格去掉。所以char类型存储的字符末尾不能有空格。</li><li>char（n）固定长度，不管存入几个字符，都将占用n个字节；varchar（n）是存入的实际字符数+1个字节。真正存入的数据位实际字节-1。会使用1-2个字节来存储值长度。<br>-char类型的字符串检索速度比varchar速度快</li></ul><blockquote><p>varchar和text区别</p></blockquote><ul><li>varchar可指定n，text不能指定n；内部存储varchar是存入的实际字节数+1个字节，text是实际字节数+2的字节。</li><li>text类型不能有默认值</li><li>varchar可直接创建索引；text创建索引要指定前多少个字符。varchar查询速度比text快。</li></ul><blockquote><p>BOLB与TEXT区别</p></blockquote><ul><li>TEXT以文本方式存储，英文存储区分大小写；而BLOB是以二进制方式存储，不分大小写。</li><li>BLOB存储的数据只能整体读出。</li><li>TEXT可以指定字符集;BLOB不用指定字符集。</li></ul><blockquote><p>如何正确的数据类型？</p></blockquote><p>①尽量使用可正确存储数据的最小数据类型</p><p>②简单数据类型的操作通常需要更少的CPU周期</p><p>③尽量避免NULL，包含NULL的列对MySQL更难优化</p><p>修饰符类型</p><table><thead><tr><th>类型</th><th>解释</th></tr></thead><tbody><tr><td>NULL</td><td>空</td></tr><tr><td>NOT NULL</td><td>确保不能有NULL值</td></tr><tr><td>DEFAULT</td><td>提供未指定时为列的默认值</td></tr><tr><td>PRIMARY KEY</td><td>唯一表示数据库表中的每一行</td></tr><tr><td>FOREIGN KEY</td><td>唯一表示热河其他数据库表中的行</td></tr><tr><td>UNIQUE KEY</td><td>确保在一列中所有的值是唯一的</td></tr><tr><td>CHARACTER SET name</td><td>指定一个字符集</td></tr><tr><td>ATUO_INCREMENT</td><td>自动递增，适用于整数类型</td></tr><tr><td>UNSIGNED</td><td>无符号</td></tr><tr><td>CHECK</td><td>确保列中的所有值满足一定的条件</td></tr></tbody></table><p>删除约束的方法<br>ALTER TABLE column_name DROP CONSTRAINT PK;</p><p>###4 SQL通配符</p><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td>%</td><td>替代一个或多个字符</td></tr><tr><td>_</td><td>仅替代一个字符</td></tr><tr><td>[]</td><td>中括号中任意单一字符</td></tr><tr><td>[^]或[!]</td><td>除中括号中任意单一字符</td></tr></tbody></table><p><strong>注意：SQL通配符必须跟LIKE运算符一起使用</strong></p><p>###5、 SQL算数运算符</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>加法</td></tr><tr><td>-</td><td>减法</td></tr><tr><td>*</td><td>乘法</td></tr><tr><td>/</td><td>除法</td></tr><tr><td>%</td><td>取模，相当于取余数</td></tr></tbody></table><p>###6、SQL比较运算符</p><p>=、!=、 &lt;&gt;、 &gt;、 &lt;、 &gt;=、 &lt;=、 !&lt;、 !&gt;</p><p>###7、SQL逻辑运算符</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>ALL</td><td>用来在另一个值设定比较值的所有值</td></tr><tr><td>AND</td><td>运行多个条件在SQL语句中，存在WHERE子句中</td></tr><tr><td>ANY</td><td>用于根据条件在列表中的值进行标胶的任何应用值</td></tr><tr><td>BETWEEN…AND</td><td>用于搜索是在一组的那个值，给定最小值和最大值</td></tr><tr><td>EXISTS</td><td>用于搜索中指定的表，以满足某些标准的存在</td></tr><tr><td>IN</td><td>用于一个值进行比较，以已被指定的文字值的列表</td></tr><tr><td>LIKE</td><td>用来标胶使用通配符运算符相似的值</td></tr><tr><td>NOT</td><td>取反</td></tr><tr><td>OR</td><td>用来多个条件子句结合起来的SQL语句</td></tr><tr><td>IS NULL</td><td>用来比较一个NULL的值</td></tr><tr><td>UNIQUE</td><td>搜索指定表的每一行的唯一性</td></tr></tbody></table><p>###8、SQL Alias<br>格式：SELECT column_names FROM table_name AS alias_name</p><p>###9、SQL表达式</p><ul><li>SQL 布尔表达式</li></ul><p>语法：SELECT column_name1 column_name2 column_name3 FROM table_name WHERER SINGLE VALUE MATCHTING EXPRESSION;</p><ul><li>SQL 数字表达式</li></ul><p>语法：SELECT numerical_expression as OPERATION_NAME [FROM table_name WHERE CONDITION];</p><ul><li>SQL 日期表达式</li></ul><p>SELECT CURRENT_TIMESTAMP;  #显示当前系统的时间值</p><p>SELECT GETDATE(); #显示时间</p><p>###10、SQL 索引<br>索引是数据库的搜索引擎使用，以加快数据检索特定的查找表，是一个指向表中的数据。相当于一本书的目录，便于快速查找，对数据没有影响。缺点：如果UPDATE和INSERT会减慢数据的输入。</p><p><strong>注意：索引是唯一的，索引防止在列或者有一个索引重复条目。</strong></p><p>语法：CREATE INDEX index_name ON table_name;</p><ul><li>单列索引：是一个基于只有创建表列。</li></ul><p>语法：CREATE INDEX index_name ON table_name （colum_name）;</p><ul><li>唯一索引:不仅用于性能，而且要求数据的完整性。</li></ul><p>语法：CREATE UNIQUE INDEX index_name ON table_name （column_name）;</p><ul><li>组合索引：两个或多个索引</li></ul><p>语法：CREATE INDEX index_name ON table_name （column_name1，column_name2..）;</p><p>###11、SQL视图<br>SQL视图（View）是SQL语句结果集的可视化表。视图中的字段是来自一个或多个数据库中真实表中的字段。</p><p><strong>注意：数据库的设计不会受到视图中的函数、where或join语句的影响。</strong></p><p>语法：CREATE VIEW view_name AS SELECT column_name（s） FROM table_name WHERE [CONDITION];</p><p>WHIT CHECK OPTION 是CREATE VIEW 语句选项。目的是为了确保所有更新和插入满足视图定义的条件。</p><p>示例：CREATE VIEW testView AS  SELECT name，age FROM testtable WHERE age IS NOT NULL  WITH CHECK OPTION;  #WITH CHECK OPTION  拒绝任何age为NULL值的行。</p><p>那么是不是这样我们就可以随便更新视图了呢？那可不一定哦，更新视图是有一定条件的：</p><ul><li>SELECT子句不包含关键字DISTINCT.</li><li>SELECT子句不包含汇总函数。</li><li>SELECT子句不包含集合函数。</li><li>SELECT子句不能包含集合运算符</li><li>SELECT子句不能包含一个ORDER BY 子句。</li><li>FROM子句中不能包含多个表。</li><li>WHERE子句中不能包含子查询。</li><li>查询不包含GROUP BY 或HAVING.</li><li>计算列无法更新</li><li>从基表中的所有NOT  NULL 列必须包含在视图。</li></ul><p>看看是不是不是随便能更新视图能。好忧伤。。。</p><p>示例：UPDATE testView SET age = 20 WHERE name ‘xiaomian’ ;</p><p>###12、SQL排序<br>语法：SELECT column-list FROM table_name [WHERE CONDITION] [ORDER BY column1,column2..][ASC|DESC];</p><p>###13SQL约束<br>事物就是对数据库执行的工作单元。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><blockquote><p>事物的特性<br>事务是必须满足4个条件（ACID）： Atomicity（原子性）、Consistency（稳定性）、Isolation（隔离性）、Durability（可靠性）</p></blockquote><ul><li><p>事务的原子性：确保工作单元中的所有操作都成功完成。否则，该事物被终止的故障点，操作回滚到操作之前的状态。</p></li><li><p>一致性：确保数据库正确后成功提交事物更改状态。</p></li><li><p>隔离性：事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。</p></li><li><p>可靠性：软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候把事务保存到日志里。</p></li></ul><p>控制事物使用的命令：</p><ul><li>COMMIT :保存修改</li><li>ROLLBACK:回滚更改</li><li>SAVEPOINT:回滚事物组创建点</li><li>SET TRANSACTION:用来设置事物的隔离级别</li></ul><p>##14、 SQL命令分类<br><strong>DDL（Data Define Language）</strong></p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>CREATE</td><td>创建一个表、数据库、表的视图</td></tr><tr><td>ALTER</td><td>修改现有数据库对象</td></tr><tr><td>DROP</td><td>删除整个表、数据库中的表或其他对象或视图</td></tr></tbody></table><p><strong>DML（Data Manager Language）</strong></p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>INSERT</td><td>插入记录</td></tr><tr><td>UPDATE</td><td>修改记录</td></tr><tr><td>DELETE</td><td>删除记录</td></tr></tbody></table><p><strong>DCL（Date  Control Language）</strong></p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>GRANT</td><td>授予用户权限</td></tr><tr><td>REVOKE</td><td>撤销授予用户的权限</td></tr></tbody></table><p><strong>DQL（Date Query Language）</strong></p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>SELECT</td><td>从一张表或多张表中检索特定的记录</td></tr></tbody></table><p>###、15、SQL语言规范</p><ul><li>在数据库系统中，SQL语句不区分大小写（建议使用大写），但在字符串中常量区分大小写。</li><li>SQL语句中可以单行书写，并以“；”结尾。</li><li>在SQL中关键词不能跨多行或简写。</li><li>子句通常独立运行，便于管理，提高可读性。</li><li>SQL注释标准：/<em>需要注释的内容</em>/    或 –需要注释的内容</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH端口转发</title>
      <link href="/2017/11/28/SSH%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
      <url>/2017/11/28/SSH%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>在日常生产中，我们常常会遇到这样的问题，在公司运行一个服务或者一些程序，想要查看其运行状态及其结果等；公司的机器只能从内部访问外网，而内部外的并不能访问内部的机器；或者公司有一台ssh服务器，不能使用telnet服务去访问内部的主机，这样我们如何解决呢？由于ssh服务加密传输数据，我们可通过ssh服务解决上述问题。通过ssh连接首先构建一个”隧道“，然后可以通过这个隧道，远程连接到主机。</p><h3 id="1、ssh本地端口转发"><a href="#1、ssh本地端口转发" class="headerlink" title="1、ssh本地端口转发"></a>1、ssh本地端口转发</h3><p>格式：ssh -L localPort:remateIp1（需要远程连接的IP）:rematePort  IP2(跳板机的IP)</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-f</td><td>后台启用</td></tr><tr><td>-N</td><td>不打开远程shell，处于等待状态</td></tr><tr><td>-g</td><td>启用网关功能</td></tr></tbody></table><p><strong>示例</strong></p><p>假设这里有三台机器，CnetOS6.9-1 IP为192.168.159.138；CnetOS6.7-1 IP为192.168.159.139；CnetOS7.3-2 IP为192.168.159.161。CentOS7.3-2和CentOS7.3-1在公司的局域网中，CentOS6.9-1想连接CentOS7.3-2与之通信，该如何实现？</p><p>（1）模拟一个环境，先禁止CentOS6.9-1远程连接CentOS7.3-2</p><p> <code>[root@localhost~]#iptables -A INPUT -s 192.168.159.138 -j REJECT</code></p><p>（2）首先确认要使用本地端口是否被别的服务占用<br><code>[root@centos7~]#ss -tn</code></p><p>（3）CentOS6.9-1利用ssh本地端口转发连接<br><code>[root@centos6~]#ssh -L 10001:192.168.159.161:23 -fN 192.168.159.139</code><br><code>root@192.168.159.139&#39;s password:</code><br><code>Last failed login: Tue Sep 12 05:04:50 CST 2017 from ``192.168.159.138 on ssh:notty</code><br><code>There were 4 failed login attempts since the last successful login.</code><br><code>Last login: Tue Sep 12 04:58:25 2017 from 192.168.159.1</code></p><p>（4）查看隧道是否建立成功</p><p><code>[root@centos6~]#ss -tn</code><br><code>State      Recv-Q Send-Q       Local Address:Port         Peer Address:Port</code><br><code>ESTAB      0      0          192.168.159.138:22          192.168.159.1:4708</code><br><code>ESTAB      0      0          192.168.159.138:35506     192.168.159.139:22</code>   #已经建立连接<br><code>[root@localhost~]#ss -tn</code>   #在CetnOS 7.3-2无连接<br><code>State      Recv-Q Send-Q Local Address:Port               Peer Address:Port</code><br><code>ESTAB      0      0      192.168.159.161:22                 192.168.159.1:474</code></p><p>（5）在CentOS6.9-1ftp服务连接操作了</p><p><code>[root@centos7~]#ssh -p 10000 127.0.0.1</code></p><p>（6）如果我们连接完成想删除“隧道”该怎么解决呢？此时只能同过kill命令删除</p><p><code>[root@centos7~]#kill -9</code>pidof ssh``</p><h3 id="2、ssh远程端口转发"><a href="#2、ssh远程端口转发" class="headerlink" title="2、ssh远程端口转发"></a>2、ssh远程端口转发</h3><p>与上述示例相反，内网中只有一台主机可以访问外网，而另外一台主机不能访问外网，但是另外一台主机要想与外部的主机连接时，只能让一台主机作为跳板机，连接至外部机器，下面是实现方法：</p><p>（1）先模拟出来一个环境，同上述环境一样</p><p>（2）在CentOS7.3-2主机上创建隧道</p><p><code>[root@centos7~]#ssh -R 9999:192.168.159.138:22 -fN 192.168.159.164</code></p><p>（3）查看端口是否创建成功</p><p><code>[root@centos7~]#ss -tn</code><br><code>State       Recv-Q Send-Q Local Address:Port                Peer Address:Port</code>                 </p><p><code>ESTAB       0      0      192.168.159.139:51608              192.168.159.164:22</code></p><p>（4）在CentOS7.3-2连接CentOS6.9-1</p><p><code>[root@localhost~]#telnet 127.0.0.1 9999</code></p><p>（5）此处删除的方法更ssh本地端口转发一样。</p><h3 id="3、ssh动态端口转发"><a href="#3、ssh动态端口转发" class="headerlink" title="3、ssh动态端口转发"></a>3、ssh动态端口转发</h3><p>上述的两种，只是点对点的转发，如果我们有许多的端口，显然这样操作是不理想的，所有ssh支持ssh动态端口转发功能。如果某一台机器不能受限制不能访问某些网站，而另一台主机可以访问，ssh动态转发就解决了这个问题。工作原理是本地机器上分配一个socket侦听port端口，一旦这个端口上有了连接，该连接就经过安全通道转发出去，根据应用程序的协议可以判断远程主机和哪里连接。</p><p><strong>注意：只有root才能转发特权端口。</strong></p><p>格式：ssh -D <local port=""> <ssh server=""></ssh></local></p><p>（1）建立通道</p><p><code>[root@centos7~]#ssh -D 1080 -fN 192.168.159.165</code></p><p>（2）测试是否成功</p><p><code>[root@centos7~]#curl --socks5 127.0.0.1 http://192.168.159.166</code><br><code>test</code></p><p>上述过程中与sshd_config中的几个选项有关，AllowTcpForwarding、<br>GatewayPorts</p><h3 id="4、X协议转发"><a href="#4、X协议转发" class="headerlink" title="4、X协议转发"></a>4、X协议转发</h3><p>格式：ssh -X user@remotehost  gedit</p><p>X协议转发与sshd_config配置文件中的选项<code>X11Forwarding</code>有关。</p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH</title>
      <link href="/2017/11/28/SSH%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/11/28/SSH%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="一、SSH基本介绍"><a href="#一、SSH基本介绍" class="headerlink" title="一、SSH基本介绍"></a>一、SSH基本介绍</h2><p>1、含义：</p><pre><code>    SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH&lt;摘自：百度&gt;。</code></pre><p>2、实现SSH的方法</p><pre><code>（1）OpenSSH 工具（2）dropbear 工具</code></pre><p>3、SSH协议版本</p><pre><code>SSHv1：基于CRC-32做MAC（Massage Autherization Code）；不安全。SSHv2：双方主机协议选择安全的MAC方式，基于DH算法做秘钥交换，基于RSA或DSA实现身份认证。</code></pre><p>4、SSH认证方式</p><pre><code>- 基于passwd认证方式- 基于秘钥认证</code></pre><h2 id="二、实现SSH的管理方法"><a href="#二、实现SSH的管理方法" class="headerlink" title="二、实现SSH的管理方法"></a>二、实现SSH的管理方法</h2><h3 id="1、基于OpenSSH"><a href="#1、基于OpenSSH" class="headerlink" title="1、基于OpenSSH"></a>1、基于OpenSSH</h3><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><pre><code>    OpenSSH 是 SSH （Secure SHell） 协议的免费开源实现。SSH协议族可以用来进行远程控制， 或在计算机之间传送文件。而实现此功能的传统方式，如telnet(终端仿真协议)、 rcp ftp、 rlogin、rsh都是极为不安全的，并且会使用明文传送密码。OpenSSH提供了服务端后台程序和客户端工具，用来加密远程控件和文件传输过程中的数据，并由此来代替原来的类似服务。</code></pre><h4 id="（2）openssh工具"><a href="#（2）openssh工具" class="headerlink" title="（2）openssh工具"></a>（2）openssh工具</h4><p>（a）ssh工具相关的安装包</p><pre><code>openssh-VERSION.rpm 通用包openssh-server-VERSION.rpm  服务端安装包openssh-client-VERSION.rpm 客户端安装包</code></pre><p>（b）配置文件</p><p> /etc/sshd/ssh_config客户端配置文件</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>Host *</td><td>表示所有主机</td></tr><tr><td>StrictHostKeyChecking ask</td><td>首次登陆是否检查提示</td></tr><tr><td>ForwardX11Trusted yes</td><td>是否开启信任x11转发</td></tr></tbody></table><p> /etc/sshd/sshd_config 服务器端配置文件</p><table><thead><tr><th>选项</th><th></th></tr></thead><tbody><tr><td>Port 22</td><td>默认端口号为22</td></tr><tr><td>AddressFamily any</td><td>地址家族</td></tr><tr><td>ListenAddress ::</td><td>监听的地址</td></tr><tr><td>HostKey</td><td>密钥存放的位置</td></tr><tr><td>AuthorizedKeysFile</td><td>认证文件存放位置</td></tr><tr><td>PermitRootLogin</td><td>是否允许管理员登录，建议改为no</td></tr><tr><td>UseDNS</td><td>是否支持dns反向解析  此选项和GSSAPIAuthentication 同时使用；</td></tr><tr><td>ClientAliveInterval和ClientAliveCountMax</td><td>同时使用，两者相乘，就是连接的存活时间。</td></tr><tr><td>MaxAuthTries</td><td>最多认证次数</td></tr><tr><td>Banner /path/file</td><td>登录的提示信息</td></tr><tr><td>MaxSessions</td><td>最多会话</td></tr><tr><td>AllowUsers</td><td>允许用户</td></tr><tr><td>AllowGroups</td><td>允许组></td></tr><tr><td>DenyUsers</td><td>禁止用户</td></tr><tr><td>DenyGroups</td><td>禁止组</td></tr></tbody></table><p>  （3）ssh工具使用格式</p><pre><code>    ssh [user@]host [COMMAND]    ssh [-l user] host [COMMAND]</code></pre><p>选项：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>压缩方式</td></tr><tr><td>-b</td><td>绑定IP连接</td></tr><tr><td>-p</td><td>PORT 指定对方的端口号</td></tr><tr><td>-X</td><td>支持x11转发</td></tr><tr><td>-y</td><td>支持信任x11转发，与配置文件ForwardX11Trusted有关</td></tr><tr><td>-t</td><td>强制伪tty分配</td></tr></tbody></table><p><code>ssh -t remoteserver1 ssh remoteserver2</code>：当远程主机remoteserver2无法直接到达时，可以使用-t参数，然后由remoteserver1跳转到remoteserver2。在此过程中要先输入remoteserver1的密码，然后再输入remoteserver2的密码，然后就可以操作remoteserver2了。</p><p><strong>示例：</strong></p><p>假设这里有三台机器，CnetOS6.9-1 IP为192.168.159.138；CnetOS6.7-1 IP为192.168.159.139；CnetOS7.3-2 IP为192.168.159.161。CentOS6.9-1 可以与CentOS7.3-1通信，不能与CentOS7.3-2通信；而CentOS7.3-1可以与CentOS7.3-2通信。如何实现CentOS6.9-1与CentOS7.3-2通信呢？</p><p>（1）在CentOS7.3-2禁止CentOS6.9-1的IP 连接<br><code>[root@localhost~]#iptables -A INPUT -s 192.168.159.138 -j REJECT</code></p><p>（2）在CentOS6.9-1测试是否能ping通<br><code>[root@centos6~]#ping 192.168.159.161</code><br><code>PING 192.168.159.161 (192.168.159.161) 56(84) bytes of data.</code><br><code>From 192.168.159.161 icmp_seq=1 Destination Port Unreachable</code></p><p>（3）然后通过CentOS7-1为跳板机连接到CentOS7.3-2主机上</p><p>（a）先测试CentOS6.9-1是否能连接到主机CentOS7.3-2<br>    <code>[root@centos6~]#ssh 192.168.159.161</code><br><code>ssh: connect to host 192.168.159.161 port 22: Connection refused</code></p><p>（b）利用CentOS7.3-1作为跳板机连接到CentOS7.3-2主机上<br><code>[root@centos6~]#ssh -t 192.168.159.139 ssh 192.168.159.161</code><br><code>root@192.168.159.139&#39;s password:</code><br><code>root@192.168.159.161&#39;s password:</code><br><code>Last login: Tue Sep 12 19:21:37 2017 from 192.168.159.161</code></p><p> 顺利的解决了我们遇到的问题。</p><p>   （4）工作机制</p><pre><code>     当客户端连接SSH服务器时，会复制ssh服务器 `/etc/ssh/ssh_host*.key.pub ` （CentOS7是/etc/ssh/ssh_host_ecdsa_key.pub）文件中的公钥到客户机的` ~./ssh/know_hosts`中。下次连接时，会自动匹配响应的私钥，如果匹配成功，则连接，反之亦然。（a）客户端向服务器端发出请求（b）服务器端接受到请求，发送公钥给客户端（c）客户端输入账户和密码通过服务器端的公钥加密回传给服务端（d）服务端通过自己的私钥解密，得到用户名和密码与本地作对比验证，验证成功则允许登录，反之亦然。</code></pre><p><strong>示例:</strong></p><p>前提：CentOS 6 IP 为192.168.10.100；CentOS 7 IP 为192.168.10.101</p><p>（1）使用ssh命令使两台主机通信</p><p>   <code>[root@centos6~]#ssh root@192.168.10.100</code><br>    The authenticity of host ‘192.168.10.100(192.168.10.100)’ can’t be established.<br>    RSA key fingerprint is a1:18:36:cc:e4:a1:de:c5:ad:6f:e4:ec:91:1d:d7:c4.<br>    Are you sure you want to continue connecting (yes/no)? yes  #第一次连接会询问是否信任此台主机<br>    Warning: Permanently added ‘192.168.10.100’ (RSA) to the list of known hosts.<br>    root@192.168.159.1’s password:  #输入密码<br>    Last login: Sat Sep  9 23:30:57 2017 from 192.168.159.1# #登录成功<br>上面询问<code>/etc/ssh/ssh_config</code>文件下的选项<code>StrictHostKeyChecking</code> 有关，如果该为no，则不会显示检查</p><p> <code>[root@localhost~]#l.</code> #查看是否生成.ssh目录</p><p>上述过程中CentOS 6系统会自动创建<code>~/.ssh/known_hosts</code>且会复制CentOS 7中的公钥到自己主机上。</p><p>（2）上述的验证机制与公钥有关还是私钥有关呢？</p><p>下面我们再启动 一台虚拟主机 CentOS 7.2 IP 为 192.168.10.102<br>现在我们让CentOS 7.2 冒充CnetOS 6</p><p>情况一：修改CentOS 7.2的IP地址为192.168.10.100，尝试连接CentOS 7 </p><p>（a）修改IP地址为192.168.10.100</p><p>（b）把CentOS6服务端IP禁用</p><p>[root@localhost~]#ifconfig eth0 down</p><p>（c）使用客户机CentOS 7 连接</p><p>[root@localhost~]#ssh 192.168.10.100<br>会发出WARNING警告远程主机认证已经改变。</p><p>情况二：如果我们把公钥复制到CentOS 7.2中连接呢？</p><p>（a）将<code>/etc/ssh/ssh_host_rsa_key.pub</code>拷贝到冒充主机上<br><code>[root@localhost~]#scp /etc/ssh/ssh_host_rsa_key.pub 192.168.10.102:/etc/ssh</code><br>（b）连接CentOS 7.2<br>    <code>[root@localhost~]#ssh 192.168.10.100</code><br>会发出警告。</p><p>情况三：如果我们发私钥复制到CentOS7.2中，连接会发生什么情况？</p><p><code>[root@localhost~]#ssh 192.168.10.100</code> 认证成功，所以我们在日常生产中保管好自己的私钥文件。</p><p>（5）ssh服务的最佳实践</p><table><thead><tr><th>建议</th><th>选项</th></tr></thead><tbody><tr><td>不要使用默认端口</td><td>Port</td></tr><tr><td>禁止使用version 1 protocol</td><td>Protocol</td></tr><tr><td>限制可登录用户</td><td>MaxAuthTries</td></tr><tr><td>设定空闲会话时长</td><td>ClientAliveInterval和ClientAliveCountMax</td></tr><tr><td>利用防火墙设置ssh访问策略</td><td></td></tr><tr><td>仅监听特定的IP地址</td><td>ListenAddress</td></tr><tr><td>基于口令认证时，使用强密码策略</td><td></td></tr><tr><td>基于密钥的认证</td><td>PubkeyAuthentication</td></tr><tr><td>禁止使用空密码</td><td>PasswordAuthentication</td></tr><tr><td>禁止root用户直接登录</td><td>PermitRootLogin</td></tr><tr><td>限制ssh的访问频度和并发在线数</td><td>MaxAuthTries和MaxSessions</td></tr><tr><td>做好日志分析</td><td>SyslogFacility</td></tr></tbody></table><h2 id="二、基于密钥认证"><a href="#二、基于密钥认证" class="headerlink" title="二、基于密钥认证"></a>二、基于密钥认证</h2><h3 id="1、工作机制"><a href="#1、工作机制" class="headerlink" title="1、工作机制"></a>1、工作机制</h3><pre><code>（a）客户端在本机生成一对密钥（b）客户端通过密令将本机的公钥拷贝到服务器端，服务端会将客户端的公钥存在至`~/.ssh/authorized.keys`目录下（c）客户端再次发送请求时，包括IP、用户名；（d）服务端在通过上述目录查找是否有与之对应的公钥，如果查找成功响应IP和用户名，会随机生成一个字符串（e）服务端将使用客户端的公钥进行加密，然后发送给客户端（f）客户端得到服务端发来的消息后，客户端使用私钥进行解密，将解密的字符串发送给服务端（g）服务端接受客户端发来的字符串后，跟之前对比，如果一致，允许登录，反之亦然。</code></pre><h3 id="2、生成密钥对命令的介绍"><a href="#2、生成密钥对命令的介绍" class="headerlink" title="2、生成密钥对命令的介绍"></a>2、生成密钥对命令的介绍</h3><pre><code>ssh-keygen:authentication key generation, management and conversion格式：    ssh-keygen [-q] [-b bits] -t type [-N new_passphrase] [-C comment]   [-f output_keyfile]选项：    -t 加密的类型    -P 是否对生成的私钥加密    -f 指定的文件名ssh-copy-id :install  your  public  key  in a remote machine’s authorized_keys格式：    ssh-copy-id [-i [identity_file]] [user@]machine选项：    -i 指定公钥存放的位置</code></pre><h3 id="3、基于key的过程"><a href="#3、基于key的过程" class="headerlink" title="3、基于key的过程"></a>3、基于key的过程</h3><p>（a）在客户端生CentOS 7在一对密钥</p><pre><code>[root@localhost~]#ssh-keygen -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): #密钥存放的位置Enter passphrase (empty for no passphrase): #是否对密钥加密，建议加密，这里相当于选项-PEnter same passphrase again:  Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:  f5:f9:21:08:dd:2a:8d:f7:9f:88:4e:88:53:3e:45:a3 root@localhost.localdomainThe key&#39;s randomart image is:+--[ RSA 2048]----+|                 ||         . .     ||        . = .    ||         B = .   ||        E * + .  ||       + = . o . ||      o + . . .  ||       . o . o . ||         .o . o  |+-----------------+</code></pre><p>（b）使用命令将公钥拷贝到服务端CentOS 6主机上</p><pre><code>[root@localhost~]#ssh-copy-id -i .ssh/id_rsa.pub root@192.168.10.100[root@centos6~]#ls .ssh/authorized_keys 查看是否在服务端生成目录`authorized.keys`.ssh/authorized_keys</code></pre><p>（c）测试</p><pre><code>[root@localhost~]#ssh 192.168.10.100Last login: Thu Sep  7 18:39:01 2017 from 192.168.159.1  #登录成功</code></pre><p><strong>如果我们私钥加密需要验证多台，如果我们一台一台的验证，这样显然不是我们想要的方法，下面就很好的解决了我们这个问题</strong></p><h4 id="ssh-agent命令介绍"><a href="#ssh-agent命令介绍" class="headerlink" title="ssh-agent命令介绍"></a>ssh-agent命令介绍</h4><pre><code>ssh-agent是个长时间持续运行的守护进程（daemon），设计它的唯一目的就是对解密的专用密钥进行高速缓存，这是一个一次性的过程，如果终端退出即消失。</code></pre><h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><pre><code>  如果执行这条命令，会启动后台一个子进程。代理一开始并没有私钥文件，私钥文件是通过命令`ssh-add`添加。并且把文件~/.ssh/id_rsa, ~/.ssh/id_dsa, ~/.ssh/id_ecdsa, ~/.ssh/id_ed25519 and ~/.ssh/identity添加到代理中。通过使用环境变量能定位和验证。SSH_AUTH_SOCK和SSH_AGENT_PID环境变量。</code></pre><h4 id="实现代理的方法"><a href="#实现代理的方法" class="headerlink" title="实现代理的方法"></a>实现代理的方法</h4><pre><code>（a）ssh-agent xterm &amp;  利用内含的export命令执行环境使环境变量可用（b）eval `ssh-agent -s`            -s sh ksh            -c csh</code></pre><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>（a）对上述生成的密钥加密</p><pre><code> [root@localhost~]#ssh-keygen -p  #-p 修改密码Enter file in which the key is (/root/.ssh/id_rsa): Key has comment &#39;/root/.ssh/id_rsa&#39;Enter new passphrase (empty for no passphrase): Enter same passphrase again: Pass phrases do not match.  Try again.</code></pre><p>（b）启动代理</p><pre><code>[root@localhost~]#ssh-agent bash #启动一个bash子进程</code></pre><p>（c）将私钥文件添加至代理中</p><pre><code>[root@localhost~]#ssh-addIdentity added: /root/.ssh/id_rsa (/root/.ssh/id_rsa)</code></pre><p>（d）测试<br>    [root@localhost~]#ssh 192.168.10.102<br>    Last login: Sun Sep 10 17:46:13 2017 from 192.168.10.101<br>登录成功，这样提高了我们的工作效率。</p><h3 id="4、利用xshell基于key连接"><a href="#4、利用xshell基于key连接" class="headerlink" title="4、利用xshell基于key连接"></a>4、利用xshell基于key连接</h3><pre><code> 在xshell中工具--&gt;新建用户密钥生成向导--&gt;选择密钥类型和密钥长度--&gt;给密钥名称命名并给密钥加密--&gt;选择公钥格式--&gt;保存公钥文件至指定目录下--&gt;将公钥复制到需要远程连接的主机上~/.ssh/authorized.keys目录下，如果没有文件需要创建此目录，并修改权限。</code></pre><p>在生成密钥是选择不合适的公钥格式，可以使用密令修改：<br><code>[root@centos6~]#ssh-keygen -i -f PUBLIK.key &gt;&gt;~/.ssh/authorized.keys</code><br>        -i 读取不加密的私钥和公钥非OpenSSH兼容输出</p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群</title>
      <link href="/2017/11/28/Redis%E9%9B%86%E7%BE%A4/"/>
      <url>/2017/11/28/Redis%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h1><h3 id="同步时间"><a href="#同步时间" class="headerlink" title="同步时间"></a>同步时间</h3><h3 id="主机名互相解析"><a href="#主机名互相解析" class="headerlink" title="主机名互相解析"></a>主机名互相解析</h3><h3 id="确保firewalld和iptables关闭"><a href="#确保firewalld和iptables关闭" class="headerlink" title="确保firewalld和iptables关闭"></a>确保firewalld和iptables关闭</h3><h3 id="1、配置三个节点"><a href="#1、配置三个节点" class="headerlink" title="1、配置三个节点"></a>1、配置三个节点</h3><p><code>[root@node3~]#yum install -y redis</code></p><h3 id="2、修改配置文件"><a href="#2、修改配置文件" class="headerlink" title="2、修改配置文件"></a>2、修改配置文件</h3><blockquote><p>node1配置：</p></blockquote><p><code>[root@node1~]#vim /etc/redis.conf</code></p><pre><code>bind 192.168.4.61requirepass centoscluster-enabled yescluster-config node1.conf   #集群节点信息配置文件，存放在/var/lib/redis目录下cluster-node-timeout 15000clusert-migration-barrier 1 #这个选项设置如果master宕机，是否从节点全部迁移到新的master上</code></pre><p><code>[root@node1~]#systemctl start redis.service</code></p><blockquote><p>node2配置：</p></blockquote><p><code>[root@node2~]#vim /etc/redis.conf</code></p><pre><code>bind 192.168.4.62requirepass centoscluster-enabled yescluster-config node2.conf   #集群节点信息配置文件，存放在/var/lib/redis目录下cluster-node-timeout 15000clusert-migration-barrier 1 #这个选项设置如果master宕机，是否从节点全部迁移到新的master上</code></pre><p><code>[root@node1~]#systemctl start redis.service</code></p><blockquote><p>node3配置：</p></blockquote><p><code>[root@node3~]#vim /etc/redis.conf</code></p><pre><code>bind 192.168.4.63requirepass centoscluster-enabled yescluster-config node3.conf   #集群节点信息配置文件，存放在/var/lib/redis目录下cluster-node-timeout 15000clusert-migration-barrier 1 #这个选项设置如果master宕机，是否从节点全部迁移到新的master上</code></pre><p><code>[root@node1~]#systemctl start redis.service</code></p><p><code>[root@node1~]#redis-cli -h 192.168.4.61 -a centos -p 6379 CLUSTER INFO</code>    查看集群信息</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-20_202207.jpg" alt=""></p><h5 id="此时看集群状态为fail，因为还没有进行分slot和建立集群关系。"><a href="#此时看集群状态为fail，因为还没有进行分slot和建立集群关系。" class="headerlink" title="此时看集群状态为fail，因为还没有进行分slot和建立集群关系。"></a>此时看集群状态为fail，因为还没有进行分slot和建立集群关系。</h5><h3 id="3、为每个redis建立slot"><a href="#3、为每个redis建立slot" class="headerlink" title="3、为每个redis建立slot"></a>3、为每个redis建立slot</h3><p><code>[root@node1~]#redis-cli -h 192.168.4.61 -a centos -p 6379 CLUSTER ADDSLOTS {0..5461}</code></p><p><code>[root@node1~]#redis-cli -h 192.168.4.62 -a centos -p 6379 CLUSTER ADDSLOTS {5462..10923}</code></p><p><code>[root@node1~]#redis-cli -h 192.168.4.63 -a centos -p 6379 CLUSTER ADDSLOTS {10924..16383}</code></p><p><strong>注意：如果有4个节点，需要自动计算除每个节点有多少个slots，然后进行分配。slot总共有16384个</strong></p><h3 id="4、设置集群关系"><a href="#4、设置集群关系" class="headerlink" title="4、设置集群关系"></a>4、设置集群关系</h3><p><code>[root@node1~]#redis-cli -h 192.168.4.61 -a centos -p 6379 CLUSTER MEET 192.168.4.62 6379</code></p><p><code>[root@node1~]#redis-cli -h 192.168.4.61 -a centos -p 6379 CLUSTER MEET 192.168.4.63 6379</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-20_202047.jpg" alt=""></p><p>#####查看集群信息时集群的状态已经为”ok“。</p><h3 id="5、测试，查看效果"><a href="#5、测试，查看效果" class="headerlink" title="5、测试，查看效果"></a>5、测试，查看效果</h3><p><code>[root@node1~]#redis-cli -h 192.168.4.61 -a centos -p 6379</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-20_202725.jpg" alt=""></p><p>#####通过从图中可以看出，在192.168.4.61这台主机不能创建testkeys hi 这个值，需要移到到192.168.4.62:6379主机上创建。</p><p><code>[root@node2~]#redis-cli -h 192.168.4.62 -a centos -p 6379</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-20_203013.jpg" alt=""></p><p><strong>小结：</strong></p><p>客户单向redis发送任何key指令，须先对key计算一个词hash作为其槽位编号，将指令发送给对应槽位的持有节点。就像我们刚刚操作的，如果发送到了错误的节点，会报错；而是返回表示MOVE的错误信息。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Samba</title>
      <link href="/2017/11/28/Samba/"/>
      <url>/2017/11/28/Samba/</url>
      
        <content type="html"><![CDATA[<p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，基于C/S架构。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。SMB协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。通过设置“NetBIOS over TCP/IP”使得Samba不但能与局域网络主机分享资源，还能与全世界的电脑分享资源。</p><h1 id="一、SAMAB基本概念"><a href="#一、SAMAB基本概念" class="headerlink" title="一、SAMAB基本概念"></a>一、SAMAB基本概念</h1><h2 id="1、SMB的基本功能"><a href="#1、SMB的基本功能" class="headerlink" title="1、SMB的基本功能"></a>1、SMB的基本功能</h2><ul><li>共享文件和打印，实现在线编辑</li><li>实现登录SMB用户的身份认证</li><li>可以进行NetBIOS名称解析</li><li>外围设备共享</li></ul><h2 id="2、SAMAB服务基于协议"><a href="#2、SAMAB服务基于协议" class="headerlink" title="2、SAMAB服务基于协议"></a>2、SAMAB服务基于协议</h2><h3 id="（1）、NetBIOS协议"><a href="#（1）、NetBIOS协议" class="headerlink" title="（1）、NetBIOS协议"></a>（1）、NetBIOS协议</h3><p>NETBIOS（Network Basic Input/Output System）协议是由IBM公司开发，主要用于数十台计算机的小型局域网。该协议是一种在局域网上的程序可以使用的应用程序编程接口（API），为程序提供了请求低级服务的统一的命令集，作用是为了给局域网提供网络以及其他特殊功能。系统可以利用WINS服务、广播及Lmhost文件等多种模式将NetBIOS名-——特指基于NETBIOS协议获得计算机名称——解析为相应IP地址，实现信息通讯，所以在局域网内部使用NetBIOS协议可以方便地实现消息通信及资源的共享。</p><h3 id="NetBIOS特点"><a href="#NetBIOS特点" class="headerlink" title="NetBIOS特点"></a>NetBIOS特点</h3><ul><li>占用系统资源少</li><li>传输效率高</li></ul><h3 id="（2）CIFS协议"><a href="#（2）CIFS协议" class="headerlink" title="（2）CIFS协议"></a>（2）CIFS协议</h3><p>CIFS 是一个新提出的协议，它使程序可以访问远程Internet计算机上的文件并要求此计算机提供服务。CIFS 使用客户/服务器模式。客户程序请求远在服务器上的服务器程序为它提供服务。服务器获得请求并返回响应。CIFS是公共的或开放的SMB协议版本，并由Microsoft使用。SMB协议在局域网上用于服务器文件访问和打印的协议。像SMB协议一样，CIFS在高层运行，而不像TCP/IP协议那样运行在底层。CIFS可以看做是应用程序协议如文件传输协议和超文本传输协议的一个实现。</p><h3 id="CIFS协议功能"><a href="#CIFS协议功能" class="headerlink" title="CIFS协议功能"></a>CIFS协议功能</h3><ul><li>访问服务器本地文件并读写这些文件</li><li>与其他用户一起共享一些文件</li><li>在短线时自动回复与网络的连接</li><li>使用统一码文件名</li></ul><h3 id="（3）smb协议"><a href="#（3）smb协议" class="headerlink" title="（3）smb协议"></a>（3）smb协议</h3><p>SMB(全称是Server Message Block)是一个协议名，它能被用于Web连接和客户端与服务器之间的信息沟通。SMB最初是IBM的贝瑞·费根鲍姆（Barry Feigenbaum）研制的，其目的是将DOS操作系统中的本地文件接口“中断13”改造为网络文件系统。</p><h2 id="3、SAMBA服务文件介绍"><a href="#3、SAMBA服务文件介绍" class="headerlink" title="3、SAMBA服务文件介绍"></a>3、SAMBA服务文件介绍</h2><h3 id="（1）samba相关包介绍"><a href="#（1）samba相关包介绍" class="headerlink" title="（1）samba相关包介绍"></a>（1）samba相关包介绍</h3><table><thead><tr><th>包名</th><th>说明</th></tr></thead><tbody><tr><td>samba</td><td>提供smb服务</td></tr><tr><td>samba-client</td><td>提供客户端工具</td></tr><tr><td>samba-common</td><td>通用软件</td></tr><tr><td>cifs-utils</td><td>smb客户端工具</td></tr><tr><td>samba-winbind</td><td>和AD相关的包</td></tr></tbody></table><h3 id="（2）主配置文件-etc-samba-smb-conf"><a href="#（2）主配置文件-etc-samba-smb-conf" class="headerlink" title="（2）主配置文件/etc/samba/smb.conf"></a>（2）主配置文件<code>/etc/samba/smb.conf</code></h3><p>sbm.conf继承了.ini（initialization）文件格式，用[]分成不同的部分。</p><p><strong>配置文件分为类</strong></p><ul><li>[global]：服务器通过或全局设置的部分</li><li>[homes]：用户的家目录共享</li><li>[printers]：定义打印机资源和服务</li><li>[SHARENAME]：自定义共享目录配置</li></ul><p><strong>配置文件宏定义</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>%m</td><td>客户端主机的NetBIOS名</td></tr><tr><td>%M</td><td>客户端的FQDN</td></tr><tr><td>%H</td><td>当前用户家目录路径</td></tr><tr><td>%U</td><td>当前用户用户名</td></tr><tr><td>%g</td><td>当前用户所属组</td></tr><tr><td>%h</td><td>samba服务器的主机名</td></tr><tr><td>%L</td><td>samba服务器的NetBIOS</td></tr><tr><td>%I</td><td>客户端主机的IP</td></tr><tr><td>%T</td><td>当前日期和时间</td></tr><tr><td>%S</td><td>可登录的用户名</td></tr></tbody></table><p><strong>配置文件选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>workgroup</td><td>指定工作组名称</td></tr><tr><td>server string</td><td>主机注释信息</td></tr><tr><td>netbios name</td><td>指定NetBIOS名</td></tr><tr><td>interface</td><td>指定服务监听的接口和IP </td></tr><tr><td>host allow</td><td>指定允许指定主机访问，如多个主机可以网段，离散可以使用“，”、空格或tab分离；或使用主机名；默允许所有主机访问。示例192.168.4.</td></tr><tr><td>config file=/PAHT/TO/SOMEFIEL/%U</td><td>用户独立的配置文件</td></tr><tr><td>log file=/var/log/samba/log.%m</td><td>不同主机采用不同日志</td></tr><tr><td>max log size</td><td>日志文件大小，单位为KB</td></tr><tr><td>log level</td><td>设置日志级别</td></tr><tr><td>comment</td><td>注释信息</td></tr><tr><td>path</td><td>所共享的目录路径</td></tr><tr><td>public = {yes或no}</td><td>能否被guest访问的共享，默认为no</td></tr><tr><td>guest ok = {yes或no}</td><td>是否允许来宾账号访问</td></tr><tr><td>writable = {yes或no}</td><td>是否可读写</td></tr><tr><td>read only = {yes或no}</td><td>是否只读，如果与writeable设置冲突，放在后面的设置生效</td></tr><tr><td>write list</td><td>指定多个用户是否可写，格式：@GROUP_NAME、+GROUP_NAME或使用“，”分隔，如设置writable = no 列表中的用户或组可读写，不在列表中的用户只读</td></tr><tr><td>vaild users</td><td>特定用户才能访问此共享，如果设置为空，将允许所有用户；用户名之间使用空格分隔</td></tr><tr><td>browsable = {yes或no}</td><td>是否允许所有用户列浏览此共享，默认为yes</td></tr><tr><td>create mask</td><td>修改上传权限</td></tr></tbody></table><p><strong>注意：如果是某个用户对目录有权限，此用户必须有目录权限和共享权限的交集。</strong></p><p> 服务脚本：<br>    /etc/rc.d/init.d/nmb<br>    /etc/rc.d/init.d/smb</p><h2 id="4、管理命令"><a href="#4、管理命令" class="headerlink" title="4、管理命令"></a>4、管理命令</h2><h3 id="（1）testparm：检查smb-conf文件是否正确"><a href="#（1）testparm：检查smb-conf文件是否正确" class="headerlink" title="（1）testparm：检查smb.conf文件是否正确"></a>（1）testparm：检查smb.conf文件是否正确</h3><p>格式：</p><pre><code>testparm [-s] {config filename} [hostname hostIP]</code></pre><h3 id="（2）smbclient-连接SMB-CIFS资源的命令"><a href="#（2）smbclient-连接SMB-CIFS资源的命令" class="headerlink" title="（2）smbclient 连接SMB/CIFS资源的命令"></a>（2）smbclient 连接SMB/CIFS资源的命令</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-I</td><td>指定服务器的IP地址；</td></tr><tr><td>-L</td><td>显示服务器端所分享出来的所有资源；</td></tr><tr><td>-n</td><td>指定用户端所要使用的NetBIOS名称；</td></tr><tr><td>-N</td><td>不用询问密码；</td></tr><tr><td>-p</td><td>指定服务器端TCP连接端口编号； </td></tr><tr><td>-T</td><td>备份服务器端分享的全部文件，并打包成tar格式的文件；</td></tr><tr><td>-U&lt;用户名称&gt;</td><td>指定用户名称； </td></tr><tr><td>-w&lt;工作群组&gt;</td><td>指定工作群组名称。</td></tr></tbody></table><h3 id="（3）mount-cifs依赖于-cifs-utils包；挂载工具"><a href="#（3）mount-cifs依赖于-cifs-utils包；挂载工具" class="headerlink" title="（3）mount.cifs依赖于 cifs-utils包；挂载工具"></a>（3）mount.cifs依赖于 cifs-utils包；挂载工具</h3><h3 id="（4）smbpasswd-设置smb用户密码"><a href="#（4）smbpasswd-设置smb用户密码" class="headerlink" title="（4）smbpasswd 设置smb用户密码"></a>（4）smbpasswd 设置smb用户密码</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>向smbpasswd文件中添加用户； </td></tr><tr><td>-c</td><td>指定samba的配置文件；</td></tr><tr><td>-x</td><td>从smbpasswd文件中删除用户；</td></tr><tr><td>-d</td><td>在smbpasswd文件中禁用指定的用户；</td></tr><tr><td>-e</td><td>在smbpasswd文件中激活指定的用户；</td></tr><tr><td>-n</td><td>将指定的用户的密码置空。</td></tr></tbody></table><p>密码文件存在在<code>/var/lib/samba/private/passdb.tdb</code></p><h3 id="（5）pdbedit"><a href="#（5）pdbedit" class="headerlink" title="（5）pdbedit"></a>（5）pdbedit</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a username</td><td>新建Samba账户。</td></tr><tr><td>-x username</td><td>删除Samba账户。</td></tr><tr><td>-L</td><td>列出Samba用户列表，读取`/var/lib/samba/private/passdb.tdb数据库文件。</td></tr><tr><td>-Lv</td><td>列出Samba用户列表的详细信息。</td></tr><tr><td>-c “[D]” –u username</td><td>暂停该Samba用户的账号。</td></tr><tr><td>-c “[]” –u username</td><td>恢复该Samba用户的账号。</td></tr></tbody></table><h3 id="（6）cifscreds-管理NTLM在内核密钥环中"><a href="#（6）cifscreds-管理NTLM在内核密钥环中" class="headerlink" title="（6）cifscreds 管理NTLM在内核密钥环中"></a>（6）cifscreds 管理NTLM在内核密钥环中</h3><pre><code>add：把指定用户的用户名和密码加入内核密钥环</code></pre><h1 id="二、实现共享"><a href="#二、实现共享" class="headerlink" title="二、实现共享"></a>二、实现共享</h1><h2 id="（1）实现linux为客户端，windows为服务器端共享"><a href="#（1）实现linux为客户端，windows为服务器端共享" class="headerlink" title="（1）实现linux为客户端，windows为服务器端共享"></a>（1）实现linux为客户端，windows为服务器端共享</h2><p>在windows系统上创建一个共享目录</p><p>选中目录–&gt;右击点属性–&gt;共享</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-18_104753.jpg" alt=""></p><p>点击图中的用户可以设置权限</p><p>在linux客户端查看</p><p><code>[root@localhost ~]# smbclient -L 192.168.4.1 -U joah%PASSWORD</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-18_105307.jpg" alt=""></p><p><code>[root@localhost ~]# smbclient //192.168.4.1/linuxclient -U joah</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-18_105624.jpg" alt=""></p><p>挂载此目录</p><p>[root@localhost ~]# mount //192.168.4.1/linuxclient -o username=joah,password=PASSWORD /mnt/samba/</p><h2 id="（2）实现linux作服务器端，windows作客户端共享文件"><a href="#（2）实现linux作服务器端，windows作客户端共享文件" class="headerlink" title="（2）实现linux作服务器端，windows作客户端共享文件"></a>（2）实现linux作服务器端，windows作客户端共享文件</h2><p>创建smb账号</p><p><code>[root@localhost ~]# useradd -r smb1</code><br><code>[root@localhost ~]# useradd -r smb2</code><br><code>[root@localhost ~]# useradd -r smb2</code></p><p>设置smb账号密码</p><p><code>[root@localhost ~]# smbpasswd -a smb1</code><br><code>[root@localhost ~]# smbpasswd -a smb2</code><br><code>[root@localhost ~]# smbpasswd -a smb3</code></p><p>使用命令查看</p><p><code>[root@localhost ~]# pdbedit -L</code></p><pre><code>smb1:496:smb3:494:smb2:495:</code></pre><p>创建共享目录</p><p><code>[root@localhost ~]# vim /etc/samba/smb.conf</code></p><pre><code>[sharewin]        comment = linux share        path = /app/smbshare</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-18_112436.jpg" alt=""></p><p>弹出对话框输入上述账户和密码即可登录</p><h2 id="（3）linux中实现不同用户权限访问共享目录"><a href="#（3）linux中实现不同用户权限访问共享目录" class="headerlink" title="（3）linux中实现不同用户权限访问共享目录"></a>（3）linux中实现不同用户权限访问共享目录</h2><p>###创建共享目录</p><p><code>[root@localhost ~]# mkdir /app/share{1,2,3}</code><br><code>[root@localhost ~]# chmod 777 /app/share{1,2,3}</code>   并设置目录权限</p><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p><code>[root@localhost ~]# vim /etc/samba/smb.conf</code>在全部设置下添加如下一行内容</p><pre><code>    config file = /etc/samba/conf.d/%U</code></pre><h3 id="创建每个用户的配置文件"><a href="#创建每个用户的配置文件" class="headerlink" title="创建每个用户的配置文件"></a>创建每个用户的配置文件</h3><p><code>[root@localhost ~]# mkdir /etc/samba/conf.d</code>   #创建指定配置文件存放位置</p><p><code>[root@localhost conf.d]# vim smb1</code></p><pre><code>[share]comment = share1path = /app/share1writeable = yes</code></pre><p><code>[root@localhost conf.d]# vim smb2</code></p><pre><code>[share]comment = share2path = /app/share2</code></pre><p><code>[root@localhost conf.d]# vim smb3</code></p><pre><code>[share]comment = share3path = /app/share3</code></pre><h3 id="重启服务测试"><a href="#重启服务测试" class="headerlink" title="重启服务测试"></a>重启服务测试</h3><p><code>[root@localhost conf.d]# service nmb restart ;service smb restart</code></p><p>在另一外linux主机上测试</p><p><code>[root@localhost ~]# smbclient -L //192.168.4.55 -U smb1%123456</code></p><p><code>[root@localhost ~]# smbclient //192.168.4.55/share -U smb1%magedu</code></p><h3 id="挂载共享目录在本地"><a href="#挂载共享目录在本地" class="headerlink" title="挂载共享目录在本地"></a>挂载共享目录在本地</h3><p><code>[root@localhost smb]# mount //192.168.4.55/share /mnt/smb/ -o username=smb1,password=123456</code></p><h3 id="实现开机自动挂载"><a href="#实现开机自动挂载" class="headerlink" title="实现开机自动挂载"></a>实现开机自动挂载</h3><p><code>[root@localhost smb]# vim /etc/fstab</code></p><pre><code>//192.168.4.55/share    /mnt/smb                cifs    username=smb1,password=magedu   0 0</code></pre><p>如果我们这样挂载的话，密码直接暴露出来，显然不安装，我们可以将用户和密码写到一个配置文件中</p><p><code>[root@localhost smb]# vim /etc/samba/userpasswd</code></p><pre><code>username=smb1password=123456</code></pre><p><code>[root@localhost ~]# chmod 600 /etc/samba/userpasswd</code>  #修改文件权限</p><p><code>[root@localhost ~]# vim /etc/fstab</code></p><pre><code>//192.168.4.55/share    /mnt/smb                cifs    credentials=/etc/samba/userpasswd       0 0</code></pre><p><code>[root@localhost ~]# mount -a</code>  #使挂载生效</p><p><code>[root@localhost ~]# df</code></p><pre><code>Filesystem           1K-blocks    Used Available Use% Mounted on/dev/sda2             50264772 1632864  46071908   4% /tmpfs                   502056       0    502056   0% /dev/shm/dev/sda3             50264772   89224  47615548   1% /app/dev/sda1               487652   35604    426448   8% /boot/dev/sr0               3878870 3878870         0 100% /media/cdrom//192.168.4.55/share  50264772   53092  47651680   1% /mnt/smb  #挂载成功</code></pre><h2 id="（4）实现多用户挂载（CentOS-7中可以启用这种方法）"><a href="#（4）实现多用户挂载（CentOS-7中可以启用这种方法）" class="headerlink" title="（4）实现多用户挂载（CentOS 7中可以启用这种方法）"></a>（4）实现多用户挂载（CentOS 7中可以启用这种方法）</h2><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p><code>[root@localhost ~]# vim /etc/samba/smb.conf</code></p><pre><code>[share]        comment = sharedirectory        path = /app/sharedir        write list = smb1   #设置只有smb1用户具有写权限</code></pre><h3 id="创建共享目录并赋予权限"><a href="#创建共享目录并赋予权限" class="headerlink" title="创建共享目录并赋予权限"></a>创建共享目录并赋予权限</h3><p><code>[root@localhost ~]# mkdir /app/sharedir</code><br><code>[root@localhost ~]# chmod 777 /app/sharedir</code></p><h3 id="在客户端创建与服务器端相同的账号"><a href="#在客户端创建与服务器端相同的账号" class="headerlink" title="在客户端创建与服务器端相同的账号"></a>在客户端创建与服务器端相同的账号</h3><p><strong>注意：客户端与服务器端必须有相同的用户。</strong></p><p><code>[root@localhost ~]# useradd smb1</code></p><p><code>[root@localhost ~]# useradd smb2</code></p><p><code>[root@localhost ~]# useradd smb3</code></p><h3 id="使用smb3用户挂载目录"><a href="#使用smb3用户挂载目录" class="headerlink" title="使用smb3用户挂载目录"></a>使用smb3用户挂载目录</h3><p><code>[root@localhost ~]# vim /etc/samba/userpasswd</code></p><pre><code>username=smb3password=123456</code></pre><h3 id="修改-etc-fstab文件"><a href="#修改-etc-fstab文件" class="headerlink" title="修改/etc/fstab文件"></a>修改<code>/etc/fstab</code>文件</h3><p><code>[root@localhost ~]# vim /etc/fstab</code></p><pre><code>//192.168.4.55/share    /mnt/smb                cifs    multiuser,credentials=/etc/samba/userpasswd     0 0//192.168.4.55/share    /mnt/smb                cifs    credentials=/etc/samba/userpasswd,multiuser     0 0credentials：用于指定包含挂载用户信息文件multiuser：用于指定使用多用户挂载</code></pre><p><code>[root@localhost ~]# mount -a</code>  #使挂载生效</p><h3 id="测试是否可以切换到smb1有写权限"><a href="#测试是否可以切换到smb1有写权限" class="headerlink" title="测试是否可以切换到smb1有写权限"></a>测试是否可以切换到smb1有写权限</h3><p><code>[root@localhost/mnt/smb]#su - smb1</code><br><code>[smb1@localhost~]$cifscreds add 192.168.4.55</code></p><pre><code>Password: </code></pre><p><code>[smb1@localhost~]$ls /mnt/smb/</code></p><pre><code>anaconda-ks.cfg  xx</code></pre>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Samba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat基于Redis缓存session共享</title>
      <link href="/2017/11/28/Tomcat%E5%9F%BA%E4%BA%8EMemcached%E7%BC%93%E5%AD%98session%E5%85%B1%E4%BA%AB/"/>
      <url>/2017/11/28/Tomcat%E5%9F%BA%E4%BA%8EMemcached%E7%BC%93%E5%AD%98session%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="基于Memcached缓存session共享"><a href="#基于Memcached缓存session共享" class="headerlink" title="基于Memcached缓存session共享"></a>基于Memcached缓存session共享</h2><p>使用memcached服务存取session信息，应用服务器接受心情求将session信息保存于memcached中。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>Memcached支持的数据结构比较单一</li><li>Memcached内存必须足够大，否则会出现session从Cache中清除</li><li>需要定期刷新缓存</li><li>如果服务器发生故障时，存储于内存的数据消失</li></ul><h2 id="基于Redis缓存session共享"><a href="#基于Redis缓存session共享" class="headerlink" title="基于Redis缓存session共享"></a>基于Redis缓存session共享</h2><p>基于Redis缓存session共享不会重启后数据消失。</p><h2 id="实验架构图"><a href="#实验架构图" class="headerlink" title="实验架构图"></a>实验架构图</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-26_210049.jpg" alt=""></p><h2 id="实验前提"><a href="#实验前提" class="headerlink" title="实验前提"></a>实验前提</h2><h3 id="每天服务器同步时间"><a href="#每天服务器同步时间" class="headerlink" title="每天服务器同步时间"></a>每天服务器同步时间</h3><h3 id="确保firewalld和selinux关闭（如果启用，自行设置即可）"><a href="#确保firewalld和selinux关闭（如果启用，自行设置即可）" class="headerlink" title="确保firewalld和selinux关闭（如果启用，自行设置即可）"></a>确保firewalld和selinux关闭（如果启用，自行设置即可）</h3><h3 id="可以基于主机名解析"><a href="#可以基于主机名解析" class="headerlink" title="可以基于主机名解析"></a>可以基于主机名解析</h3><h3 id="基于密钥认证（非必须）"><a href="#基于密钥认证（非必须）" class="headerlink" title="基于密钥认证（非必须）"></a>基于密钥认证（非必须）</h3><h2 id="node4中tomcat设置"><a href="#node4中tomcat设置" class="headerlink" title="node4中tomcat设置"></a>node4中tomcat设置</h2><p><code>[root@node4~]#yum install -y java-1.8.0-openjdk</code></p><p><code>[root@node4~]#yum install -y tomcat-admin-webapps tomcat-webapps tomcat</code></p><p><code>[root@node4/var/lib/tomcat/webapps]#mkdir test/{WEB-INF,lib,classes} -pv</code></p><p><code>[root@node4/var/lib/tomcat/webapps/test]#vi index.jsp</code></p><pre><code>&lt;%@ page language=&quot;java&quot; %&gt;&lt;html&gt;        &lt;head&gt;&lt;title&gt;TomcatA&lt;/title&gt;&lt;/head&gt;        &lt;body&gt;                &lt;h1&gt;&lt;font color=&quot;red&quot;&gt;TomcatA.magedu.com&lt;/font&gt;&lt;/h1&gt;                &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt;                        &lt;tr&gt;                                &lt;td&gt;Session ID&lt;/td&gt;                        &lt;% session.setAttribute(&quot;magedu.com&quot;,&quot;magedu.com&quot;); %&gt;                                &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                                &lt;td&gt;Created on&lt;/td&gt;                                &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt;                        &lt;/tr&gt;                &lt;/table&gt;        &lt;/body&gt;&lt;/html&gt; </code></pre><p><code>[root@node4/etc/tomcat]#vim server.xml</code>    #在host内填入如下一行</p><pre><code>&lt;Context path=&quot;&quot; docBase=&quot;test&quot; reloadable=&quot;&quot; /&gt;</code></pre><p><code>[root@node4/etc/tomcat]#systemctl start tomcat.service</code></p><h3 id="node5中tomcat配置"><a href="#node5中tomcat配置" class="headerlink" title="node5中tomcat配置"></a>node5中tomcat配置</h3><p><code>[root@node5/var/lib/tomcat/webapps]#mkdir test/{WEB-INF,lib,classes} -pv</code><br><code>[root@node5/var/lib/tomcat/webapps/test]#vi index.jsp</code></p><pre><code>&lt;%@ page language=&quot;java&quot; %&gt;&lt;html&gt;        &lt;head&gt;&lt;title&gt;TomcatB&lt;/title&gt;&lt;/head&gt;                &lt;body&gt;                &lt;h1&gt;&lt;font color=&quot;blue&quot;&gt;TomcatB.magedu.com&lt;/font&gt;&lt;/h1&gt;                &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt;                        &lt;tr&gt;                                &lt;td&gt;Session ID&lt;/td&gt;                        &lt;% session.setAttribute(&quot;magedu.com&quot;,&quot;magedu.com&quot;); %&gt;                                &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                                &lt;td&gt;Created on&lt;/td&gt;                                &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt;                        &lt;/tr&gt;                &lt;/table&gt;                &lt;/body&gt;&lt;/html&gt;</code></pre><p><code>[root@node5/etc/tomcat]#vim server.xml</code></p><pre><code>&lt;Context path=&quot;&quot; docBase=&quot;test&quot; reloadable=&quot;&quot; /&gt;</code></pre><p><code>[root@node5/etc/tomcat]#systemctl start tomcat.service</code></p><h2 id="node4和node5安装redis"><a href="#node4和node5安装redis" class="headerlink" title="node4和node5安装redis"></a>node4和node5安装redis</h2><p><code>[root@node4~]#yum install -y redis</code></p><p><code>[root@node4~]#vim /etc/redis.conf</code></p><pre><code>bind 192.168.4.64requirepass centos</code></pre><p><code>[root@node5~]#vim /etc/redis.conf</code></p><pre><code>bind 192.168.4.65requirepass centos</code></pre><p><code>[root@node5~]#systemctl start redis.service</code></p><h2 id="node4和node5上传所需要的jar文件"><a href="#node4和node5上传所需要的jar文件" class="headerlink" title="node4和node5上传所需要的jar文件"></a>node4和node5上传所需要的jar文件</h2><p>tomcat-redis-session-manager-VERSION.jar</p><p>下载地址：<a href="https://github.com/jcoleman/tomcat-redis-session-manager" target="_blank" rel="noopener">https://github.com/jcoleman/tomcat-redis-session-manager</a></p><p>jedis-VERSION.jar</p><p>下载地址：<a href="https://github.com/xetorthio/jedis/releases" target="_blank" rel="noopener">https://github.com/xetorthio/jedis/releases</a></p><p>commons-poolVERSION.jar</p><p>下载地址：<a href="http://commons.apache.org/proper/commons-pool/download_pool.cgi" target="_blank" rel="noopener">http://commons.apache.org/proper/commons-pool/download_pool.cgi</a></p><p><code>[root@node4~]#ls *.jar</code><br>commons-pool2-2.2.jar  jedis-2.5.2.jar  tomcat-redis-session-manager-1.2-tomcat-7.jar</p><p><code>[root@node4~]#cp *.jar /usr/share/tomcat/lib/</code></p><p><strong>注意：可能有强依赖的版本。</strong></p><h2 id="node4和node5修改配置"><a href="#node4和node5修改配置" class="headerlink" title="node4和node5修改配置"></a>node4和node5修改配置</h2><p><code>[root@node4/etc/tomcat]#vim context.xml</code>  #在配置文件中填入以下几行</p><pre><code> 37 &lt;Valve className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot; /&gt; 38 &lt;Manager className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot; 39          host=&quot;192.168.4.65&quot; 主机IP，默认为localhost 40          port=&quot;6379&quot;  端口               password=&quot;&quot;  如果redis设置密码需要设置，否则连不上 41          database=&quot;0&quot; 数据库 42          maxInactiveInterval=&quot;60&quot; 最大非活动间隔 /&gt;</code></pre><p><code>[root@node5/etc/tomcat]#vim context.xml</code></p><pre><code> 36 &lt;Valve className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot; /&gt; 37 &lt;Manager className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot; 38          host=&quot;192.168.4.65  39          port=&quot;6379&quot;  40          database=&quot;0&quot;  41          maxInactiveInterval=&quot;60&quot; /&gt; 42 &lt;Context/&gt;</code></pre><h3 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h3><p><code>[root@node4~]#systemctl start tomcat.service</code></p><h2 id="Apache服务器配置"><a href="#Apache服务器配置" class="headerlink" title="Apache服务器配置"></a>Apache服务器配置</h2><p><code>[root@node3/etc/httpd/conf.d]#vim tomcat-http.conf</code></p><pre><code>  1 &lt;proxy balancer://tcsrvs&gt;  #相当于定义一组后端服务器  2         BalancerMember ajp://192.168.4.62:8009  loadfactor=1  3         BalancerMember ajp://192.168.4.63:8009  loadfactor=2  4         ProxySet lbmethod=byrequests  5 &lt;/Proxy&gt;  6   7 &lt;VirtualHost *:80&gt;  8         ServerName www.test.com  9         ProxyVia on 10         ProxyRequests off 11         ProxyPreserveHost on 12         &lt;Proxy *&gt;   13                 Require all granted 14         &lt;/Proxy&gt; 15         ProxyPass / balancer://tcsrvs/ 16         ProxyPassReverse / balancer://tcsrvs/ 17         &lt;Location /&gt; 18                 Require all granted 19         &lt;/Location&gt; 20 &lt;/VirtualHost&gt; 21  22 &lt;Location /bm&gt;  #定义管理主机 23         SetHandler balancer-manager 24         ProxyPass ! 25         Require all granted #建议这里使用本机主机访问 26 &lt;/Location&gt; 27 &lt;Location /status&gt;  #定义状态页 28         ProxyPass ! 29         SetHandler server-status 30         Require all granted 31 &lt;/Location&gt;</code></pre><h3 id="查看redis服务器"><a href="#查看redis服务器" class="headerlink" title="查看redis服务器"></a>查看redis服务器</h3><p><code>[root@node5~]#redis-cli -p 6379 -h 192.168.4.65</code></p><pre><code>redis 192.168.4.65:6379&gt; keys *1) &quot;AAB3EB7FC0F829F0DEB07BFADC1B21A2&quot;</code></pre><p><strong>注意这里默认存储在0数据库中，这时我们在context.xml文件database中设置的。</strong></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="http://owatlfstl.bkt.clouddn.com/tomcat-redis.gif" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>1、在构建过程中，jar文件包耽搁了很长时间，由于版本的依赖性较强。如果可以修改jar包最好修改下，即可。</strong></p><p><strong>2、在构建过程中需要验证每一步都是正确再进行如下步骤。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat会话保持</title>
      <link href="/2017/11/28/Tomcat%E4%BC%9A%E8%AF%9D%E4%BF%9D%E6%8C%81/"/>
      <url>/2017/11/28/Tomcat%E4%BC%9A%E8%AF%9D%E4%BF%9D%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h1 id="会话保持"><a href="#会话保持" class="headerlink" title="会话保持"></a>会话保持</h1><p>保证同一个用户相关的访问请求被分配到同一台服务器上。</p><h3 id="1、会话保持的类型"><a href="#1、会话保持的类型" class="headerlink" title="1、会话保持的类型"></a>1、会话保持的类型</h3><p>（1）session sticky</p><p>与调度器有关</p><h4 id="不同调度器实现方式"><a href="#不同调度器实现方式" class="headerlink" title="不同调度器实现方式"></a>不同调度器实现方式</h4><pre><code>nginx：ip_hashhaproxy：sourcelvs：sh</code></pre><p>（2）session cluster：delta session manager</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-06_221632.jpg" alt=""></p><p>如上图所示，就是session cluster工作原理：基于IP组播来完成session复制</p><h5 id="Tomcat会话复制分类："><a href="#Tomcat会话复制分类：" class="headerlink" title="Tomcat会话复制分类："></a>Tomcat会话复制分类：</h5><pre><code>全局会话复制：利用Delta Manager复制会话中的变更信息到集群中的所有其他节点非全局复制：使用backup Manager进行复制，它会把session复制给一个指定的备份节点</code></pre><p><strong>此中session保持一般不超过6个节点，如果小型可以使用。</strong></p><p>（3）session server：redis（store），memcached（cache）</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-06_222444.jpg" alt=""></p><p>如图所示为此中会话保持的工作原理，基于共享会话实现</p><p>上述两种与server端有关</p><h3 id="2、Tomcat-Cluster（Session）"><a href="#2、Tomcat-Cluster（Session）" class="headerlink" title="2、Tomcat Cluster（Session）"></a>2、Tomcat Cluster（Session）</h3><h4 id="（1）httpd-tomcat-cluster"><a href="#（1）httpd-tomcat-cluster" class="headerlink" title="（1）httpd+tomcat cluster"></a>（1）httpd+tomcat cluster</h4><p><em>前提：</em></p><p>httpd：mod_proxy,mod_proxy_http,mod_proxy_balancer</p><p>tomcat cluster :http connector</p><h5 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h5><blockquote><p>同步时间</p></blockquote><p><code>[root@tomcatA~]#ntpdate 172.18.0.1</code></p><p><code>[root@tomcatA~]#vim /etc/chrony.conf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-07_070410.jpg" alt=""></p><blockquote><p>修改hosts文件</p></blockquote><p><code>[root@tomcatA~]#vim /etc/hosts</code></p><pre><code>  3 192.168.4.62 tomcatA  4 192.168.4.63 tomcatB</code></pre><blockquote><p>基于密钥连接</p></blockquote><p><code>[root@tomcatA~]#ssh-keygen</code></p><pre><code>Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:z+CBC0/eQP/sW9O+TqUXn6DCxR1j6Wt/XAyvuHMMW9E root@tomcatAThe key&#39;s randomart image is:+---[RSA 2048]----+|                 ||              .  ||      .      = . ||     . o  . + = E||    . + S  o + *.||     = =.B. o.+oB||      + oo=.oO+++||         ...=+=.o||          o..=+o.|+----[SHA256]-----+</code></pre><p><code>[root@tomcatA~]#ssh-copy-id -i /root/.ssh/id_rsa.pub tomcatB</code></p><p>tomcatB：</p><p><code>[root@tomcatB~]#ssh-keygen</code></p><p><code>[root@tomcatB~]#ssh-copy-id -i /root/.ssh/id_rsa.pub tomcatA</code></p><p>tomcatB中的其他配置都和tomcatA配置相同这里就不累述</p><blockquote><p>安装jdk环境</p></blockquote><p><code>[root@tomcatB~]#yum install -y java-1.8.0-openjdk</code></p><blockquote><p>tomcat安装及配置</p></blockquote><p><code>[root@tomcatA~]#yum install -y tomcat-docs-webapp tomcat-lib tomcat-webapps tomcat</code></p><p><code>[root@tomcatA~]#systemctl enable tomcat</code></p><p><code>[root@tomcatA~]#systemctl start tomcat</code></p><p>配置一个示例程序</p><p><code>[root@tomcatA/usr/share/tomcat/webapps]#mkdir test/{WEB-INF,classes,lib} -pv</code></p><p><code>[root@tomcatA/usr/share/tomcat/webapps/test]#vi index.jsp</code></p><pre><code>&lt;%@ page language=&quot;java&quot; %&gt;&lt;html&gt;        &lt;head&gt;&lt;title&gt;TomcatA&lt;/title&gt;&lt;/head&gt;             &lt;body&gt;                &lt;h1&gt;&lt;font color=&quot;red&quot;&gt;TomcatA.magedu.com&lt;/font&gt;&lt;/h1&gt;                &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt;                               &lt;tr&gt;                                &lt;td&gt;Session ID&lt;/td&gt;                                             &lt;% session.setAttribute(&quot;magedu.com&quot;,&quot;magedu.com&quot;); %&gt;                                &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt;                                 &lt;/tr&gt;                        &lt;tr&gt;                                &lt;td&gt;Created on&lt;/td&gt;                                                     &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt;                        &lt;/tr&gt;                &lt;/table&gt;        &lt;/body&gt;&lt;/html&gt; </code></pre><p><code>[root@tomcatB/usr/share/tomcat/webapps]#mkdir test/{WEB-INF,classes,lib} -pv</code></p><p><code>[root@tomcatB/usr/share/tomcat/webapps/test]#vi index.jsp</code></p><pre><code>&lt;%@ page language=&quot;java&quot; %&gt;&lt;html&gt;        &lt;head&gt;&lt;title&gt;TomcatB&lt;/title&gt;&lt;/head&gt;                     &lt;body&gt;                &lt;h1&gt;&lt;font color=&quot;blue&quot;&gt;TomcatB.magedu.com&lt;/font&gt;&lt;/h1&gt;                &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt;                               &lt;tr&gt;                                &lt;td&gt;Session ID&lt;/td&gt;                                             &lt;% session.setAttribute(&quot;magedu.com&quot;,&quot;magedu.com&quot;); %&gt;                                &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt;                                 &lt;/tr&gt;                        &lt;tr&gt;                                &lt;td&gt;Created on&lt;/td&gt;                                                     &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt;                        &lt;/tr&gt;                &lt;/table&gt;                &lt;/body&gt;&lt;/html&gt; </code></pre><p><code>[root@tomcatA/usr/share/tomcat/webapps]#vim /etc/tomcat/server.xml</code>   #在host中添加如下内容  </p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-07_073155.jpg" alt=""></p><p><code>[root@tomcatA/usr/share/tomcat/webapps]#systemctl restart tomcat.service</code>  #重启测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-07_073454.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-07_073439.jpg" alt=""></p><p>至此tomcatA和tomcatB配置完成 </p><blockquote><p>http安装及配置</p></blockquote><p>查看是否已经加载所需要的模块</p><p><code>[root@httpd/etc/httpd/conf.d]#httpd -M |grep proxy</code></p><p>安装及配置成开启启动并启动服务</p><p><code>[root@httpd~]#yum install -y httpd</code></p><p><code>[root@httpd~]#systemctl enable httpd.service</code></p><p><code>[root@httpd~]#systemctl start httpd.service</code></p><p>修改配置文件并实现http调度功能</p><p><code>[root@httpd/etc/httpd/conf]#vim httpd.conf</code></p><p>   354 Include conf.d/tomcat-host.conf</p><p><code>[root@httpd/etc/httpd/conf.d]#vim tomcat-host.conf</code></p><pre><code>&lt;proxy balancer://tcsrvs&gt;BalancerMember http://192.168.4.62:8080BalancerMember http://192.168.4.63:8080ProxySet lbmethod=byrequests&lt;/Proxy&gt;&lt;VirtualHost *:80&gt;    ServerName www.test.com    ProxyVia on    ProxyRequests off    ProxyPreserveHost on    &lt;Proxy *&gt;        Require all granted    &lt;/Proxy&gt;    ProxyPass / balancer://tcsrvs/    ProxyPassReverse / balancer://tcsrvs/    &lt;Location /&gt;        Require all granted    &lt;/Location&gt;&lt;/VirtualHost&gt;</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-07_083456.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-07_083511.jpg" alt=""></p><p><strong>选项说明：</strong></p><pre><code>ProxyPreserveHost {on|off}：如果启用此功能，代理会将用户请求报文中的Host行发送给后端服务器，而不再使用PorxyPress指定的服务器地址。如果在反向代理中支持虚拟主机，则需开启此项。ProxyVia：{on|off|full|block}：用于控制在http首部是否使用Via，主要用于在多级代理中控制代理请求的流向。    off：不开启此功能    on：表示每个请求和响应报文均添加Via    full：表示每个Via都会添加当前apache服务器的版本信息    block：表示每个代理请求报文中的Via都会被移除ProxyRequests {on|off}：是否开启apache正向代理的功能；启用此项时为了代理http协议需启用mod_proxy_http模块ProxyPass [path] !|URL [key=value ...]：将后端服务器某URL与当前服务器的某虚拟路径关联起来作为提供服务的路径。    path：当前服务器上的某虚拟路径    URL：后端服务器上某URL路径注意：如果path以“/”结尾，则对应的URL也必须&quot;/&quot;结尾。    key类型        min：连接池的最小容量        max：连接池最大容量        loadfactor：用于负载均衡集群配置中，定义对应后端服务器的权重        retry：当apache将请求发送至后端服务器得到错误响应时等待多长时间以后重试**lbmethod类型**    byrequests：基于权重将统计请求个数进行调度    bytraffic：基于权重的流量计数调度    bybusyness：通过考量每个后端服务器的当前负载进行调度maxattempts：放弃请求之前实现故障转义的次数，默认为1，其最大值不应该大于总的节点数nofailover {on|off}    on：表示后端服务器故障时，用户的session将损坏stickysession：调度器的stickyProxyPassReverse：用于让apache调整HTTP重定向响应报文中的Location、Content-Location及URI标签所对应的URL，在反向代理环境中必须使用此指令避免重定向报文绕过proxy服务器。BalancerMember [balancerurl] url [key=value [key=value...]]    status:        D:设置不可用disabled        S：设置为stopped        I：忽略错误，请求还会往此主机上调        H：如果别的主机不可用时启用相当于backup        E：设置为error状态        N：仅仅接受seesion sticky请求</code></pre><p>实现会话粘性</p><p><code>[root@httpd/etc/httpd/conf.d]#vim tomcat-host.conf</code></p><pre><code>  1 Header add Set-Cookie &quot;ROUTEID=.%{BALANCER_WORKER_ROUTE}e;path=/&quot; env=BALANCER_ROUTE_CHANGED  2 &lt;proxy balancer://tcsrvs&gt;  3         BalancerMember http://192.168.4.62:8080 route=tomcatA loadfactor=1  4         BalancerMember http://192.168.4.63:8080 route=tomcatB loadfactor=2  5         ProxySet lbmethod=byrequests  6         ProxySet stickysession=ROUTEID  7 &lt;/Proxy&gt;  8   9 &lt;VirtualHost *:80&gt; 10         ServerName www.test.com 11         ProxyVia on 12         ProxyRequests off 13         ProxyPreserveHost on 14         &lt;Proxy *&gt; 15                 Require all granted 16         &lt;/Proxy&gt; 17         ProxyPass / balancer://tcsrvs/ 18         ProxyPassReverse / balancer://tcsrvs/ 19         &lt;Location /&gt; 20                 Require all granted 21         &lt;/Location&gt; 22 &lt;/VirtualHost&gt;</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-07_091219.jpg" alt=""></p><p>至此我们就实现的session sticky</p><p><strong>实现管理功能</strong></p><p> 24 <location balancer-manager=""><br> 25         SetHandler balancer-manager<br> 26         ProxyPass !<br> 27         Require all granted<br> 28 </location></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-07_091721.jpg" alt=""></p><p>这里为了测试方便我们设置成了所有用户都可以访问，在实际生产中需要指定特定IP访问。</p><p><strong>显示状态信息</strong></p><p><code>[root@httpd/etc/httpd/conf.d]#vim tomcat-host.conf</code></p><pre><code> 29 &lt;Location /status&gt; 30         ProxyPass ! 31         SetHandler server-status 32         Require all granted 33 &lt;/Location&gt;</code></pre><p>重启服务器测试</p><h4 id="（2）httpd-tomcat-cluster"><a href="#（2）httpd-tomcat-cluster" class="headerlink" title="（2）httpd+tomcat cluster"></a>（2）httpd+tomcat cluster</h4><p><em>前提：</em></p><p>httpd:mod_proxy,mod_proxy_ajp,mod_proxy_balancer</p><p>tomcat cluster:ajp connecotr</p><h5 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h5><blockquote><p>前面的步骤都和上述配置相同</p><p>编辑tomcat-host.conf配置文件</p></blockquote><p><code>[root@httpd/etc/httpd/conf.d]#vim tomcat-host.conf</code></p><pre><code>  1 Header add Set-Cookie &quot;ROUTEID=.%{BALANCER_WORKER_ROUTE}e;path=/&quot; env=BALANCER_ROUTE_CHANGED  2 &lt;proxy balancer://tcsrvs&gt;  3         BalancerMember ajp://192.168.4.62:8009 route=tomcatA loadfactor=1  4         BalancerMember ajp://192.168.4.63:8009 route=tomcatB loadfactor=2  5         ProxySet lbmethod=byrequests  6         ProxySet stickysession=ROUTEID  7 &lt;/Proxy&gt;  8   9 &lt;VirtualHost *:80&gt; 10         ServerName www.test.com 11         ProxyVia on 12         ProxyRequests off 13         ProxyPreserveHost on 14         &lt;Proxy *&gt; 15                 Require all granted 16         &lt;/Proxy&gt; 17         ProxyPass / balancer://tcsrvs/ 18         ProxyPassReverse / balancer://tcsrvs/ 19         &lt;Location /&gt; 20                 Require all granted 21         &lt;/Location&gt; 22 &lt;/VirtualHost&gt; 23  24 &lt;Location /bm&gt; 25         SetHandler balancer-manager 26         ProxyPass ! 27         Require all granted 28 &lt;/Location&gt; 29 &lt;Location /status&gt; 30         ProxyPass ! 31         SetHandler server-status 32         Require all granted 33 &lt;/Location&gt;</code></pre><h4 id="（3）httpd-tomcat-cluster"><a href="#（3）httpd-tomcat-cluster" class="headerlink" title="（3）httpd+tomcat cluster"></a>（3）httpd+tomcat cluster</h4><p><em>前提：</em></p><p>httpd:mod_jk</p><p>tomcat cluster:ajp connector</p><p>此种方法现在不常用就不介绍了… </p><h4 id="（-4）nginx-tomcat-cluster"><a href="#（-4）nginx-tomcat-cluster" class="headerlink" title="（ 4）nginx+tomcat cluster"></a>（ 4）nginx+tomcat cluster</h4><h5 id="实战-2"><a href="#实战-2" class="headerlink" title="实战"></a>实战</h5><blockquote><p>nginx安装并设置为开机启动</p></blockquote><p><code>[root@httpd~]#yum install -y nginx</code></p><p><code>[root@httpd~]#systemctl enable nginx</code></p><p><code>[root@httpd~]#systemctl start nginx</code></p><blockquote><p>修改配置文件实现调度功能</p></blockquote><p><code>[root@httpd/etc/nginx/conf.d]#vim tomcat-nginx.conf</code></p><pre><code>  1 upstream tomsrvs {  2         server 192.168.4.62:8080 ;  3         server 192.168.4.63:8080 ;  4 }  5   6 server {  7         listen 80;  8         server_name www.test.com;  9         location /{ 10                 proxy_pass http://tomsrvs; 11         } 12 }</code></pre><p>基于ip_hash实现会话粘性</p><p><code>[root@httpd/etc/nginx/conf.d]#vim tomcat-nginx.conf</code></p><pre><code>  1 upstream tomsrvs {  2         server 192.168.4.62:8080 ;  3         server 192.168.4.63:8080 ;  4         ip_hash;  5 }  6   7 server {  8         listen 80;  9         server_name www.test.com; 10         location /{ 11                 proxy_pass http://tomsrvs; 12         } 13 }</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-07_110756.jpg" alt=""></p><p>基于hash key 实现</p><p>基于指定的key的hash表来实现对请求的调度</p><pre><code>  1 upstream tomsrvs {  2         server 192.168.4.62:8080 ;  3         server 192.168.4.63:8080 ;  4         hash $remote_addr consistent;  5 }  6   7   8   9 server { 10         listen 80; 11         server_name www.test.com cookie; 12         location /{ 13                 proxy_pass http://tomsrvs; 14         } 15 }</code></pre><h3 id="3、tomcat-session-replication-cluster"><a href="#3、tomcat-session-replication-cluster" class="headerlink" title="3、tomcat session replication cluster"></a>3、tomcat session replication cluster</h3><blockquote><p>在tomcat服务器上进行配置</p></blockquote><p><code>[root@tomcatB/etc/tomcat]#vi server.xml</code></p><pre><code>&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;tomcatA&quot;&gt;     #添加jvmRoute</code></pre><p><strong>下面的配置可以放在Host、Engine、Context中其作用效果不同</strong></p><pre><code>    &lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot;             channelSendOptions=&quot;8&quot;&gt;      &lt;Manager className=&quot;org.apache.catalina.ha.session.DeltaManager&quot;               expireSessionsOnShutdown=&quot;false&quot;               notifyListenersOnReplication=&quot;true&quot;/&gt;      &lt;Channel className=&quot;org.apache.catalina.tribes.group.GroupChannel&quot;&gt;        &lt;Membership className=&quot;org.apache.catalina.tribes.membership.McastService&quot;                    address=&quot;228.100.100.4&quot;                    port=&quot;45564&quot;                    frequency=&quot;500&quot;                    dropTime=&quot;3000&quot;/&gt;        &lt;Receiver className=&quot;org.apache.catalina.tribes.transport.nio.NioReceiver&quot;                  address=&quot;auto&quot;    #这里设定为tomcat真实IP                  port=&quot;4000&quot;                  autoBind=&quot;100&quot;                  selectorTimeout=&quot;5000&quot;                  maxThreads=&quot;6&quot;/&gt;        &lt;Sender className=&quot;org.apache.catalina.tribes.transport.ReplicationTransmitter&quot;&gt;          &lt;Transport className=&quot;org.apache.catalina.tribes.transport.nio.PooledParallelSender&quot;/&gt;        &lt;/Sender&gt;        &lt;Interceptor className=&quot;org.apache.catalina.tribes.group.interceptors.TcpFailureDetector&quot;/&gt;        &lt;Interceptor className=&quot;org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor&quot;/&gt;      &lt;/Channel&gt;      &lt;Valve className=&quot;org.apache.catalina.ha.tcp.ReplicationValve&quot;             filter=&quot;&quot;/&gt;      &lt;Valve className=&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot;/&gt;      &lt;Deployer className=&quot;org.apache.catalina.ha.deploy.FarmWarDeployer&quot;                tempDir=&quot;/tmp/war-temp/&quot;                deployDir=&quot;/tmp/war-deploy/&quot;                watchDir=&quot;/tmp/war-listen/&quot;                watchEnabled=&quot;false&quot;/&gt;      &lt;ClusterListener className=&quot;org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener&quot;&gt;      &lt;ClusterListener className=&quot;org.apache.catalina.ha.session.ClusterSessionListener&quot;&gt;    &lt;/Cluster&gt;</code></pre><p><code>[root@tomcatA/etc/tomcat]#cp /etc/tomcat/web.xml /usr/share/tomcat/webapps/test/WEB-INF/</code></p><p><code>[root@tomcatA/etc/tomcat]#vim /usr/share/tomcat/webapps/test/WEB-INF/web.xml</code></p><pre><code>  23   &lt;distributable/&gt; #添加此内容</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-07_142906.jpg" alt=""></p><p>重启服务测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/tomcatcab.gif" alt=""></p><p>tomcatA和tomcatB的配置相似就不累述。</p><p><strong>如果修改/etc/tomcat/web.xml文件时全局配置。</strong></p><h1 id="注意的问题："><a href="#注意的问题：" class="headerlink" title="注意的问题："></a>注意的问题：</h1><p>（1）官方文档上面的配置文件中：</p><pre><code>&lt;ClusterListener className=&quot;org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener&quot;/&gt;&lt;ClusterListener className=&quot;org.apache.catalina.ha.session.ClusterSessionListener&quot;/&gt;</code></pre><p>上述少了“/”结尾，记得加上</p><p>（2）绑定地址为auto时，会自动解析本地主机名，并解析得出的IP地址作为使用的地址；建议指定IP地址。</p><h3 id="4、session-server"><a href="#4、session-server" class="headerlink" title="4、session server"></a>4、session server</h3><p>tomcatA和tomcatB配置相似，这里以tomcatA为例</p><p>（1）安装tomcat和memcache并进行配置</p><p><code>[root@tomcatA/etc/tomcat]#yum install -y memcached</code></p><p><code>[root@tomcatA/etc/tomcat]#systemctl enable memcached</code></p><p><code>[root@tomcatA/etc/tomcat]#systemctl start memcached</code></p><p>（2）配置tomcat</p><p>下载所需要的jar文件</p><p><a href="https://github.com/magro/memcached-session-manager/wiki/SetupAndConfiguration" target="_blank" rel="noopener">https://github.com/magro/memcached-session-manager/wiki/SetupAndConfiguration</a></p><p><a href="http://owatlfstl.bkt.clouddn.com/2017-11-07_171315.jpg" target="_blank" rel="noopener">http://owatlfstl.bkt.clouddn.com/2017-11-07_171315.jpg</a></p><p><code>[root@tomcatA~]#cp *.jar /usr/share/tomcat/lib/</code></p><p><code>[root@tomcatA/etc/tomcat]#vim server.xml</code> #编辑配置文件</p><pre><code>131 &lt;Context&gt;132   &lt;Manager className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot;133     memcachedNodes=&quot;n1:192.168.4.62:11211,n2:192.168.4.63:11211&quot;134     failoverNodes=&quot;n1&quot;135     requestUriIgnorePattern=&quot;.*\.(ico|png|gif|jpg|css|js)$&quot;136     transcoderFactoryClass=&quot;de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory&quot;137     /&gt;138 &lt;/Context&gt;</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-07_171710.jpg" alt=""></p><p><code>[root@tomcatA/etc/tomcat]#scp server.xml tomcatB:/etc/tomcat/server.xml</code></p><p><code>[root@tomcatB/usr/share/tomcat/webapps/test]#vim index.jsp</code>    编辑index.jsp文件</p><pre><code>  1 &lt;%@ page language=&quot;java&quot; %&gt;  2 &lt;html&gt;  3         &lt;head&gt;&lt;title&gt;TomcatB&lt;/title&gt;&lt;/head&gt;  4                 &lt;body&gt;  5                 &lt;h1&gt;&lt;font color=&quot;blue&quot;&gt;TomcatB.magedu.com&lt;/font&gt;&lt;/h1&gt;  6                 &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt;  7                         &lt;tr&gt;  8                                 &lt;td&gt;Session ID&lt;/td&gt;  9                         &lt;% session.setAttribute(&quot;magedu.com&quot;,&quot;magedu.com&quot;); %&gt; 10                                 &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt; 11                         &lt;/tr&gt; 12                         &lt;tr&gt; 13                                 &lt;td&gt;Created on&lt;/td&gt; 14                                 &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt; 15                         &lt;/tr&gt; 16                 &lt;/table&gt; 17                 &lt;/body&gt; 18 &lt;/html&gt;</code></pre><p>tomcatB同理</p><p><code>[root@tomcatA~]#systemctl restart tomcat</code></p><blockquote><p>配置http服务器</p></blockquote><p><code>[root@httpd/etc/httpd/conf.d]#vim tomcat-host.conf</code></p><pre><code>  1 &lt;proxy balancer://tcsrvs&gt;  2         BalancerMember ajp://192.168.4.62:8009  loadfactor=1  3         BalancerMember ajp://192.168.4.63:8009  loadfactor=2  4         ProxySet lbmethod=byrequests  5 &lt;/Proxy&gt;  6   7 &lt;VirtualHost *:80&gt;  8         ServerName www.test.com  9         ProxyVia on 10         ProxyRequests off 11         ProxyPreserveHost on 12         &lt;Proxy *&gt; 13                 Require all granted 14         &lt;/Proxy&gt; 15         ProxyPass / balancer://tcsrvs/ 16         ProxyPassReverse / balancer://tcsrvs/ 17         &lt;Location /&gt; 18                 Require all granted 19         &lt;/Location&gt; 20 &lt;/VirtualHost&gt; 21  22 &lt;Location /bm&gt; 23         SetHandler balancer-manager 24         ProxyPass ! 25         Require all granted 26 &lt;/Location&gt; 27 &lt;Location /status&gt; 28         ProxyPass ! 29         SetHandler server-status 30         Require all granted 31 &lt;/Location&gt;</code></pre><p>重启http服务</p><p><code>[root@httpd/etc/httpd/conf.d]#systemctl restart httpd</code></p><p>测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/tomcatabc.gif" alt=""></p><p>查看是否已有缓存到本地</p><p><code>[root@tomcatA~]#memcached-tool 127.0.0.1:11211 dump</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-07_183109.jpg" alt=""></p><p>接下来停止tomcatA服务测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/tomcatabcd.gif" alt=""></p><p>重启启动tomcatA 测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/tomcatabcde.gif" alt=""></p><p>至此已经实现了session server</p><p>序列化工具lavolution实现<br>-<br>memcached-session-manager-tc7-2.1.1.jar</p><p>memcached-session-manager-2.1.1.jar </p><p>spymemcached-2.12.3.jar</p><p>msm-javolution-serializer-2.1.1.jar</p><p>javolution-5.4.3.1.jar </p><p><code>[root@memcache~]#scp /etc/tomcat/server.xml tomcatB:/etc/tomcat/server.xml</code></p><p><code>[root@memcache~]#systemctl restarst tomcat</code></p><p>上述创建站点及测试也相同就不累述</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p><img src="http://owatlfstl.bkt.clouddn.com/tomcatabcded.gif" alt=""></p><p><code>[root@memcache/usr/share/tomcat/lib]#memcached-tool 127.0.0.1:11211 dump</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-07_211825.jpg" alt=""></p><p>在测试过程中，存在版本不兼容的情况，更换版本即可。</p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VRRP协议</title>
      <link href="/2017/11/28/VRRP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2017/11/28/VRRP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-29_104256.jpg" alt=""></p><h1 id="一、VRRP协议"><a href="#一、VRRP协议" class="headerlink" title="一、VRRP协议"></a>一、VRRP协议</h1><p>虚拟路由冗余协议（VRRP，Virtual Router Redundancy Protocol）通过把几台路由设备联合组成一台虚拟的路由设备，使用一定的机制保证当主机的下一跳路由机出现故障时，及时将业务切换到备份路由器，从而保持业务的持续性和可靠性。</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-29_111935.jpg" alt=""></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>虚拟路由器（Virutal Router）：又陈VRRP备份组，由一个master设备和多个backup设备组成，被当做一个共享局域网内主机的缺省网关</li><li>Master设备（Virtual Router Master）：承担转发报文任务的VRRP设备</li><li>Backup设备（Virtual Router Backup）：一组没有承担转发任务的VRRP设备，当Master设备出现故障时，他们将通过优先级成为新的Master设备</li><li>VRID：虚拟路由器的表示</li><li>虚拟IP地址（Virtual IP Address）：虚拟路由器IP地址，一个虚拟路由器可以有一个或多个IP地址</li><li>IP地址拥有者（IP Address Owner）：如果一个VRRP设备将虚拟路由器IP地址作为真实的接口地址，则该设备称为IP地址拥有者，如果IP地址拥有者是可用的，通常称为Master</li><li>虚拟MAC地址（Virtual MAC Address）：虚拟路由器根据虚拟路由器ID生成的MAC地址</li><li>主IP地址（Primary IP Address）：从接口的真实IP地址中选出来的一个主用IP地址，通常选择配置的第一个IP地址。VRRP广播报文使用主IP地址作为IP报文的源地址。</li><li>优先级（Priority）：虚拟路由器中VRRP设备的优先级。虚拟路由器根据优先级选举出Master设备和Backup设备</li><li>抢占模式：如果Backup设备的优先级比当前Master设备的优先级高，则主动将自己切换成Master</li><li>非抢占模式：只要Master设备没有出现故障，Backup设备即使随后被配置了更高的优先级也不会成为Master设备</li></ul><h2 id="VRRP工作原理"><a href="#VRRP工作原理" class="headerlink" title="VRRP工作原理"></a>VRRP工作原理</h2><p>（1）VRRP备份组中的交换机根据优先级选举出Master。Master交换机通过发送免费ARP报文，将虚拟MAC地址通知给与它连接的设备或主机，从而承担报文转发任务。</p><p>（2）Master交换机周期性向备份组内的Backup交换机发送VRRP通告报文，以公布其配置信息和工作状态。</p><p>（3）如果Master交换机出现故障，VRRP备份组中的Backup交换机将根据优先级重新选举新的Master。</p><p>（4）VRRP备份组状态切换时，Master交换机由一台设备切换为另外一台设备，新的Master交换机立即发送携带虚拟路由器的虚拟MAC地址和虚拟IP地址信息的免费ARP报文，刷新与它连接的主机或者设备中的MAC表项。</p><p>（5）如果原来的Master恢复时，若优先级高时，将直接切换为Master状态。</p><p>VRRP主备备份示例<br>-</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-30_085822.jpg" alt=""></p><h2 id="VRRP主主示例"><a href="#VRRP主主示例" class="headerlink" title="VRRP主主示例"></a>VRRP主主示例</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-30_090006.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VRRP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB工作过程</title>
      <link href="/2017/11/28/WEB%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
      <url>/2017/11/28/WEB%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Web服务请求处理过程"><a href="#Web服务请求处理过程" class="headerlink" title="Web服务请求处理过程"></a>Web服务请求处理过程</h2><p><img src="http://owatlfstl.bkt.clouddn.com/dggb.jpg" alt=""><br>    此图为经过的OSI模型</p><p><img src="http://owatlfstl.bkt.clouddn.com/dgg.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/http%E8%BF%87%E7%A8%8Bsocket.jpg" alt=""></p><p>（1）Client需要和Server通信，这时需要发出建立连接请求</p><p>（2）Client与Server进行传输数据包时，需要经应用层–&gt;传输层–&gt;网络层–&gt;链路层:层层打包然后传输至Server，Server对此包进行 链路层–&gt;网络层–&gt;传输层–&gt;应用层：层层解封装。http协议工作在应用层，TCP/IP协议工作在网络层，这时就要经过三次握手进行连接（具体想看上述过程）</p><p>（3）Server接受Client发过的请求</p><p>（4）Server接受请求之后需要对处理请求，对请求报文进行解析，获取Client请求的资源及请求资源使用的方法等相关信息；Server根据解析到的结果进行处理</p><p>（5）Server这时获取报文中需要请求的资源Web服务器，即存放了Web资源的服务器，此服务器存Client请求的静态文静或运行后生成的资源<br>（6）存放Web资源的服务器识别了请求的资源，执行Client要求的动作并将返回响应报文。响应报文中包括：响应状态码、响应头部、如果生成了响应主体并返回响应主体。</p><p>（7）构建完报文之后需要就此报文发送给Client，但是这时Server需要面对一个严重的问题：Server到Client有很多连接，有些是空闲的，有些是正向Server发送数据，还有一些在向客户端回送响应数据。在连接中存在非长连接（服务器应该在发送了整条报文之后关闭自己这条连接）和长连接（在传输完成之后可能还扔保持打开状态）。这时Server就需要精确计算除Content-Length首部，目的是为了知道传送什么时候才能结束。<br>（8）当传输完成之后，理应是把这个通道关闭，这时就要出发TCP四次挥手过程（详细过程请查看上述过程），这种情况是对非长连接说的。如果是长连接，此通道会保持此状态。直到<code>KeepAliveTimeout</code>时间到之后触发TCP四次挥手，结束连接。</p><p>（9）如果你有一个好习惯的话，做完一件事情之后要对这件事请求有一个总结，不能做完之后什么都得不到把。Server跟这个性质一样。当完成传输之后在日志文件中记录这条信息。方便以后出现什么情况好解决。</p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Apache，HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP_wrappers</title>
      <link href="/2017/11/28/TCP_wrappers/"/>
      <url>/2017/11/28/TCP_wrappers/</url>
      
        <content type="html"><![CDATA[<h2 id="tcp-wrappers"><a href="#tcp-wrappers" class="headerlink" title="tcp_wrappers"></a>tcp_wrappers</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>Transmission Control Protocol (TCP) Wrappers 为由 inetd 生成的服务提供了增强的安全性。TCP Wrappers 是一种对使用 /etc/inetd.sec 的替换方法。TCP Wrappers 提供防止主机名和主机地址欺骗的保护。欺骗是一种伪装成有效用户或主机以获得对系统进行未经授权的访问的方法。</p><h3 id="2、工作机制"><a href="#2、工作机制" class="headerlink" title="2、工作机制"></a>2、工作机制</h3><p>（1）工作在第四层的TCP协议<br>（2）对有状态的特定服务进行安全检测并实现访问控制<br>（3）以库文件形式实现<br>（4）其进程是否接受libwrap的控制取决于发起此进程的程序在编译时是否针对libwrap进行编译的。</p><h3 id="3、如何查看服务程序是否支持libwrap访问控制"><a href="#3、如何查看服务程序是否支持libwrap访问控制" class="headerlink" title="3、如何查看服务程序是否支持libwrap访问控制"></a>3、如何查看服务程序是否支持libwrap访问控制</h3><p>（1）先使用命令查看执行程序文件是哪个</p><p><code>which COMMAND</code></p><p>（2）使用命令ldd 对上述文件查找</p><p><code>ldd</code>which COMMAND<code>|grep libwrap</code></p><h3 id="4、配置文件"><a href="#4、配置文件" class="headerlink" title="4、配置文件"></a>4、配置文件</h3><p>1、配置文件</p><p><code>/etc/hosts.allow</code>和<code>/etc/hosts.deny</code></p><p>2、检查顺序</p><blockquote><p>在tcp_wrappers中检查顺序并不像前面的服务一样，前面的成功后面的就不再执行。而tcp_wrappers的检查顺序为<code>/etc/hosts.allow</code>–&gt;<code>/etc/hosts.deny</code> 前面的规则一旦匹配成功，直接生效，将不再继续后面的执行；如果前面的没有成功，则继续向后执行。</p></blockquote><p>3、基本语法<br>damon_list@host：client_list [:option:option…]</p><p>damon_list格式：</p><pre><code>（1）单个应用程序的二进制文件名，而非服务名（2）以逗号或空格分隔的应用程序文件名列表（3）ALL 表示所有接受tcp_wrappers控制的服务程序（4）主机有多个IP ，可用@hostIP来实现      如：in.telnetd@192.168.159.131</code></pre><p>client_host格式：</p><pre><code>（1）以逗号或空格分隔的客户端列表（2）基于IP地址（3）基于主机名（4）基于网络/掩码  192.168.159.0/255.255.255.0（5）基于CIDR格式  192.168.159.0/24（6）基于网络组    @munetwork（7）内置ACL：ALL,LOCAL,KNOWN,UNKNOWN,PARANOID</code></pre><p>EXPECT用法</p><p>示例：</p><pre><code>sshd:192.168.159.0/24 EXPECT 192.168.159.151</code></pre><p>[:OPTIONS]选项</p><p>(1)deny 主要用在/etc/host.allow文件中，定义“拒绝”规则。<br>如：vsftpd:192.168.159.159:deny   先定义了这个IP可以访问但是又否定。</p><p>(2)allow 主要用在/etc/hosts.deny 定义“允许”规则<br>如：vsftpd:192.168.159.159:allow 先定义192.168.159.159不允许然后否定允许使用</p><p>(3)spawn 启动一个外部进程完成执行的操作<br>    选项：<br>    %c：客户端信息<br>    %s：服务器端信息<br>    %d：服务名<br>    %p：守护进程的PID<br><strong>注意：如果在配置文件中想使用“%”需要使用两个“%”；如果使用“：”则需要使用“\”进行转义。</strong></p><p>示例：<br>在CentOS6主机上编辑<code>/etc/hosts.allow</code>文件<br><code>[root@localhost~]#vim /etc/hosts.allow</code><br><code>sshd:192.168.4.135:spaw echo &quot;</code>date<code>%c to %s %d %p &quot; &gt;&gt; /var/log/sshd.log</code></p><p>在CentOS7主机上连接<br><code>[root@centos7/var/log]#ssh 192.168.4.131</code></p><p>在CentOS6上查看是否生成sshd.log文件并且有内容<br><code>[root@localhost~]#cat /var/log/sshd.log</code><br><code>Thu Sep 14 09:33:18 CST 2017 192.168.4.135 to sshd@192.168.4.131 sshd 29705</code></p><p>(4)twist 实际动作是拒绝访问，使用指定的操作替换当前服务，标准I/O和ERROR发送到客户端，默认输出至/dev/null</p><p><strong>示例：</strong><br>在CentOS6上配置<code>/etc/hosts.allow</code>文件<br><code>[root@localhost~]#vim /etc/hosts.allow</code></p><pre><code>vsftpd:192.168.4.135:twist /bin/echo &quot;Do not login&quot;</code></pre><p>在CentOS7上连接<br><code>[root@centos7~]#ftp 192.168.4.131</code></p><pre><code>Connected to 192.168.4.131 (192.168.4.131).Do not loginftp&gt; </code></pre><p>测试工具：</p><p>tcpdmatch [-d] daemon[@host] client</p><pre><code>-d 测试当前目录下的host.allow和hosts.deny文件</code></pre><p><code>[root@localhost~]#tcpdmatch -d /etc/hosts.deny 192.168.4.135</code></p><pre><code>client:   address  192.168.4.135server:   process  hosts.denyaccess:   granted</code></pre><p><code>[root@localhost~]#tcpdmatch -d /etc/hosts.allow 192.168.4.135</code></p><pre><code>client:   address  192.168.4.135server:   process  hosts.allowaccess:   granted</code></pre>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp_wrappers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xtrabackup</title>
      <link href="/2017/11/28/Xtrabackup/"/>
      <url>/2017/11/28/Xtrabackup/</url>
      
        <content type="html"><![CDATA[<h2 id="xtrabackup"><a href="#xtrabackup" class="headerlink" title="xtrabackup"></a>xtrabackup</h2><p>由percona提供、开源工具，支持对InnoDB做热备，物理备份工具。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>物理备份；速率快、可靠；</li><li>备份完成后自动校验备份结果是否可用</li><li>还原速度快</li></ul><h3 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h3><pre><code>[innobackupex [--defaults-file=#] --backup | innobackupex [--defaults-file=#] --prepare] [OPTIONS]</code></pre><p><a href="https://www.percona.com/software/mysql-database/percona-server" target="_blank" rel="noopener">https://www.percona.com/software/mysql-database/percona-server</a></p><p><strong>innobackupex命令</strong></p><p>使用innobackupex备份时，其会调用xtrabackup备份所有的InnoDB表，复制所有关于表结构定义相关文件（.frm）、以及MyISAM、MERGE、CSV和ARCHIVE表相关文件，同时还会备份触发器和数据库配置信息相关文件。这些文件会被保存至一个以时间命名的目录中。</p><blockquote><p>在备份的同时，innobackupex还会备份目录中创建如下文件：</p></blockquote><ul><li><p>xtrabackup_checkpoints</p><p>  备份类型（如完全或增量）、备份状态（如是否已经为prepared状态）和LSN（日志序列号）范围信息<br>  每个InnoDB页（通常为16k大小）都会包含一个日志序列号（LSN）。LSN是整个数据库系统的系统版本号，每个页面相关的LSN能够表明此页面时如何发生改变的。</p></li><li><p>xtrabackup_binlog_info</p><p>  mysql服务器当前正在使用的二进制日志文件及至备份这一刻为止二进制日志事件的位置</p></li><li><p>xtrabackup_binlog_pos_innodb</p><p>  二进制日志文件及用于InnoDB或XtraDB表的二进制日志文件的当前position</p></li><li><p>xtrabackup_binary</p><p>  备份中用到的xtrabackup的可执行文件</p></li><li><p>backup-my.cnf</p><p>  备份命令用到的配置选项信息</p></li></ul><p>在使用innobackupes进行备份时，还可以使用–no-timestamp选项来阻止命令自动创建一个以时间命名的目录；如此一来，innobackupex命令将会创建一个BCAKUP-DIR目录来存储备份数据。</p><blockquote><p>准备一个完全备份</p></blockquote><p>一般情况下，在备份完成后，数据尚且不能用于恢复操作，因为备份的数据中可能会包含尚未提交的事务或已经提交单尚未同步至数据文件中的事务。因此，此时数据文件仍处理不一致状态。“准备”的主要作用是通过回滚为提交的事务及同步已经提交的事务至数据文件也使得数据文件处于一致性状态。</p><pre><code>--apply-log选项可用于实现上述功能。</code></pre><p>使用格式：</p><pre><code>innobackupex --apply-log /PATH/TO/BACKUP-DIR</code></pre><p>在实现“准备”过程中，innobackupex通常还可以使用–use-memory选项来指定其可以使用的内存大小，默认为100M。如果有足够的内存使用，可以多划分一些内存给prepare的过程，以提高其完成速度。</p><blockquote><p>从一个完全备份中恢复数据</p></blockquote><p><strong>注意：恢复时不用启动mysql服务</strong></p><p>innobackupex命令的–copy-back选项用于执行恢复操作，其通过复制所有数据相关的文件至mysql服务器的DATADIR目录中来执行恢复过程。innobackupex通过backup-my.cnf来获取DATADIR目录的相关信息。</p><p>使用格式：</p><pre><code>innobackupex --copy-back /PATH/TO/BACKUP-DIR</code></pre><p>当数据恢复之DATADIR目录中，需要确保所有数据文件的所属主和所属组均为mysql用户。否则，在启动mysql服务器前事先修改数据文件的所有者和所属组。</p><blockquote><p>使用innobackupex进行增量备份</p></blockquote><p>每个InnoDB的页面都会包含一个LSN信息，每当相关数据发生改变，相关的页面的LSN就会自动增长。这正式InnoDB表可以进行增量备份的基础，即innobackupex通过备份上次完全备份之后发生改变的页面来实现。</p><p>使用格式：</p><pre><code>innobackupex --incremental /BACKUP --incremental-basedir=/BASEDIR</code></pre><p>其中BASEDIR指的是完全备份所在的目录，此命令执行结束后，innobackupex命令会在/BACKUP目录中创建一个新的以时间命名的目录以存放所有的增量备份的数据。另外，在执行过增量备份之后再一次进行增量备份时，其–incremental-basedir应该指向上一次的增量备份所在的目录。</p><p><strong>增量备份仅能应用于InnoDB或XtraDB表，对弈MyISAM表而言，执行增量备份时其实进行的完全备份。</strong></p><blockquote><blockquote><p>“准备“增量备份与整理备份不同：</p></blockquote></blockquote><p>（1）需要在每个备份（包括完全和增量备份）上，将已经提交的事物进行“回放”。所有的备份数据将合并到完全备份上</p><p>（2）基于所有的备份将未提交的事物进行“回滚”</p><p>操作步骤</p><pre><code>innobackupex --apply-log --redo-log BASE-DIRinnobackupex --apply-log --redo-log BASE-DIR --incremental-dir=INCREMENTAL-DIR-1innobackupex --apply-log --redo-log BASE-DIR --incremental-dir=INCREMENTAL-DIR-2</code></pre><p>其中BASE-DIR指的是完全备份所在的目录，而INCREMENTAL-DIR-1指的是第一次增量备份的目录，INCREMENTAL-DIR-2指的是第二次增量备份目录，其他依次类推，即如果有多次增量备份，每一次都要执行如上操作。</p><blockquote><p>Xtrabackup的“流”及“备份压缩”功能</p></blockquote><p>Xtrabackup对备份的数据文件支持“流”功能，即可以将备份的数据通过STDOUT传输给tar程序进行归档，而不是默认的直接保存至某备份目录中。要使用此功能仅需要使用–stream选项即可。</p><p>使用格式：</p><pre><code>innbackupex --stream=tar /BACKUP |gzip &gt; /BACKUP/`date +F_$H-$M_%M_%S`.tar.gz</code></pre><p>也可是使用如下命令将数据备份至某服务器上：</p><pre><code>innobackupex --stream=tar /BACKUP |ssh user@IP &quot;cat - &gt; /backups/`date +%F_%H-%M-%S`.tar&quot;</code></pre><p>在执行本地备份时，还可以使用–parallel选项对多个文件进行并行复制。此选项用于指定在复制时启动的线程数目。在实际进行备份时要利用此功能的便利性，也需要启动inndb_file_per_table选项或共享表空间通过innodb_data_file_path选项存储在多个ibdata文件中。对某一数据库的多个文件的复制无法利用此功能。</p><p>使用格式：</p><pre><code>innobackupex --parallel /path/to/backup</code></pre><p>同时innobackupex备份数据文件也可以存储值远程主机，使用–remote-host选项</p><p>使用格式：</p><pre><code>innobackupex --remote-host=user@IP /PATH/IN/REMOTE/HOST/TO/BACKUP</code></pre><blockquote><p>导入或导出单张表</p></blockquote><p>默认情况下，InnoDB表不能通过直接复制文件的方式在mysql服务器之间进行移植，即便使用了innodb_file_per_table选型。而使用Xtreabackup工具可以实现此种功能，不过此时需要“导出”表的mysql服务器启动innodb_file_per_table选项（严格来说，是要“导出”的表在其创建之前，msyql服务器就启用了innodb_file_per_table选项），并且“导入”表的服务器同时启用了innodb_file_per_table和innodb_expand_import选项。</p><p>（1）导出表</p><p>导出表示在备份的prepare阶段进行的，因此一旦完成备份，就可以在prepare过程中通过–export选项将某表导出了</p><p>使用格式：</p><pre><code>innobackupex --apply-log --export /path/to/bacup</code></pre><p>此命令会为每个innodb表的表空间创建一个以.exp结尾的文件，这些以.exp结尾的文件则可以用于导入至其它服务器。</p><p>（2）导入表</p><p>要在mysql 服务器上导入来自于其他服务器的某个innodb表，需要先在当前服务器上创建一个跟原表结构一致的表，而后才能实现将表导入：</p><pre><code>CREATE TABLE mytable ENGING=InnoDB;然后将此表的表空间删除ALTER TABLE mydatabase.mytable DISCARD TABLESPACE;接下来，将来自于导出表的服务器的mytable表的mytable.ibd和mysqtalbe.exp文件复制到当前服务器的数据目录：ALTER TABLE mydatabase.mytable IMPORT TABLESPACE;</code></pre><blockquote><p>使用Xtrabackup对数据库进行部分备份</p></blockquote><p>Xtrabackup也可以实现部分备份，即只备份某个或某些指定的数据库或某数据库中的某个或某些表。但要使用此功能，必须启用innodb_file_per_table选项，即每张表保存为一个独立的文件。同时其也不支持–stream选项，即不支持将数据通过管道传输给其他程序进行处理。</p><p>此外，还原部分备份跟还原全部数据备份也有所不同，即不能通过简单地将prepared的部分备份使用–copy-back选项直接复制回数据目录，而是要通过导入表的防线来实现还原。当前，有些情况下，部分备份也可以直接通过–copy-back进行还原，但这种范式还原而来的数据多数会产生数据不一致的文件。</p><p>（1）创建部分备份</p><p>创建部分备份的方式：</p><ul><li>正则表达式（–include）</li></ul><p>要求为其制定要备份的表的完整名称，即如databasesname.tablename</p><pre><code>innobackupex --include ‘^student[.]tb1’ /path/to/backup</code></pre><ul><li>枚举表文件（–tables-file）</li></ul><p>此选项的参数需要一个文件名，此文件中每行包含一个要备份的表的完整名称</p><pre><code>echo -e &#39;test.tb1\ntest.tb2&#39; &gt; /tmp/tables.txtinnobackupex --tables-file=/tmp/tables.txt /path/to/backup</code></pre><ul><li>列出要备份的数据库（–databases）</li></ul><p>此选项接受参数参数为数据名，如果要指定多个数据库，彼此间需要以空格隔开；同时，在指定某数据库时，也可以只指定其中的某张表。此外，此选项也可以接受一个文件为参数，文件中每一行为一个要备份的对象。</p><pre><code>innobackupex --databases=“test testb” /path/to/backup</code></pre><p>（2）整理（preparing）部分备份</p><p>prepare部分备份的过程类似于导出表的过程，要使用–export选项进行</p><pre><code>innobackupex --apply-log --export /PATH/TO/PARTIAL/BACKUP</code></pre><p>此命令执行过程中，innobackupex会调用xtrabackup命令从数据字典中移除缺失的表，因此，会显示出许多关于“表不存在”类的警告信息。同时，也会显示出为备份文件中存在的表创建.exp文件的相关信息。</p><p>（3）还原部分备份</p><p>还原部分备份的过程跟导入表的过程相同。当然，也可以通过直接复制prepared状态的备份直接至数据目录中实现还原，不过此时要求数据目录处于一致状态。</p><p><strong>实战：</strong></p><p>准备两台虚拟器node1和node2</p><blockquote><p>同步时间</p></blockquote><p><code>[root@node1~]#ntpdate 172.18.0.1</code></p><p><code>[root@node2~]#ntpdate 172.18.0.1</code></p><p><code>[root@node1~]#vim /etc/chrony.conf</code>   #node1和node2操作一样</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_184716.jpg" alt=""></p><p><code>[root@node1~]#systemctl start chronyd.service</code> #启动服务</p><blockquote><p>基于root密钥认证</p></blockquote><p>node1和node2配置一样</p><p><code>[root@node2~]#ssh-keygen</code></p><p><code>[root@node2~]#ssh-copy-id -i /root/.ssh/id_rsa.pub 192.168.4.61</code></p><blockquote><p>修改hosts文件<br>node1和node2配置相同</p></blockquote><p><code>[root@node1~]#vim /etc/hosts</code></p><pre><code>  3 192.168.4.61 node1  4 192.168.4.62 node2</code></pre><blockquote><p>安装数据库和extabackup</p></blockquote><p><code>[root@node1~]#yum install -y mariadb-server</code></p><p><code>[root@node1~]#yum install -y percona-xtrabackup-24-2.4.7-2.el7.x86_64.rpm</code></p><blockquote><p>导入一个数据库并备份</p></blockquote><p><code>[root@node1~]#vim /etc/my.cnf.d/server.cnf</code></p><pre><code>  9 [server] 10 log_bin = /data/mysql/master-log</code></pre><p><code>[root@node1~]#vim /etc/my.cnf</code></p><pre><code>10 innodb_file_per_table</code></pre><p><code>[root@node1~]#systemctl start mariadb.service</code></p><p>创建目录并修改权限</p><p><code>[root@node1~]#mkdir /data/mysql -pv</code></p><p><code>[root@node1~]#chown -R mysql.mysql /data/mysql</code></p><p>查看是否真正开启二进制日志功能</p><pre><code>MariaDB [(none)]&gt; SELECT @@global.log_bin;+------------------+| @@global.log_bin |+------------------+|                1 |+------------------+</code></pre><p>关闭当前会话二进制功能，并导入数据库</p><pre><code>MariaDB [(none)]&gt; SET @@session.sql_log_bin=OFF;</code></pre><p><code>[root@node1~]#mysql &lt; hellodb.sql</code></p><blockquote><p>使用xtrabackup备份数据库</p></blockquote><pre><code>MariaDB [(none)]&gt; GRANT ALL ON *.* TO &#39;root&#39;@&#39;192.168.4.63&#39; IDENTIFIED BY &#39;123456&#39;; #授权远程用户权限</code></pre><p><code>[root@node1~]#innobackupex --user=root --host=localhost /data/mysql/</code>  #使用命令进行备份</p><p><code>[root@node1~]#scp -r /data/mysql/*  node2:/data/mysql</code>   #将备份数据复制到node2中</p><p>在node1中添加一些数据</p><pre><code>MariaDB [hellodb]&gt; INSERT INTO scores (ID,StuID,CourseID,Score) VALUES (16,9,3,95);</code></pre><p>在node2进行如下操作：</p><p><code>[root@node2~]#innobackupex --apply-log /data/mysql/2017-11-11_19-45-11/</code>   #将数据进行回滚</p><p><code>[root@node2~]#innobackupex --copy-back /data/mysql/2017-11-11_19-45-11/</code>   #恢复</p><p><code>[root@node2~]#chown -R mysql.mysql /var/lib/mysql/</code>    #修改权限</p><p>此时只是复制了某个时间点的数据，时间点之后的数据没有如何解决？</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_200331.jpg" alt=""></p><p>查看时间点是的二进制日志在哪个地方</p><p><code>[root@node2/data/mysql/2017-11-11_19-45-11]#cat xtrabackup_binlog_info</code>  </p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_200530.jpg" alt=""></p><p>在node1节点上查看并导出</p><p><code>[root@node1~]#mysqlbinlog -j 8203 /data/mysql/master-log.000001  &gt; change.sql</code></p><p><code>[root@node1~]#scp change.sql node2:/tmp</code></p><p>在node2节点上导入</p><pre><code>MariaDB [hellodb]&gt; SET @@session.sql_log_bin=OFF；   先关闭二进制日志功能MariaDB [hellodb]&gt; \. /tmp/change.sql   #导入</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-11_201808.jpg" alt=""></p><p>####如何实现全量和增量？</p><p>#####在node1节点操作：</p><p><code>[root@node1~]#innobackupex --user=root --host=localhost /data/mysql/</code></p><pre><code>MariaDB [hellodb]&gt; INSERT INTO scores (ID,StuID,CourseID,Score) VALUES (17,10,3,95);    #添加一行记录</code></pre><p><code>[root@node1~]#innobackupex --user=root --host=localhost /data/mysql/ --incremental --incremental-basedir=/data/mysql/2017-11-11_20-19-31</code>  #增量备份</p><pre><code>MariaDB [hellodb]&gt; INSERT INTO scores (ID,StuID,CourseID,Score) VALUES (18,11,4,95);    #再次添加一条记录</code></pre><p><code>[root@node1~]#innobackupex --user=root --host=localhost /data/mysql/ --incremental --incremental-basedir=/data/mysql/2017-11-11_20-22-16</code>  #再次进行增量备份</p><p>进行准备操作：</p><p><code>[root@node1/data/mysql]#innobackupex --apply-log --redo-only 2017-11-11_20-19-31/</code></p><p><code>[root@node1/data/mysql]#innobackupex --apply-log --redo-only 2017-11-11_20-19-31/ --incremental-dir=/data/mysql/2017-11-11_20-22-16</code>   #第一次增量准备</p><p><code>[root@node1/data/mysql]#innobackupex --apply-log --redo-only 2017-11-11_20-19-31/ --incremental-dir=/data/mysql/2017-11-11_20-24-32</code>   #第二次增量准备</p><p><code>[root@node1/data/mysql]#innobackupex --apply-log /data/mysql/2017-11-11_20-19-31/</code></p><p><code>[root@node1/data/mysql]#mysqlbinlog  -j 8203 master-log.000002 &gt; /root/mysql.sql</code></p><p><code>[root@node1/data/mysql]#scp -r /root/mysql.sql node2:/tmp</code></p><p>将准备好的备份文件复制到node2节点中</p><p><code>[root@node1/data/mysql]#scp -r /data/mysql/2017-11-11_20-19-31/ node2:/data/mysql</code></p><h4 id="在node2节点上操作"><a href="#在node2节点上操作" class="headerlink" title="在node2节点上操作"></a>在node2节点上操作</h4><p><code>[root@node1/data/mysql]#innobackupex --copy-back /data/mysql/2017-11-11_20-19-31/</code> #恢复数据库</p><p><code>[root@node1/data/mysql]#chown -R mysql.mysql /var/lib/mysql/</code>  #修改权限</p><pre><code>MariaDB [hellodb]&gt; \. /tmp/mysql.sql</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xtrabackup，mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zabbix+Grafana</title>
      <link href="/2017/11/28/Zabbix+Grafana/"/>
      <url>/2017/11/28/Zabbix+Grafana/</url>
      
        <content type="html"><![CDATA[<p>Grafana<br>-<br>Grafana是一款开源度量分析和可视化套件。它有良好的展示页面。它最常用与对基础设施和应用分析的时间序列数据进行可视化，如工业传感器、进程控制等等。</p><h2 id="Installing-Grafana"><a href="#Installing-Grafana" class="headerlink" title="Installing Grafana"></a>Installing Grafana</h2><h4 id="安装Grafana"><a href="#安装Grafana" class="headerlink" title="安装Grafana"></a>安装Grafana</h4><p><code>[root@localhost~]#yum install https://s3-us-west-2.amazonaws.com/grafana-releases/release/grafana-4.6.2-1.x86_64.rpm</code></p><h4 id="配置yum仓库安装"><a href="#配置yum仓库安装" class="headerlink" title="配置yum仓库安装"></a>配置yum仓库安装</h4><pre><code>[grafana]name=grafanabaseurl=https://packagecloud.io/grafana/stable/el/6/$basearchrepo_gpgcheck=1enabled=1gpgcheck=1gpgkey=https://packagecloud.io/gpg.key https://grafanarel.s3.amazonaws.com/RPM-GPG-KEY-grafanasslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crt</code></pre><p><code>[root@node1/etc/grafana]#yum install grafana</code></p><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><p><code>[root@node1~]#systemctl start grafana-server.service</code><br><code>[root@node1~]#systemctl status grafana-server.service</code></p><p>地址栏输入：<a href="http://192.168.4.61:3000/" target="_blank" rel="noopener">http://192.168.4.61:3000/</a></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-23_200736.jpg" alt=""></p><p><strong>默认的登陆账号和密码均为admin；建议登陆后修改密码。</strong></p><h4 id="安装zabbix插件"><a href="#安装zabbix插件" class="headerlink" title="安装zabbix插件"></a>安装zabbix插件</h4><p><code>[root@node1~]#grafana-cli plugins install alexanderzobnin-zabbix-app</code></p><p><strong>建议：只给Grafana SELECT权限。因为Grafana不能验证。</strong></p><h4 id="添加zabbix"><a href="#添加zabbix" class="headerlink" title="添加zabbix"></a>添加zabbix</h4><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-23_203843.jpg" alt=""><br><img src="http://owatlfstl.bkt.clouddn.com/2017-11-23_204231.jpg" alt=""></p><h4 id="添加数据库"><a href="#添加数据库" class="headerlink" title="添加数据库"></a>添加数据库</h4><p>为了能在刚刚配置的中直连数据库需要先添加数据库信息</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-23_210111.jpg" alt=""></p><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-23_210350.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 监控系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zabbix，Grafana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat简单介绍</title>
      <link href="/2017/11/28/Tomcat%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/11/28/Tomcat%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-03_190947.jpg" alt=""></p><p>Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阈等。但是不能将Tomcat和Apache HTTP服务器混淆，Apache HTTP服务器时一个用C语言实现的HTTP web服务器，而Tomcat则是由Java编写。</p><h1 id="一、java"><a href="#一、java" class="headerlink" title="一、java"></a>一、java</h1><p>Java是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。Java的特点之一面向对象，是程序设计方法的一种。</p><h5 id="程序是由指令和数据组成。"><a href="#程序是由指令和数据组成。" class="headerlink" title="程序是由指令和数据组成。"></a>程序是由指令和数据组成。</h5><pre><code>过程式编程：以指令为中心，数据服务于代码对象式编程：以数据位中，指令服务于数据</code></pre><h3 id="1、Java代码编译过程"><a href="#1、Java代码编译过程" class="headerlink" title="1、Java代码编译过程"></a>1、Java代码编译过程</h3><p><img src="http://owatlfstl.bkt.clouddn.com/java%E8%BF%87%E7%A8%8B.png" alt=""></p><p>用java语言编译源代码，通过JAVAC （Java complie）它编译成java .class(bytes code)文件，然后在Java VM中运行.class文件；当编写程序时，通过调用类（API class）中的方法来访问系统资源，而当程序运行时，它通过调用class文件中实现Java API的方法来满足程序的Java API调用。Java VM 和Java API一起组成一个平台，被称为JDK（Java Development Kit），所有的Java程序都在其上编译和运行。</p><p><strong>Java VM</strong>主要任务时装载class文件并且执行其中的字节码，加载程序的类文件即程序的类文件依赖到的其他的类文件而后运行，整个运行表现为一个jvm进程。它包含一个类装载器（class loader）可以从程序和API装载class文件；但是Java API的类只在程序执行中需要时才会装载。</p><h3 id="2、Java-API"><a href="#2、Java-API" class="headerlink" title="2、Java API"></a>2、Java API</h3><p>Java SE包含了Java二进制程序（如JVM和Java字码编译器）和Java的核心代码库；而Java EE标准则包含了一组适用于创建企业级Web应用程序API。Java EE是建立在Java SE基础之上；它包含了多个独立的API，如Servlet和JSP等</p><h3 id="3、Java-VM-内部体系结构"><a href="#3、Java-VM-内部体系结构" class="headerlink" title="3、Java VM 内部体系结构"></a>3、Java VM 内部体系结构</h3><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-03_200219.jpg" alt=""></p><p><strong>方法区</strong>线程共享，用于存储被JVM加载的class信息、常量、静态变量、方法等</p><p><strong>堆</strong>JVM所管理的内存中占用空间最大的一部分；也是GC管理的主要区域；存储对象</p><p><strong>栈</strong>线程私有，存储线程自己的局部变量</p><p><strong>PC寄存器</strong>线程私有的内存空间，程序的指令指针</p><p><strong>本地方法栈</strong>执行引擎调用本地方法是的运行时聂村去</p><p>JVM的功能模块主要包括类加载器、执行引擎和垃圾回收系统。</p><p>– JVM组成</p><pre><code>JRE（JVM+java SE API）：是用于实现java程序运行的最小环境JDK（Java+API+JVM）：是用于实现Java程序开发的最小环境</code></pre><h3 id="3、JSP代码运行过程"><a href="#3、JSP代码运行过程" class="headerlink" title="3、JSP代码运行过程"></a>3、JSP代码运行过程</h3><p><img src="http://owatlfstl.bkt.clouddn.com/tomcat-http-guocheng.jpg" alt=""></p><p>index.jsp–&gt;jasper–&gt;servert Source Code(.java)–&gt;Java Compiler (.class)–&gt;在JVM虚拟机上运行</p><p>注意：基于jasper将静态输出的数据转为java代码进行输出，结果为servlet规范的代码。<br>-</p><h1 id="二、Tomcat"><a href="#二、Tomcat" class="headerlink" title="二、Tomcat"></a>二、Tomcat</h1><p>Tomcat不是一个完整意义上的Java EE服务器，甚至没有提供对一个主要java EE API。由于遵守apache开源协议，tomcat为众多java应用程序服务器嵌入自己的产品中构建商业的java应用程序服务器，如JBoss等</p><h3 id="1、JSP和Servlet区别"><a href="#1、JSP和Servlet区别" class="headerlink" title="1、JSP和Servlet区别"></a>1、JSP和Servlet区别</h3><p>Servlet通常需要实现编译好，而JSP则并非必须事先编译。这意味着Servlet通常放置于私有资源区域，而JSP则通常以嵌入代码的方式包含于HTML页面文件中，这些HTML文件通常放置在公开资源区域。</p><h3 id="2、MVC架构"><a href="#2、MVC架构" class="headerlink" title="2、MVC架构"></a>2、MVC架构</h3><p>MVC架构由Contoller、Model和View构成，实现Apache Structs框架。</p><pre><code>a、Servlet用于实现应用逻辑b、JSP用于内容展示c、标签库和JSP扩展语言用于替换JSP内部嵌入Java代码，进而降低了HTML维护的复杂度d、MVC框架用于实现展示和应用逻辑分离</code></pre><h3 id="3、Servlet目录结构"><a href="#3、Servlet目录结构" class="headerlink" title="3、Servlet目录结构"></a>3、Servlet目录结构</h3><p>对于一个web应用程序而言，其通常由Servlet、JSP和其他文件等共同组成。这些文件通常被打包成WAR（Web Application Archive）格式，并以.war作为打包后的文件扩展名。而Servlet规范则定义了在WAR内部组织这些文件的标准目录结构。</p><pre><code>/   ：web应用程序的根目录，所有可被公开访问的文件均放置于此处，如HTML、JSP和图片文件等/WEB-INF :此目录为私有资源目录，其内部的所有文件和子目录不能被公开访问；包含此web应用程序的配置文件web.xml，通常放置于此目录/WEB-INF/classes：当前web应用程序的类文件存在目录/WEB-INF/lib：可被打包为JAR格式的类文件通常放置于此目录</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/java-http.png" alt=""></p><h3 id="4、Tomcat目录"><a href="#4、Tomcat目录" class="headerlink" title="4、Tomcat目录"></a>4、Tomcat目录</h3><pre><code>bin：脚本，即启动时用到的类conf：配置文件目录lib：库文件，Java类库，jarlogs：日志文件目录temp：临时文件目录webapps：webapp的默认目录work：工作目录，存放编译后的字节码文件</code></pre><h3 id="5、Tomcat文件"><a href="#5、Tomcat文件" class="headerlink" title="5、Tomcat文件"></a>5、Tomcat文件</h3><ul><li><strong>server.xml</strong> tomcat主配置文件，包含service、connector、engine、realm、valve、host相关配置信息</li><li><strong>web.xml</strong> 每个webapp只有“部署”后才能被访问，它的部署方式通常有web.xml进行定义，其存放的位置为WEB-INF/目录下，次文件为所有的webapps提供默认部署相关的配置</li><li><strong>context.xml</strong> 每个文本app都可以使用的配置文件，它通常有专用的配置文件contest.xml来定义，其存放位置为WEB-INF/目录下</li><li><strong>tomcat-user.xml</strong> realm认证时用到的相关角色、用户和密码等信息；tomcat自带的manager默认情况下会用到此文件。此文件在tomcat启动时被装入内存</li><li><strong>catalina.policy</strong> 当使用-security选项启动tomcat时，用于为tomcat设置安全策略</li><li><strong>catalina.properties</strong>  Java属性的定义文件，用于设定类加载器路径，以及一些与JVM调优相关参数</li><li><strong>logging.properties</strong> 日志系统相关的配置</li></ul><h4 id="server-xml组件"><a href="#server-xml组件" class="headerlink" title="server.xml组件"></a>server.xml组件</h4><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-03_221835.jpg" alt=""></p><p><strong>Tomcat组件</strong></p><pre><code>顶级组件：位于配置层次的顶级，并且彼此间有着严格的对应关系（server、service）连接器：连接客户端请求至servlet（connector）容器：包含一组其他组件（engine、host、context）被嵌套的组件：位于一个容器当中，但不能包含其他组件（valve、logger、realm）        &lt;Server&gt;            &lt;Service&gt;                &lt;connector/&gt;                &lt;connector/&gt;                ...                &lt;Engine&gt;                    &lt;Host&gt;                        &lt;Context/&gt;                        &lt;Context/&gt;                        ...                    &lt;/Host&gt;                    &lt;Host&gt;                        ...                    &lt;/Host&gt;                    ...                &lt;/Engine&gt;            &lt;/Service&gt;        &lt;/Server&gt;</code></pre><h5 id="tomcat常用组件配置"><a href="#tomcat常用组件配置" class="headerlink" title="tomcat常用组件配置"></a>tomcat常用组件配置</h5><ul><li><em>server</em>：代表tomcat instance，即表现出一个java进程；监听在8005端口，只能接受“SHUTDOWN”指令。各server监听的端口不能相同，因此在同一物理主机启动多个示例时，需要修改其监听端口为不同的端口。这个端口的定义为管理员提供一个关闭此示例的便捷途径，管理员可以直接使用telnet命令连接此端口SHUTDOWN关闭此示例。基于安全角度考虑，通常不允许远程进行</li><li><p><em>service</em>：用于实现将一个或多个connector组件关联至一个engine组件</p><p>  <em>className</em>：用于实现service的类名<br>  <em>name</em>：此服务的名称，默认为catalina</p></li><li><p><em>connector</em>：负责接收请求，常见的有三类http、https、ajp</p><p>  <em>address</em>：指定连接器监听的地址，默认为所有地址<br>  <em>maxThreads</em>：支持的最大并发连接数，默认为200<br>  <em>port</em>：监听的端口，默认为0<br>  <em>protocol</em>：连接器使用的协议，默认为HTTP/1.1，定义AJP协议时通常为AJP/1.3<br>  <em>redirectPort</em>：如果某连接器支持的协议时HTTP，当接收客户端发来的HTTPS请求时则转发至此属性的定义端口<br>  <em>connectionTimeout</em>：等待客户端发送请求的超时时间，单位为毫秒，默认为6000<br>  <em>enableLookups</em>：是否通过request.getRemoteHost（）即是否启用DNS查询功能<br>  <em>acceptCount</em>：设置等待队列的最大长度</p></li><li><p><em>engine</em>： servlet示例，即servlet引擎，其内部可以一个或多个host组件来定义站点；通常需要defaultHost属性来为其定义一个接受所有发往非明确定义虚拟主机的请求的host组件</p><p>  <em>name</em>：engine组件的名称，用于日志和错误信息记录时却别不同的引擎</p></li><li><p><em>host</em>：位于engine内部用于接受请求并进行响应处理的主机或虚拟主机</p><p>  <em>appBase</em>：此host的webapps的默认存放目录，指存放非归档的web应用程序的目录或归档的WAR文件目录路径；可以使用基于$CATALINA_BASE变量所定义的路径的相对路径<br>  <em>autoDepoly</em>：在tomcat处于运动状态时，将某webapp放置于appBase所定义的目录中，是否自动将其部署至tomcat；默认为true<br>  <em>unpackWars</em>：在启用此webapss时是否对WAR格式的归档文件先进行展开，默认为true</p></li></ul><p>主机别名定义：如果一个主机有两个或两个以上的主机名，额外的名称均可以以别名的形式进行定义</p><p><strong>示例</strong></p><pre><code>&lt;Host name=&quot;www.test.com&quot; appBase=&quot;webapps&quot; unpackWARS=&quot;true&quot;&gt;    &lt;Alias&gt;test.com&lt;/Alias&gt;&lt;/Host&gt;</code></pre><ul><li><p><em>context</em>：context在某些意义上类似于apache的路径别名，一个context定义用于表示tomcat示例中的一个web应用程序</p><p>  <em>docBase</em>：相应的web应用程序存放位置；也可以使用相对路径，起始路径为Context所属Host中appBase定义的路径；切记，docBase的路径名不能与相应的Host中的appBase中定义的路径名有包含关系，比如appBase为deploy，而docBase决不能为deploy-bbs类的名字<br>  <em>path</em>：相对于web服务器根目录而言的URI，如果为空，则表示为webapp的根路径；如果context定义了一个单独的xml文件，此属性不需要定义<br>  <em>reloadable</em>：是否允许重新加载此context相关的web应用程序类，默认为false</p></li></ul><p><strong>示例</strong></p><pre><code>&lt;Context path=&quot;/path&quot; docBase=&quot;/path/to/somedir&quot; reloadable=&quot;&quot;/&gt;</code></pre><ul><li><p><em>realm</em>：一个realm表示一个安全上下文，授权访问某个给定context的用户列表和某用户所允许切换角色相关定义的列表</p></li><li><p><em>valve</em>：<br>类似于过滤器，valve定义的次序决定了他们的生效次序。</p><p>  RemoteHostValve：基于远程主机名称的访问控制<br>  RemouteAddrValve：基于远程地址的访问控制</p><p>  控制本身可以通过allow或deny来进行定义，这有点类似于apache的访问控制功能</p></li></ul><p><strong>示例：</strong></p><pre><code>&lt;Context path=&quot;/test&quot; docBase=&quot;test&quot;&gt;    &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;127\.0\.0\.1&quot;/&gt;&lt;/Context&gt;*className*：相关的java实现的类名*allow*：以逗号分开的允许访问的IP地址列表，支持正则表达式，使用“.”需要转义；仅定义allow选项是，被明确allow的地址均被deny*deny*：以逗号分开的禁止访问IP地址列表，支持正则表达式，使用方式同allow</code></pre><p><strong>部署（deploy）webapp相关操作</strong></p><p>将webapp的源文件放置于目标目录，配置tomcat服务器能够基于web.xml和context.xml文件中定义的路径来访问webapp；将其特有的类和依赖的类通过class loader装载至JVM中</p><pre><code>部署方式：    （1）自动部署auto deploy    （2）手动部署            冷部署：把webapp复制到指定的位置，而后才能启动tomcat            热部署：在不停止tomcat的前提下进行部署                部署工具：manager、ant脚本、tcd（tomcat client deployer）        undeploy：拆除（反部署），停止webapp，并从tomcat示例上卸载webapp        start：启动处于停止状态的webapp        stop：停止webapp，不再向用户提供服务，其类亦然在jvm上        redeploy：重新部署</code></pre><h3 id="6、启动manager功能"><a href="#6、启动manager功能" class="headerlink" title="6、启动manager功能"></a>6、启动manager功能</h3><pre><code>&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;manager-script&quot;/&gt;&lt;role rolename=&quot;standard&quot;/&gt;&lt;user username=&quot;tomcat&quot; password=&quot;secret&quot; roles=&quot;admin-gui,manager-script,standard&quot;/&gt;</code></pre><h3 id="7、tomcat请求的分类"><a href="#7、tomcat请求的分类" class="headerlink" title="7、tomcat请求的分类"></a>7、tomcat请求的分类</h3><pre><code>（1）standalone：请求来自客户端浏览器（2）由其他的web server反代，来自前段的反代服务器        nginx--&gt;http connector --&gt;tomcat        httpd(proxy_http_module)--&gt;http connector--&gt;tomcat        httpd(proxy_ajp_module)--&gt;ajp connector --&gt;tomcat        http(mod_jk)--&gt;ajp connector --&gt;tomcat</code></pre><h1 id="三、Tomcat安装"><a href="#三、Tomcat安装" class="headerlink" title="三、Tomcat安装"></a>三、Tomcat安装</h1><p>方式一：<br>-</p><p>使用yum源安装即可</p><p>（1）安装jdk环境，由于base源提供了三个不同版本的jdk环境，根据我们的需要自行安装所需要的版本</p><p><code>[root@localhost~]#yum install -y java-1.8.0-openjdk-src</code></p><p><code>[root@localhost~]#java -version</code>   #查看是否安装成功</p><p><em>如果多 版本并存时，可使用alternatives命令设定默认使用的版本。</em></p><p>（2）安装tomcat</p><p><code>[root@localhost~]#yum install -y tomcat tomcat-admin-webapps tomcat-docs-webapp tomcat-webapps tomcat-libs</code></p><p><code>[root@localhost~]#systemctl start tomcat.service</code>  #启动服务</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_093049.jpg" alt=""></p><h1 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h1><p>（1）从官网下载rpm安装jdk</p><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><p><code>[root@localhost~]#rpm -ivh jdk-8u144-linux-x64.rpm</code></p><p><code>[root@localhost~]#java -version</code>   #测试是否安装成功</p><p>（2）二进制安装tomcat</p><p><a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-80.cgi</a></p><p><code>[root@localhost~]#tar xf apache-tomcat-7.0.78.tar.gz -C /usr/local/</code>   #解压缩</p><p><code>[root@localhost~]#cd /usr/local/</code></p><p><code>[root@localhost/usr/local]#ln -sv apache-tomcat-7.0.78/ tomcat</code>    #创建软连接</p><p><code>[root@localhost/usr/local/tomcat]#vim /etc/profile.d/tomcat.sh</code>    #修改环境变量</p><pre><code>  1 export CATALINA_BASE=/usr/local/tomcat  2 export PATH=$CATALINA_BASE/bin:$PATH</code></pre><blockquote><p>修改权限</p></blockquote><p><code>[root@localhost/usr/local]#useradd -r tomcat</code>  #创建用户</p><p><code>[root@localhost/usr/local]#chown -R :tomcat tomcat/</code>   #修改配置文件所属组</p><p><code>[root@localhost/usr/local/tomcat]#chown tomcat ./{logs,temp,work,webapps}</code></p><p><code>[root@localhost/usr/local/tomcat]#source /etc/profile.d/tomcat.sh</code> #使环境变量生效</p><p>（3）重启服务测试</p><p><code>[root@localhost/usr/local/tomcat/bin]#catalina.sh --help</code></p><pre><code>Usage: catalina.sh ( commands ... )commands:  debug             Start Catalina in a debugger  debug -security   Debug Catalina with a security manager  jpda start        Start Catalina under JPDA debugger  run               Start Catalina in the current window  run -security     Start in the current window with security manager  start             Start Catalina in a separate window  start -security   Start in a separate window with security manager  stop              Stop Catalina, waiting up to 5 seconds for the process to end  stop n            Stop Catalina, waiting up to n seconds for the process to end  stop -force       Stop Catalina, wait up to 5 seconds and then use kill -KILL if still running  stop n -force     Stop Catalina, wait up to n seconds and then use kill -KILL if still running  configtest        Run a basic syntax check on server.xml - check exit code for result  version           What version of tomcat are you running?</code></pre><p><code>[root@localhost~]#mkdir test/{logs,temp,work,webapps} -pv</code></p><p><code>[root@localhost~]#chown -R tomcat test/{logs,temp,work,webapps}</code>   </p><p><code>[root@localhost/usr/local/tomcat/bin]#catalina.sh start</code>   #启动服务</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_101732.jpg" alt=""></p><p><strong>建议一般以普通用户运行tomcat</strong></p><h1 id="四、示例"><a href="#四、示例" class="headerlink" title="四、示例"></a>四、示例</h1><h3 id="1、冷部署方法"><a href="#1、冷部署方法" class="headerlink" title="1、冷部署方法"></a>1、冷部署方法</h3><p>（1）创建所需要的目录</p><p><code>[root@localhost~]#mkdir test/{classes,lib,WEB-INF} -pv</code></p><p>（2）创建index.jsp文件</p><p><code>[root@localhost~]#vim test/index.jsp</code></p><pre><code>  1  &lt;%@ page language=&quot;java&quot; %&gt;  2  &lt;%@ page import=&quot;java.util.*&quot; %&gt;  3  &lt;html&gt;  4          &lt;head&gt;  5                  &lt;title&gt;Test Page&lt;/title&gt;  6          &lt;/head&gt;  7          &lt;body&gt;  8                  &lt;% out.println(&quot;hello world&quot;);  9                  %&gt; 10          &lt;/body&gt; 11  &lt;/html&gt;</code></pre><p>（3）将test目录移动到webapps目录下</p><p><code>[root@localhost~]#cp -r test/ /usr/share/tomcat/webapps/</code></p><p>（4）重启服务测试</p><p><code>[root@localhost~]#systemctl start tomcat</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_110703.jpg" alt=""></p><p><strong>如果是程序员将打包好的jar文件发给我们，可以将此包直接防止webapps目录下，可以自行部署</strong></p><p>（5）查看部署过程</p><p><code>[root@localhost/usr/share/tomcat/work/Catalina/localhost]#tree test/</code></p><pre><code>test/└── org    └── apache        └── jsp            ├── index_jsp.class            └── index_jsp.java</code></pre><h3 id="2、手动使用SHUTDOWN关闭服务"><a href="#2、手动使用SHUTDOWN关闭服务" class="headerlink" title="2、手动使用SHUTDOWN关闭服务"></a>2、手动使用SHUTDOWN关闭服务</h3><p>（1）首先先查看下我们的服务是否正常运行</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_111511.jpg" alt=""></p><p>（2）使用telnet连接关闭服务</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_111645.jpg" alt=""></p><p>此时我们再看服务已经没有开启了，为了防止恶意之人，我们需要将命令修改为随机数等等</p><p><code>[root@localhost/etc/tomcat]#openssl rand -hex 20</code></p><pre><code>fb8a9c1a78827dcb81950feca0e18c6d4470997e</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_111922.jpg" alt=""></p><h3 id="3、创建站点"><a href="#3、创建站点" class="headerlink" title="3、创建站点"></a>3、创建站点</h3><p><code>[root@localhost/etc/tomcat]#vim server.xml</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_113352.jpg" alt=""></p><p><code>[root@localhost/etc/tomcat]#mkdir -pv /app/webapps</code></p><p><code>[root@localhost/etc/tomcat]#mkdir -pv /app/webapps/ROOT/{lib,classes,WEB-INF}</code></p><p><code>[root@localhost/etc/tomcat]#cp /usr/share/tomcat/webapps/test/index.jsp /app/webapps/ROOT/</code>    #创建站点文件</p><blockquote><p>重启服务测试</p></blockquote><p><code>[root@localhost/etc/tomcat]#systemctl start tomcat</code></p><p><code>[root@localhost/etc/tomcat]#curl www.test.com:8080</code></p><pre><code> &lt;html&gt;         &lt;head&gt;                 &lt;title&gt;Test Page&lt;/title&gt;         &lt;/head&gt;         &lt;body&gt;                 hello world         &lt;/body&gt; &lt;/html&gt;</code></pre><p>出现上述结果正常，使用的是curl命令没有做修改</p><p><code>[root@localhost/etc/tomcat]#links www.test.com:8080</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_113653.jpg" alt=""></p><h3 id="4、修改conext组件相当于修改别名"><a href="#4、修改conext组件相当于修改别名" class="headerlink" title="4、修改conext组件相当于修改别名"></a>4、修改conext组件相当于修改别名</h3><p>（1）创建目录</p><p><code>[root@localhost~]#cp -r test/ /data/test</code></p><p>（2）编辑server.xml文件</p><p><code>[root@localhost~]#vim /etc/tomcat/server.xml</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_114918.jpg" alt=""></p><p>（3）编辑index.jsp文件</p><p><code>[root@localhost/data/test]#vim index.jsp</code></p><pre><code>  1  &lt;%@ page language=&quot;java&quot; %&gt;  2  &lt;%@ page import=&quot;java.util.*&quot; %&gt;  3  &lt;html&gt;  4          &lt;head&gt;  5                  &lt;title&gt;Test Page&lt;/title&gt;  6          &lt;/head&gt;  7          &lt;body&gt;  8                  &lt;% out.println(&quot;hello tomcat&quot;);  9                  %&gt; 10          &lt;/body&gt; 11  &lt;/html&gt;</code></pre><p>（4）重启服务测试</p><p><code>[root@localhost/data/test]#links www.test.com:8080/test</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_114840.jpg" alt=""></p><h3 id="5、启动web-gui管理"><a href="#5、启动web-gui管理" class="headerlink" title="5、启动web-gui管理"></a>5、启动web-gui管理</h3><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_115428.jpg" alt=""></p><p>（1）如果我们想启用Server Status功能需要认证，如果我们点击cancle则出现指示方法</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_141848.jpg" alt=""></p><p>（2）修改tomcat-user.xml配置文件</p><p><code>[root@localhost/etc/tomcat]#vim tomcat-users.xml</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_142628.jpg" alt=""></p><p>（3）重启tomcat服务测试</p><p><code>[root@localhost/etc/tomcat]#systemctl restart tomcat</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_142853.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_142837.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_142908.jpg" alt=""></p><h3 id="5、禁止或允许某个或某些远程IP主机管理"><a href="#5、禁止或允许某个或某些远程IP主机管理" class="headerlink" title="5、禁止或允许某个或某些远程IP主机管理"></a>5、禁止或允许某个或某些远程IP主机管理</h3><p>（1）编辑server.xml配置文件</p><p><code>[root@localhost/etc/tomcat]#vim server.xml</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_143912.jpg" alt=""></p><p>（2）测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_144159.jpg" alt=""></p><p>禁止此IP访问没有显示内容 </p><p>那么接下来我们允许此IP访问并再次重启服务测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-04_144330.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP三次握手和四次挥手</title>
      <link href="/2017/11/28/TCP/"/>
      <url>/2017/11/28/TCP/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Socket"><a href="#一、Socket" class="headerlink" title="一、Socket"></a>一、Socket</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p> socket是“孔”和“插座”之意。在linux中显然是插座的意思，相当于我们家中插头和插座之意，它们连接才能通电。在Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。实现进程间通信，允许位于不同主机（或同一主机）上不同进程之间进行通信和数据交换。Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。</p><h3 id="2、Socket的类型"><a href="#2、Socket的类型" class="headerlink" title="2、Socket的类型"></a>2、Socket的类型</h3><h4 id="（1）Socket-Domain"><a href="#（1）Socket-Domain" class="headerlink" title="（1）Socket Domain"></a>（1）Socket Domain</h4><pre><code>AF_INET：Address Family IPv4 AF_INET6：Address Family IPv6AF_UNIX：同一台主机不同进程之间通信使用。</code></pre><h4 id="（2）Socket-Type"><a href="#（2）Socket-Type" class="headerlink" title="（2）Socket Type"></a>（2）Socket Type</h4><pre><code>SOCK_STREAM：流套接字，TCP套接字；可靠传输，面向对象传输。SOCK_DGRAM：数据报，UDP套接字；不可靠传输，无直接连接。SOCK_RAW：裸套接字，无须TCP或UDP，应用程序直接通过IP 包通信。</code></pre><h4 id="（3）Socket-Protocol"><a href="#（3）Socket-Protocol" class="headerlink" title="（3）Socket Protocol"></a>（3）Socket Protocol</h4><pre><code>指定实际使用的传输协议。常见IPPROTO_TCP、IPPROTO_UDP等。</code></pre><h3 id="3、Socket函数"><a href="#3、Socket函数" class="headerlink" title="3、Socket函数"></a>3、Socket函数</h3><blockquote><p>socket（）</p></blockquote><p> 为通讯创建一个端点，为套接字返回一个文件描述符。</p><p>注意：当调用socket（）创建一个socket时，只赋予其所使用的协议，没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind（），否则就当调用connect（）、listen（）时系统会自动随机分配一个端口。</p><blockquote><p>bind()</p></blockquote><p> 为一个套接字分配地址。对应的Socket protocol把一个IPv4 或IPv6地址和端口组合赋给socket。</p><p>通常服务器在启动时会绑定IP地址和端口，用于提供服务；而客户端就不用指定，系统自动分配一个端口和自身的IP 地址。这就是为什么通常服务器端在listen之前要bind（），而客户端不会调用，而是在connect（）时由系统自动生成一个。</p><blockquote><p>listen（）</p></blockquote><p>当socket和一个地址（IP和端口）绑定之后，listen（）函数就开始监听可能的链接请求。socket（）函数创建的socket默认是一个主动类型，listen函数将socket变为被动类型，等待客户的连接请求。一旦连接被接受，返回0表示成功，-1表示错误。</p><blockquote><p>accept（）</p></blockquote><p>当应用程序监听来自其他主机的面对数据流的连接时，通过时间通知它。必须用accept（）函数初始化连接，TCP服务器监听到这个请求之后，就会调用accept（）函数接受请求。这样就连接就建立好了。之后就可以进行I/O操作了。</p><p>accept默认会阻塞进程，直到有一个客户连接建立后返回，返回一个新可用的套接字，这个套接字是连接套接字。</p><pre><code>监听套接字：在调用函数listen函数之后，是服务器开始调用socket（）生成的；存在于服务器整个生命周期。连接套接字：一个套接字会从主动连接变为一个监听套接字；accept函数返回值是已经连接socket描述符，它代表着一个网络已经存在的点点连接；利用I/O可以实现不同进程间的通信。</code></pre><blockquote><p>connect()</p></blockquote><p>系统调用为一个套接字设置连接，参数有文件描述符和主机地址。</p><p>某些类型的套接字是无连接的，如DUP协议，连接时默认发送和接受数据的主机由给定的地址确定，可以使用send（）和recv（）。</p><blockquote><p>read()、write()</p></blockquote><p>服务器与客户已经建立连接。就可以使用不同进程之间的通信了。</p><blockquote><p>close（）</p></blockquote><p>在服务器与客户建立连接之后，会进行一些读写操作，完成之后就要关闭响应的socket描述子。</p><p>注意：close只是在相应的socket描述字的引用计数-1，只有当计数为0时，才会触发TCP客户端向服务器发送终止请求。</p><h3 id="4、Socket工作"><a href="#4、Socket工作" class="headerlink" title="4、Socket工作"></a>4、Socket工作</h3><p><img src="http://owatlfstl.bkt.clouddn.com/InternetSocketBasicDiagram_zhtw.png" alt=""></p><h2 id="二、TCP三次握手和TCP四次挥手"><a href="#二、TCP三次握手和TCP四次挥手" class="headerlink" title="二、TCP三次握手和TCP四次挥手"></a>二、TCP三次握手和TCP四次挥手</h2><p>我们先来举一个示例想必大家就懂了它的工作流程了。</p><pre><code>小明：您好，请问您是小红么？小红：是的，您是谁？小明：我是小明。小红：有什么事情呢？</code></pre><p>然后他们就开始友好的聊天了 。这个过程和我们TCP三次握手一样，TCP三次握手也是分为三步，然后建立连接实现通信。</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-27_153237.png" alt=""></p><blockquote><p>第一步</p></blockquote><p>Client主动向和Server发送请求；发送SYN=1，seq=x(Synchronize Sequence Numbers)，此时Client由状态<code>CLOSED</code>进入<code>SYS_SENT</code>状态。</p><blockquote><p>第二步</p></blockquote><p>Server接受到Client请求时，此时状态由<code>LISTEN</code>进入<code>SYN_RECV</code>状态。并向Client发送自己的SYN=1，ACK=1，seq=y，并确定Client同步序列号seq+1并返回，即ack=x+1。</p><blockquote><p>第三步</p></blockquote><p>Client接受到Server请求时,并向Server发送ACK=1，seq=x+1代表要进行通信的序列号，发送希望Server下次通信的数据包的ack=y+1。这里需要注意只有Server接受到ack=y+1时才代表通讯成功。此时就可以愉快的通信了；此时状态进入<code>ESTABLISHED</code>。</p><h5 id="TCP和Socket怎么结合工作呢？如下表。"><a href="#TCP和Socket怎么结合工作呢？如下表。" class="headerlink" title="TCP和Socket怎么结合工作呢？如下表。"></a>TCP和Socket怎么结合工作呢？如下表。</h5><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-27_155834.png" alt=""></p><p>Server</p><ol><li>Server服务器端调用socket()，生成socket</li><li>调用bind()绑定，为socket分配一个地址（IP和端口）</li><li>调用listen()进行监听；默认socket为主动连接状态，变为被动监听状态 </li><li>调用accept()阻塞，等待客户端连接。</li></ol><p>Clinet</p><ol><li>Client调用socket()生成socket</li><li>调用connect()阻塞，等待服务端的回应</li></ol><p>接下来就是TCP三次握手的过程：</p><blockquote><p>第一步</p></blockquote><p>Client主动向和Server发送请求；发送SYN=1，seq=x(Synchronize Sequence Numbers)，此时Client由状态<code>CLOSED</code>进入<code>SYS_SENT</code>状态。</p><blockquote><p>第二步</p></blockquote><p>Server接受到Client请求时，此时状态由<code>LISTEN</code>进入<code>SYN_RECV</code>状态。并向Client发送自己的SYN=1，ACK=1，seq=y，并确定Client同步序列号seq+1并返回，即ack=x+1。</p><blockquote><p>第三步</p></blockquote><p>Client接受到Server请求时,并向Server发送ACK=1，seq=x+1代表要进行通信的序列号，发送希望Server下次通信的数据包的ack=y+1。这里需要注意只有Server接受到ack=y+1时才代表通讯成功。此时就可以愉快的通信了；此时状态进入<code>ESTABLISHED</code>。</p><p>那么Client想和Server分手怎么办呢？</p><p>假如小明和小红在一起久了，觉得双方在一起不合适，这是就会发生如下事情</p><pre><code>小明：我发现我们在这么久了，不太适合，我们分手吧！假如这时候小明和小红有一些经济的往来，借了一些钱小红：为什么呢？我还没有还你那些钱呢，等我换一阵子我们了清了就分手！！！过了一段时间小红把小明的钱还了之后，并和小明说小红：我们分手吧小明：这时小明收到小红的分手信，好的，那就分手吧，从此一段姻缘就这样结束了。</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-27_165222.png" alt=""></p><h2 id="二、TCP四次挥手的过程"><a href="#二、TCP四次挥手的过程" class="headerlink" title="二、TCP四次挥手的过程"></a>二、TCP四次挥手的过程</h2><blockquote><p>第一步</p></blockquote><p>Client和Server相互传送完包以后，Client主动向Server发送关闭连接的信息：FIN=1，seq=u；此时进入<code>FIN_WAIT</code>状态</p><blockquote><p>第二步</p></blockquote><p>Server接收到Client请求之后，假如他们过程中还有一些包传输没有完成，这就Server向Client发送：ACK=1，seq=y（自己的序列号），ack=u+1（确认Client发送过程的请求号），此时进入<code>CLOSE_WAIT</code>。</p><blockquote><p>第三步</p></blockquote><p>当数据包全部传送完成之后，Server主动向Client发送回应：FIN=1，ACK=1，seq=w（此时完成传送的序列号），ack=u+1（这是这个确认好还是确认那序列号），此时进入<code>LASET_ACK</code>状态</p><blockquote><p>第四步</p></blockquote><p>Client接受到Server指令，并向Server发送：ACK=1，seq=u+1，ack=w+1，此时进入`TIME_WAIT状态，而不是直接关闭，原因是如果网络不通畅，重新发送包，相当于防止zombie状态。</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-27_165356.png" alt=""></p><ol><li>Client调用close()主动关闭连接，TCP发送一个FIN 1,seq=u</li><li>Server接收到FIN 1,seq=u之后，执行被动关闭，对这个seq=u进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；这是并不能立即关闭连接，如果有数据传送ACK=1，seq=y,ack=u+1，但没有发送FIN信号。</li><li>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。ServerTCP也发送一个FIN 1，ACK=1，seq=w,ack=u+1</li><li>Client接收到这个FIN它进行确认,并向Server发送ACK=1，seq=u+1，ack=w+1。此时进入<code>TIME_WAIT</code></li></ol><blockquote><p>1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</p></blockquote><pre><code>因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</code></pre><blockquote><p>2．为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？</p></blockquote><pre><code>因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态但是网络并不能保证通畅，无法确保发送的ACK报文会Server能接受到；因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible基础</title>
      <link href="/2017/11/28/ansible%E5%88%9D%E7%BA%A7%E8%AE%A4%E8%AF%86/"/>
      <url>/2017/11/28/ansible%E5%88%9D%E7%BA%A7%E8%AE%A4%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一、ansible介绍"><a href="#一、ansible介绍" class="headerlink" title="一、ansible介绍"></a>一、ansible介绍</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>ansible是自动化运维工具，基于Python开发，集合了众多的运维工具的优先，实心了批量系统配置、批量程序部署、批量运行命令等功能。</p><h3 id="2、特性"><a href="#2、特性" class="headerlink" title="2、特性"></a>2、特性</h3><ul><li>模块化：调用特定的模块完成特定的任务</li><li>基于Python语言实现，由Paramiko、PyYAML和Jinja2三个关闭模块</li><li>部署简单，agentless</li><li>支持自定义模块</li><li>支持playbook</li></ul><h3 id="3、ansible工作原理"><a href="#3、ansible工作原理" class="headerlink" title="3、ansible工作原理"></a>3、ansible工作原理</h3><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-18_100652.jpg" alt=""></p><p>由图中我们可以看出ansible的组成结构：</p><pre><code>Host Inventory ：主机库设置Playbook：剧本，按照事先设定的顺序完成安排的任务Core Modules：核心模块Custom Modules：自定义模块Connection Plugins：连接插件，一般基于ssh连接，加密传输，相对安全。</code></pre><p>后面的Host1、Host2等都是在Host Inventory定义的主机。</p><p>用户通过命令执行，Ansible使用ssh等方式连接到Host Inventory定义的主机；执行事先好的Playbook，调用Core Modules或Custom Modules等完成任务。</p><h3 id="4、ansible安装"><a href="#4、ansible安装" class="headerlink" title="4、ansible安装"></a>4、ansible安装</h3><p><code>[root@localhost~]#yum install -y ansible</code>  </p><p>由于ansible是由Python开发，所以依赖于有关Python包，需要epel源环境。</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><ul><li><p>主配置文件：<code>/etc/ansible/ansible.cfg</code></p></li><li><p>设置主机清单：<code>/etc/ansible/hosts</code></p></li></ul><p><strong>定义格式：</strong></p><pre><code> 定义单个主机： green.example.com blue.example.com192.168.100.1192.168.100.10 定义一组主机 [webservers] alpha.example.org beta.example.org 192.168.1.100 192.168.1.110 如果有一组主机格式相同可以使用如下格式： www[001:006].example.com如果一个主机属于多个组可以写入不同的组中。</code></pre><ul><li>设置角色路径：<code>/etc/ansible/roles</code></li></ul><p>定义每个角色时，均需在此目录创建目录，在新创建的目录下创建目录：</p><pre><code>files/：存放由copy或script模块等调用的文件templates/：template模块查找所需要的模板文件的目录，文件均需以“.j2”结尾tasks/：定义任务的目录；至少应该包含一个名为main.yml的文件，其他的文件需要在此文件中通过include进行包含handlers/：定义触发条件的目录；至少应该包含一个名为main.yml的文件，其他的文件需要通过include进行包含vars/：定义变量的目录；至少应该包含一个名为main.yml文件，其他的文件需要在此文件中通过include进行包含meta/：定义元数据目录；至少应该包含一个名为main.yml的文件，定义当前角色的特殊设定及其依赖关系；其他的文件需要在此文件中通过include进行包含。default/：设定默认值变量时使用此目录的main.yml文件</code></pre><h4 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h4><p>（1）ansible - run a task on a target host(s) 是一个额外简单的tool/framework/API管理远程主机。允许运行一个简单的任务剧本的adhoc命令。</p><p>使用格式:</p><pre><code>   ansible &lt;host-pattern&gt; [-m module_name] [-a args] [options]</code></pre><p>#</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a ‘ARGUMENTS’, –args=’ARGUMENTS’</td><td>设定参数</td></tr><tr><td>-C, –check</td><td>在远程不做任何修改，相当于干跑</td></tr><tr><td>-c CONNECTION, –connection=CONNECTION</td><td>指定使用的连接类型，如ssh、winrm和local，默认为ssh</td></tr><tr><td>-e EXTRA_VARS, –extra-vars=’EXTRA_VARS</td><td>指定额外的变量插入到剧本中，变量需要使用“‘’”引起来，并且命令行的优先级大于剧本中变量的优先级</td></tr><tr><td>-f NUM, –forks=NUM</td><td>指定并行级别。默认为5</td></tr><tr><td>-i PATH, –inventory=PATH</td><td>指定主机库，默认为/etc/ansible/hosts</td></tr><tr><td>–list-hosts</td><td>列出指定主机</td></tr><tr><td>-m NAME, –module-name=NAME</td><td>指定模块名称，默认为command模块</td></tr><tr><td>-M DIRECTORY, –module-path=DIRECTORY</td><td>指定模块路径，默认为/usr/share/ansible</td></tr><tr><td>-o, –one-line</td><td>输出信息在一行</td></tr><tr><td>-u USERNAME, –user=USERNAME</td><td>设定连接主机的名称，默认为root</td></tr><tr><td></td></tr></tbody></table><p>（2） ansible-doc - show documentation on Ansible modules显示模块信息</p><p>使用格式：</p><pre><code>ansible-doc [-M module_path] [-l] [-s] [module...]</code></pre><p>#</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-M DIRECTORY, –module-path=DIRECTORY</td><td>指定模块路径，默认为/usr/share/ansible</td></tr><tr><td>-s, –snippet=</td><td>列出模块使用方法</td></tr><tr><td>-l, –list=</td><td>列出所有模块信息</td></tr></tbody></table><p>（3）ansible-playbook - run an ansible playbook管理剧本</p><p>使用格式：</p><pre><code>ansible-playbook &lt;filename.yml&gt; ... [options]</code></pre><p>#</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-C, –check</td><td>检查脚本是否正确</td></tr><tr><td>-c CONNECTION, –connection=CONNECTION</td><td>连接使用的方法</td></tr><tr><td>-e EXTRA_VARS, –extra-vars=EXTRA_VARS</td><td>设定变量</td></tr><tr><td>–list-tasks</td><td>列出任务</td></tr><tr><td>–list-tags</td><td>列出标签</td></tr><tr><td>–list-hosts</td><td>列出主机</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ansible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zabbix介绍</title>
      <link href="/2017/11/28/Zabbix%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/11/28/Zabbix%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-21_192245.jpg" alt=""></p><p>Zabbix是一款能够监控各种网络参数以及服务器健康性和完整性的软件。Zabbix使用灵活的通知机制，允许用户为几乎任何事件配置基于邮件告警。Zabbix提供了出色的报告和数据可视化功能。Zabbix所有的报告、统计信息和配置参数都可以通过基于Web的前端页面进行访问。</p><h2 id="一、Zabbix"><a href="#一、Zabbix" class="headerlink" title="一、Zabbix"></a>一、Zabbix</h2><h3 id="1、Zabbix特点"><a href="#1、Zabbix特点" class="headerlink" title="1、Zabbix特点"></a>1、Zabbix特点</h3><ul><li>数据收集<ul><li>可用性和性能检查</li><li>支持SNMP,IPMI,JMX,VMware监控</li><li>自定义检查</li><li>按照自定义的间隔收集需要的数据</li></ul></li><li>灵活的阈值定义</li><li>高度可配置化的告警</li><li>实时图表绘制</li><li>Web监控功能</li><li>丰富的可视化选项<ul><li>能够创建自定义的图形，图形中可将多个监控项组合在一个视图展示</li><li>网络拓扑图</li><li>以仪表盘的样式展现自定义的展现和幻灯片</li><li>报告</li><li>监控资源的高级视图</li></ul></li><li>历史数据存储<ul><li>数据存储在数据库中</li><li>可配置历史数据</li><li>内置数据管理机制</li></ul></li><li>配置简单<ul><li>将被监控对象添加为主机</li><li>主机被创建用于监控，在数据库中唯一存在</li><li>应用模板来监控设备</li></ul></li><li>使用模板<ul><li>在模板中分组检查</li><li>模板可以关联其他模板</li></ul></li><li>网络发现<ul><li>自动发现网络设备</li><li>监控代理自动注册</li><li>发现文件系统，网络接口和SNMP OID值</li></ul></li><li>简介的Web界面<ul><li>web前段基于PHP</li><li>可以自定义自己的操作方式</li><li>审核日志</li></ul></li><li>权限管理系统<ul><li>安全用户认证</li><li>特定用户可以限制访问特定的视图</li></ul></li><li>功能强大并易于扩展监控代理<ul><li>部署在被监控对象上</li><li>可以部署在OS</li></ul></li></ul><h3 id="2、Zabbix结构"><a href="#2、Zabbix结构" class="headerlink" title="2、Zabbix结构"></a>2、Zabbix结构</h3><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-21_194622.jpg" alt=""></p><ul><li>zabbix_server：服务端守护进程；负责接收agent发送的报告信息的核心组件，所有配置、统计数据及操作系统均由其组织进行</li><li>zabbix_agentd：agent守护进程</li><li>zabbix_proxy：代理服务器，可选组件</li><li>zabbix_get：命令行工具，手动测试向agent发起数据采集请求</li><li>zabbix_sender：命令行工具，运行于agent端，手动向server端发送数据</li><li>zabbix_java_gateway：java网关</li><li>zabbix_database：MySQL或PGSQL；专用于存储所有配置信息，以及由zabbix收集的数据</li><li>zabbix_web：Web-GUI结构，可以运行在任意主机中，连接Zabbix-Server并将数据库的内容在前段展示</li></ul><h3 id="3、Zabbix逻辑组件"><a href="#3、Zabbix逻辑组件" class="headerlink" title="3、Zabbix逻辑组件"></a>3、Zabbix逻辑组件</h3><ul><li>Host Group（主机组）：主机的逻辑容器，可以包含主机和模板，但同一组内的主机和模板不能互相连接；主机组通常在给用户或用户组指派监控权限时使用</li><li>Host（主机）：要监控的网络设备，可由IP或DNS名称指定</li><li>item（监控项）：关键时key（实现获取监控的目标上的数据命令或脚本名称）；key+parameter构成。<ul><li>key分类：<ul><li>（1）Zabbix内建key</li><li>（2）用户自定义key</li></ul></li><li>存储的值<ul><li>As is：不对数据做任何处理，保留原值</li><li>Delta：（simple change）本次采样减去前一次采样值的结果</li><li>Delta：（speed per second）本次采样减去上一次采样的值除以经过的时长</li></ul></li></ul></li></ul><ul><li>application（应用）：同一类监控项的集合</li><li>trigger（触发器）：用于评估某监控对象的特定item内所接受到的数据是否在合理范围内，即阈值；如果不在合理范围内，触发器状态从“ok”转为“problem”<pre><code>  - 安全级别：      - Not classified      - Information      - Warning      - Average      - High      - Disaster  - trigger条件的设定：使用数据运算符</code></pre></li></ul><p><strong>注意：触发器之间存在依赖关系，如果前段有路由器down，则可以后端主机不发生告警。</strong></p><ul><li>event（事件）：即发生的一个值得关注的事情</li><li>action（动作）：由条件（condition，多个条件之间存在逻辑关系，如果第一步执行不成功则进行设定的下一步，以此类推。）和操作（operation，条件满足时触发的动作）组件构成</li></ul><ul><li><p>media（媒介）：发送通知的通道；需要用户上定义对各种媒介通道的接收方式</p><p>  （1）email<br>  （2）script：告警脚本</p><pre><code>      脚本放置路径在zabbix_server.conf配置文件汇总AlertScriptsPath定义，默认路径为/usr/lib/zabbix/alertscripts/目录下      zabbix服务器调用脚本时可以传递三个参数              $1：经由此信道接受信息的目标              $2：subject              $3：body</code></pre><p>   （3）remote command执行远程命令</p><pre><code>      在agent所在的主机上运行用户指定的命令或脚本；如，重启服务、通过IPMI重启服务器、任何用户自定义脚本中定义的操作</code></pre></li></ul><p><strong>注意：在agent执行远程命令时需要进行配置</strong></p><p><strong>a、zabbix用户拥有所需要执行命令的权限，编译<code>/etc/sudoers</code>配置文件</strong></p><pre><code>Defaults requiretty  关闭使用终端执行命令，这里需要在进程中执行命令zabbix ALL（ALL） NOPASSWD：ALL  这里需要注意的是，如果要执行某种命令给定即可，越小权限越好；NOPASSWD必须给定，如果不给定的话执行命令需要输入命令，但是我们在进程中运行，显然这不是理想的结果，因此不需要输入密码。</code></pre><p><strong>b、agent进程要允许远程执行命令</strong></p><pre><code>编辑/etc/zabbix/zabbix_agentd.conf    EnableRemoteCommands=1 设定允许远程执行 命令    LogRemoteCommands=1 执行命令记录日志中</code></pre><ul><li>notification（通知）：通过选定的媒介发送通知，例如email，wechat等</li><li>remote command（远程命令）：预定义的命令，可在被监控主机处于某特定条件下自动执行</li><li>告警升级：如果在设定的条件中，没有解决则向上一级发送通知</li><li>template（模板）：快速定义被监控主机的各监控项的预设项目集合</li><li>graph（图形）：用于展示历史数据或趋势数据的图像</li><li>screen（屏幕）：由多个graph组成</li></ul><p><strong>注意：zabbix执行过程为Host Group–&gt;Host–&gt;Application–&gt;Item–&gt;trigger<br>–&gt;action，只有前一步发生才会执行下一步操作。</strong></p><h3 id="4、zabbix检查方式"><a href="#4、zabbix检查方式" class="headerlink" title="4、zabbix检查方式"></a>4、zabbix检查方式</h3><p>Zabbix agent可以执行被动和主动两种检方式，Zabbix Server执行的方式取决于Zabbix agent设定的方式</p><p><strong>passive</strong></p><pre><code>在passive check模式中agent应答数据请求，Zabbix server询问agent数据，如CPU负载情况，然后返回给Zabbix agent结果</code></pre><p><strong>active</strong></p><pre><code>Action check模式中，Zabbix agent首先从Zabbix server索取监控项列表进行独立处理，然后周期性地发送新的值给Zabbix server</code></pre><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>预设的文本替换模式</p><h5 id="级别："><a href="#级别：" class="headerlink" title="级别："></a>级别：</h5><pre><code>全局：Administation--&gt;Genersl--&gt;Macros模板：编辑模板--&gt;Macros主机：编辑主机--&gt;Macros</code></pre><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><pre><code>主机  &gt;   模板   &gt;  全局</code></pre><h5 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h5><pre><code>内建：{MACRO_NAME}自定义：{$MACRO_NAME}    命名方式：大写字母、数字和下划线    宏名称中允许使用以下字符：A-Z , 0-9 , _ , . </code></pre><h5 id="Zabbix优先级解析宏"><a href="#Zabbix优先级解析宏" class="headerlink" title="Zabbix优先级解析宏"></a>Zabbix优先级解析宏</h5><pre><code>（1）主机级别的宏（首先检查）（2）为主机的第一级别模板定义的宏（直接链接到主机的模板），按照模板ID来排序（3）为主机的第二级别模板定义的宏等（4）全局宏（最后检查）</code></pre><h3 id="用户自定义参数key"><a href="#用户自定义参数key" class="headerlink" title="用户自定义参数key"></a>用户自定义参数key</h3><p>格式：</p><pre><code>UserParameter=&lt;key&gt;,&lt;command&gt;</code></pre><p><strong>用户自定义key需要在代理端设置，设定完之后必须重启才能生效。</strong></p><p>格式2：</p><pre><code>UserParameter=key[*],command    key：唯一的监控项key；[*]定义该key接受括号内的参数    command：执行的命令</code></pre><p><strong>注意：可以使用命令中的位置引用监控项key中的相应参数。不管使用双引号还是单引号，都会解析位置引用。要使用位置引用不变，需使用”$$”</strong></p><h2 id="二、Zabbix安装"><a href="#二、Zabbix安装" class="headerlink" title="二、Zabbix安装"></a>二、Zabbix安装</h2><p>使用创建仓库的方式安装。</p><p>地址为：<img src="http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-2.el7.noarch.rpm" alt=""></p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p><code>[root@node4~]#yum install -y http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-2.el7.noarch.rpm</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-21_204201.jpg" alt=""></p><h4 id="一台主机上安装"><a href="#一台主机上安装" class="headerlink" title="一台主机上安装"></a>一台主机上安装</h4><blockquote><p>mariadb安装</p></blockquote><p>由于Zabbix数据时存储在database中需要数据存放，这里安装mariadb</p><p><code>[root@node4~]#yum install -y mariadb-server</code></p><p><code>[root@node4~]#systemctl start mariadb.service</code> 启动mariadb服务</p><p><code>[root@node4~]#mysql_secure_installation</code>  #基于安全考虑执行此命令，取出空密码等操作</p><p><code>MariaDB [(none)]&gt; CREATE DATABASE zabbix;</code>     #创建存放表的数据库</p><p><code>MariaDB [(none)]&gt; GRANT ALL ON zabbix.* TO &#39;zbxuser&#39;@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39;;</code>    #授权用户</p><p><code>[root@node4~]#yum install -y zabbix-server-mysql zabbix-web zabbix-web-mysql zabbix-agent zabbix-get zabbix-sender</code>       #安装所需要的包</p><table><thead><tr><th>包名</th><th>说明</th></tr></thead><tbody><tr><td>zabbix-server-mysql</td><td>连接后端mysql包</td></tr><tr><td>zabbix-web</td><td>zabbix的web展示接口</td></tr><tr><td>zabbix-server</td><td>zabbix作为监控端提供服务程序包</td></tr><tr><td>zabbix-agent</td><td>zabbix的agent用于做为客户端交互接口</td></tr><tr><td>zabbix-get</td><td>zabbix的get工具，手动调试使用</td></tr><tr><td>zabbix-sender</td><td>zabbix的sender工具，手动调试使用</td></tr></tbody></table><p><strong>zabbix中web是基于LAMP环境构建的，所以在安装时自动安装了所需要的包。如果分开安装需要先搭建LAMP环境。</strong></p><blockquote><p>初始化数据库</p></blockquote><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-21_210721.jpg" alt=""></p><p><code>[root@node4~]#unzip /usr/share/doc/zabbix-server-mysql-3.4.4/create.sql.gz</code>    #解压</p><p><code>[root@node4~]#mysql -uroot -p zabbix &lt; /usr/share/doc/zabbix-server-mysql-3.4.4/create.sql</code>    #将表导入创建的数据库中</p><p><strong>注意：这里需要制定导入数据库的名称。</strong></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-21_211657.jpg" alt=""></p><h4 id="zabbix-server-conf文件"><a href="#zabbix-server-conf文件" class="headerlink" title="zabbix_server.conf文件"></a>zabbix_server.conf文件</h4><p><code>[root@node4~]#grep &#39;####&#39; /etc/zabbix/zabbix_server.conf</code></p><pre><code>############ GENERAL PARAMETERS #################   全局参数设置############ ADVANCED PARAMETERS ################   高级参数设置####### LOADABLE MODULES #######    模块设置####### TLS-RELATED PARAMETERS #######  加密设置</code></pre><p><code>[root@node4~]#grep &#39;###&#39; /etc/zabbix/zabbix_server.conf</code>  #可以查看每个块中的选项类型</p><p><code>[root@node4~]#vim /etc/zabbix/zabbix_server.conf</code> #修改服务配置文件</p><pre><code>ListenPort=10051    设置监听端口SourceIP=192.168.4.64 绑定地址LogFile=/var/log/zabbix/zabbix_server.log   日志文件位置LogFileSize=0   日志文件大小DebugLevel=3   日志级别PidFile=/var/run/zabbix/zabbix_server.pid   pid文件SocketDir=/var/run/zabbix   socket文件DBHost=192.168.4.64 数据库主机DBName=zabbix   数据库名DBUser=zbxuser  数据库用户DBPassword=centos   数据库密码DBSocket=/tmp/mysql.sock    数据库socket文件DBPort=3306 数据库端口</code></pre><blockquote><p>设置时区</p></blockquote><p><strong>方法一：</strong></p><p>在<code>/etc/php.ini</code>配置文件中设置</p><pre><code>date.timezone   </code></pre><h5 id="这种方法设置对php程序都有效。"><a href="#这种方法设置对php程序都有效。" class="headerlink" title="这种方法设置对php程序都有效。"></a>这种方法设置对php程序都有效。</h5><p><strong>方法二：</strong></p><p>在<code>/etc/httpd/conf.d/zabbix/conf</code>配置文件中设置</p><pre><code>php_value date.timezone</code></pre><h5 id="这种方法设置仅对zabbix程序有效。"><a href="#这种方法设置仅对zabbix程序有效。" class="headerlink" title="这种方法设置仅对zabbix程序有效。"></a>这种方法设置仅对zabbix程序有效。</h5><p><code>[root@node4~]#vim /etc/httpd/conf.d/zabbix.conf</code></p><pre><code>php_value date.timezone Asia/Shanghai</code></pre><p><code>[root@node4~]#systemctl start zabbix-server.service</code>  启动服务</p><p><code>[root@node4~]#systemctl start httpd.service</code>   #启动httpd服务</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><a href="http://192.168.4.64/zabbix/setup.php" target="_blank" rel="noopener">http://192.168.4.64/zabbix/setup.php</a></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-21_214628.jpg" alt=""></p><h5 id="出现这个界面初步已经搭建成功"><a href="#出现这个界面初步已经搭建成功" class="headerlink" title="出现这个界面初步已经搭建成功"></a>出现这个界面初步已经搭建成功</h5><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-21_214738.jpg" alt=""></p><h5 id="如果配置不正确，有的选项会显示false。"><a href="#如果配置不正确，有的选项会显示false。" class="headerlink" title="如果配置不正确，有的选项会显示false。"></a>如果配置不正确，有的选项会显示false。</h5><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-21_233644.jpg" alt=""></p><h5 id="这里填写创建数据库的名称，密码等"><a href="#这里填写创建数据库的名称，密码等" class="headerlink" title="这里填写创建数据库的名称，密码等"></a>这里填写创建数据库的名称，密码等</h5><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-21_234016.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-21_234126.jpg" alt=""></p><p><strong>建议：登陆以后修改密码</strong></p><p>分别在三台主机安装<br>-</p><h3 id="安装database"><a href="#安装database" class="headerlink" title="安装database"></a>安装database</h3><p><code>[root@node3~]#yum install -y mariadb-server</code></p><p><code>[root@node3~]#systemctl start mariadb.service</code></p><p><code>[root@node3~]#mysql_secure_installation</code></p><p><code>MariaDB [(none)]&gt; CREATE DATABASE zabbix;</code></p><p><code>MariaDB [(none)]&gt; GRANT ALL ON zabbix.* TO &#39;zbxuser&#39;@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39;;</code></p><h3 id="安装web-GUI"><a href="#安装web-GUI" class="headerlink" title="安装web GUI"></a>安装web GUI</h3><p><code>[root@node2~]#yum install -y httpd php php-mysql php-mbstring php-gd php-bcmath php-ldap php-xml</code></p><p><code>[root@node2~]#yum install -y zabbix-web zabbix-sender</code></p><p><code>[root@node2~]#vim /etc/httpd/conf.d/zabbix.conf</code></p><pre><code>php_value date.timezone Asia/Shanghai</code></pre><p><code>[root@node2~]#systemctl start httpd.service</code></p><h3 id="安装server端"><a href="#安装server端" class="headerlink" title="安装server端"></a>安装server端</h3><p><code>[root@node1~]#yum install -y zabbix-server-mysql zabbix-get</code></p><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p><code>[root@node1~]#scp /usr/share/doc/zabbix-server-mysql-3.4.4/create.sql.gz 192.168.4.63:/root/test.sql.gz</code></p><p><code>[root@node3~]#gzip -d test.sql.gz</code></p><p><code>[root@node3~]#mysql -uroot -p zabbix &lt;test.sql</code></p><h3 id="编辑zabbix-server-conf配置文件"><a href="#编辑zabbix-server-conf配置文件" class="headerlink" title="编辑zabbix_server.conf配置文件"></a>编辑<code>zabbix_server.conf</code>配置文件</h3><pre><code>ListenPort=10051LogFile=/var/log/zabbix/zabbix_server.logLogFileSize=0DebugLevel=3PidFile=/var/run/zabbix/zabbix_server.pidSocketDir=/var/run/zabbixDBHost=192.168.4.63DBName=zabbixDBUser=zbxuserDBPassword=centosDBPort=3306</code></pre><p><code>[root@node1~]#systemctl status zabbix-server.service</code></p><p>在地址栏输入：<br><a href="http://192.168.4.62/zabbix/" target="_blank" rel="noopener">http://192.168.4.62/zabbix/</a></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-22_193458.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-22_193706.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-22_193814.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-22_193946.jpg" alt=""></p><h4 id="图中信息介绍"><a href="#图中信息介绍" class="headerlink" title="图中信息介绍"></a>图中信息介绍</h4><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-22_194133.jpg" alt=""></p><pre><code>Zabbix server is running    Yes    192.168.4.61:10051     #显示zabbix是否正常运行以及IP及端口Number of hosts (enabled/disabled/templates)    76    0 / 1 / 75    0：表示是否已经启用的主机    1：表示不可用的主机    75：表示模板数量Number of items (enabled/disabled/not supported)    68    0 / 68 / 0    0：表示启用的监控项    68：没有启动的监控项    0：监控项是否不支持Number of triggers (enabled/disabled [problem/ok])    46    0 / 46 [0 / 0]    0：表示启动的触发器    46：未启用的触发器    [0/0]：表示状态Number of users (online)    2    2    2：表示用户Required server performance, new values per second    0        0：表示每秒的值</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="在node5上安装"><a href="#在node5上安装" class="headerlink" title="在node5上安装"></a>在node5上安装</h4><p><code>[root@node5~]#wget http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-2.el7.noarch.rpm</code><br><code>[root@node5~]#rpm -ivh zabbix-release-3.4-2.el7.noarch.rpm</code></p><p><code>[root@node5~]#yum install -y zabbix-agent zabbix-sender</code></p><h5 id="编辑-etc-zabbix-zabbix-agent-conf配置文件"><a href="#编辑-etc-zabbix-zabbix-agent-conf配置文件" class="headerlink" title="编辑/etc/zabbix/zabbix_agent.conf配置文件"></a>编辑<code>/etc/zabbix/zabbix_agent.conf</code>配置文件</h5><pre><code>PidFile=/var/run/zabbix/zabbix_agentd.pid   #pid文件LogFile=/var/log/zabbix/zabbix_agentd.log   #日志存放位置LogFileSize=0   #是否滚动日志DebugLevel=3    #日志级别SourceIP=192.168.4.65   #监听地址，如果有多个地址需要指定EnableRemoteCommands=1  #是否启用远程命令LogRemoteCommands=1 #是否记录执行的远程命令Server=192.168.4.61 #Zabbix Server 地址ListenPort=10050    #监听的端口ListenIP=192.168.4.65StartAgents=3ServerActive=192.168.4.61   #是否主动监听Hostname=node5  #Zabbix Agent主机名</code></pre><h4 id="创建一个主机（host）"><a href="#创建一个主机（host）" class="headerlink" title="创建一个主机（host）"></a>创建一个主机（host）</h4><p><img src="http://owatlfstl.bkt.clouddn.com/zabbix01.gif" alt=""></p><h4 id="定义一个item（监控项）"><a href="#定义一个item（监控项）" class="headerlink" title="定义一个item（监控项）"></a>定义一个item（监控项）</h4><p><img src="http://owatlfstl.bkt.clouddn.com/zabbix02.gif" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-22_230317.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/zabbix03.gif" alt=""></p><h3 id="创建trigger"><a href="#创建trigger" class="headerlink" title="创建trigger"></a>创建trigger</h3><p><code>[root@node5~]#vim /etc/nginx/nginx.conf</code></p><pre><code> 53         location /status { 54             stub_status on; 55             allow 192.168.4.0/24; 56             deny all; 57         }</code></pre><p><code>[root@node5~]#systemctl start nginx.service</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-22_232237.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/zabbix04.gif" alt=""></p><h3 id="定义action"><a href="#定义action" class="headerlink" title="定义action"></a>定义action</h3><p><img src="http://owatlfstl.bkt.clouddn.com/zabbix05.gif" alt=""></p><h6 id="如果在远程执行命令需要对zabbix用户给予权限。"><a href="#如果在远程执行命令需要对zabbix用户给予权限。" class="headerlink" title="如果在远程执行命令需要对zabbix用户给予权限。"></a>如果在远程执行命令需要对zabbix用户给予权限。</h6><p><code>[root@node5~]#visudo</code><br>zabbix ALL=(ALL) NOPASSWOD: ALL</p><h6 id="需要在agent端开启执行远程命令的选项"><a href="#需要在agent端开启执行远程命令的选项" class="headerlink" title="需要在agent端开启执行远程命令的选项"></a>需要在agent端开启执行远程命令的选项</h6><p><code>[root@node5~]#vim /etc/zabbix/zabbix_agentd.conf</code></p><pre><code> EnableRemoteCommands=1 LogRemoteCommands=1</code></pre><h3 id="创建template"><a href="#创建template" class="headerlink" title="创建template"></a>创建template</h3><p><img src="http://owatlfstl.bkt.clouddn.com/zabbix06.gif" alt=""></p><p>#######下面的操作就和创建item、action、traggers等一样。</p><h3 id="创建screen"><a href="#创建screen" class="headerlink" title="创建screen"></a>创建screen</h3><p><img src="http://owatlfstl.bkt.clouddn.com/zabbix07.gif" alt=""></p><h3 id="创建slide-show"><a href="#创建slide-show" class="headerlink" title="创建slide show"></a>创建slide show</h3><p><img src="http://owatlfstl.bkt.clouddn.com/zabbix08.gif" alt=""></p><h3 id="web监控"><a href="#web监控" class="headerlink" title="web监控"></a>web监控</h3><p>web场景包括一个或多个HTTP请求或”步骤”。Zabbix服务器根据预定义的命令周期性的执行这些步骤。</p><h6 id="所有web收集的数据："><a href="#所有web收集的数据：" class="headerlink" title="所有web收集的数据："></a>所有web收集的数据：</h6><pre><code>整个场景中所有步骤的下载速度失败的步骤数量最后一次错误信息</code></pre><h6 id="对于web场景的所有步骤收集的数据"><a href="#对于web场景的所有步骤收集的数据" class="headerlink" title="对于web场景的所有步骤收集的数据"></a>对于web场景的所有步骤收集的数据</h6><pre><code>平均下载速度响应时间HTTP状态码</code></pre><p>参考地址：<a href="https://www.zabbix.com/documentation/3.4/zh/manual/web_monitoring" target="_blank" rel="noopener">https://www.zabbix.com/documentation/3.4/zh/manual/web_monitoring</a></p><h3 id="网络发现"><a href="#网络发现" class="headerlink" title="网络发现"></a>网络发现</h3><p>Zabbix提供了有效和非常灵活的网络自动发现功能。包括发现（discovery）和动作（action）</p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><pre><code>加快Zabbix部署简化管理无需过多管理就能快速变化的环境中使用Zabbix</code></pre><h5 id="网络发现方式"><a href="#网络发现方式" class="headerlink" title="网络发现方式"></a>网络发现方式</h5><pre><code>IP范围可用的外部服务zabbix agent信息snmp agetn信息    </code></pre><h5 id="网络发现模块每次检测到service和host都会生成一个discovey时间"><a href="#网络发现模块每次检测到service和host都会生成一个discovey时间" class="headerlink" title="网络发现模块每次检测到service和host都会生成一个discovey时间"></a>网络发现模块每次检测到service和host都会生成一个discovey时间</h5><p>|<br>|Service Discovered    |服务首次被发现或者由’down’变’up’<br>|Service Up    |服务持续 ‘up’<br>|Service Lost    |服务由 ‘up’ 变 ‘down’<br>|Service Down    |服务持续 ‘down’<br>|Host Discovered    |在主机的所有服务都 ‘down’ 之后，至少一个服务是’up’。<br>|Host Up    |主机至少有一个服务是 ‘up’ 状态<br>|Host Lost|    主机的所有服务在至少一个是 ‘up’ 之后全部是 ‘down’。<br>|Host Down    |所有服务都持续 ‘down’</p><h5 id="采取的动作"><a href="#采取的动作" class="headerlink" title="采取的动作"></a>采取的动作</h5><pre><code>发送通知添加/删除主机启用/禁用主机添加主机到组从组中删除主机将主机链接到模板/从模板中取消链接执行远程脚本命令</code></pre><h3 id="JMX监控"><a href="#JMX监控" class="headerlink" title="JMX监控"></a>JMX监控</h3><p>JMX监控可用于监视java应用程序的JMX计数器。</p><h5 id="为java应用程序启用远程JMX监视功能"><a href="#为java应用程序启用远程JMX监视功能" class="headerlink" title="为java应用程序启用远程JMX监视功能"></a>为java应用程序启用远程JMX监视功能</h5><p>编辑<code>/etc/sysconfig/tomcat</code>配置文件</p><pre><code>CATALINA_OPTS=&quot;-Djava.rmi.server.hostname=TOMCAT_SERVER_IP -Djavax.management.builder.initial= -Dcom.sun.management.jmxremote=true   -Dcom.sun.management.jmxremote.port=12345  -Dcom.sun.management.jmxremote.ssl=false  -Dcom.sun.management.jmxremote.authenticate=false&quot;</code></pre><h5 id="在Zabbix-Web管理段配置JMX接口"><a href="#在Zabbix-Web管理段配置JMX接口" class="headerlink" title="在Zabbix Web管理段配置JMX接口"></a>在Zabbix Web管理段配置JMX接口</h5><pre><code>JavaGateway=192.168.3.14JavaGatewayPort=10052StartJavaPollers=5</code></pre><h5 id="在Zabbix-Web添加监控项"><a href="#在Zabbix-Web添加监控项" class="headerlink" title="在Zabbix Web添加监控项"></a>在Zabbix Web添加监控项</h5><pre><code>jmx[&quot;java.lang:type=Memory&quot;,&quot;HeapMemoryUsage.used&quot;]    object name 代表MBean的对象名称    attribute name 一个MBean属性名称，可选的符合数据字段名称以点分隔</code></pre><p><strong>示例：</strong></p><p><code>[root@node3~]#yum install -y zabbix-agent zabbix-sender</code></p><p><code>[root@node3~]#yum install -y java-1.8.0-openjdk tomcat-admin-webapps tomcat-doc-webapp tomcat-webapps</code></p><p><code>[root@node3~]#vim /etc/sysconfig/tomcat</code></p><pre><code>28 CATALINA_OPTS=&quot;-Djava.rmi.server.hostname=192.168.4.63 -Djavax.management.builder.initial= -Dcom.sun.management.jmxremote=true   -Dcom.sun.management.jmxremote.port=12345  -Dcom.sun.management.jmxremote.ssl=false  -Dcom.sun.management.jmxremote.authenticate=false&quot;</code></pre><p><code>[root@node3~]#systemctl start tomcat.service</code><br><code>[root@node3~]#systemctl status tomcat.service</code></p><p><code>[root@node3~]#grep &#39;^[^#]&#39; /etc/zabbix/zabbix_agentd.conf</code></p><pre><code>PidFile=/var/run/zabbix/zabbix_agentd.pidLogFile=/var/log/zabbix/zabbix_agentd.logLogFileSize=0DebugLevel=3SourceIP=192.168.4.63EnableRemoteCommands=1LogRemoteCommands=1Server=192.168.4.61ListenPort=10050ServerActive=192.168.4.61Hostname=node3</code></pre><p><code>[root@node3~]#systemctl start zabbix-agent.service</code><br><code>[root@node3~]#systemctl status zabbix-agent.service</code></p><p>Zabbix Server配置<br>-</p><p><code>[root@node1~]#yum install -y zabbix-java-gateway</code></p><p><code>[root@node1~]#vim /etc/zabbix/zabbix_server.conf</code></p><pre><code>JavaGateway=192.168.4.61JavaGatewayPort=10052StartJavaPollers=5</code></pre><p><code>[root@node1~]#systemctl start zabbix-java-gateway.service</code></p><p><code>[root@node1~]#systemctl status zabbix-java-gateway.service</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-23_140540.jpg" alt=""></p><h4 id="进行配置"><a href="#进行配置" class="headerlink" title="进行配置"></a>进行配置</h4><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-23_140657.jpg" alt=""></p><h5 id="导入模板即可"><a href="#导入模板即可" class="headerlink" title="导入模板即可"></a>导入模板即可</h5><h3 id="Zabbix-Proxy"><a href="#Zabbix-Proxy" class="headerlink" title="Zabbix Proxy"></a>Zabbix Proxy</h3><p>zabbix proxy可以替代zabbix server收集性能和可用性数据，然后把数据汇报给zabbix server，并且在一定程度上分担了zabbix server的压力。</p><h5 id="zabbix-proxy使用场景"><a href="#zabbix-proxy使用场景" class="headerlink" title="zabbix proxy使用场景"></a>zabbix proxy使用场景</h5><ul><li>监控远程区域设备</li><li>监控本地网络不稳定区域</li><li>当zabbix监控上千设备时，使用它来减轻server的压力</li><li>简化分布式监控的维护</li></ul><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-23_144642.jpg" alt=""></p><p><strong>注意：使用agent active模式，一定要在agent配置文件参数ServerActive加上proxy的IP地址。</strong></p><p><strong>示例：</strong></p><p><code>[root@node4~]#yum install -y zabbix-proxy-mysql zabbix-get zabbix-agent zabbix-sender</code></p><p><code>[root@node4~]#yum install -y mariadb-server</code></p><p><code>MariaDB [(none)]&gt; CREATE DATABASE zbxdb CHARACTER &#39;utf8&#39;;</code></p><p><code>MariaDB [(none)]&gt; GRANT ALL ON zbxdb.* TO  &#39;zbxuser&#39;@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39;;</code></p><p><code>[root@node4~]#mysql -uroot -p zabbix &lt; test.sql</code></p><p><code>[root@node4~]#grep &#39;^[^#]&#39; /etc/zabbix/zabbix_proxy.conf</code></p><pre><code>Server=192.168.4.61ServerPort=10051Hostname=node4LogFile=/var/log/zabbix/zabbix_proxy.logLogFileSize=0PidFile=/var/run/zabbix/zabbix_proxy.pidSocketDir=/var/run/zabbixDBHost=192.168.4.64DBName=zbxdbDBUser=zbxuserDBPassword=centosDBPort=3306ConfigFrequency=10  #根据实际生产中修改DataSenderFrequency=1</code></pre><p><code>[root@node4~]#systemctl restart zabbix-proxy.service</code><br><code>[root@node4~]#systemctl status zabbix-proxy.service</code></p><p><code>[root@node5~]#vim /etc/zabbix/zabbix_agentd.conf</code></p><pre><code>Server=192.168.4.61,192.168.4.64ServerActive=192.168.4.61,192.168.4.64</code></pre><p><strong>需要在被代理主机上填入代理主机的地址</strong></p><p><code>[root@node5~]#systemctl restart zabbix-agent.service</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-23_152252.jpg" alt=""></p><h3 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h3><p><strong>示例：</strong></p><p><code>[root@node2~]#yum install -y net-snmp net-snmp-utils</code><br><code>[root@node2~]#systemctl start snmpd.service</code><br><code>[root@node2~]#systemctl status snmpd.service</code></p>]]></content>
      
      
      <categories>
          
          <category> 监控系统 </category>
          
          <category> Zabbix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible常用模块</title>
      <link href="/2017/11/28/ansible%E6%A8%A1%E5%9D%97/"/>
      <url>/2017/11/28/ansible%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="常用模块介绍"><a href="#常用模块介绍" class="headerlink" title="常用模块介绍"></a>常用模块介绍</h2><p><strong>ansible中执行命令时，必须考虑其幂等性；即返回的结果不是错误的。如果一个文件存在则不再创建等等情况。</strong></p><p>（1）command模块：在远程节点执行命令，此模块为默认模块</p><table><thead><tr><th>action</th><th>说明</th></tr></thead><tbody><tr><td>chdir</td><td>执行命令切换工作目录至指定位置</td></tr><tr><td>creates</td><td>如果此处给定的文件或目录存在，则不执行命令</td></tr><tr><td>remove</td><td>如果给定的文件后目录不存在，则不执行命令；即存在才执行此命令</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@localhost~]#ansible all -m command -a &quot;pwd chdir=/etc/&quot;</code></p><p><code>[root@localhost~]#ansible all -m command -a &quot;pwd chdir=/etc/ansible creates&quot;</code></p><p>（2）shell模块：执行命令在节点上。</p><p>这个模块解决了echo等情况的问题，如果给一个用户添加密码执行如下指令会报错：</p><p><code>[root@localhost~]#ansible all -m command -a &quot;echo test | passwd --stdin test&quot;</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-18_105723.jpg" alt=""></p><p>因此shell解决了这个问题，支持管道传输命令。</p><table><thead><tr><th>action</th><th>说明</th></tr></thead><tbody><tr><td>chdir</td><td>在执行命令前切换目录</td></tr><tr><td>creates</td><td>如果一个文件已经存在则不执行命令</td></tr><tr><td>removes</td><td>如果一个给定的文件不存在则不执行命令</td></tr><tr><td>excutable</td><td>指定运行命令使用的shell解释器</td></tr></tbody></table><p><code>[root@localhost~]#ansible all -m command -a &quot;useradd joah &quot;</code></p><p><code>[root@localhost~]#ansible all -m shell -a &quot;echo centos |passwd --stdin joah&quot;</code></p><p>（3）copy模块：复制文件到远程主机</p><table><thead><tr><th>action</th><th>说明</th></tr></thead><tbody><tr><td>dest</td><td>指定远程绝对路径</td></tr><tr><td>group</td><td>设置文件的所属组</td></tr><tr><td>mode</td><td>设置文件的权限</td></tr><tr><td>owner</td><td>设置文件的所有者</td></tr><tr><td>src</td><td>设定本地的文件路径，可以使用相对路径也可以使用绝对路径</td></tr><tr><td>content</td><td>指定复制的内容</td></tr></tbody></table><p><code>[root@localhost~]#ansible all -m copy -a &quot;src=&#39;/etc/hosts&#39; dest=/root/hosts group=joah owner=joah mode=644  &quot;</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-18_120322.jpg" alt=""></p><p><code>[root@localhost~]#ansible all -m copy -a &quot;context=&#39;hello ansible&#39; dest=/tmp owner=joah group=joah mode=666&quot;</code> 这种使用方法需要在template中使用</p><p>（4）fetch模块：把远程文件复制到本地，此时只能点对点复制</p><table><thead><tr><th>action</th><th>说明</th></tr></thead><tbody><tr><td>dest</td><td>目标地址</td></tr><tr><td>src</td><td>源文件路径或文件</td></tr></tbody></table><p><code>[root@localhost~]#ansible 192.168.4.61 -m fetch -a &quot;src=&#39;/etc/fstab&#39; dest=&#39;/root/&#39;&quot;</code></p><p>（5）file模块：设置文件属性</p><table><thead><tr><th>action</th><th>说明</th></tr></thead><tbody><tr><td>group</td><td>设置所属组</td></tr><tr><td>mode</td><td>设置权限</td></tr><tr><td>owner</td><td>设置所有者</td></tr><tr><td>path</td><td>要修改文件的路径</td></tr><tr><td>src</td><td>原文件路径</td></tr><tr><td>state</td><td>如果为link设置软连接；如果是hard设置硬链接；如果是absent，如果存在则删除；如果为touch，如果要创建的文件不存在则创建一个空文件；</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@localhost~]#ansible all -m file -a &quot;path=/root/test1 state=directory&quot;</code>  创建目录</p><p><code>[root@localhost~]#ansible all -m file -a &quot;path=/root/test1/hidb state=touch&quot;</code>  创建空文件</p><p><code>[root@localhost~]#ansible all -m file -a &quot;path=/root/host src=/root/test1/hidb state=link&quot;</code>    创建软连接</p><p><code>[root@localhost~]#ansible all -m file -a &quot;path=/root/host src=/root/test1/hidb state=absent&quot;</code> 删除软连接</p><p>（6）user模块：管理用户账户</p><table><thead><tr><th>action</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>用户名</td></tr><tr><td>password</td><td>设置用户的密码</td></tr><tr><td>createhome</td><td>是否创建家目录</td></tr><tr><td>local</td><td>设定时区</td></tr><tr><td>system</td><td>是否设置为系统用户</td></tr><tr><td>uid</td><td>指定uid</td></tr><tr><td>shell</td><td>设置使用的shell类型</td></tr><tr><td>group</td><td>设置组</td></tr><tr><td>groups</td><td>设置附加组</td></tr><tr><td>comment</td><td>添加注释信息</td></tr><tr><td>home</td><td>指定家目录位置</td></tr></tbody></table><p><strong>注意：如果用户的属性修改可以直接执行命令修改</strong></p><p><strong>示例：</strong></p><p><code>[root@localhost~]#ansible all -m user -a &quot;name=hello password=centos createhome=yes system=no shell=/sbin/nologin &quot;</code></p><p>（7）group模块：管理组</p><table><thead><tr><th>action</th><th>说明</th></tr></thead><tbody><tr><td>gid</td><td>设置组ID</td></tr><tr><td>name</td><td>设置组名</td></tr><tr><td>state</td><td>如果present，如果用户存在则不创建，如果absent，用户删除时需存在组</td></tr><tr><td>system</td><td>是否创建系统用户</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@localhost~]#ansible all -m group -a &quot;name=hi gid=1005 state=present&quot;</code>    创建组</p><p><code>[root@localhost~]#ansible all -m group -a &quot;name=hi state=absent&quot;</code> 删除用户</p><p>（8）get_url：下载文件从HTTP、HTTPS、或者FTP到节点上</p><table><thead><tr><th>action</th><th>说明</th></tr></thead><tbody><tr><td>checksum</td><td>是否检查</td></tr><tr><td>dest</td><td>目标地址</td></tr><tr><td>force</td><td>no，如果目标路径存在且为空则下载；yes如果目标不是目录则覆盖原来的文件</td></tr><tr><td>url</td><td>指定url</td></tr><tr><td>url_password</td><td>如果下载链接需要使用密码则给定</td></tr><tr><td>url_username</td><td>如果下载链接需要使用用户则给定</td></tr><tr><td>use_proxy</td><td>如果为no则不使用代理</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@localhost~]#ansible all -m get_url -a &quot;url=https://www.percona.com/downloads/percona-toolkit/3.0.4/binary/redhat/7/x86_64/percona-toolkit-3.0.4-1.el7.x86_64.rpm dest=/root&quot;</code></p><p>（9）hostname模块：管理主机名</p><table><thead><tr><th>action</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>主机名称</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@localhost~]#ansible 192.168.4.61 -m hostname -a &quot;name=node6&quot;</code></p><p>（10）pip模块：Manages Python library dependencies.管理Python库依赖关系</p><table><thead><tr><th>action</th><th>说明</th></tr></thead><tbody><tr><td>chdir</td><td>切换目录</td></tr><tr><td>state</td><td>forcereinstall是否强制重装</td></tr></tbody></table><p>（11）yum模块：管理yum包</p><table><thead><tr><th>action</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>包名</td></tr><tr><td>state</td><td>是否安装；present、installed和latest表示安装；remove、absent和remove表示卸载</td></tr><tr><td>list</td><td>列出</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@localhost~]#ansible all -m yum -a &quot;name=nginx state=latest&quot;</code></p><p>（12）service模块：管理服务</p><table><thead><tr><th>action</th><th>说明</th></tr></thead><tbody><tr><td>arguments</td><td>添加参数</td></tr><tr><td>enabled</td><td>是否设置为开启启动</td></tr><tr><td>name</td><td>服务名</td></tr><tr><td>state</td><td>started启动；stopped停止；restarted重启；</td></tr><tr><td>runlevel</td><td>设定运行级别</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@localhost~]#ansible all -m service -a &quot;name=nginx state=started enabled=yes&quot;</code></p><p>（13）git模块：部署软件从git导出</p><table><thead><tr><th>action</th><th>说明</th></tr></thead><tbody><tr><td>repo</td><td>仓库路径</td></tr><tr><td>dest</td><td>目标路径</td></tr><tr><td>version</td><td>版本</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@localhost~]#ansible all -m git -a &quot;repo=https://github.com/mbdavid/FileDB.git dest=/root/test1&quot;</code></p><p>（14）haproxy模块：管理代理</p><table><thead><tr><th>action</th><th>说明</th></tr></thead><tbody><tr><td>backend</td><td>代理后端池</td></tr><tr><td>host</td><td>修改后端主机名称</td></tr><tr><td>state</td><td>后端主机状态</td></tr><tr><td>weight</td><td>设置权重</td></tr></tbody></table><p>（15）cron模块：管理计划任务</p><table><thead><tr><th>action</th><th>说明</th></tr></thead><tbody><tr><td>minute</td><td>设定分钟，0-59, <em>, </em>/2,</td></tr><tr><td>month</td><td>设定月份， 1-12, <em>, </em>/2,</td></tr><tr><td>name</td><td>计划任务名称，</td></tr><tr><td>hour</td><td>设定小时</td></tr><tr><td>day</td><td>设置天</td></tr><tr><td>job</td><td>设定任务</td></tr><tr><td>disabled</td><td>是否禁用任务</td></tr><tr><td>state</td><td>如果为present则创建，如果为absent删除</td></tr></tbody></table><p><strong>注意：若果name没有设置并且state=present，如果一个新的任务创建，将覆盖原来的任务</strong></p><p><strong>示例：</strong></p><p><code>[root@localhost~]#ansible all -m cron -a &quot;name=test job=&#39;ntpdate 172.18.0.1 &amp;&gt; /dev/null&#39; hour=*/2&quot;</code></p><p>（16）setup模块：收集远程主机信息</p>]]></content>
      
      
      <categories>
          
          <category> 自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ansible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zabbix基于微信告警</title>
      <link href="/2017/11/28/Zabbix%E5%9F%BA%E4%BA%8E%E5%BE%AE%E4%BF%A1%E5%91%8A%E8%AD%A6/"/>
      <url>/2017/11/28/Zabbix%E5%9F%BA%E4%BA%8E%E5%BE%AE%E4%BF%A1%E5%91%8A%E8%AD%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="在zabbix监控中，国内越来越流行使用微信、钉钉、邮件报警，这正式结合了当下的发展趋势。接下来介绍下zabbix如何结合微信发送警报信息。"><a href="#在zabbix监控中，国内越来越流行使用微信、钉钉、邮件报警，这正式结合了当下的发展趋势。接下来介绍下zabbix如何结合微信发送警报信息。" class="headerlink" title="在zabbix监控中，国内越来越流行使用微信、钉钉、邮件报警，这正式结合了当下的发展趋势。接下来介绍下zabbix如何结合微信发送警报信息。"></a>在zabbix监控中，国内越来越流行使用微信、钉钉、邮件报警，这正式结合了当下的发展趋势。接下来介绍下zabbix如何结合微信发送警报信息。</h3><h2 id="一、企业微信注册"><a href="#一、企业微信注册" class="headerlink" title="一、企业微信注册"></a>一、企业微信注册</h2><p>企业微信注册地址：<a href="https://work.weixin.qq.com/" target="_blank" rel="noopener">https://work.weixin.qq.com/</a></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-25_105258.jpg" alt=""></p><ul><li><img src="http://owatlfstl.bkt.clouddn.com/2017-11-25_105410.jpg" alt=""></li></ul><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-25_105630.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-25_105928.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-25_110351.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-25_110441.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-25_110634.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-25_110922.jpg" alt=""><br><strong>注意：我们需要记录以下几个值：</strong></p><pre><code>AgentldSecretCorpID部门ID</code></pre><h2 id="二、下载脚本"><a href="#二、下载脚本" class="headerlink" title="二、下载脚本"></a>二、下载脚本</h2><p><code>[root@node1~]#wget https://www.guoxiangfu.com/wechat</code></p><p><code>[root@node1~]#vim wechat</code></p><pre><code>  1 #!/usr/bin/env python   #如果是python修改为python3 即可  2 # -*- coding: utf-8 -*-  3 ## File Name: wechat.sh  6 reload(sys)  7 sys.setdefaultencoding( &quot;utf-8&quot; )  8   9 class WeChat(object): 10         __token_id = &#39;&#39; 11         # init attribute 12         def __init__(self,url): 13                 self.__url = url.rstrip(&#39;/&#39;) 14                 self.__corpid = &#39;你的Corpid&#39; 15                 self.__secret = &#39;你的SecretID&#39; 16                  17         # Get TokenID 18         def authID(self): 19                 params = {&#39;corpid&#39;:self.__corpid, &#39;corpsecret&#39;:self.__secret} 20                 data = urllib.urlencode(params) 21                  22                 content = self.getToken(data) 23                  24                 try: 25                         self.__token_id = content[&#39;access_token&#39;] 26                         # print content[&#39;access_token&#39;] 27                 except KeyError: 28                         raise KeyError 29                          30         # Establish a connection 31         def getToken(self,data,url_prefix=&#39;/&#39;): 32                 url = self.__url + url_prefix + &#39;gettoken?&#39; 33                 try: 34                         response = urllib2.Request(url + data) 35                 except KeyError:  36                         raise KeyError 37                 result = urllib2.urlopen(response) 38                 content = json.loads(result.read()) 39                 return content 40  41         # Get sendmessage url 42         def postData(self,data,url_prefix=&#39;/&#39;): 44                 request = urllib2.Request(url,data) 45                 try: 46                         result = urllib2.urlopen(request) 47                 except urllib2.HTTPError as e: 48                         if hasattr(e,&#39;reason&#39;): 49                                 print &#39;reason&#39;,e.reason 50                         elif hasattr(e,&#39;code&#39;): 51                                 print &#39;code&#39;,e.code 52                         return 0 53                 else: 54                         content = json.loads(result.read()) 55                         result.close() 56                 return content 57  58         # send message 59         def sendMessage(self,touser,message): 60  61                 self.authID() 62  63                 data = json.dumps({ 64                         &#39;touser&#39;:touser, 65                         &#39;toparty&#39;:&quot;2&quot;,  #这个相当于刚刚记录的部门ID 66                         &#39;msgtype&#39;:&quot;text&quot;, 67                         &#39;agentid&#39;:&quot;2&quot;,  #修改为刚刚记录的agentid 68                         &#39;text&#39;:{ 69                                 &#39;content&#39;:message 70                         }, 71                         &#39;safe&#39;:&quot;0&quot; 72                 },ensure_ascii=False) 73  74                 response = self.postData(data) 75                 print response 76  77  78 if __name__ == &#39;__main__&#39;: 79         a = WeChat(&#39;https://qyapi.weixin.qq.com/cgi-bin&#39;) 80         a.sendMessage(sys.argv[1],sys.argv[3])</code></pre><p>##修改权限，所有者、所属组<br><code>[root@node1~]#chmod +x wechat</code><br><code>[root@node1~]#chown zabbix.zabbix wechat</code></p><p>##验证是否可以发送成功<br><code>[root@node1~]#./wechat zabbix test test</code></p><pre><code>{u&#39;invaliduser&#39;: u&#39;zabbix&#39;, u&#39;errcode&#39;: 0, u&#39;errmsg&#39;: u&#39;ok&#39;}</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/Screenshot_20171125-112639.png" alt=""></p><p><strong>到此我们就配置好了。</strong></p><h2 id="Zabbix配置"><a href="#Zabbix配置" class="headerlink" title="Zabbix配置"></a>Zabbix配置</h2><h3 id="查看存放的脚本"><a href="#查看存放的脚本" class="headerlink" title="查看存放的脚本"></a>查看存放的脚本</h3><p><code>[root@node1~]#grep &quot;AlertScriptsPath&quot; /etc/zabbix/zabbix_server.conf</code></p><pre><code>### Option: AlertScriptsPath# AlertScriptsPath=${datadir}/zabbix/alertscriptsAlertScriptsPath=/usr/lib/zabbix/alertscripts</code></pre><p><code>[root@node1~]#mv wechat /usr/lib/zabbix/alertscripts/</code></p><p>在地址栏输入：<a href="http://192.168.4.61/zabbix/zabbix.php?action=mediatype.edit" target="_blank" rel="noopener">http://192.168.4.61/zabbix/zabbix.php?action=mediatype.edit</a></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-25_114322.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-25_204542.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-25_204859.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-25_205023.jpg" alt=""></p><h4 id="发送警报信息内容："><a href="#发送警报信息内容：" class="headerlink" title="发送警报信息内容："></a>发送警报信息内容：</h4><h5 id="故障恢复信息："><a href="#故障恢复信息：" class="headerlink" title="故障恢复信息："></a>故障恢复信息：</h5><pre><code>服务器:{HOST.NAME}: {TRIGGER.NAME}已恢复!{&quot;告警主机&quot;:&quot;{HOST.NAME}&quot;,&quot;告警地址&quot;:&quot;{HOST.IP}&quot;,&quot;告警时间&quot;:&quot;{EVENT.DATE} {EVENT.TIME}&quot;,&quot;恢复时间&quot;:&quot;{EVENT.RECOVERY.DATE} {EVENT.RECOVERY.TIME}&quot;,&quot;告警等级&quot;:&quot;{TRIGGER.SEVERITY}&quot;,&quot;告警信息&quot;:&quot;{TRIGGER.NAME}&quot;,&quot;监控项目&quot;:&quot;{ITEM.NAME}&quot;,&quot;当前状态&quot;:&quot;{TRIGGER.STATUS}&quot;,&quot;持续时间&quot;:&quot;{EVENT.AGE}&quot;,&quot;事件ID&quot;:&quot;{EVENT.ID}&quot;,&quot;监控ID&quot;:&quot;{ITEM.ID}&quot;,&quot;监控取值&quot;:&quot;{ITEM.LASTVALUE}&quot;}</code></pre><h5 id="发生故障发送的信息"><a href="#发生故障发送的信息" class="headerlink" title="发生故障发送的信息"></a>发生故障发送的信息</h5><pre><code>服务器:{HOST.NAME}发生: {TRIGGER.NAME}故障!{&quot;告警主机&quot;:&quot;{HOST.NAME}&quot;,&quot;告警地址&quot;:&quot;{HOST.IP}&quot;,&quot;告警时间&quot;:&quot;{EVENT.DATE} {EVENT.TIME}&quot;,&quot;告警等级&quot;:&quot;{TRIGGER.SEVERITY}&quot;,&quot;告警信息&quot;:&quot;{TRIGGER.NAME}&quot;,&quot;监控项目&quot;:&quot;{ITEM.NAME}&quot;,&quot;当前状态&quot;:&quot;{TRIGGER.STATUS}&quot;,&quot;持续时间&quot;:&quot;{EVENT.AGE}&quot;,&quot;事件ID&quot;:&quot;{EVENT.ID}&quot;,&quot;监控ID&quot;:&quot;{ITEM.ID}&quot;,&quot;监控取值&quot;:&quot;{ITEM.LASTVALUE}&quot;}</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="http://owatlfstl.bkt.clouddn.com/EFBC52C9B1398C609B3F59CD6C34AEFC.jpg" alt=""></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>（1）使用微信告警，必须有CorpID、AgentId和Secret。这是建立与微信通信的措施。</p><p>（2）创建过程中，建议每一步都要测试是否成功，再进行下一步。</p><p>（3）可以指定多个用户接受信息。</p>]]></content>
      
      
      <categories>
          
          <category> 监控系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axel</title>
      <link href="/2017/11/28/axel/"/>
      <url>/2017/11/28/axel/</url>
      
        <content type="html"><![CDATA[<h1 id="axel"><a href="#axel" class="headerlink" title="axel"></a>axel</h1><p>axel是 Linux 下一个不错的HTTP/FTP高速下载工具。支持多线程下载、断点续传，且可以从多个地址或者从一个地址的多个连接来下载同一个文件。适合网速不给力时多线程下载提高下载速度</p><pre><code>--max-speed=x        -s x    最大速度（字节/秒）--num-connections=x    -n x    最大连接数--output=f        -o f    指定文件名--search[=x]        -S [x]    从镜像搜索并下载--header=x        -H x    添加头部--user-agent=x        -U x    设置用户代理--no-proxy        -N    不使用任何代理--quiet            -q    静默--verbose        -v    显示更多状态信息--alternate        -a    显示简单进度条--version        -V    显示版本信息</code></pre><p>示例：</p><p><code>[root@localhost~]#axel -n 3 -o /root ftp://172.18.0.1/pub/ISOs/CentOS-6.9-x86_64-bin-DVD1.iso</code></p>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible之playbook</title>
      <link href="/2017/11/28/ansible%E4%B8%ADplaybook/"/>
      <url>/2017/11/28/ansible%E4%B8%ADplaybook/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Playbook"><a href="#一、Playbook" class="headerlink" title="一、Playbook"></a>一、Playbook</h2><h3 id="1、Playbook核心元素"><a href="#1、Playbook核心元素" class="headerlink" title="1、Playbook核心元素"></a>1、Playbook核心元素</h3><ul><li>Hosts：运行指定任务的目标主机</li><li>remote_user：在远程主机上执行任务的用户<ul><li>sudo_user：切换用户</li></ul></li><li><p>Tasks：任务列表</p><ul><li><p>格式：</p><p>  （1）action：module argument<br>  （2）module：arguments</p></li></ul></li></ul><p><strong>注意：shell和command模块后面直接跟命令，而不是key:value的参数列表</strong>    </p><ul><li><p>Variables：变量</p><p>  （1）facts：可直接调用的变量</p><pre><code>      可以使用ansible HOSTS -m setup查看</code></pre><p>  （2）用户自定义的变量</p><pre><code>      （a）在命令行中指定使用 -e ARGS或--extra-vars=VARS      （b）在playbook中定义变量的方法      vars：      - var1：values1      - var2：values2      ...</code></pre><p>  （3）通过roles传递变量<br>  （4）Host Inventory</p><pre><code>      （a）用户自定义变量             向不同主机传递不同的变量：          IP/HOSTNAME  variable=value var1=vaule1             向组中的主机传递相同的变量可以定义成一个组,可以引用多次          [groupname:vars]          variable=value      （b）invertory参数          用于定义ansible远程连接目标主机时使用的参数，而非传递给playbook的变量          ansible_ssh_host          ansible_ssh_port          ansible_ssh_user          ansible_ssh_pass          ansbile_sudo_pass                  </code></pre></li></ul><p>变量引用方法：</p><ul><li>Template：模板文件</li></ul><p><strong>注意文件名必须以“j2”结尾。</strong></p><p>格式说明：</p><pre><code>字符串：使用单引号或双引号数字：整数、浮点数列表：[item1,item2..]元组：（item1，item2...）字典：{key1:values1,key2:value2...}布尔型：true/false算数运算：+ - / *% **逻辑运算：and or not</code></pre><ul><li>Handers：由特定触发的任务</li></ul><p>当某个文件参数修改时，这样我们修改了但是并不会立即生效；有没有一个办法当我们修改以后如果某个参数只修改这个文件呢？</p><h4 id="notify和tags就是帮我们解决这个问题的。"><a href="#notify和tags就是帮我们解决这个问题的。" class="headerlink" title="notify和tags就是帮我们解决这个问题的。"></a>notify和tags就是帮我们解决这个问题的。</h4><p>notify通知给相应的handler被触发；tags指定某个服务重启。</p><h3 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h3><p>有时我们管理的主机会使不同版本的服务器，每类型服务的执行的命令有些不同，这时就需要条件判断执行。</p><p>when语句：在task中使用，jinja2的语法格式</p><pre><code>- hosts: websrvs  remote_user: root  tasks:  - name: install conf file to centos7    template: src=/root/nginx.conf.j2 dest=/etc/nginx/nginx.conf    when: ansible_distribution_major_version == &quot;7&quot;  - name: install conf file to centos6    template: src=/root/nginx.conf2.j2 dest=/etc/nginx/nginx.conf    when: ansible_distribution_majoe_version == &quot;6&quot;</code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>迭代，需要重复执行的任务</p><p>对迭代项的引用，固定变量名为“item”，要在task中使用with_items给定要迭代的元素列表</p><ul><li><p>方式一：</p><ul><li>name: install some package<br>yum: name= state=present<br>with_items：<ul><li>nginx</li><li>memcache</li><li>php-fpm</li></ul></li></ul></li><li><p>方式二：</p><ul><li>name: add some users<br>user: name= group=  state=present<br>with_items:<ul><li>{ name: ‘user1’,group: ‘group1’ }</li><li>{ name: ‘user2’,group: ‘group2’ }</li></ul></li></ul></li></ul><p>在playbook调用角色方法一：</p><pre><code>- hosts: websrvs  remote_user: root  roles:  - mysql  - memcached  - nginx</code></pre><p>在playbook调用角色方法二：</p><ul><li>hosts: websrs<br>remote_user: root<br>roles:<ul><li>{ role:nginx, username: nignx }</li></ul></li></ul><p>键role用于指定角色名称，后续的k/v用于传递变量给角色</p><h2 id="二、完整示例"><a href="#二、完整示例" class="headerlink" title="二、完整示例"></a>二、完整示例</h2><blockquote><p>安装httpd并配置</p></blockquote><p>（1）方式一：</p><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p><code>[root@localhost/etc/ansible/roles]#mkdir -pv http/{tasks,templates,files,handlers,vars,meta,default}</code></p><h3 id="创建task文件"><a href="#创建task文件" class="headerlink" title="创建task文件"></a>创建task文件</h3><p><code>[root@localhost/etc/ansible/roles/http]#vim tasks/main.yml</code></p><pre><code>  1 - name: install package httpd  2   yum: name=nginx state=latest  3 - name: create webdoc  4   file: path={{ http_doc_root }} state=directory  5 - name: service httpd service  6   service: name=nginx state=started  7 - name: configure httpd conf  8   template: src=httpd.conf.j2 dest=/etc/httpd/conf.d/  9   tags: httpconf  10   notify: reload httpd</code></pre><h3 id="创建handler文件"><a href="#创建handler文件" class="headerlink" title="创建handler文件"></a>创建handler文件</h3><p><code>[root@localhost/etc/ansible/roles/http]#vim handlers/main.yml</code></p><pre><code>  1 - name: relad httpd  2   service: name=httpd state=reloaded</code></pre><h3 id="创建vars文件"><a href="#创建vars文件" class="headerlink" title="创建vars文件"></a>创建vars文件</h3><p><code>[root@localhost/etc/ansible/roles/http]#vim vars/main.yml</code></p><pre><code>  1 http_server_port: 8080  2 http_server_name: www.test.com  3 http_doc_root: /webdate</code></pre><h3 id="创建template文件"><a href="#创建template文件" class="headerlink" title="创建template文件"></a>创建template文件</h3><p><code>[root@localhost/etc/ansible/roles/http]#vim templates/httpd.conf.j2</code></p><pre><code>  1 listen {{ http_server_port }}  2 ServerName {{ http_server_name }}  3 DocumentRoot {{ http_doc_root }}  4 &lt;Directory {{ http_doc_root }}&gt;   5     Require all granted  6 &lt;/Directory&gt;</code></pre><h3 id="创建剧本"><a href="#创建剧本" class="headerlink" title="创建剧本"></a>创建剧本</h3><p><code>[root@localhost/etc/ansible]#vim http.yml</code></p><pre><code>  1 - hosts: websrvs  2   remote_user: root  3   roles:  4   - http</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><code>[root@localhost~]#ansible-playbook   /etc/ansible/http.yml</code></p><p>实战：基于msm的tomcat集群<br>-</p><h4 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h4><table><thead><tr><th>主机名</th><th>IP</th><th>安装的包</th></tr></thead><tbody><tr><td>node1</td><td>192.168.4.61</td><td>nginx、keepalived</td></tr><tr><td>node2</td><td>192.168.4.62</td><td>nginx、keepalived</td></tr><tr><td>node3</td><td>192.168.4.63</td><td>tomcat、tomcat-docs-webapp、tomcat-webapps、tomcat-adim-webapps、java-1.8.0-openjdk、memcached-session-manager-2.1.1.jar  、memcached-session-manager-tc7-2.1.1.jar、spymemcached-2.12.3.jar  、msm-javolution-serializer-2.1.1.jar 、javolution-5.4.3.1</td></tr><tr><td>node4</td><td>192.168.4.64</td><td>tomcat、tomcat-docs-webapp、tomcat-webapps、tomcat-adim-webapps、java-1.8.0-openjdk、memcached-session-manager-2.1.1.jar  、memcached-session-manager-tc7-2.1.1.jar、spymemcached-2.12.3.jar  、msm-javolution-serializer-2.1.1.jar 、javolution-5.4.3.1</td></tr><tr><td>node5</td><td>192.168.4.65</td><td>ansible、memcached</td></tr></tbody></table><h3 id="基于ssh密钥认证"><a href="#基于ssh密钥认证" class="headerlink" title="基于ssh密钥认证"></a>基于ssh密钥认证</h3><p><code>[root@node5~]#vim ssh.sh</code></p><pre><code>  1 #!/bin/bash  2 [ ! -f /root/.ssh/id_rsa.pub ] &amp;&amp; ssh-keygen -t rsa -P &#39;&#39; &amp;&gt; /dev/null  3 while read line;do  4 expect &lt;&lt; EOF  5     spawn ssh-copy-id -i /root/.ssh/id_rsa.pub root@$line  6     expect {  7         &quot;yes/no&quot; { send &quot;yes\n&quot;;exp_continue }  8         &quot;password&quot; { send &quot;magedu\n&quot; }  9     } 10     expect eof 11 EOF 12  13 done &lt; /root/ip.txt</code></pre><p><code>[root@node5~]#vim ip.txt</code></p><pre><code>  1 192.168.4.61  2 192.168.4.62  3 192.168.4.63  4 192.168.4.64  5 192.168.4.65</code></pre><p><code>[root@node5~]#chmod +x ssh.sh</code></p><h3 id="ansible中修改主机库文件"><a href="#ansible中修改主机库文件" class="headerlink" title="ansible中修改主机库文件"></a>ansible中修改主机库文件</h3><p><code>[root@node5~]#vim /etc/ansible/hosts</code></p><pre><code> 25 [nginx-keep] 26 192.168.4.61 27 192.168.4.62 28 [tomcat-cluster] 29 192.168.4.63 30 192.168.4.64 31 [memcached] 32 192.168.4.65</code></pre><h3 id="同步时间"><a href="#同步时间" class="headerlink" title="同步时间"></a>同步时间</h3><p><code>[root@node5/etc/ansible]#vim ntp.yml</code></p><pre><code>  1 - hosts: all  2   remote_user: root  3   tasks:  4   - name: sync time  5     command: ntpdate 172.18.0.1  6   - name: chrony conf  7     file: src=/etc/chrony.conf dest=/etc/chrony.conf  8     tags: chrony  9     notify: restart chronyd.service 10   - name: start chrony 11     service: name=chronyd state=started 12   handlers: 13   - name: restart chronyd.service 14     service: name=chronyd state=restarted</code></pre><p><code>[root@node5~]#vim /etc/chrony.conf</code></p><pre><code>  7 server 172.18.0.1 iburst</code></pre><p><code>[root@node5/etc/ansible]#ansible-playbook --syntax-check ntp.yml</code> #检测语法是否正确</p><h2 id="注意：由于yaml格式对于初学者来说有一定的坑，需要严格按照格式写。"><a href="#注意：由于yaml格式对于初学者来说有一定的坑，需要严格按照格式写。" class="headerlink" title="注意：由于yaml格式对于初学者来说有一定的坑，需要严格按照格式写。"></a>注意：由于yaml格式对于初学者来说有一定的坑，需要严格按照格式写。</h2><p><code>[root@node5/etc/ansible]#ansible-playbook ntp.yml</code> #语法检测没有问题后，执行剧本</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-19_184804.jpg" alt=""></p><h5 id="温馨提示：为了以后不必要的错误，建议没此执行完以后，都要确认是否执行正确后再进行下一步"><a href="#温馨提示：为了以后不必要的错误，建议没此执行完以后，都要确认是否执行正确后再进行下一步" class="headerlink" title="温馨提示：为了以后不必要的错误，建议没此执行完以后，都要确认是否执行正确后再进行下一步"></a>温馨提示：为了以后不必要的错误，建议没此执行完以后，都要确认是否执行正确后再进行下一步</h5><h3 id="基于主机名解析"><a href="#基于主机名解析" class="headerlink" title="基于主机名解析"></a>基于主机名解析</h3><p><code>[root@node5/etc/ansible]#ansible all  -m copy -a &quot;src=/etc/hosts dest=/etc/hosts&quot;</code></p><h3 id="挂载光盘"><a href="#挂载光盘" class="headerlink" title="挂载光盘"></a>挂载光盘</h3><p><code>[root@node5~]#ansible all -m mount -a &quot;name=/media/cdrom src=/dev/sr0 state=mounted fstype=iso9660&quot;</code></p><h3 id="配置nginx角色"><a href="#配置nginx角色" class="headerlink" title="配置nginx角色"></a>配置nginx角色</h3><blockquote><p>创建所需要的目录</p></blockquote><p><code>[root@node5/etc/ansible/roles]#mkdir haproxy/{tasks,handler,files,templates,vars,default,meta} -pv</code></p><blockquote><p>创建任务文件</p></blockquote><p><code>[root@node5/etc/ansible/roles/haproxy]#vim tasks/main.yml</code> </p><pre><code>  1 - name: install haproxy package  2   yum: name=haproxy state=latest  3 - name: modify haproxy conf  4   template: src=haproxy.cfg.j2 dest=/etc/haproxy/haproxy.cfg  5   tags: haproxy  6   notify: haproxy restart  7 - name: start haproxy service  8   service: name=haproxy state=started  9 handlers: 10 - name: haproxy restart  11   service: name=haproxy state=restarted</code></pre><blockquote><p>创建模板文件</p></blockquote><p><code>[root@node5/etc/ansible/roles/haproxy]#cp /etc/haproxy/haproxy.cfg templates/haproxy.cfg.j2</code></p><pre><code> 42 defaults 43     mode                    http 44     log                     global 45     option                  httplog 46     option                  dontlognull 47     option http-server-close 48     option forwardfor       except 127.0.0.0/8 43     mode                    http 44     log                     global 45     option                  httplog 46     option                  dontlognull 47     option http-server-close 48     option forwardfor       except 127.0.0.0/8 49     option                  redispatch 50     retries                 3 51     timeout http-request    10s 52     timeout queue           1m 53     timeout connect         10s 54     timeout client          1m 55     timeout server          1m 56     timeout http-keep-alive 10s 57     timeout check           10s 58     maxconn                 3000 59  60 frontend tomcat  #定义前段并指定名称 61    bind 172.18.4.60:{{ tomcat_server_port }}    #绑定地址和端口 62  63 backend tomcat-cluster  #定义后端服务 64    balance roundrobin 65    server node3 192.168.4.63 check 66    server node4 192.168.4.64 check 67 listen      #定义管理界面 68    bind 127.0.0.1:9000 69    stats enable 70    stats uri /stats 71    stats auth joah:centos 72    stats relam &quot;tomcat&quot; 73    stats hide-version 74    stats refresh 10s 75    stats admin if TRUE</code></pre><p><strong>注意：模板文件必须以“j2”结尾。</strong>  </p><blockquote><p>创建变量文件</p></blockquote><p><code>[root@node5/etc/ansible/roles/haproxy]#vim vars/main.yml</code></p><pre><code>  1 tomcat_server_port: 80</code></pre><blockquote><p>创建触发文件</p></blockquote><p><code>[root@node5/etc/ansible/roles/haproxy]#vim handlers/main.yml</code></p><pre><code>  1 - name: haproxy restart  2   service: name=haproxy state=restarted</code></pre><p><strong>注意：创建tasks、templates、vars文件时必须以main.yml文件为入口，如果定义别的文件使用include指定即可。</strong></p><h3 id="添加IP"><a href="#添加IP" class="headerlink" title="添加IP"></a>添加IP</h3><p><code>[root@node5/etc/ansible/roles/haproxy]#ansible tomcat-cluster -m shell -a  &quot;ip addr add 192.168.4.60/24 dev eth0 &quot;</code></p><h3 id="创建keepalived角色"><a href="#创建keepalived角色" class="headerlink" title="创建keepalived角色"></a>创建keepalived角色</h3><blockquote><p>创建所需目录</p></blockquote><p><code>[root@node5/etc/ansible/roles]#mkdir keepalived/{tasks,handler,files,templates,vars,default,meta} -pv</code></p><blockquote><p>创建任务文件</p></blockquote><p><code>[root@node5/etc/ansible/roles/keepalived]#vim tasks/main.yml</code></p><pre><code>  1 - name: install keepalived package  2   yum: name=keepalived state=latest  3 - name: modify keepalived conf  4   template: src=keepalived.conf.j2 dest=/etc/keepalived/keepalived.conf  5   when: ansible_hostname == &quot;node1&quot;  6   notify: keepalived reloaded  7   tags: keepalived  8 - name: modify keepalived conf  9   template: src=keepalived.conf.j2 dest=/etc/keepalived/keepalived.conf 10   when: ansible_hostname == &quot;node2&quot; 11   notify: keepalived reloaded 12   tags: keepalived 13 - name: start keepalived 14   service: name=keepalived state=started</code></pre><blockquote><p>创建触发文件</p></blockquote><p><code>[root@node5/etc/ansible/roles/keepalived]#vim handlers/main.yml</code></p><pre><code>  1 - name: keepalived reloaded  2   service: name=keepalived state=reloaded</code></pre><blockquote><p>创建模板文件</p></blockquote><p><code>[root@node5/etc/ansible/roles/keepalived]#vim templates/keepalived.conf.j2</code>   #创建master</p><pre><code>  1 ! Configuration File for keepalived  2   3 global_defs {  4    notification_email {  5      locahost@qq.com  6    }  7    notification_email_from haproxy@qq.com  8    smtp_server 127.0.0.1  9    smtp_connect_timeout 30 10    router_id node3 11    route_mcast_group4 224.0.100.4 12    vrrp_strict chk_haproxy { 13         script &quot;killall -0 haporxy&quot; 14         interval 3 15         weight -15 16    } 17 }   18  19 vrrp_instance VI_1 { 20     state MASTER 21     interface eth0 22     virtual_router_id 4 23     priority 100 24     advert_int 1 25     authentication { 26         auth_type PASS 27         auth_pass 152369 28     }    29     virtual_ipaddress {                172.18.4.60/16 32     } 33     track_script { 34         chk_haproxy 35     } 36 }</code></pre><p><code>[root@node5/etc/ansible/roles/keepalived]#cp templates/keepalived.conf.j2 templates/keepalived.conf2.j2</code> 创建backup</p><pre><code>  1 ! Configuration File for keepalived  2   3 global_defs {  4    notification_email {  5      locahost@qq.com  6    }  7    notification_email_from haproxy@qq.com  8    smtp_server 127.0.0.1  9    smtp_connect_timeout 30 10    router_id node2 11    route_mcast_group4 224.0.100.4 12    vrrp_strict chk_haproxy { 13         script &quot;killall -0 haporxy&quot; 14         interval 3 15         weight -15 16    } 17 } 18  19 vrrp_instance VI_1 { 20     state BACKUP 21     interface eth0 22     virtual_router_id 4 23     priority 90 24     advert_int 1 25     authentication { 26         auth_type PASS 27         auth_pass 152369 28     } 29     virtual_ipaddress {              172.18.4.60/16 32     } 33     track_script { 34         chk_haproxy 35     } 36 }</code></pre><p><strong>注意：</strong></p><p><strong>（1）master和backup中<code>priority</code>、<code>state</code>需要修改，其他的配置不需要修改。</strong></p><p><strong>（2）如果使用<code>auth_type</code>认证，需要双方<code>auth_pass</code>必须相同</strong></p><p><strong>（3）如果你想使用脚本检测，<code>vrrp_script</code>可以指定脚本位置/PATH/TO/SCRIPT.sh</strong></p><h3 id="创建tomcat角色"><a href="#创建tomcat角色" class="headerlink" title="创建tomcat角色"></a>创建tomcat角色</h3><blockquote><p>创建所需要的目录</p></blockquote><p><code>[root@node5/etc/ansible/roles]#mkdir tomcat/{tasks,handlers,files,templates,vars,default,meta} -pv</code></p><blockquote><p>创建tomcat任务</p></blockquote><p><code>[root@node5/etc/ansible/roles/tomcat]#vim tasks/main.yml</code></p><pre><code> 1 - name: install tomcat package  2   yum: name={{ item }} state=latest  3   with_items:  4   - java-1.8.0-openjdk  5   - tomcat  6   - tomcat-docs-webapp  7   - tomcat-admin-webapps  8   - tomcat-webapps  9   - memcached 10 - name: modify tomcat conf 11   template: src=server.xml.j2 dest=/etc/tomcat/server.xml 12   notify: tomcat reload 13   tags: tomcat 14 - name: kryo jar 15   copy: src=/root/{{ item }}.jar dest=/usr/share/tomcat/lib/ 16   with_items: 17   - asm-6.0 18   - kryo-4.0.1 19   - kryo-serializers-0.42 20   - memcached-session-manager-2.1.1 21   - memcached-session-manager-tc7-2.1.1 22   - minlog-1.3.0 23   - msm-kryo-serializer-2.1.1 24   - objenesis-2.6 25   - reflectasm-1.11.3 26   - spymemcached-2.12.3 27 - name: start tomcat 28   service: name=tomcat state=started 29 - name: mkdir directory 30   file: path=/usr/share/tomcat/webapps/test state=directory 31 - name: touch file 32   file: path=/usr/share/tomcat/webapps/test/{{ item }} state=touch 33   with_items: 34   - WEB-INF 35   - classes 36   - lib  37 - name: copy index.jsp 38   copy: src=index.jsp.j2 dest=/usr/share/tomcat/webapps/index.jsp 39   when: ansible_hostname == &quot;node3&quot; 40   notify: tomcat reload 41   tags: tomcat 42 - name: copy index.jsp 43   copy: src=index2.jsp.j2 dest=/usr/share/tomcat/webapps/index.jsp 44   when: ansible_hostname == &quot;node4&quot; 45   notify: tomcat reload 46   tags: tomcat</code></pre><blockquote><p>创建模板文件</p></blockquote><p><code>[root@node5/etc/ansible/roles/tomcat/templates]#vim server.xml.j2</code></p><pre><code>126       &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;127             unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;128         &lt;Context path=&quot;&quot; docBase=&quot;test&quot; reloadable=&quot;&quot; /&gt;129 &lt;Context&gt;130   &lt;Manager className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot;131     memcachedNodes=&quot;n1:192.168.4.63:11211,n2:192.168.4.64:11211&quot;    #指定位置132     failoverNodes=&quot;n1&quot;133     requestUriIgnorePattern=&quot;.*\.(ico|png|gif|jpg|css|js)$&quot;134     transcoderFactoryClass=&quot;de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory&quot;135     /&gt;136 &lt;/Context&gt;</code></pre><p><code>[root@node5/etc/ansible/roles/tomcat/templates]#vim index.jsp.j2</code></p><pre><code>  1 &lt;%@ page language=&quot;java&quot; %&gt;  2 &lt;html&gt;  3         &lt;head&gt;&lt;title&gt;TomcatA&lt;/title&gt;&lt;/head&gt;  4         &lt;body&gt;  5                 &lt;h1&gt;&lt;font color=&quot;red&quot;&gt;TomcatA.test.com&lt;/font&gt;&lt;/h1&gt;  6                 &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt;  7                         &lt;tr&gt;  8                                 &lt;td&gt;Session ID&lt;/td&gt;  9                         &lt;% session.setAttribute(&quot;test.com&quot;,&quot;test.com&quot;); %&gt; 10                                 &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt; 11                         &lt;/tr&gt; 12                         &lt;tr&gt; 13                                 &lt;td&gt;Created on&lt;/td&gt; 14                                 &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt; 15                         &lt;/tr&gt; 16                 &lt;/table&gt; 17         &lt;/body&gt; 18 &lt;/html&gt;</code></pre><p><code>[root@node5/etc/ansible/roles/tomcat/templates]#vim index2.jsp.j2</code></p><pre><code>  1 &lt;%@ page language=&quot;java&quot; %&gt;  2 &lt;html&gt;  3         &lt;head&gt;&lt;title&gt;TomcatB&lt;/title&gt;&lt;/head&gt;  4                 &lt;body&gt;  5                 &lt;h1&gt;&lt;font color=&quot;blue&quot;&gt;TomcatB.test.com&lt;/font&gt;&lt;/h1&gt;  6                 &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt;  7                         &lt;tr&gt;  8                                 &lt;td&gt;Session ID&lt;/td&gt;  9                         &lt;% session.setAttribute(&quot;test.com&quot;,&quot;test.com&quot;); %&gt; 10                                 &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt; 11                         &lt;/tr&gt; 12                         &lt;tr&gt; 13                                 &lt;td&gt;Created on&lt;/td&gt; 14                                 &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt; 15                         &lt;/tr&gt; 16                 &lt;/table&gt; 17                 &lt;/body&gt; 18 &lt;/html&gt;</code></pre><blockquote><p>编辑触发文件</p></blockquote><p><code>[root@node5/etc/ansible/roles/tomcat]#vim handlers/main.yml</code></p><pre><code>  1 - name: tomcat reload  2   service: name=tomcat state=reloaded</code></pre><blockquote><p>编辑剧本</p></blockquote><p><code>[root@node5/etc/ansible]#vim tomcat.yml</code></p><pre><code>  1 - hosts: nginx-keep  2   remote_user: root  3   roles:  4   - keepalived  5   - haproxy  6 - hosts: tomcat-cluster  7   remote_user: root  8   roles:  9   - tomcat</code></pre>]]></content>
      
      
      <categories>
          
          <category> 自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ansible </tag>
            
            <tag> playbook </tag>
            
            <tag> 自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dig和nslookup命令</title>
      <link href="/2017/11/28/dig%E3%80%81nslookup%E7%AD%89%E5%B7%A5%E5%85%B7/"/>
      <url>/2017/11/28/dig%E3%80%81nslookup%E7%AD%89%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="管理命令"><a href="#管理命令" class="headerlink" title="管理命令"></a>管理命令</h2><h3 id="1、dig命令"><a href="#1、dig命令" class="headerlink" title="1、dig命令"></a>1、dig命令</h3><p>作用：只能用于测试DNS系统，不会查询hosts文件进行解析。</p><p>格式：</p><pre><code>dig [@server] [-b address] [-c class] [-f filename] [-k filename] [-m]       [-p port#] [-q name] [-t type] [-x addr] [-y [hmac:]name:key] [-4] [-6]       [name] [type] [class] [queryopt...]</code></pre><p>simple usage： dig @server name type</p><p>选项：</p><pre><code>-b：绑定源IP-4：仅使用IPv4-t：指定RR类型，默认为A记录，atfr（反向解析）-x：反向解析+[no]trace:跟踪解析过程+[no]recure：递归解析</code></pre><h3 id="2、host命令"><a href="#2、host命令" class="headerlink" title="2、host命令"></a>2、host命令</h3><p>格式：</p><pre><code> host [-aCdlnrsTwv] [-c class] [-N ndots] [-R number] [-t type] [-W wait]        [-m flag] [-4] [-6] {name} [server] </code></pre><p>选项：</p><pre><code>-t：指定RR类型</code></pre><h3 id="3、nslookup"><a href="#3、nslookup" class="headerlink" title="3、nslookup"></a>3、nslookup</h3><p>格式：nslookup [-option] [name | -] [server]</p><pre><code> nslookup&gt;server IP: 指明使用哪个DNS server进行查询set q=RR_TYPE: 指明查询的资源记录类型NAME: 要查询的名称</code></pre><h3 id="4、rndc命令-953-tcp"><a href="#4、rndc命令-953-tcp" class="headerlink" title="4、rndc命令(953/tcp)"></a>4、rndc命令(953/tcp)</h3><p>格式：</p><pre><code>rndc [-b source-address] [-c config-file] [-k key-file] [-s server] [-p port]  [-V] [-y key_id] {command}reload：重载主配置文件和区域解析库文件retranfer：手动启动区域传送，而不管序列号是否增减；notify：重新对区域传送发通知；reconfig：重载主配置文件querylog：开启或关闭查询日志文件`/var/log/message`trace：递增debug一个级别trace LEVEL：指定使用的级别notrace：将调试级别设置为0flush：清空DNS服务器的所有缓存记录</code></pre>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dig，nslookup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitlab</title>
      <link href="/2017/11/28/GitLab/"/>
      <url>/2017/11/28/GitLab/</url>
      
        <content type="html"><![CDATA[<p>Gitlab是一个利用 Ruby on Rails开发的开源应用程序，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或私人项目。它拥有与GitHub类似的功能，能够给浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。</p><h2 id="一、Gitlab结构"><a href="#一、Gitlab结构" class="headerlink" title="一、Gitlab结构"></a>一、Gitlab结构</h2><p><img src="http://owatlfstl.bkt.clouddn.com/components.png" alt=""></p><h3 id="1、安装Gitlab"><a href="#1、安装Gitlab" class="headerlink" title="1、安装Gitlab"></a>1、安装Gitlab</h3><p>官方推荐使用Omnibus Gitlab方法安装。</p><p>参考安装方法<img src="https://packages.gitlab.com/gitlab/gitlab-ce/install" alt=""></p><h4 id="前提：由于Gitlab运行很吃内存，建议内存至少4GB。"><a href="#前提：由于Gitlab运行很吃内存，建议内存至少4GB。" class="headerlink" title="前提：由于Gitlab运行很吃内存，建议内存至少4GB。"></a>前提：由于Gitlab运行很吃内存，建议内存至少4GB。</h4><h5 id="选择CentOS-7安装方法"><a href="#选择CentOS-7安装方法" class="headerlink" title="选择CentOS 7安装方法"></a>选择CentOS 7安装方法</h5><h4 id="（1）如果想使用邮件发送通知信息，可以进行如下设置，如果不使用邮件发送通知可以跳过此步骤。"><a href="#（1）如果想使用邮件发送通知信息，可以进行如下设置，如果不使用邮件发送通知可以跳过此步骤。" class="headerlink" title="（1）如果想使用邮件发送通知信息，可以进行如下设置，如果不使用邮件发送通知可以跳过此步骤。"></a>（1）如果想使用邮件发送通知信息，可以进行如下设置，如果不使用邮件发送通知可以跳过此步骤。</h4><p><code>[root@node1~]#yum install -y postfix</code></p><p><code>[root@node1~]#systemctl enable postfix</code></p><p><code>[root@node1~]#systemctl start postfix</code></p><h4 id="（2）安装Gtilab仓库并安装gitlab包"><a href="#（2）安装Gtilab仓库并安装gitlab包" class="headerlink" title="（2）安装Gtilab仓库并安装gitlab包"></a>（2）安装Gtilab仓库并安装gitlab包</h4><p>[root@node1~]#curl <a href="https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh" target="_blank" rel="noopener">https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh</a> |  bash</p><p><strong>注意：如果不想下载就直接安装可以下下载rpm包，然后在执行<code>rpm -vih</code>安装即可</strong></p><h5 id="如果想直接安装修改配置文件，并通过此URL直接访问，可以如下安装"><a href="#如果想直接安装修改配置文件，并通过此URL直接访问，可以如下安装" class="headerlink" title="如果想直接安装修改配置文件，并通过此URL直接访问，可以如下安装"></a>如果想直接安装修改配置文件，并通过此URL直接访问，可以如下安装</h5><h4 id="Gitlab版本分类"><a href="#Gitlab版本分类" class="headerlink" title="Gitlab版本分类"></a>Gitlab版本分类</h4><p>Gitlab EE ：适用于官方企业版<br>Gitlab CE：官方社区办<br>Unstable：不稳定版<br>Nighty Builds：为ngihtly<br>Raspberry：树莓派版</p><h4 id="（3）修改URL为Gitlab示例的URL"><a href="#（3）修改URL为Gitlab示例的URL" class="headerlink" title="（3）修改URL为Gitlab示例的URL"></a>（3）修改URL为Gitlab示例的URL</h4><p><code>[root@node1~]#EXTERNAL_URL=&quot;http://192.168.4.61&quot;  yum install -y gitlab-ce</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-03_200120.jpg" alt=""></p><h4 id="（3）使修改的配置文件生效"><a href="#（3）使修改的配置文件生效" class="headerlink" title="（3）使修改的配置文件生效"></a>（3）使修改的配置文件生效</h4><p><code>[root@node1~]#EXTERNAL_URL=&quot;http://192.168.4.61&quot;  yum install -y gitlab-ce</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-03_203613.jpg" alt=""></p><h5 id="设定管理员密码"><a href="#设定管理员密码" class="headerlink" title="设定管理员密码"></a>设定管理员密码</h5><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-03_204042.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CURL、elinks工具</title>
      <link href="/2017/11/28/CURL%E3%80%81elinks%E5%B7%A5%E5%85%B7/"/>
      <url>/2017/11/28/CURL%E3%80%81elinks%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="CURL工具"><a href="#CURL工具" class="headerlink" title="CURL工具"></a>CURL工具</h2><p>curl是居于URL语法在命令行方式下工作的文件传输工具，它支持FTP,FTPS,HTTP,HTTPS,GOPHER,TELNET,DICT,FILE及LDAP等协议。curl支持HTTPS认证，并且支持HTTP的POST、PUT等方法，FTP上传，kerberos认证，HTTP上传，代理服务器，cookies，用户名/密码认证，下载文件断电续传，上传文件断电续传，httpd代理服务器通道，还支持IPv6，socket5代理服务器，通过http代理服务器上传文件到FTP服务器等。</p><p>格式：</p><pre><code>curl [OPTIONSS] [URL...]-A/--user-agent &lt;string&gt;:设置用户代理发送给服务器-e/-referer &lt;URL&gt;:查看此网址从那个网址转发过来--cacert &lt;file&gt;:CA证书-k/--insecure:允许忽略证书进行SSL连接--compressed:要求返回时压缩的格式--H/--header &lt;line&gt;：自定义首部信息传递给服务器，构造请求首部-i：显示页面内容，包括报文首部信息-I/--head：只显示响应报文首部信息-D/--dump-header &lt;file&gt;：将url的header信息存放在指定文件中--limit-rate &lt;rate&gt;：设置传输速度，默认为k--basic：使用HTTP基本认证-u/--user&lt;user[:passwd]&gt;:设置服务器的用户和密码-L：如果有3XX响应吗，重新发请求到新位置-o &lt;file&gt;：将网络文件保存为指定的文件中-O：使用url中默认的文件名保存文件到本地-0/--http1.0：使用http1.0协议-C：选项可对文件使用断电续传功能-c/--cookie-jar &lt;filename&gt; :将url中cookie存放在指定文件中-x/--proxy&lt;proxyhost[:port]&gt;：指定代理服务器地址-X/--request &lt;command&gt;：向服务器发送指定请求方法-U/--proxy-user &lt;user:password&gt;：代理服务器用户和密码-T：将指定本地文件上传到FTP服务器上--date/-d:指定使用POST方式传递数据</code></pre><h2 id="elinks命令"><a href="#elinks命令" class="headerlink" title="elinks命令"></a>elinks命令</h2><p>格式：elinks [option]  [url]…</p><pre><code>-dump:非交互式模式，将URL的内容输出至标准输出-source：打印源码</code></pre>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> curl，elinks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>keepalived简单介绍</title>
      <link href="/2017/11/28/keepalived/"/>
      <url>/2017/11/28/keepalived/</url>
      
        <content type="html"><![CDATA[<h1 id="keepalived介绍"><a href="#keepalived介绍" class="headerlink" title="keepalived介绍"></a>keepalived介绍</h1><p>keepalived是linux下一个轻量级高可用的解决方案，主要通过VRRP实现高可用功能，作用域网络层、传输层和应用层；主要用作RealServer的健康性检查以及LoadBalance主机和Bcakup主机之间failover的实现。原生设计目的为了高可用的ipvs服务。（常见的前段高可用组合有LVS+Keepalived、Nginx+Keepalvied、HAproxy+Keepalived）</p><h2 id="1、keepalived功能"><a href="#1、keepalived功能" class="headerlink" title="1、keepalived功能"></a>1、keepalived功能</h2><ul><li><p>（1）VRRP协议完成地质流动</p></li><li><p>（2）为VIP地质所在的节点生成ipvs规则</p></li><li><p>（3）为ipvs集群的各RS做健康状态检测</p></li><li><p>（4）基于脚本调用接口通过执行脚本完成脚本中定义的功能，进而影响集群事物，以支持nginx、haproxy等服务</p></li></ul><h2 id="2、keepalived组成"><a href="#2、keepalived组成" class="headerlink" title="2、keepalived组成"></a>2、keepalived组成</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-30_091056.jpg" alt=""></p><p>keepalived主要有三个模块，分别是core、check和vrrp。</p><ul><li>core模块为keepalived的核心，负责主进程启动、维护以及全局配置文件的加载和解析</li><li>check模块负责健康检查，包括常见的各种检查方式</li><li>vrrp模块来实现VRRP协议</li></ul><h2 id="3、Keepalived工作原理"><a href="#3、Keepalived工作原理" class="headerlink" title="3、Keepalived工作原理"></a>3、Keepalived工作原理</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-30_091409.jpg" alt=""></p><ul><li>（1）在网络层，运行着四个重要的协议：互联网协议IP、互联网控制报文协议ICMP、地址转换协议以及反向地址转换协议RARP。keepalived在网络层采用的最常见的工作方式通过ICMP协议向服务器集群中的每个节点发送一个ICMP数据包，如果某个及诶单没有返回响应数据包，那么就认为此节点发生了故障，keepalived将报告此节点失效，并从服务器集群中剔除故障节点。</li><li>（2）在传输层，提供了主要的协议：传输控制协议TCP和用户数据协议UDP。keepalived在传输层利用TCP协议的端口连接和扫描技术来判断集群点是否工作正常。例如：web服务端口默认为80，如果keepalived在传输层探测到这些端口没有响应数据返回，就认为这些端口发生异常，然后强制将此端口对应的节点从服务器集群中移除。</li><li>（3）在应用层，运行着ftp、telnet、smtp、dns等各种不同类型的协议，用户可以编写脚本运行keepalived，keepalived根据用户设定检测各种程序或服务是否运行正常，如果keepalived的检测结果与用户设定不一致时，将对应的服务器从集群中移除。</li></ul><h2 id="4、keepalived配置文件"><a href="#4、keepalived配置文件" class="headerlink" title="4、keepalived配置文件"></a>4、keepalived配置文件</h2><p>安装方式一：<br>-</p><p><code>[root@localhost~]#yum install -y keepalived</code>   #安装keepalived</p><p><code>[root@localhost~]#rpm -ql keepalived</code></p><pre><code>/etc/keepalived/keepalived.conf #主配置文件/etc/sysconfig/keepalived   #unit file环境配置文件/usr/lib/systemd/system/keepalived.service  #unit文件</code></pre><p>安装方式二：<br>-<br><code>[root@localhost/usr/local/src]#tar xf keepalived-1.3.9.tar.gz</code></p><p><code>[root@localhost/usr/local/src]#cd keepalived-1.3.9/</code></p><p><code>[root@localhost/usr/local/src/keepalived-1.3.9]#./configure</code></p><p><code>[root@localhost/usr/local/src/keepalived-1.3.9]#make &amp;&amp; make install</code></p><h3 id="etc-keepalived-keepalived-conf文件详解"><a href="#etc-keepalived-keepalived-conf文件详解" class="headerlink" title="/etc/keepalived/keepalived.conf文件详解"></a><code>/etc/keepalived/keepalived.conf</code>文件详解</h3><ul><li><p>Global definitions synopsis</p><p>  global_defs{        #全局定义</p><pre><code>  notification_email {    #指定keepalived在发生切换时需要发送email到的对象，格式：一行一个。      email  }  notification_email_from email   #指定发件人  smtp_server host    #smtp服务器地址  smtp_connect_timeout num    #smtp服务器连接超时时间  lvs_id string       #表示本节点的字符串，通常为hostname</code></pre><p>  }</p></li><li><p>Virtual server definitions synopsis</p></li></ul><pre><code>virtual_server (@IP PORT)|(fwmark num) {    #设置一个VS ：VIP:PORT    delay_loop num  #服务轮询的时间间隔    lb_algo rr|wrr|lc|wlc|sh|dh|lblc    #LVS调度算法    lb_kind NAT|DR|TUN  #   LVS集群模式    persistence_timeout num #会话保持时间    persistence_granularity @IP #LVS会话保持粒度，ipvsadm中的-M参数，即每个客户端都做会话保持    virtualhost string  #检查web服务器的虚拟主机    protocol TCP|UDP    #健康检查使用协议    sorry_server @IP PORT   #备用服务器，当后端所有RS节点不可用时，就用此设置，把请求临时请求到这里    real_server @IP PORT {  #后端真实节点服务器IP:PORT        weight num  #权重；0表示失效        TCP_CHECK {            connect_ip &lt;IP ADDRESS&gt; #向当前RS的哪个IP地址发起健康状态检测请求            connect_port num    #健康检查的端口            connect_timeout num #连接超时时间            bindto &lt;IP ADDRESS&gt; #发出健康状态检测请求时使用的源地址            bind_port &lt;PORT&gt;    #发出健康状态检测请求时使用的源端口        }    }    real_server @IP PORT {        weight num        MISC_CHECK {            misc_path /path_to_script/script.sh             (or   misc_path &quot;/path_to_script/script.sh &lt;arg_list&gt;&quot;) #外部脚本或程序            misc_timeout num    #脚本或程序超时时间        }    }    real_server @IP PORT {        weight num        HTTP_GET|SSL_GET {  健康检查方式            url {   #要检查的URL                path alphanum   #具体路径                status_code &lt;INT&gt; #判断上述检测机制为健康状态的响应码                digect alphanum #摘要            }            connect_port num    #监控检查端口            connect_timeout num #连接超时时长            nb(nat_mask)_get_retry num  #重连次数            delay_before_retry num  #重连间隔            bindto &lt;IP ADDRESS&gt;：发出健康状态检测请求时使用的源地址            bind_port &lt;PORT&gt; #发出健康状态检测请求时使用的源端口            connect_ip  #向当前RS哪个IP地址发起健康状态检测请求        }    }}</code></pre><ul><li><p>VRRP intance definitions synopsis</p><p>  vrrp_sync_group string {    #同步vrrp组</p><pre><code>  group {      string      string  }  notify_master /path_to_script/script_master.sh （or notify_master “/path_to_script/script_master.sh &lt;arg_list&gt;”）  notify_backup /path_to_script/script_backup.sh (or notify_backup &quot;/path_to_script/script_backup.sh &lt;arg_list&gt;&quot;)  notify_fault /path_to_script/script_backup.sh (or notify_fault &quot;/path_to_script/script_fault.sh &lt;arg_list&gt;&quot;)</code></pre><p>  }<br>  vrrp_instance string {  #示例名称</p><pre><code>  state MASTER|BACKUP #当前节点在此虚拟路由器上的初始状态；只能有一个MASTER，其余的为BACKUP  interface string    #绑定为当前虚拟路由器使用的物理接口  mcast_src_ip @IP    #组播IP  lvs_sync_daemon_interface string  virtual_router_id num   #虚拟路由ID，用来区别多个instance的VRRP组播  priority num    #优先级  advert_int num  #检查间隔  smtp_alert    authentication {    #认证区域      auth_type PASS（最长8位）|AH #认证类型，默认是PASS认证      auth_pass string    #PASS认证密码  }  virtual_ipaddress { 不能超过20个      @IP     #虚拟VIP地址      @IP  }     virtual_ipaddress_excluded {      @IP       @IP  }  notify_master /path_to_script/script_master.sh （or notify_master “/path_to_script/script_master.sh &lt;arg_list&gt;”） #当前节点成为主节点时触发的脚本  notify_backup /path_to_script/script_backup.sh (or notify_backup &quot;/path_to_script/script_backup.sh &lt;arg_list&gt;&quot;) #当前节点转为备节点时触发的脚本  notify_fault /path_to_script/script_backup.sh (or notify_fault &quot;/path_to_script/script_fault.sh &lt;arg_list&gt;&quot;)    #当前节点转为“失败”状态时触发的脚本  notify &lt;STRING&gt;|&lt;QUOTED-STRING&gt;</code></pre><p>  一个脚本可完成以上上中状态转换时的通知</p><p>  }   </p></li></ul><pre><code>vrrp_script chk_http {    script &quot;/path_to_script/script.sh&quot; http服务检测脚本    interval num        #检查间隔    weight num  #权重    fall        #如果连接失败次数达到此值，则认为服务器已经down    rise    #如果连接次数达到此值，则认为服务器已UP，但不修改优先级    weight -NUM     #检测失败则优先级-NUM}track_interface {   #定义额外的监听网卡，只要其中一个网卡出现故障就会发生准备切换        eth0        eth1         ...}track_script {    chk_http    #引用VRRP脚本，即在vrrp_script部分指定的名字}</code></pre><p><strong>小结</strong></p><ul><li>（1）优先级不会不断的提高或降低</li><li>（2）可以编写多个检测脚本为每个检测脚本设置不同的weight</li><li>（3）不管提高优先级还是降低优先级，范围为1-254</li><li>（4）在MASTER节点的vrrp_instance中配置nopreempt，当它异常恢复后，即时它的优先级更高也不会抢占</li></ul><h2 id="keepalived调用脚本进行资源监控"><a href="#keepalived调用脚本进行资源监控" class="headerlink" title="keepalived调用脚本进行资源监控"></a>keepalived调用脚本进行资源监控</h2><p>keepalived调用外部辅助脚本进行资源监控，并根据监控结果状态能实现优先动态太正。</p><ul><li>vrrp_script：自定义资源监控脚本，vrrp示例根据脚本返回值，公共定义，可对悲多个示例调用，定义在vrrp示例之外</li><li>track_script：调用vrrp_script定义的脚本去监控资源，定义在示例之外，调用事先定义的vrrp_script</li></ul><h2 id="定义keepalived日志"><a href="#定义keepalived日志" class="headerlink" title="定义keepalived日志"></a>定义keepalived日志</h2><p><code>[root@localhost~]#vim /etc/sysconfig/keepalived</code></p><pre><code>14 KEEPALIVED_OPTIONS=&quot;-D -S 2&quot; </code></pre><p><code>[root@localhost~]#vim /etc/rsyslog.conf</code></p><pre><code>74 local2.*                                                /var/log/keepalived.log</code></pre><p>重启服务</p><p><code>[root@localhost~]#systemctl restart rsyslog.service</code></p><p><code>[root@localhost~]#systemctl restart keepalived.service</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-30_113512.jpg" alt=""></p><h1 id="二、实战"><a href="#二、实战" class="headerlink" title="二、实战"></a>二、实战</h1><h3 id="keepalived单实例，高可用性IPVS集群，IPVS集群提供apache；NAT模式"><a href="#keepalived单实例，高可用性IPVS集群，IPVS集群提供apache；NAT模式" class="headerlink" title="keepalived单实例，高可用性IPVS集群，IPVS集群提供apache；NAT模式"></a>keepalived单实例，高可用性IPVS集群，IPVS集群提供apache；NAT模式</h3><p>topology<br><img src="http://owatlfstl.bkt.clouddn.com/2017-10-30_140946.jpg" alt=""></p><blockquote><p>（1）node1和node2环境前提</p></blockquote><h4 id="时间同步："><a href="#时间同步：" class="headerlink" title="时间同步："></a>时间同步：</h4><p><code>[root@node1 ~]# ntpdate 172.18.0.1</code></p><p><code>[root@node1 ~]# vim /etc/ntp.conf</code><br><img src="http://owatlfstl.bkt.clouddn.com/2017-10-30_115043.jpg" alt=""></p><p><code>[root@node1 ~]# service ntpd start</code>    #重启服务</p><p><code>[root@node1 ~]# chkconfig ntpd on</code> #设置为开机启动</p><p>另外一个节点也是这样操作</p><h4 id="如果是CentOS-7-操作如下"><a href="#如果是CentOS-7-操作如下" class="headerlink" title="如果是CentOS 7 操作如下"></a>如果是CentOS 7 操作如下</h4><p><code>[root@node2~]#vim /etc/chrony.conf</code><br><img src="http://owatlfstl.bkt.clouddn.com/2017-10-30_115043.jpg" alt=""><br><code>[root@node2~]#systemctl start chronyd.service</code></p><p><code>[root@node2~]#systemctl enable chronyd</code></p><blockquote><p>（2）关闭iptables和selinux</p></blockquote><p>node1：</p><p><code>[root@node1 ~]# iptables -F</code></p><p><code>[root@node1 ~]# service iptables stop</code></p><p><code>[root@node1 ~]# chkconfig iptables off</code></p><p><code>[root@node1 ~]# vim /etc/selinux/config</code></p><pre><code>SELINUX=disabled</code></pre><p><code>[root@node1 ~]# setenforce 0</code></p><p>node2：</p><p><code>[root@node2~]#systemctl disable firewalld</code></p><p><code>[root@node2 ~]# vim /etc/selinux/config</code></p><pre><code>SELINUX=disabled</code></pre><p><code>[root@node1 ~]# setenforce 0</code></p><blockquote><p>（3）修改<code>/etc/hosts</code>文件</p></blockquote><p>node1</p><p><code>[root@node1 ~]# vim /etc/hosts</code></p><pre><code>192.168.4.61 node2192.168.4.56 node1</code></pre><p>node2</p><p><code>[root@node2 ~]# vim /etc/hosts</code></p><pre><code>192.168.4.56 node1192.168.4.61 node2</code></pre><p>测试ping能否ping通</p><p><code>[root@node1 ~]# ping node2</code></p><pre><code>PING node2 (192.168.4.61) 56(84) bytes of data.64 bytes from node2 (192.168.4.61): icmp_seq=1 ttl=64 time=0.392 ms</code></pre><p><code>[root@node2~]#ping node1</code></p><pre><code>PING node1 (192.168.4.56) 56(84) bytes of data.64 bytes from node1 (192.168.4.56): icmp_seq=1 ttl=64 time=0.247 ms</code></pre><blockquote><p>（4）node1和node2之间root用户可以基于密钥认证ssh服务完成互相通信</p></blockquote><p>node1：</p><p><code>[root@node1 ~]# ssh-keygen -t rsa</code></p><p><code>[root@node1 ~]# ssh-copy-id -i /root/.ssh/id_rsa.pub node2</code></p><p>node2：</p><p><code>[root@node2 ~]# ssh-keygen -t rsa</code></p><p><code>[root@node2~]#ssh-copy-id -i /root/.ssh/id_rsa.pub node1</code></p><blockquote><p>（5）node1和node2安装keepalived服务并配置</p></blockquote><p><code>[root@node1 ~]# yum install -y keepalived</code></p><pre><code>! Configuration File for keepalivedglobal_defs {   notification_email {     client@mail.com   }   notification_email_from node1@mail.com   smtp_server 192.168.4.132   smtp_connect_timeout 30   router_id node1  #node2为node2   vrrp_mcast_group4 224.100.100.4}vrrp_instance VI_1 {    state MASTER    interface eth0    virtual_router_id 4    priority 12 #此处node1和node2优先级不一样    advert_int 1    authentication {        auth_type PASS        auth_pass e60f4024    }    virtual_ipaddress {        172.18.4.60/16    }    delay_loop 3    lb_algo wrr     lb_kind NAT     persistence_timeout 50    protocol TCP    sorry_server 172.18.4.60 80    real_server 192.168.4.62 80 {        weight 3        HTTP_GET {            url {               path /app/website              status_code 200            }             connect_timeout 1            nb_get_retry 3            delay_before_retry 1        }       }       real_server 192.168.4.63 80 {        weight 1        HTTP_GET {            url {               path /app/website              status_code 200            }             connect_timeout 1            nb_get_retry 3            delay_before_retry 1        }       }   }   </code></pre><p>node2和node1配置类似这里不再累述</p><p>测试是否VRRP实现</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-30_145724.jpg" alt=""></p><p>如果关闭node1服务，会出现图中情况。</p><blockquote><p>（6）实现lvs调度</p></blockquote><p>node1：开启路由转发功能</p><p><code>[root@node1 keepalived]# vim /etc/sysctl.conf</code></p><pre><code>net.ipv4.ip_forward = 1</code></pre><p><code>[root@node1 keepalived]# sysctl -p</code></p><p>node2：开启路由转发功能</p><p><code>[root@node2 keepalived]# vim /etc/sysctl.conf</code></p><pre><code>net.ipv4.ip_forward = 1</code></pre><p><code>[root@node1 keepalived]# sysctl -p</code></p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Keepalived </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>memcached</title>
      <link href="/2017/11/28/memcached/"/>
      <url>/2017/11/28/memcached/</url>
      
        <content type="html"><![CDATA[<p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-07_200818.jpg" alt=""></p><p>memcached是是一款开源、高性能、分布式存储内存对象缓存系统。主要目的是通过降低对Database的访问来加速web应用程序。一个基于内存的”键值对”存储用于存储数据库调用、API调用或页面引用结果的直接数据，如字符串、对象等。</p><h1 id="一、memcached"><a href="#一、memcached" class="headerlink" title="一、memcached"></a>一、memcached</h1><h3 id="1、memcached特点"><a href="#1、memcached特点" class="headerlink" title="1、memcached特点"></a>1、memcached特点</h3><p>（1）简单key/value存储，服务器不关心数据本身的意义及结构，只要是可序列化数据即可。</p><p>（2）功能的实现一般依赖于客户端，一般基于服务器端，客户端负责发送存储箱至服务器端，从服务器端获取数据以及无法连接至服务器时采用响应的动作；服务器端负责接收、存储数据，并负责数据项的超时过期</p><p>（3）各服务器彼此无视，不再服务器间进行数据同步</p><p>（4）o（1）的执行效率</p><p>（5）清理超期数据，默认情况下，memcached是一个LRU缓存，它按事先预设的时长清理超期数据，但是，memcached不会删除任何已缓存数据，只是在其过期之后不再为客户所见；也不会真正按期限清理缓存，而仅是当get命令到达时检查其时长</p><h3 id="2、yum安装memcached"><a href="#2、yum安装memcached" class="headerlink" title="2、yum安装memcached"></a>2、yum安装memcached</h3><p><code>[root@memcache~]#yum install -y memcached</code></p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>主程序：</p><pre><code>/usr/bin/memcached</code></pre><p>配置文件：</p><pre><code>/etc/sysconfig/memcached  1 PORT=&quot;11211&quot;  2 USER=&quot;memcached&quot;  3 MAXCONN=&quot;1024&quot;  4 CACHESIZE=&quot;64&quot;  5 OPTIONS=&quot;&quot;</code></pre><p>unit file</p><pre><code>memcached.service</code></pre><h3 id="3、命令"><a href="#3、命令" class="headerlink" title="3、命令"></a>3、命令</h3><h4 id="memcached程序常用选项"><a href="#memcached程序常用选项" class="headerlink" title="memcached程序常用选项"></a>memcached程序常用选项</h4><pre><code>-l &lt;ip_addr&gt;：指定进程监听的地址-d：以服务模式运行-u &lt;username&gt;：以指定的用户身份运行memcached进程-m &lt;num&gt;：用于缓存数据最大内存空间，单位为MB，默认为64MB-c &lt;num&gt;：最大支持的并发连接数，默认为1024-p&lt;num&gt;：指定监听的TCP端口，默认为11211-U&lt;num&gt;：指定监听的UDP端口，默认为11211,0表示关闭UDP端口-M：内存耗尽时，不执行LRU清理缓存，而是拒绝存入新的缓存项，直到有多余的空间可用时为止-f &lt;factor&gt;：增长因子，默认是1.25-t &lt;threads&gt;：启动的用于响应用户请求的线程数</code></pre><h4 id="memcached-tool"><a href="#memcached-tool" class="headerlink" title="memcached-tool"></a>memcached-tool</h4><p>stats and management tool for memcached</p><p>使用格式：</p><pre><code> memcached-tool &lt;host[:port] | /path/to/socket&gt; [mode]    display：打印分类信息。默认模式</code></pre><p><code>[root@tomcatB~]#memcached-tool 127.0.0.1:11211</code></p><pre><code>#  Item_Size  Max_age   Pages   Count   Full?  Evicted Evict_Time OOM          #      Number of the slab class.          Item_Size                 The amount of space each chunk uses. One item uses one chunk of the appropri‐                 ate size.          Max_age                 Age of the oldest item in the LRU.          Pages  Total number of pages allocated to the slab class.          Count  Number of items presently stored in this class. Expired items are  not  auto‐                 matically excluded.          Full?  Yes if there are no free chunks at the end of the last allocated page.          Evicted                 Number of times an item had to be evicted from the LRU before it expired.          Evict_Time                 Seconds  since  the  last  access  for the most recent item evicted from this                 class.          OOM    Number of times the underlying slab class was unable to store a new item.    stats：显示状态信息    dump：使部分缓存写</code></pre><h4 id="远程命令"><a href="#远程命令" class="headerlink" title="远程命令"></a>远程命令</h4><p><code>[root@memcache~]#telnet 127.0.0.1 11211</code></p><pre><code>Trying 127.0.0.1...Connected to 127.0.0.1.Escape character is &#39;^]&#39;.</code></pre><p>格式：</p><pre><code>&lt;command name&gt; &lt;key&gt; &lt;flags&gt; &lt;exptime&gt; &lt;bytes&gt;  &lt;cas unique&gt;</code></pre><p>统计类：</p><pre><code>stats stats items ,stats slabs ,stats sizes</code></pre><p>存储类：</p><pre><code>set，add，replace，append，prepend</code></pre><p>检索类：</p><pre><code>get ，delete，incr/decr</code></pre><p>清空：</p><pre><code>flush_all</code></pre>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> memcached </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iptables</title>
      <link href="/2017/11/28/iptables/"/>
      <url>/2017/11/28/iptables/</url>
      
        <content type="html"><![CDATA[<h1 id="一、iptables"><a href="#一、iptables" class="headerlink" title="一、iptables"></a>一、iptables</h1><h2 id="1、iptables历史"><a href="#1、iptables历史" class="headerlink" title="1、iptables历史"></a>1、iptables历史</h2><p>iptables的前身叫ipfirewall （内核1.x时代）,这是一个作者从freeBSD上移植过来的，能够工作在内核当中的，对数据包进行检测的一款简易访问控制工具。但是ipfirewall工作功能极其有限(它需要将所有的规则都放进内核当中，这样规则才能够运行起来，而放进内核，这个做法一般是极其困难的)。当内核发展到2.x系列的时候，软件更名为ipchains，它可以定义多条规则，将他们串起来，共同发挥作用，而现在，它叫做iptables，可以将规则组成一个列表，实现绝对详细的访问控制功能。</p><h2 id="2、iptables概念"><a href="#2、iptables概念" class="headerlink" title="2、iptables概念"></a>2、iptables概念</h2><p>iptables包含两部分，一部分是netfilter组件，是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤处理的规则集；另一部分是iptables，工作在用户空间中，定义规则的工具，本身并不算是防火墙。它们定义的规则可以让在内核空间当中的netfilter来读取，并且实现让防火墙工作。而放入内核的地方必须要是特定的位置，必须是tcp/ip的协议栈经过的地方；而这个tcp/ip协议栈必须经过的地方，可以实现读取规则的地方就叫做 netfilter.(网络过滤器)</p><h2 id="3、防火墙的分类"><a href="#3、防火墙的分类" class="headerlink" title="3、防火墙的分类"></a>3、防火墙的分类</h2><ul><li>主机防火墙：服务范围为当前主机网络防火墙，防火墙一侧的局域网</li><li>硬件防火墙：专用硬件级别实现部分功能的防火墙</li><li>软件防火墙：运行于通用硬件平台上的防火墙的应用软件</li><li>网络层防火墙：OSI下面第三层应用层防火墙</li></ul><h3 id="（1）网络层防火墙（包过滤防火墙）"><a href="#（1）网络层防火墙（包过滤防火墙）" class="headerlink" title="（1）网络层防火墙（包过滤防火墙）"></a>（1）网络层防火墙（包过滤防火墙）</h3><ul><li>工作机理</li></ul><p>网络层对数据包进行选择（依据是系统内设置的过滤逻辑，被称为访问控制列表（ACL）），通过检查数据流中每个数据的源地址、目标地址、所用端口和协议状态等因素，或者他们的组合确定是否允许此数据包通过。</p><ul><li>优点</li></ul><p>对于用户来说是透明的，处理速度快且易于维护</p><ul><li>缺点</li></ul><p>无法检查应用层数据，如病毒等。</p><h3 id="（2）应用层防火墙（代理服务器型防火墙）"><a href="#（2）应用层防火墙（代理服务器型防火墙）" class="headerlink" title="（2）应用层防火墙（代理服务器型防火墙）"></a>（2）应用层防火墙（代理服务器型防火墙）</h3><ul><li>工作机理</li></ul><p>将所有跨越防火墙的网络通信链路分为两段，内外网用户的访问都是通过代理服务器上的链接来实现的</p><ul><li>优点</li></ul><p>应用层对数据进行检查，比较安全</p><ul><li>缺点 </li></ul><p>增加防火墙的负载</p><p>在现实生产环境中所使用的防火墙一般都是上述两者结合一起发挥功用；即先进行网络数据检查，如果通过之后再送到应用层检查。</p><h2 id="4、Netfilter组件"><a href="#4、Netfilter组件" class="headerlink" title="4、Netfilter组件"></a>4、Netfilter组件</h2><p>netfilter工作在内核空间中，集成于linux内核中，提供一整套hook函数管理机制，使得数据包过滤、网络地址转换和基于协议类型的链接跟中成为了可能。内核中选取五个位置放五个hook function,INPUT、OUTPUNT、PREROUTING、POSTROUTING、FORWARD。由信息过滤表组成，包含控制IP 包处理的规则集，规则被分组放在chain上。</p><h3 id="三种报文流向"><a href="#三种报文流向" class="headerlink" title="三种报文流向"></a>三种报文流向</h3><ul><li>流入本机：PREROUTING–&gt;INPUT–&gt;用户进程</li><li>流出本机：用户进程–&gt;OUTPUT–&gt;POSTROUTING</li><li>转发：PREROUTING–&gt;FORWARD–&gt;POSTROUTING</li></ul><h2 id="5、iptables组成"><a href="#5、iptables组成" class="headerlink" title="5、iptables组成"></a>5、iptables组成</h2><p>防火墙的管理工具，工作在用户进程空间中。在用户进程空间中编写好规则之后，被发送给netfilter，告诉内核如何去处理信息包。</p><h3 id="iptables由四张表和五个链以及一些规则组成。"><a href="#iptables由四张表和五个链以及一些规则组成。" class="headerlink" title="iptables由四张表和五个链以及一些规则组成。"></a>iptables由四张表和五个链以及一些规则组成。</h3><ul><li>四张表</li></ul><p>filter ：过滤规则表，根据预先定义的规则过滤符合条件的数据表</p><p>nat（network addresss translation）表：地址转换表</p><p>mangle表：修改数据标记位规则表</p><p>raw表：关闭nat表上启动的链接追踪机制，加快封包速率</p><ul><li>四张表的优先级</li></ul><p>raw  &gt; mangle &gt; nat &gt;filter</p><h4 id="netfilter表盒链对应关系"><a href="#netfilter表盒链对应关系" class="headerlink" title="netfilter表盒链对应关系"></a>netfilter表盒链对应关系</h4><p><img src="http://owatlfstl.bkt.clouddn.com/netfiler.jpg" alt=""></p><p><strong>防火墙是iptabls和netfilter的组合，可以让规则进行生效，本身不是一种服务。</strong></p><h2 id="数据包过滤匹配流程如下"><a href="#数据包过滤匹配流程如下" class="headerlink" title="数据包过滤匹配流程如下"></a>数据包过滤匹配流程如下</h2><p><img src="http://owatlfstl.bkt.clouddn.com/sf.jpg" alt=""></p><h2 id="6、内核中数据包传输过程"><a href="#6、内核中数据包传输过程" class="headerlink" title="6、内核中数据包传输过程"></a>6、内核中数据包传输过程</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-20_102750.jpg" alt=""></p><p>（1）当一个数据包进入网卡时，数据包首先进入PREROUTING链，内核根据数据包目的IP 判断是否需要转发出去</p><ul><li><p>如果上述判断数据包是进入本机，数据沿着②到达INPUT。数据包进入INPUT链后，任何进程都会接收到它。本机运行的程序可以发送数据包，这些数据包经过OUTPUT链然后到达POSTROUTING链输出</p></li><li><p>如果数据包要转发出去，且内核开启转发功能，数据包会沿着⑤到达FORWARD链，然后沿着⑥到达POSTROUTING链输出</p></li></ul><h2 id="7、iptables组成"><a href="#7、iptables组成" class="headerlink" title="7、iptables组成"></a>7、iptables组成</h2><p>根据规则的匹配条件尝试匹配报文，对匹配成功的报文根据规则定义的处理动作做出处理。</p><p>规则和链是有计数器：</p><pre><code>pkgs：由规则和链所匹配到的报文的个数bytes：由规则或链匹配到的所有报文大小之和</code></pre><ul><li>匹配条件</li></ul><p>基本匹配：IP 、端口、TCP的标记位</p><p>扩展匹配：通过复杂高级功能匹配</p><ul><li>处理动作</li></ul><p>内置处理动作：ACCEPT DROP REJECT SNAT DNAT MASQUERADE MARK LOG</p><p>自定义处理动作：自定义chain，利用分类管理复杂情形</p><ul><li>链</li></ul><p>内置链：每个内置链对应一个hook函数</p><p>自定义链：用于对内置链进行扩展或补充，可以实现更灵活的规则管理机制；只有hook调用自定义链才能生效。</p><p><strong>报文不会经过自定义链，只能在内置链上通过规则进行引用后生效。</strong></p><h2 id="8、添加规则的考量点"><a href="#8、添加规则的考量点" class="headerlink" title="8、添加规则的考量点"></a>8、添加规则的考量点</h2><p>（1）实现哪种功能：判断添加在哪张表上合适</p><p>（2）报文流经的路径：判断添加在哪个链上</p><h1 id="链上的规则次序，即检查次序"><a href="#链上的规则次序，即检查次序" class="headerlink" title="链上的规则次序，即检查次序"></a>链上的规则次序，即检查次序</h1><ul><li>同类规则（控制同一种应用访问），匹配范围小的放在上面</li><li>不同类规则（访问不同应用），匹配到报文频率较大的放在上面</li><li>将那些可有一条规则描述的多个规则合并为一个规则</li><li>设置默认策略</li></ul><h1 id="二、iptables命令"><a href="#二、iptables命令" class="headerlink" title="二、iptables命令"></a>二、iptables命令</h1><p>格式：</p><pre><code>iptables [-t table] SUBCOMMAND chain [-m ] matchname [per-match-options]] -j targetname [per-target-options]</code></pre><h2 id="链管理"><a href="#链管理" class="headerlink" title="链管理"></a>链管理</h2><p>|<br>|-F flush|清空规则链；<br>|-N new|创建新的自定义规则链<br>|-X drop|删除用户自定义空的规则链<br>|-Z zero|清零，置零规则计数器<br>|-P policy|为指定链设定默认策略，对于filter表，默认策略通常有ACCEPT、DROP、REJECT<br>|-E rEname|重命名自定义链，注意：引用计数不为0自定义链无法改名，也无法删除<br>|-A append|将新规则追加于指定链的尾部<br>|-I insert|将新规则追加于指定链的位置<br>|-D delete|删除指定链上的指定规则，指明规则序号；指明规则本身<br>|-R replace|替换指定链上的指定规则</p><h3 id="查看链规则"><a href="#查看链规则" class="headerlink" title="查看链规则"></a>查看链规则</h3><p>|<br>|-L list|列出指定链上的所有规则<br>|-n |以数字格式显示地址和端口号<br>|-v|显示详细信息<br>|–line-number|显示规则编号<br>|-x  exactly|显示计数器计数结果的精确值</p><h2 id="匹配条件"><a href="#匹配条件" class="headerlink" title="匹配条件"></a>匹配条件</h2><h3 id="基本匹配"><a href="#基本匹配" class="headerlink" title="基本匹配"></a>基本匹配</h3><p>[!]-s,–src,–source address[/mask]:检查报文中的源IP地址是否符合此处指定的地址范围</p><p>[!]-d,–dst,–destination address[/mask]:检查报文中源IP地址是否符合此处指定的地址范围</p><p>-p，–protocol {tcp|udp|icmp} ：检查报文中的的协议，即IP首部中的protocol所表示的协议</p><p>-i，–in-interface INFACE：数据报文的流入接口；仅能用于PREROUTING INPUT FORWARD链上</p><p>-o，–out-interface INFACE：数据报文的流出接口；仅能用于FORWARD OUTPUT POSTROUTING链上</p><h3 id="扩展匹配"><a href="#扩展匹配" class="headerlink" title="扩展匹配"></a>扩展匹配</h3><p>使用扩展匹配需加载模块</p><h4 id="隐式扩展"><a href="#隐式扩展" class="headerlink" title="隐式扩展"></a>隐式扩展</h4><p>在使用-p选项指明了特定的协议时，无需再使用-m选项指明扩展模块的扩展机制，不需要手动加载扩展模块</p><h5 id="tcp协议扩展选项"><a href="#tcp协议扩展选项" class="headerlink" title="tcp协议扩展选项"></a>tcp协议扩展选项</h5><p>[!] –source-port,–sport port[:port] ：匹配报文源端口</p><p>[!] –destination-port ,–dport port[:port]：匹配报文目标端口</p><p>[!] –tcp-flags LIST1 LIST2 ：检查LIST1所指明的所有标志位，且LIST2所表示标记位必须为1，而余下的必须为0,；没有LIST1中指明的不做检查</p><pre><code>--syn：用于匹配检查第一次三次握手 与--tcp-flags SYN,ACK,FIN,RST SYN作用相同</code></pre><h5 id="udp协议扩展选项"><a href="#udp协议扩展选项" class="headerlink" title="udp协议扩展选项"></a>udp协议扩展选项</h5><p>[!] –source-port,–sport port[:port] ：匹配报文源端口</p><p>[!] –destination-port ,–dport port[:port]：匹配报文目标端口</p><h5 id="icmp协议扩展选项"><a href="#icmp协议扩展选项" class="headerlink" title="icmp协议扩展选项"></a>icmp协议扩展选项</h5><p>[!] –icmp-type {type[/mode]|typename}</p><pre><code>type/code    0/0 echo-replay :icmp应答    8/0 echo-reques :icmp请求</code></pre><h4 id="显示扩展"><a href="#显示扩展" class="headerlink" title="显示扩展"></a>显示扩展</h4><p>显示扩展必须使用选项-m指定，必须显示指明使用的模块</p><p><code>[root@localhost ~]# rpm -ql iptables |grep  \.so$</code></p><ul><li><strong>mulitport</strong>扩展，以离散方式定义多端口匹配，最多指定15个端口</li></ul><p>[!] –source-ports,–sports port[,port|port:port]指明多个源端口</p><p>[!] –destination-ports,–dports port[,port|:port] :指明多个目标端口</p><p>[!] –ports port[,port|,port:port] :指明多个源或目标端口</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p><code>[root@localhost ~]# iptables -A INPUT -s 192.168.4.61 -d 192.168.4.55 -p tcp -m multiport --sports 20:23 -j ACCEPT</code></p><ul><li><strong>iprange</strong>扩展，指明连续ip地址范围使用；但一般是不能扩展整个网络</li></ul><p>[!] –src-range from [-to]:指明连续的源ip地址范围<br>[!] –dst-range from [-to]：指明连续的目标ip地址范围</p><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><p><code>[root@localhost ~]# iptables -A INPUT -m iprange --src-range 192.168.4.61-192.168.4.65 -p tcp -j ACCEPT</code></p><ul><li><strong>string</strong> 检查报文中出现的字符串</li></ul><p>–algo {bm|kmp}：字符串匹配检测算法</p><p>–from offset ：开始偏移</p><p>–to offset ：结束偏移</p><p>[!] –string PATTERN ：要检查的字符串模式</p><p>[!] –hex-string PATTERN：要检测字符串模式</p><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><p><code>[root@localhost html]# iptables -A OUTPUT -s 192.168.4.61 -d 0/0 -p tcp --sport 80 -m string --algo bm --string &quot;www.google.com&quot; -j REJECT</code></p><ul><li><strong>time</strong>根据报文到达时间与指定的时间范围进行匹配</li></ul><p>–datestart YYYY[-MM[-DD[Thh[:mm[:ss]]]]]</p><p>–datestop YYYY[-MM[-DD[Thh[:mm[:ss]]]]]</p><p>–timestart hh:mm[:ss]</p><p>–timestop hh:mm[:ss]</p><p>[!] –monthdays day[,day…]</p><p>[!] –weekdays day[,day…]  Mon, Tue, Wed, Thu,<br>              Fri, Sat, Sun, or values from 1 to 7, respectively.</p><p>–kerneltz:内核时区，不建议使用；CentOS 7系统默认使用UTC；CentOS 6 不支持kerneltz，–localtz指定本地时区（默认）</p><h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><p><code>[root@localhost html]# iptables -A INPUT  -s 192.168.4.61 -d 192.168.4.55 -p tcp --dport 80 -m time --timestart 15:00 --timestop 16:00 --weekdays 5 -j DROP</code></p><ul><li><strong>connlimit</strong> 根据每客户端IP 做并发数量限制；通常分别于默认的拒绝或允许策略配合使用</li></ul><p>–connlimit-upto N ：连接的数量小于等于N时匹配</p><p>–connlimit-above N：连接的数量大于N时匹配</p><h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><p><code>[root@localhost html]# iptables -A INPUT -d 192.168.4.61 -p tcp --dport 22 -m connlimit --connlimit-above 2 -j REJECT</code></p><ul><li><strong>limit</strong>扩展，基于收发报文的速率做匹配</li></ul><p>–limit rate[/second|/minute|/hour|/day]    限制速率</p><p>–limit-burst number    限制浏览  默认为5</p><h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><p><code>[root@localhost ~]# iptables -A INPUT  -d 192.168.4.55 -p icmp --icmp-type 8 -m limit --limit 3/minute --limit-burst 5 -j ACCEPT</code></p><ul><li><strong>state</strong>扩展，根据“连接追踪机制”去检查连接的状态，此扩展比较消耗资源</li></ul><table><thead><tr><th>state</th><th>注释</th></tr></thead><tbody><tr><td>NEW</td><td>新发出的请求，连接追踪模板中不存在此连接相关的信息条目，因此，将其识别为第一次发出的请求。</td></tr><tr><td>ESTABLISHED</td><td>NEW状态之后，连接追踪模板中为建立的条目失效之前期间所进行的通信的状态。这个状态不管这个数据包是发往防火墙还是由防火墙转发的。ICMP的错误和重定向等信息包也被看做是ESTABLISHED，只要他们是我们所发出的信息应答。</td></tr><tr><td>RELATED</td><td>相关的连接，如ftp协议的命令连接和数据之间的关系。</td></tr><tr><td>INVALID</td><td>无法识别的连接</td></tr></tbody></table><p>[!] –state STATE</p><p>conntrack机制：追踪本机上的请求和响应之间的关系</p><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>/proc/net/nf_conntrack</td><td>已经追踪到的并记录下来的连接信息库</td></tr><tr><td>/proc/sys/net/nf_conntrack_max</td><td>调整连接追踪所能够容纳的最大连接数量</td></tr><tr><td>/proc/sys/net/netfilter</td><td>不同的协议连接追踪时长</td></tr></tbody></table><p><strong>注意：CentOS 7中需要加载模块：modprobe nf_conntrack</strong></p><p>iptablesde 连接追踪表最大容量为/proc/sys/net/nf_conntrack_max,各种状态超时连接会从表中删除，当模板满载时，后续连接可能会超时；那么我们如何解决此问题呢？</p><p><em>方法一：</em></p><p>加大nf_conntrack_max的值</p><p><code>[root@localhost ~]# vim /etc/sysctl.conf</code></p><pre><code>net.nf_conntrack_max = 393216 net.netfilter.nf_conntrack_max = 393216</code></pre><p><em>方法二</em></p><p>降低nf_conntrack timeout 时间</p><p><code>[root@localhost ~]# vim /etc/sysctl.conf</code></p><pre><code>net.netfilter.nf_conntrack_tcp_timeout_established = 300 net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120 net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60 net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120 </code></pre><h3 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h3><p><code>[root@localhost ~]# iptables -A OUTPUT -s 192.168.4.55 -p tcp -m multiport --dports 22,80 -m state --state ESTABLISHED -j ACCEPT</code></p><p><code>[root@localhost ~]# iptables -A INPUT -d 192.168.4.55 -p tcp -m multiport --dports 22,80 -m state --state NEW -j ACCEPT</code></p><ul><li><strong>mac</strong>扩展 指明源MAC地址；适用于PREROUTING、FORWARD、INPUT</li></ul><p>[!] –mac-source MAC</p><h3 id="示例：-7"><a href="#示例：-7" class="headerlink" title="示例："></a>示例：</h3><p><code>[root@localhost ~]# iptables -A INPUT -s 192.168.4.61 -p icmp --icmp-type 8 -m mac --mac-source 00:0c:29:40:d6:de -j DROP</code></p><h2 id="目标-target"><a href="#目标-target" class="headerlink" title="目标 target"></a>目标 target</h2><pre><code>-j TARGET：jump值指定的target</code></pre><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>ACCEPT</td><td>允许数据包通过</td></tr><tr><td>DROP</td><td>丢弃数据包</td></tr><tr><td>REJECT</td><td>丢弃数据包，并且将拒绝信息发送给发送方</td></tr><tr><td>SNAT</td><td>源地址转换</td></tr><tr><td>DNAT</td><td>目标地址转换</td></tr><tr><td>REDIRECT</td><td>目标端口转换</td></tr><tr><td>MASQUERADE</td><td>地址伪装</td></tr></tbody></table><p>LOG：非中断target，本身不拒绝和允许，放在拒绝和允许规则之前，并将日志记录在/var/log/messages系统日志中</p><p>–log-level LEVEL 指定日志级别</p><p>–log-prefix PREFIX：日志前缀，用于区别不同的日志，最多29个字符</p><h3 id="示例：-8"><a href="#示例：-8" class="headerlink" title="示例："></a>示例：</h3><p><code>[root@localhost ~]# iptables -A INPUT -s 192.168.4.61 -p tcp -m multiport --dports 21:23,80 -m state --state NEW -j LOG --log-level info --log-prefix &quot;new connections:&quot;</code></p><p><strong>小结</strong></p><p>任何不允许的访问，应该在请求到达时给予拒绝。规则在表中的次序为其检查时的生效次序</p><p>基于上述，规则优化建议：</p><p>（1）安全放行所有入站和出站的状态为ESTABLISHED状态连接</p><p>（2）谨慎放行入站的新请求</p><p>（3）有特殊目的的限制访问功能，要在放行规则之前加以拒绝</p><p>（4）同类规则，匹配范围小的放在前面，用于特殊处理</p><p>（5）不同类规则，匹配范围大的放在前面</p><p>（6）应该将那些可由一条规则能够描述的多个规则合并为一条</p><p>（7）设置默认策略，建议白名单（只放心特定连接）</p><pre><code>iptables -P 不建议使用建议在规则的最后定义规则作为默认策略 iptables -A INPUT -j DROP</code></pre><h2 id="规则的保存和恢复"><a href="#规则的保存和恢复" class="headerlink" title="规则的保存和恢复"></a>规则的保存和恢复</h2><p>service iptables save 将规则覆盖保存至<code>/etc/sysconfig/iptables</code>文件中</p><p>iptables-save /PATH/TO/SOMEFILE 保存至指定文件中</p><p>iptables -S /PATH/TO/SOMEFILE 保存至指定文件中</p><p>service iptables restart 会从<code>/etc/sysconfig/iptables</code>文件中重新载入规则</p><p>iptables-restore &lt; /PATH/TO/SOMEFILE 从指定文件中加载规则</p><pre><code>-n，--noflush：不清楚原有规则-t，--test：仅分析生成规则集，但不提交</code></pre><p>如果需要开启自动加载自己配置的规则，如何实现？</p><p><em>方法一：</em></p><p>将iptables命令写至<code>/etc/rc.d/rc.local</code>，让此脚本开机后自动运行</p><p><em>方法二：</em></p><p>将iptables命令写入一个专门放置<code>/PATH/TO/SOMEFILE</code>文件中，然后将此脚本文件放置<code>/etc/rc.d/rc.local</code>文件中</p><pre><code>iptables-restore &lt; /PATH/TO/SOMEFILE</code></pre><p><em>方法三：</em></p><p>在CentOS 7 中可以自定义Unit File ，进行iptables-restore</p><p><strong>注意：由于CentOS 7 中<code>/etc/rc.d/rc.local</code>文件没有执行权限，需要赋予执行权限才能实现</strong></p><p>如果要实现不同场景中实现不同规则，可以将规则集放入到不同的文件中，在不同场景中使用  <code>iptables-restore &lt; /PATH/TO/SOMEFILE</code>即可。但是只能有且只用一个规则集生效。</p>]]></content>
      
      
      <categories>
          
          <category> 防火墙 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>puppet  master/agent</title>
      <link href="/2017/11/28/puppet%20%E4%B8%BB%E4%BB%8E/"/>
      <url>/2017/11/28/puppet%20%E4%B8%BB%E4%BB%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="一、master-slave"><a href="#一、master-slave" class="headerlink" title="一、master/slave"></a>一、master/slave</h2><p>agent每个30分钟到master端请求与自己相关的catalog。</p><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><pre><code>master ‘node_name’ {    ...puppet code ...}</code></pre><h3 id="2、部署master："><a href="#2、部署master：" class="headerlink" title="2、部署master："></a>2、部署master：</h3><p>安装程序包：facter、puppet、puppet-server</p><p>初始化master：</p><pre><code>puppet master --no-daemonize --version</code></pre><p>生成一个完整配置参数列表：</p><pre><code>puppet master --genconfigpuppet agent --genconfig</code></pre><h3 id="3、master端管理证书签署"><a href="#3、master端管理证书签署" class="headerlink" title="3、master端管理证书签署"></a>3、master端管理证书签署</h3><p>puppet cert <action> [–all|-a] [<host>]</host></action></p><pre><code>action:    list    sign    revoke    clean:吊销指定的客户端的证书，并删除与其相关的所有文件</code></pre><h3 id="4、站点清单定义"><a href="#4、站点清单定义" class="headerlink" title="4、站点清单定义"></a>4、站点清单定义</h3><p>主机名定义：</p><pre><code>主机名-机架-机房-运营商-区域.域名</code></pre><h3 id="5、agent配置"><a href="#5、agent配置" class="headerlink" title="5、agent配置"></a>5、agent配置</h3><p>vim /etc/puppet/puppet.conf</p><pre><code>server = node_name</code></pre><p>puppet agent –no-daemonize -v -d –noop –test</p><h3 id="6、master签证"><a href="#6、master签证" class="headerlink" title="6、master签证"></a>6、master签证</h3><p>puppet cert sign node_name</p><p>/etc/puppet/manifest/site.pp</p><pre><code>node &#39;base&#39; {    include ntp }node &#39;HOSTNAME&#39; {    ...puppet code...}node /PATTERN/ {    ...puppet code...}node /node[0-9]+\.magedu\.com/</code></pre><p>清单配置信息可模块化组织：</p><pre><code>databases.d/tomcatservers.d/nodes.d/：可通过多个pp文件分别定义各类站点的清单；而后统一导入site.pp，方法如下：site.pp文件使用中如下配置：    import &#39;nodes/*.pp&#39;</code></pre><p>多环境配置：（开发环境、测试环境、线上环境）<br>        默认环境是production；</p><pre><code>    environmentpath =    创建一个连接文件。    puppet 3.4 之前的版本配置多环境的方法：         各环境配置：            /etc/puppet/environments/{production,development,testing}        master支持多环境：puppet.conf            [master]            # modulepath=            # manifest=            environments = production, development, testing            [production]            modulepath=/etc/puppet/environments/production/modules/            manifest=/etc/puppet/environments/production/manifests/site.pp            [development]            modulepath=/etc/puppet/environments/development/modules/            manifest=/etc/puppet/environments/development/manifests/site.pp                [testing]            modulepath=/etc/puppet/environments/testing/modules/            manifest=/etc/puppet/environments/testing/manifests/site.pp        puppet 3.6之后的版本配置多环境的方法：        puppet config print confdir        master支持多环境：            (1) 配置文件puppet.conf            [master]            environmentpath = $confdir/environments        puppet config print enviromentpath --section master        mkdir -pv /etc/puppet/environments/{testing,development,production}/{manifests,modules}                (2) 在多环境配置目录下为每个环境准备一个子目录            ENVIRONMENT_NAME/                manifests/                    site.pp                modules/    agent端：        [agent]        environment = { production|development | testing }额外配置文件：    文件系统：fileserver.conf    认证（URL）：auth.confpuppet kick：    agent：        puppet.conf        [agent]        listen = true  默认监听在8139/TCP        auth.conf文件中添加如下内容：        path /run        method save         auth any         allow master.magedu.com         path /        auth any    master端：        puppet kick             puppet kick [--host &lt;HOST&gt;] [--all]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> puppet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP配置</title>
      <link href="/2017/11/28/HTTP%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/11/28/HTTP%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Http安装及文件介绍"><a href="#Http安装及文件介绍" class="headerlink" title="Http安装及文件介绍"></a>Http安装及文件介绍</h2><h3 id="1、文件类型"><a href="#1、文件类型" class="headerlink" title="1、文件类型"></a>1、文件类型</h3><ul><li><p>主配置文件</p><p>  /etc/httpd/conf/httpd.conf<br>  /etc/httpd/conf.d/*.conf</p></li><li><p>服务脚本文件</p><p>  /etc/rc.d/init.d/httpd<br>  /etc/sysconfig/httpd    #脚本配置文件</p></li><li><p>站点网页文档默认目录</p><p>  /var/www/html</p></li><li><p>模块文件路径</p><p>  /etc/httpd/modules<br>  /usr/lib64/httpd/modules</p></li><li><p>主程序文件</p><p>  /usr/sbin/httpd<br>  /usr/sbin/httpd.worker<br>  /usr/sbin/httpd.event</p></li><li><p>主进程文件</p><p>  /etc/httpd/run /httpd.pid   #如果这个文件之前存在，系统重启之后会覆盖此配置文件。如果没有会自动创建之。</p></li><li><p>日志文件目录</p><p>  /var/log/httpd/access_log<br>  /var/log/httpd/err_log</p></li><li><p>帮助文档包</p><p>  httpd-manual    #如果需要使用可以安装，访问示例<code>http:192.168.4.135/manual</code></p></li></ul><h3 id="2、-etc-httpd-conf-httpd-conf文件选项介绍"><a href="#2、-etc-httpd-conf-httpd-conf文件选项介绍" class="headerlink" title="2、/etc/httpd/conf/httpd.conf文件选项介绍"></a>2、<code>/etc/httpd/conf/httpd.conf</code>文件选项介绍</h3><ul><li>httpd.conf文件的主要分类</li></ul><p><code>[root@localhost ~]# grep &#39;###&#39; /etc/httpd/conf/httpd.conf</code></p><pre><code>### Section 1: Global Environment   #全局配置### Section 2: &#39;Main&#39; server configuration  #主机配置### Section 3: Virtual Hosts    #虚拟主机配置</code></pre><ul><li>选项介绍</li></ul><p>（1）ServerTokens 显示服务器版本信息</p><p>syntax：ServerTokens Major|Minor|Min[imal]|Prod[uctOnly]|OS|Full</p><pre><code>ServerTokens Prod[uctOnly]  #仅显示类型  Server sends (e.g.): Server: ApacheServerTokens Major  #显示版本及主版本号Server sends (e.g.): Server: Apache/2ServerTokens Minor  #显示类型主板本号及此版本号Server sends (e.g.): Server: Apache/2.0ServerTokens Min[imal]Server sends (e.g.): Server: Apache/2.0.41ServerTokens OS #显示类型版本号及系统类型Server sends (e.g.): Server: Apache/2.0.41 (Unix)ServerTokens Full (or not specified)    #全部显示  #系统默认#Server sends (e.g.): Server: Apache/2.0.41 (Unix) PHP/4.2.2 MyMod/1.2   </code></pre><p><em>建议使用ServerTokens prod，防止此版本有漏洞被入侵。建议一般不要显示版本号。</em></p><p>（2）Listen 修改监听的IP和Port</p><p>Syntax:    Listen [IP-address:]portnumber [protocol]</p><ul><li>省略IP 表示为0.0.0.0</li><li>Listen指令至少一个，可重复出现多次</li><li>修改监听socket，重启或重新加载服务进程方可生效</li></ul><p>示例：</p><pre><code>Listen 80Listen 8080Listen 192.168.4.150:80</code></pre><p>（3）持久连接<br>建立连接，每个资源获取完成后不断开连接，而好似继续等待其他的请求完成，默认关闭</p><blockquote><p>KeepAlive</p></blockquote><p>Syntax:    KeepAlive On|Off    #默认为关闭</p><blockquote><p>MaxKeepAliveRequests </p></blockquote><p>Synatax:MaxKeepAliveRequests number     #默认最大连接请求100</p><blockquote><p>KeepAliveTimeout</p></blockquote><p>Syntax：KeepAliveTimeout  seconds    #默认持久连接超时时间为5秒</p><p>缺点：对并发量较大的服务器，持久连接功能会使其它有些请求得不到回应。</p><p>解决方法：使用较短的持久时间设置。</p><p>（4）MPM（Multi-Processing Module） 多进程处理模块</p><p>MPM的类型在前面已经详细的介绍，这里来说说在配置文件中怎么配置</p><blockquote><p>prefork配置</p></blockquote><pre><code>&lt;IfModule prefork.c&gt;StartServer number  #初始化开启几个进程MinSpareServers number  #最小空闲进程MaxSpareServers number  #最大空闲进程ServerLimit number  #最大开启的进程数 ，最大为20000个MaxClients number   #最大并发量MaxRequestsPerChild number  #最多处理的请求数量  默认为10000。在子进程请求之后，子进程会被父进程终止，子进程占用的内容就会释放（为0是永远释放）。&lt;/IfModule&gt;</code></pre><blockquote><p>worker配置</p></blockquote><pre><code>&lt;IfModule worker.c&gt;StartServers number  #初始化开启几个进程MaxClients number   #最大并发量MinSpareThreads number  #最小空闲线程MaxSpareThreads number  #最大空闲进程ThreadsPerChild number  #一个子进程最多开启几个线程MaxRequestsPerChild number #一个子进程最多有多个访问请求 默认10000&lt;/IfModule&gt;</code></pre><p>配置文件默认内容</p><pre><code>&lt;IfModule worker.c&gt;    StartServers 4     MaxClients 300     MinSpareThreads 25     MaxSpareThreads 75    ThreadsPerChild25    MaxRequestsPerChild 0  &lt;/IfModule&gt;  </code></pre><p>这里需要注意: <code>StartServers</code>*<code>ThreadsPerChild</code>&gt;<code>MaxSpareThreads</code> 所以系统初始时会少开一个进程。</p><p>如何更改工作模式呢？</p><p><code>[root@localhost ~]# vim /etc/sysconfig/httpd</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-29_114451.jpg" alt=""></p><p>如何计算PV的值呢？</p><p>假设每秒中开启256进程，持久连接，每个进程能处理5个资源；每个网页有100个资源，如何计算PV？</p><p>pv：256<em>5</em>86400/100=1105920</p><p>带宽1024<em>5</em>256/1024/1024*8=8M 网络中计算是以位为单位</p><p>（5）DSO：Dynamic Shared Object 动态加载模块</p><pre><code>httpd -M #查看动态加载模块httpd -l  #查看静态加载模块</code></pre><p>格式：</p><pre><code>LoadModule   &lt;mod_name&gt;   &lt;mod_path&gt;</code></pre><p>mod_path写路径时要写相对路径：相对于<code>ServerRoot</code></p><p>（6）DocumentRoot 定义Main server 中文档页面路径</p><p>Syntax:    DocumentRoot directory-path </p><p>文档路径映射：DocumentRoot指向的路径为URL路径的起始位置。</p><p><strong>示例：</strong></p><pre><code>http://HOST:PORT/test/index.html                              \|/                                  /app/data/test/index.html </code></pre><p>（7）DirectoryIndex 定义站点页面</p><p>Syntax:    DirectoryIndex local-url [local-url] …</p><p><code>/etc/httpd/conf.d/welcome.conf</code>如果主站点出错可以跳转至此页面</p><p>（8）站点访问控制常见机制</p><p>可基于两种机制指明对哪些资源进行何种访问控制</p><blockquote><p>文件系统路径：</p></blockquote><pre><code>&lt;directory &quot;/PATH&quot;&gt;    ...&lt;/directory&gt;&lt;File &quot;/PATH/FILE&quot;&gt;    ...&lt;/File&gt;&lt;FileMatch&gt;    ...&lt;/FileMatch&gt;</code></pre><blockquote><p>URL路径：</p></blockquote><pre><code>&lt;Location URL-path|URL&gt;    ...&lt;/Location&gt;&lt;LocationMatch regex&gt;    ...&lt;/LocationMatch&gt;</code></pre><p>其上的路径都可以使用正则表达式和通配符</p><table><thead><tr><th>通配符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>匹配任意长度字符</td></tr><tr><td>?</td><td>匹配任意单个字符</td></tr><tr><td>[]</td><td>匹配中括号内的任意单个字符</td></tr><tr><td>[^]</td><td>除中括号里的都匹配</td></tr></tbody></table><p>正则表达式：</p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配任意单个字符</td></tr><tr><td>*</td><td>匹配前一个字符任意长度，0次或多次</td></tr><tr><td>？</td><td>匹配前一个字符一次或0次</td></tr><tr><td>+</td><td>匹配前一个字符一次或多次</td></tr><tr><td>[]</td><td>匹配括号里的任意单个字符</td></tr></tbody></table><p>…</p><p><strong>示例：</strong></p><pre><code>&lt;FilesMatch &quot;\.(gif|jpe?g|png)$&quot;&gt;&lt;Files “?at.*”&gt; &lt;Location /status&gt; &lt;LocationMatch &quot;/(extra|special)/data&quot;&gt;</code></pre><p><strong>注意：使用正则表达式比较耗费资源，会遍历整个路径去寻找，建议不要使用。</strong></p><p>（9）<directory>中“基于源地址”实现访问控制</directory></p><ul><li>Options</li></ul><p>Syntax:    Options [+|-]option [[+|-]option] …</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>Indexes</td><td>指明的URL路径下不存在于定义的主页面资源相符的资源文件时，返回索引列表给用户</td></tr><tr><td>FollowSymlinks</td><td>允许访问符号链接文件所指向的源文件，默认支持软连接。</td></tr><tr><td>None</td><td>全部禁用</td></tr><tr><td>All</td><td>全部允许，系统默认选项</td></tr><tr><td>MultiViews</td><td>允许使用多视图</td></tr></tbody></table><p><strong>注意：Options只对<direcotry>有效。</direcotry></strong></p><p><strong>示例：</strong></p><p>（1）在<code>/etc/httpd/conf.d/</code>目录下创建custom.conf文件</p><p><code>[root@localhost conf.d]# vim custom.conf</code></p><pre><code>&lt;Directory &quot;/app/testweb&quot;&gt;Options None    #全部禁用&lt;/Directory&gt;</code></pre><p>（2）把welcome.conf文件删除或修改名字</p><p><code>[root@localhost conf.d]# mv welcome.conf welcome.conf.bak</code></p><p>（3）重启服务测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-29_160342.jpg" alt=""></p><p>现在我们再修改配置文件修改为<code>Options Indexes</code></p><pre><code>&lt;Directory &quot;/app/testweb&quot;&gt;     Options Indexes&lt;/Directory&gt;</code></pre><p>重启服务测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-29_160628.jpg" alt=""></p><ul><li>AllowOverride </li></ul><p>与访问控制相关的的指令可以放在指定目录下.htaccess文件中，覆盖之前配置指令。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>AuthConfig</td><td>允许使用与认证授权相关的指令</td></tr><tr><td>FileInfo</td><td>允许使用控制文档类型的指令</td></tr><tr><td>Indexes</td><td>允许使用控制目录索引的指令</td></tr><tr><td>Limit</td><td>允许使用控制主机访问的指令</td></tr><tr><td>Options[=Option,…]</td><td>允许使用控制指定目录功能的指令</td></tr><tr><td>None</td><td>.htaccess文件失效</td></tr></tbody></table><p><strong>示例:</strong></p><p>在上面的基础上我们再<code>/app/testweb.htaccess</code>此文件</p><p><code>[root@localhost testweb]# vim .htaccess</code></p><pre><code>Options Indexes</code></pre><p>在<code>custom.conf</code>编辑</p><p><code>[root@localhost conf.d]# vim custom.conf</code></p><pre><code>&lt;Directory &quot;/app/testweb&quot;&gt;Options NoneAllowOverride All&lt;/Directory&gt;</code></pre><p>由于我们在上面测试的时候如果Options为None时候网页出现如下情况</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-29_160342.jpg" alt=""></p><p>先我们再测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-29_160628.jpg" alt=""></p><p>这时你会不会想到放到站点目录下会不会被访问到呢？这样显然就不安全了，开发人员已经想到了这点如下：</p><pre><code>&lt;Files ~ &quot;^\.ht&quot;&gt;    Order allow,deny    Deny from all    Satisfy All&lt;/Files&gt;</code></pre><p>现在我们真正了解了<code>AllowOverride</code>选项作用了。使用这种方法我们控制一些内容。</p><ul><li>Order 和allow 、deny</li></ul><p>定义生效次序；写在后面的表示默认规则，优先级高。</p><table><thead><tr><th>匹配次序</th><th>条件</th><th>结果</th></tr></thead><tbody><tr><td>Match</td><td>Allow,Deny result</td><td>Deny,Allow result</td></tr><tr><td>Match Allow only</td><td>Request allowed</td><td>Request allowed</td></tr><tr><td>Match Deny only</td><td>Request denied</td><td>Request denied</td></tr><tr><td>No match</td><td>Default to second directive: Denied</td><td>Default to second directive: Allowed</td></tr><tr><td>Match both Allow &amp; Deny</td><td>Final match controls: Denied</td><td>Final match controls: Allowed</td></tr></tbody></table><blockquote><p>格式：</p></blockquote><p>A (partial) domain-name</p><p>Example:</p><pre><code>Allow from apache.orgdeny from .net example.edu</code></pre><p>A full IP address</p><p>Example:</p><pre><code>Allow from 10.1.2.3deny from 192.168.1.104 192.168.1.205</code></pre><p>A partial IP address</p><p>Example:</p><pre><code>Allow from 10.1deny from 10 172.20 192.168.2</code></pre><p>A network/netmask pair</p><p>Example:</p><pre><code>Allow from 10.1.0.0/255.255.0.0deny from 20.1.0.0/255.255.0.0</code></pre><p>A network/nnn CIDR specification</p><p>Example:</p><pre><code>Allow from 10.1.0.0/16deny from 20.1.0.0/16</code></pre><blockquote><p>示例</p></blockquote><p>编辑<code>custom.conf</code>文件</p><pre><code>&lt;Directory &quot;/app/testweb&quot;&gt;    Options Indexes    Order allow,deny    Deny from 192.168&lt;/Directory&gt;</code></pre><p>重启服务测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-29_160342.jpg" alt=""></p><p>如果修改为Allow</p><pre><code>&lt;Directory &quot;/app/testweb&quot;&gt;    Options Indexes    Order allow,deny    Allow from 192.168&lt;/Directory&gt;</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-29_160628.jpg" alt=""></p><p>（10）日志设定</p><p>LogLevel 设定日志级别</p><p>LogFormat   定义日志格式</p><blockquote><p>示例</p></blockquote><p>LogFormat “%h %l %u %t \”%r\” %&gt;s %b \”%{Referer}i\” \”%{User-Agent}i\”” combined</p><p>Syntax:    CustomLog file|pipe format|nickname [env=[!]environment-variable</p><blockquote><p>示例</p></blockquote><p>CustomLog logs/access_log combined</p><pre><code>/var/log/error_log 错误日志存放位置/var/log/access_log 访问成功日志存放位置</code></pre><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>%h</td><td>客户端IP地址</td></tr><tr><td>%L</td><td>远程用户，启动<code>mod_ident</code>才有效，通常为“-”</td></tr><tr><td>%u</td><td>验证远程用户，非登录访问时，为一个“-”</td></tr><tr><td>%t</td><td>服务器收到请求时的时间</td></tr><tr><td>%r</td><td>表示请求报文的首行，记录了此次请求的方法、URL以及协议版本</td></tr><tr><td>%&gt;s</td><td>响应状态码</td></tr><tr><td>%b</td><td>响应报文的大小，单位为字节；不包括响应报文http首部</td></tr><tr><td>%{Referer}i</td><td>请求报文中首部“referer”的值，即从哪个页面中的超链接跳转至当前页面</td></tr><tr><td>%{User-Agent}i</td><td>请求报文中首部“User-Agent”的值，即发出请求的应用程序</td></tr></tbody></table><p><strong>示例：</strong></p><p>192.168.4.1 - - [18/Sep/2017:17:14:09 +0800] “GET / HTTP/1.1” 403 281 “-“ “Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:56.0) Gecko/20100101 Firefox/56.0”</p><p>（11）AddDefaultCharset 设定默认字符集</p><p>Syntax:    AddCharset charset extension [extension] …</p><p>常用类型：UTF-8 GBK GB2312 GB18030</p><p>（12）定义路径别名</p><p>Syntax:    <code>Alias</code> URL-path file-path|directory-path</p><p>Syntax:    <code>AliasMatch</code> regex file-path|directory-path #可以使用通配符和正则表达式</p><p><strong>示例:</strong></p><p>修改<code>custom.conf</code>文件</p><pre><code>Alias /test /app/testweb&lt;Directory &quot;/app/testweb&quot;&gt;    Options Indexes&lt;/Directory&gt;</code></pre><p>重启服务测试</p><p><code>[root@localhost testweb]# curl -I 192.168.4.132/test</code></p><pre><code>HTTP/1.1 301 Moved PermanentlyDate: Mon, 18 Sep 2017 09:38:50 GMTServer: Apache/2.2.15 (CentOS)Location: http://192.168.4.132/test/Connection: closeContent-Type: text/html; charset=iso-8859-1</code></pre><p>（13）基于用户的访问控制</p><p>认证质询：WWW-Authenticate</p><p>Authorization：客户端用户填入账号和密码后再次发送请求报文；认证通过时，服务器发送响应的资源。</p><p>认证方式类型：</p><pre><code>basic：明文digest：消息摘要认证，兼容性查</code></pre><p>安全域：需要用户认证后才能访问的路径；通过名称对齐进行标识，以便于告知用户认证原因。</p><p>虚拟账户：仅用于访问某服务时用到的认证标识。创建文件的位置在<code>/etc/httpd/conf.d/</code>目录下。</p><blockquote><p>basic认证示例<br>（1）定义安全域</p></blockquote><pre><code>&lt;Directory “/PATH”&gt;    AuthType #认证类型    AuthName #提示信息    AuthUserFile #认证文件位置    Require user UserName1 UserName2 .. #从认证文件中挑选出的用户可以访问    Requie vaild-user #允许账户文件中的所有用户登录访问    AuthGroupFile  组文件存放的位置    Require group GrpName1 GrpName1.. #允许指定组用户登录访问&lt;/Directory&gt;</code></pre><p>（2）提供账号和密码存储的位置，一般为隐藏文件</p><h5 id="htpasswd命令"><a href="#htpasswd命令" class="headerlink" title="htpasswd命令"></a>htpasswd命令</h5><p>htpasswd ：Manage user files for basic authentication</p><p>选项：</p><pre><code>-c：自动创建文件，仅在文件不存在创建时使用-m：使用md5加密-s：使用sha格式加密-D：删除指定用户</code></pre><p>（3）创建组账号文件</p><pre><code>组名称：user1  user2 ...</code></pre><h5 id="远程客户端和用户验证的控制"><a href="#远程客户端和用户验证的控制" class="headerlink" title="远程客户端和用户验证的控制"></a>远程客户端和用户验证的控制</h5><p>Satisfy： Interaction between host-level access control and user authentication 主机访问控制和用户认证之间的交互</p><p>|<br>|All|客户机IP和用户验证都需要通过才能访问<br>|Any|客户机IP和用户验证有一个满足就可以访问</p><blockquote><p>示例一</p></blockquote><p>基于用户认证控制</p><p>（1）创建存放密码的配置文件</p><p><code>[root@localhost conf.d]# htpasswd -c .htusers wang</code><br><code>[root@localhost conf.d]# htpasswd -s .htusers li</code><br><code>[root@localhost conf.d]# htpasswd -s .htusers joah</code></p><p>（2）修改<code>custom.conf</code>配置文件</p><pre><code>Alias /test /app/testweb&lt;Directory &quot;/app/testweb&quot;&gt;    Options Indexes    AuthType basic    AuthName &quot;welcom visit...&quot;    AuthUserFile &quot;/etc/httpd/conf.d/.htusers&quot;    Require user wang&lt;/Directory&gt;</code></pre><p>（3）重启服务测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-29_173622.jpg" alt=""></p><p>输入wang账户后</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-29_160628.jpg" alt=""></p><blockquote><p>示例二</p></blockquote><p>基于组账户认证</p><p>在上述基础之上进行如下操作</p><p>（1）将上述用户加入组中<br><code>[root@localhost conf.d]# groupmems -a wang -g webtest</code></p><p><code>[root@localhost conf.d]# groupmems -a li -g webtest</code></p><p><code>[root@localhost conf.d]# groupmems -a joah -g webtest</code></p><p>（2）创建组用户文件</p><p><code>[root@localhost conf.d]# vim .htgrps</code></p><pre><code>webtest:wang li</code></pre><p>（3）修改<code>custom.conf</code>文件<br>Alias /test /app/testweb</p><pre><code>&lt;Directory &quot;/app/testweb&quot;&gt;    Options Indexes    AuthType basic    AuthName &quot;welcom visit...&quot;    AuthUserFile &quot;/etc/httpd/conf.d/.htusers&quot;    AuthGroupFile &quot;/etc/httpd/conf.d/.htgrps&quot;    Require group webtest&lt;/Directory&gt;</code></pre><p>（4）重启服务测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-29_173622.jpg" alt=""></p><p>输入li账户后</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-29_160628.jpg" alt=""></p><p>（14）虚拟主机</p><p>虚拟主机有三种实现方式：</p><ul><li>基于IP，为每个虚拟主机准备至少一个IP地址</li><li>基于Port，为每个虚拟主机使用至少一个独立的Port</li><li>基于FQDN，为每个虚拟主机使用至少一个FQDN</li></ul><p><strong>注意：一般虚拟主机不要与Main主机混用；如果要使用虚拟主机，一般先禁用Main主机。<br>如果要禁用Main主机，直接禁用DocumentRoot即可。</strong></p><blockquote><p>示例一：基于IP的虚拟主机</p></blockquote><p>（1）编辑配置文件<code>custom.conf</code></p><pre><code>&lt;VirtualHost  192.168.4.132:80&gt;    DocumentRoot &quot;/app/a.com/htdocs&quot;&lt;/VirtualHost&gt;&lt;VirtualHost  192.168.4.133:80&gt;    DocumentRoot &quot;/app/b.net/htdocs&quot;&lt;/VirtualHost&gt;&lt;VirtualHost  192.168.4.134:80&gt;    DocumentRoot &quot;/app/c.org/htdocs&quot;&lt;/VirtualHost&gt;</code></pre><p>（2）创建所需文件</p><p><code>[root@localhost conf.d]# mkdir /app/a.com/htdocs -pv</code></p><p><code>[root@localhost conf.d]# mkdir /app/b.net/htdocs -pv</code></p><p><code>[root@localhost conf.d]# mkdir /app/c.org/htdocs -pv</code></p><p><code>[root@localhost conf.d]# echo www.a.com &gt; /app/a.com/htdocs/index.html</code></p><p><code>[root@localhost conf.d]# echo www.b.net&gt; /app/b.net/htdocs/index.html</code></p><p><code>[root@localhost conf.d]# echo www.c.org&gt; /app/c.org/htdocs/index.html</code></p><p>（3）添加IP地址</p><p><code>[root@localhost conf.d]# ip addr add 192.168.4.133/24 dev eth0</code></p><p><code>[root@localhost conf.d]# ip addr add 192.168.4.134/24 dev eth0</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-29_185150.jpg" alt=""></p><p>（4）重启服务测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-29_185248.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-29_185306.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-29_185320.jpg" alt=""></p><blockquote><p>示例二：基于Port的虚拟主机</p></blockquote><p>（1）编辑<code>custom.com</code>文件</p><pre><code>Listen 192.168.4.132:81Listen 192.168.4.132:82Listen 192.168.4.132:83&lt;VirtualHost  192.168.4.132:80&gt;    DocumentRoot &quot;/app/a.com/htdocs&quot;&lt;/VirtualHost&gt;&lt;VirtualHost  192.168.4.132:81&gt;    DocumentRoot &quot;/app/b.net/htdocs&quot;&lt;/VirtualHost&gt;&lt;VirtualHost  192.168.4.132:82&gt;    DocumentRoot &quot;/app/c.org/htdocs&quot;&lt;/VirtualHost&gt;</code></pre><p>（2）重启服务器测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-30_135922.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-30_135935.jpg" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-30_135949.jpg" alt=""></p><blockquote><p>示例三：基于FQDN的虚拟主机</p></blockquote><p>我们准备三台虚拟主机，一台CentOS 6 配置3个FQDN，一台CentOS 7配置DNS，一台CentOS 7测试</p><p>第一步：在CentOS 6 上配置3个FQDN</p><pre><code>NameVirtualHost *:80    #注意这项配置在CentOS 6 中必须开启，切记！！！NameVirtualHost *:80&lt;VirtualHost *:80&gt;    ServerName &quot;www.a.com&quot;    DocumentRoot &quot;/app/a.com&quot;&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt;    ServerName &quot;www.b.com&quot;    DocumentRoot &quot;/app/b.com&quot;&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt;    ServerName &quot;www.c.com&quot;    DocumentRoot &quot;/app/c.com&quot;&lt;/VirtualHost&gt;</code></pre><p>第二步：在CentOS 7上配置DNS服务器 </p><p><code>[root@localhost~]#yum install -y bind</code></p><p><code>[root@localhost/etc/named]#vim /etc/named.conf</code>    #修改图中方框内容</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-01_101243.jpg" alt=""></p><p><code>[root@localhost/etc/named]#vim /etc/named.rfc1912.zones</code><br><img src="http://owatlfstl.bkt.clouddn.com/2017-10-01_101804.jpg" alt=""></p><p><code>[root@localhost/var/named]#vim a.com.zone</code>    #b.com.zone 和c.com.zone类似这里就不累述。</p><pre><code>  1 $TTL 1D  2 @       IN SOA  dns1 mail.a.com. (  3                                         0       ; serial  4                                         1D      ; refresh  5                                         1H      ; retry  6                                         1W      ; expire  7                                         3H )    ; minimum  8         NS      dns1  9 dns1    A       192.168.4.164 10 www     A       192.168.4.132</code></pre><p>重启服务</p><p>第三步：在另一台CentOS 7 主机上测试</p><p><code>[root@localhost~]#vim /etc/resolv.conf</code>    #修改DNS</p><pre><code>  1 # Generated by NetworkManager  2 search localdomain  3 nameserver 192.168.4.164</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-01_115724.jpg" alt=""></p><p>（15）status页面</p><p>要实现这个功能需要加载模块<code>mod_status.so</code></p><p>格式：</p><pre><code>LoadModule  status_module  modules/mod_status.so&lt;Location /server-status&gt;    SetHandler server-status    Order allow,deny    Allow   192.168.4&lt;/Location&gt;</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-01_120206.jpg" alt=""></p><pre><code>ExtendedStatus On   #开启此选项显示更多内容</code></pre><p><strong>建议：不要开启此选项，如果处于测试状态可以开启拍错。</strong></p><p>（16）mod_deflate模块 压缩页面优化传输速度</p><p>适用场景：</p><ul><li>节约带宽，额外消耗CPU；</li><li>压缩适于压缩的资源，如文本文件</li></ul><p>如何启用压缩功能？</p><p>SetOutputFilter DEFLATE</p><pre><code>AddOutputFilterByType DEFLATE text/plain AddOutputFilterByType DEFLATE text/html AddOutputFilterByType DEFLATE application/xhtml+xmlAddOutputFilterByType DEFLATE text/xml AddOutputFilterByType DEFLATE application/xml AddOutputFilterByTypeDEFLATE application/x-javascript AddOutputFilterByType DEFLATE text/javascript AddOutputFilterByType DEFLATE text/css </code></pre><p>Level of compression    指定压缩比 （1-9），默认为9</p><p>（17）mod_ssl模块 认证模块</p><p>http基于ssl认证过程：</p><pre><code>（1）客户端发送可供选择的加密方式，并向服务器请求证书（2）服务器端发送证书以及选定的加密方式给客户端（3）客户端取得证书并进行证书验证如果信任给其发证书的CA    验证证书的来源的合法性：用CA的公钥解密证书上数字签名    验证证书内容的合法性：完整性验证    验证证书有效期限    检查证书是否被吊销（4）客户端生成临时会话密钥，并使用服务器端的公钥加密此数据发送给服务器，完成密钥交换（5）服务用此密钥加密用户请求的资源，响应客户端。</code></pre><p><strong>注意：SSL是基于IP地址实现，单IP的主机仅可以使用一个HTTPS虚拟主机。</strong></p><blockquote><p>实现https的过程：</p></blockquote><p>（1）先建立私有CA；在CentOS 7上</p><p><code>[root@localhost~]#cd /etc/pki/CA/</code></p><p><code>[root@localhost/etc/pki/CA]#(umask 066；openssl genrsa -out private/cakey.pem 2048</code>）</p><p><code>[root@localhost/etc/pki/CA]#openssl req -new -x509 -key private/cakey.pem -out casert.pem -days 4650</code></p><p><code>[root@localhost/etc/pki/CA]#echo 01 &gt; serial</code></p><p><code>[root@localhost/etc/pki/CA]#touch index.txt</code></p><p>（2）在CentOS 6上创建请求认证证书</p><p><code>[root@localhost ssl]# (umask 066；openssl genrsa -out httpd.key 2048）</code></p><p><code>[root@localhost ssl]# openssl req -new -key httpd.key -out httpd.csr</code></p><p><code>[root@localhost ssl]# scp httpd.csr 192.168.4.163:/etc/pki/CA/certs/</code></p><p>（3）CentOS 7对收到的证书签证并返回</p><p><code>[root@localhost/etc/pki/CA/certs]#openssl ca -in httpd.csr -out httpd.crt -days 300</code></p><p><code>[root@localhost/etc/pki/CA/certs]#scp httpd.crt 192.168.4.132:/etc/httpd/conf/ssl</code></p><p>（4）在CentOS 6上安装此 模块并修改配置文件</p><p><code>[root@localhost conf.d]# yum install -y mod_ssl</code></p><p><code>[root@localhost conf.d]# vim ssl.conf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-30_083150.jpg" alt=""><br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-30_074017.jpg" alt=""></p><p>（5）将证书拷贝到本地添加至浏览器中</p><p>当我们每次输入<a href="http://192.168.4.132时想要直接https://192.168.4.132访问网页怎么做呢？" target="_blank" rel="noopener">http://192.168.4.132时想要直接https://192.168.4.132访问网页怎么做呢？</a></p><p>将http请求转发至https的URL，可以使用重定向</p><pre><code>Redirect [status] URL-path URL</code></pre><blockquote><p>status分类：</p></blockquote><ul><li>Permanent:Returns a permanent redirect status(301)    indicating that the resource has moved permanently</li><li>Temp:Returns a temporary redirect status (302). This is the default</li></ul><blockquote><p>示例：</p></blockquote><pre><code>Redirect temp  / https://www.a.com/Redirect permanent / https://www.a.com/</code></pre><p><strong>注意：设置跳转时，根下的目录也会自动跳转。</strong></p><p><code>[root@localhost conf.d]# vim custom.conf</code></p><pre><code>Redirect temp / https://192.168.4.132/</code></pre><p>测试</p><p><code>[root@localhost conf.d]# curl --cacert -L 192.168.4.132/</code></p><pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;    #由于之前我们已经介绍了状态码，所以看到302代表临时跳转。&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Found&lt;/h1&gt;&lt;p&gt;The document has moved &lt;a href=&quot;https://192.168.4.132/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;hr&gt;&lt;address&gt;Apache/2.2.15 (CentOS) Server at 192.168.4.132 Port 80&lt;/address&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>（18）HSTS:HTTP Strict Transport Security</p><p>如果我们使用HTTPS 访问一个网站，我们大多数情况习惯按<code>http://</code>这样的方式去访问，在配置文件中添加<code>Redirect temp / https://</code> 或<code>Redirect permanent / https://</code>这种方式解决；其工作方式如下</p><p><img src="http://owatlfstl.bkt.clouddn.com/%E9%87%8D%E5%AE%9A%E5%90%91.png" alt=""></p><p>当浏览器第一次发出HTTP请求时是明文发送的，这种容易被攻击者拦截下来，攻击者作为代理，把当前请求转发至钓鱼网站，钓鱼网站返回假冒的网页内容，攻击者把假冒的网页返回给浏览器；如下图</p><p><img src="http://owatlfstl.bkt.clouddn.com/%E9%87%8D%E5%AE%9A%E5%90%91%E6%94%BB%E5%87%BB%E8%80%85.png" alt=""></p><p>为了解决这个文件就有人提出了HSTS方案：服务器端配置支持HSTS后，会在给浏览器返回的HTTP首部中携带HSTS字段。浏览器获取到该信息后，会将所有HTTP访问请求在内部做307跳转到HTTPS，而无需任何网络过程；从而使得中间人攻击失效。<br><img src="http://owatlfstl.bkt.clouddn.com/hsts1.png" alt=""></p><blockquote><p>如何设置HSTS呢？</p></blockquote><p>Strict-Transport-Security: <max-age=>[; includeSubDomains][; preload]</max-age=></p><pre><code>max-age：过期时间，默认单位为秒，你每次访问它都会在访问时间之后的值时间。includeSubDomains：是可选参数，如果包含它意味着当前域名或子域均开启HSTS保护preload：是可选参数，只有当你申请将自己的加入到浏览器内置列表的时候才需要使用到它。</code></pre><blockquote><p>重定向的另外一种方式：使用模块mod_rewrite</p></blockquote><p>在使用这种方式之前我们先确认<code>mod_rewrite</code>是否被加载</p><p>格式：</p><p><img src="http://owatlfstl.bkt.clouddn.com/syntax_rewritecond.png" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/syntax_rewriterule.png" alt=""></p><p><img src="http://owatlfstl.bkt.clouddn.com/rewrite_backreferences.png" alt=""></p><p><strong>示例:</strong></p><pre><code>Header always set Strict-Transport-Security &quot;max-age=15768000&quot;RewriteEngine on    #是否开启重启引擎RewriteRule ^(/.*)$    https://%{HTTP_HOST}$1 [redirect=301] </code></pre><p>（19）httpd自带的工具程序</p><ul><li>ab命令：压力测试工具</li></ul><p>usage：ab  [OPTIONS]  URL</p><pre><code>-n：总请求数-c：模拟的并行数-k：以持久连接模式测试</code></pre><ul><li>htpasswd：基于认证basci时，用到的账户密码文件生成工具</li></ul><p>usage： htpasswd [ -c ] [ -m ] [ -D ] passwdfile username</p><pre><code>-c：如果passwdfile文件不存在使用-D：删除用户-m：使用md5加密，默认-s：使用SHA格式加密</code></pre><h2 id="三、编译安装httpd-2-4"><a href="#三、编译安装httpd-2-4" class="headerlink" title="三、编译安装httpd-2.4"></a>三、编译安装httpd-2.4</h2><p>（1）准备安装前环境</p><p><code>[root@localhost ~]# yum groupinstall -y &quot;development tools&quot;</code></p><p>（2）编译安装apr</p><p><code>[root@localhost src]# tar xf apr-1.6.2.tar.gz</code><br><code>[root@localhost apr-1.6.2]# ./configure --prefix=/app/apr</code><br><code>[root@localhost apr-1.6.2]# make &amp;&amp; make install</code></p><p>（3）编译安装apr-util</p><p><code>[root@localhost src]# tar xf apr-util-1.6.0.tar.gz</code><br><code>[root@localhost apr-util-1.6.0]# ./configure --prefix=/app/apr-util --with-apr=/app/apr</code><br><code>[root@localhost apr-util-1.6.0]# yum install -y expat-devel</code>   #编译依赖与这个包（Expat是一个用C语言开发的、用来解析XML文档的开发库）<br><code>[root@localhost apr-util-1.6.0]# make &amp;&amp; make install</code></p><p>（4）编译安装httpd-2.4<br><code>[root@localhost src]# useradd -r -m -d /app/website -s /sbin/nologin apache</code></p><p><code>[root@localhost src]# tar xf httpd-2.4.27.tar.bz2</code></p><p><code>[root@localhost httpd-2.4.27]# yum install -y pcre-devel openssl-devel</code></p><p><code>[root@localhost httpd-2.4.27]# ./configure --prefix=/app/httpd24 --enable-so --enable-ssl --enable-cgi --enable-rewrite --with-zlib --with-pcre --with-apr=/app/apr/ --with-apr-util=/app/apr-util/ --enable-modules=most --enable-mpms-shared=all --with-mpm=prefork</code></p><p><code>[root@localhost bin]# make &amp;&amp; make install</code></p><blockquote><p>修改PATH路径</p></blockquote><p><code>[root@localhost bin]# vim /etc/profile.d/http24.sh</code></p><pre><code>export PATH=/app/httpd24/bin:$PATH</code></pre><p><code>[root@localhost bin]# source /etc/profile.d/http24.sh</code>    #使其生效<br><code>[root@localhost bin]# echo $PATH</code></p><pre><code>/app/httpd24/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</code></pre><blockquote><p>修改配置文件</p></blockquote><p><code>[root@localhost conf]# vim httpd.conf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-02_181833.jpg" alt=""><br><img src="http://owatlfstl.bkt.clouddn.com/2017-10-02_182033.jpg" alt=""></p><blockquote><p>配置启动脚本</p></blockquote><p>方法一：</p><p><code>[root@localhost conf]# scp 192.168.4.132:/etc/init.d/httpd /etc/init.d/httpd24</code>  #如果其他主机上有可以拷贝一份</p><p><code>[root@localhost httpd-2.4.27]# vim /etc/init.d/httpd24</code></p><pre><code>apachectl=/app/httpd24/apachectlhttpd=${HTTPD-/app/httpd24/httpd}prog=httpdpidfile=${PIDFILE-/app/httpd24/logs/httpd.pid}lockfile=${LOCKFILE-/var/lock/subsys/httpd}RETVAL=0STOP_TIMEOUT=${STOP_TIMEOUT-10}</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-02_211234.jpg" alt=""></p><p><code>[root@localhost conf]# chkconfig --add httpd24</code>    #将此服务加到服务中心<br><code>[root@localhost conf]# chkconfig httpd24 on</code>设为开机启动</p><p>方法二：由于CentOS 6中支持rc.local脚本所有我们可以把命令写到脚本中，设为开机启动</p><p><code>[root@localhost conf]# vim /etc/rc.d/rc.local</code></p><pre><code>/app/httpd24/apachectl start</code></pre><p><code>[root@localhost conf]# chmod +x /etc/rc.d/rc.local</code></p><blockquote><p>测试</p></blockquote><p><code>[root@localhost website]# echo index.html &gt; index.html</code></p><p><code>[root@localhost website]# apachectl start</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-02_183544.jpg" alt=""></p><blockquote><p>安装方式二</p></blockquote><p>（1）准备安装前环境</p><p><code>[root@localhost ~]# yum groupinstall -y &quot;development tools&quot;</code></p><p>（2）解压apr包</p><p><code>[root@localhost src]# tar xf apr-1.6.2.tar.gz</code> </p><p>（3）解压apr-util包</p><p><code>[root@localhost src]# tar xf apr-util-1.6.0.tar.gz</code> </p><p>（4）编译安装httpd-2.4<br><code>[root@localhost src]# useradd -r -m -d /app/website -s /sbin/nologin apache</code></p><p><code>[root@localhost src]# tar xf httpd-2.4.27.tar.bz2</code></p><p><code>[root@localhost httpd-2.4.27]# yum install -y pcre-devel openssl-devel</code></p><blockquote><p>将解压包移动到srclib目录下<br><code>[root@localhost src]# mv apr-1.6.2 httpd-2.4.27/srclib/apr</code> </p></blockquote><p><code>[root@localhost src]# mv apr-util-1.6.0 httpd-2.4.27/srclib/apr-util</code></p><p><code>[root@localhost httpd-2.4.27]# ./configure --prefix=/app/httpd24 --enable-so --enable-ssl --enable-cgi --enable-rewrite --with-zlib --with-pcre --with-included-apr --enable-modules=most --enable-mpms-shared=all --with-mpm=prefork</code></p><p><code>[root@localhost httpd-2.4.27]# make &amp;&amp; make install</code></p><blockquote><p>修改配置文件</p></blockquote><p><code>[root@localhost conf]# vim httpd.conf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-02_181833.jpg" alt=""><br><img src="http://owatlfstl.bkt.clouddn.com/2017-10-02_182033.jpg" alt=""></p><blockquote><p>配置启动脚本</p></blockquote><p>方法一：</p><p><code>[root@localhost conf]# scp 192.168.4.132:/etc/init.d/httpd /etc/init.d/httpd24</code>  #如果其他主机上有可以拷贝一份</p><p><code>[root@localhost httpd-2.4.27]# vim /etc/init.d/httpd24</code></p><pre><code>apachectl=/app/httpd24/apachectlhttpd=${HTTPD-/app/httpd24/httpd}prog=httpdpidfile=${PIDFILE-/app/httpd24/logs/httpd.pid}lockfile=${LOCKFILE-/var/lock/subsys/httpd}RETVAL=0STOP_TIMEOUT=${STOP_TIMEOUT-10}</code></pre><p><code>[root@localhost conf]# chkconfig --add httpd24</code>    #将此服务加到服务中心<br><code>[root@localhost conf]# chkconfig httpd24 on</code>设为开机启动</p><p>方法二：由于CentOS 6中支持rc.local脚本所有我们可以把命令写到脚本中，设为开机启动</p><p><code>[root@localhost conf]# vim /etc/rc.d/rc.local</code></p><pre><code>/app/httpd24/apachectl start</code></pre><p><code>[root@localhost conf]# chmod +x /etc/rc.d/rc.local</code></p><p>方法三：将/app/httpd24/bin/apachectl文件拷贝至/etc/init.d/httpd</p><p><code>[root@localhost httpd24]# cp /app/httpd24/bin/apachectl /etc/init.d/httpd24</code></p><blockquote><p>测试</p></blockquote><p><code>[root@localhost website]# echo index.html &gt; index.html</code></p><p><code>[root@localhost website]# apachectl start</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-02_183544.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP，Apache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobbler</title>
      <link href="/2017/11/28/Cobbler/"/>
      <url>/2017/11/28/Cobbler/</url>
      
        <content type="html"><![CDATA[<h2 id="一、cobbler"><a href="#一、cobbler" class="headerlink" title="一、cobbler"></a>一、cobbler</h2><h3 id="1、cobbler概念"><a href="#1、cobbler概念" class="headerlink" title="1、cobbler概念"></a>1、cobbler概念</h3><p>Cobbler是一个Linux服务器快速网络安装的服务，而且在经过调整也可以支持网络安装windows。<br>该工具使用python开发，小巧轻便（才15k行python代码），可以通过网络启动(PXE)的方式来快速安装、重装物理服务器和虚拟机，同时还可以管理DHCP，DNS，TFTP、RSYNC以及yum仓库、构造系统ISO镜像。<br>Cobbler可以使用命令行方式管理，也提供了基于Web的界面管理工具(cobbler-web)，还提供了API接口，可以方便二次开发使用。<br>Cobbler是较早前的kickstart的升级版，优点是比较容易配置，还自带web界面比较易于管理。<br>Cobbler内置了一个轻量级配置管理系统，但它也支持和其它配置管理系统集成，如Puppet，暂时不支持SaltStack。<br>Cobbler客户端Koan支持虚拟机安装和操作系统重新安装，使重装系统更便捷。</p><h3 id="2、工作流程"><a href="#2、工作流程" class="headerlink" title="2、工作流程"></a>2、工作流程</h3><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-17_230927.png" alt=""></p><p>（a）client裸机配置了从网络启动后，开机后会广播包请求DHCP服务器（cobbler server）发送其分配好的一个IP</p><p>（b）DHCP服务器（cobbler server）收到请求后发送responese，包括其ip地址</p><p>（c）client裸机拿到ip后再向cobbler server发送请求OS引导文件的请求</p><p>（d）cobbler server告诉裸机OS引导文件的名字和TFTP server的ip和 port</p><p>（e）client裸机通过上面告知的TFTP server地址通信，下载引导文件</p><p>（f）client裸机执行执行该引导文件，确定加载信息，选择要安装的os，</p><p>（g）期间会再向cobbler server请求kickstart文件和os image</p><p>（h）cobbler server发送请求的kickstart和os iamge<br>client裸机加载kickstart文件</p><p>（i）client裸机接收os image，安装该os image</p><h3 id="3、cobbler包介绍"><a href="#3、cobbler包介绍" class="headerlink" title="3、cobbler包介绍"></a>3、cobbler包介绍</h3><p>cobbler包集成了dhcp，pxe服务，rsync，http，dns，kiskstart，IPMI电源管理。</p><h3 id="cobbler命令"><a href="#cobbler命令" class="headerlink" title="cobbler命令"></a>cobbler命令</h3><p>格式：<br>cobbler command [subcommand] [–arg1=value1] [–arg2=value2]</p><p>cobbler check 核对当前设置是否有问题<br>cobbler list 列出所有的cobbler元素<br>cobbler repo 列出元素的详细信息</p><p>cobbler sync 同步配置到数据目录，更改配置</p><p>cobbler reposync 同步yum仓库</p><p>cobbler distro 查看导入的发行版系统信息</p><pre><code>cobbler distro addcobbler distro copycobbler distro editcobbler distro findcobbler distro listcobbler distro removecobbler distro renamecobbler distro report</code></pre><p>cobbler system 查看添加的系统信息</p><p>cobbler profile 查看配置信息</p><pre><code>cobbler profile add    --name=NAME    --distro=DISTRO     --kickstart=KICKSTART cobbler profile list    #列出配置文件信息cobbler profile remove     cobbler profile rename  修改配置文件名称  cobbler profile report  #列出某个配置文件的报告    --name=NAME </code></pre><p>cobbler improt</p><p>|<br> | –arch=ARCH         |  OS architecture being imported<br> | –breed=BREED       |  the breed being imported<br> | –os-version=OS_VERSION  |the version being imported<br> | –path=PATH         |  local path or rsync location<br> | –name=NAME      |     name, ex ‘RHEL-5’<br> | –available-as=AVAILABLE_AS |  tree is here, don’t mirror<br> | –kickstart=KICKSTART_FILE    |  assign this kickstart file<br> | –rsync-flags=RSYNC_FLAGS |   pass additional flags to rsync</p><h3 id="3、cobbler目录介绍"><a href="#3、cobbler目录介绍" class="headerlink" title="3、cobbler目录介绍"></a>3、cobbler目录介绍</h3><pre><code>/etc/cobbler/settings : cobbler 主配置文件 /etc/cobbler/iso/: iso模板配置文件 /etc/cobbler/pxe: pxe模板文件 /etc/cobbler/power: 电源配置文件 /etc/cobbler/user.conf: web服务授权配置文件/etc/cobbler/users.digest: web访问的用户名密码配置文件    /etc/cobbler/dhcp.template : dhcp服务器的的配置模板   /etc/cobbler/dnsmasq.template : dns服务器的配置模板/etc/cobbler/tftpd.template : tftp服务的配置模板   /etc/cobbler/modules.conf : 模块的配置文件</code></pre><p> 数据目录</p><pre><code>/var/lib/cobbler/config/: 用于存放distros，system，profiles 等信息配置文件/var/lib/cobbler/triggers/: 用于存放用户定义的cobbler命令 /var/lib/cobbler/kickstart/: 默认存放kickstart文件/var/lib/cobbler/loaders/: 存放各种引导程序</code></pre><p>镜像目录</p><pre><code>/var/www/cobbler/ks_mirror/: 导入的发行版系统的所有数据/var/www/cobbler/images/ : 导入发行版的kernel和initrd镜像用于远程网络启动/var/www/cobbler/repo_mirror/: yum 仓库存储目录 </code></pre><p>日志目录</p><pre><code>/var/log/cobbler/installing: 客户端安装日志/var/log/cobbler/cobbler.log : cobbler日志</code></pre><h3 id="4、相关术语"><a href="#4、相关术语" class="headerlink" title="4、相关术语"></a>4、相关术语</h3><p>发行版：表示一个操作系统。它承载了内核和initrd信息，以及内核参数等其他数据。</p><p>配置文件：包含一个发行版、一个kickstart文件以及可能的存储库，还包含更多特定的内核参数等其他数据。</p><p>系统：表示要配给的机器。它包含一个配置文件或一个镜像，还包含IP和MAC地址、电源管理以及更专业的数据信息。</p><p>存储库：保存一个yum或rsync存储库的镜像信息。<br>镜像：可替换一个包含不属于此类别的文件的发行版对象。（例如，无法分为内核和initrd对象）</p><h2 id="二、cobbler实战"><a href="#二、cobbler实战" class="headerlink" title="二、cobbler实战"></a>二、cobbler实战</h2><p>（1）安装cobbler安装包和dhcp<br><code>[root@localhost ~]# yum install -y cobbler</code></p><p><code>[root@localhost ~]# yum install -y dhcp</code></p><p>（2）将服务设为开机启动并启动服务<br><code>[root@localhost ~]# systemctl enable tftp</code> #将tftp服务设为开机启动，并启动它</p><p><code>[root@localhost ~]# systemctl start tftp</code></p><p><code>[root@localhost ~]# systemctl enabel httpd</code>    #将http服务设为开机启动并启动</p><p><code>[root@localhost ~]# systemctl enable httpd</code></p><p><code>[root@localhost ~]# systemctl start httpd</code></p><p><code>[root@localhost ~]# systemctl enable cobblerd</code> #将cobbler设为开机启动并启动</p><p><code>[root@localhost ~]# systemctl start cobblerd</code></p><p>（3）运行<code>cobbler check</code>命令解决问题<br>为了确保出现不必要的问题，禁用iptables和setenforce</p><p><code>[root@localhost ~]# iptables -F</code>#清空防火墙规则<br><code>[root@localhost ~]# setenforce 0</code>   #将selinux设为permissiving</p><p><code>[root@localhost ~]# cobbler check</code>   #检查cobbler环境是否配置正确</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-18_112328.png" alt=""></p><p>当运行<code>cobbler check</code>命令时出现上述的问题，我们通过一个一个解决就可以慢慢的实现cobbler自动化安装CentOS 系统。下面我们一个一个的解决这些文件</p><p>（a）修改cobbler服务端地址选项server<code></code>[root@localhost ~]# vim /etc/cobbler/settings<br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-18_113027.png" alt=""></p><p><code>[root@localhost ~]# cobbler sync</code>  #将修改过的文件同步</p><p>（b）修改next_server    此选项是修改tftp的地址<br><code>[root@localhost ~]# vim /etc/cobbler/settings</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-18_113142.png" alt=""></p><p><code>[root@localhost ~]# cobbler sync</code></p><p>（c）修改mange_dhcp 此选项是要cobbler管理dhcp<br><code>[root@localhost ~]# vim /etc/cobbler/settings</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-18_113339.png" alt=""></p><p><code>[root@localhost ~]# cobbler sync</code></p><p>（d）获取启动菜单<br>方法一：<br>如果有网络的话使用如下方式</p><p><code>[root@localhost ~]# cobbler get-loaders</code><br>方法二：</p><p>如果没有网络<code>/var/lib/tftpboot/</code>目录下的pxelinux.0和menu.c32文件复制到<code>/var/lib/cobbler/loaders</code></p><p><code>[root@localhost ~]# cp /var/lib/tftpboot/{pxelinux.0,menu.c32} /var/lib/cobbler/loaders/</code><br><code>[root@localhost ~]# cobbler sync</code></p><p>（e）修改用户口令</p><p><code>[root@localhost ~]# openssl passwd -1</code>    #生成加密口令</p><pre><code>Password: Verifying - Password: $1$gMx01QUD$eo5dQGlEDGh9o0fY8dgnr.</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-18_115919.png" alt=""></p><p><code>[root@localhost ~]# cobbler sync</code></p><p>（f）配置dhcp服务</p><p><code>[root@localhost ~]# vim /etc/cobbler/dhcp.template</code></p><p><code>[root@localhost tftpboot]# cobbler sync</code>   #将修改后内容太同步到<code>/etc/dhcp/dhcpd.conf</code>文件中</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-18_120239.png" alt=""></p><p>（4）导入yum源</p><p><code>[root@localhost ~]# cobbler import --path=/media/cdrom --name=centos7.3 --arch=x86_64</code></p><pre><code>--path：指明yum源的路径--name：指明复制到`/var/www/cobbler`目录下--arhc：指明架构类型</code></pre><p>（5）编辑ks文件并导入</p><p>默认的ks位置<code>/var/lib/cobbler/kickstarts/sample.ks</code></p><p>首先将ks文件复制到<code>/var/lib/cobbler/kickstarts</code>目录下，然后将ks文件导入</p><p><code>[root@localhost kickstarts]# cobbler profile edit/add  --name=centos7.3-x86_64 --distro=centos7.3-x86_64 --kickstart=/var/lib/cobbler/kickstarts/ks7.cfg</code>      #编辑原有的ks文件</p><p><code>[root@localhost tftpboot]# cobbler sync</code></p><p>（6）编辑菜单文件</p><p>默认的菜单文件<code>/etc/cobbler/pxe/pxedefault.template</code>   #默认菜单模板</p><p>启动菜单存放位置<code>/var/lib/tftpboot/pxelinux.cfg/default</code></p><p><code>[root@localhost tftpboot]# cobbler sync</code></p><p>（7）新建一台虚拟机测试</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-18_141500.png" alt=""></p><p>另外cobbler也提供web管理。Cobbler web界面是一个很好的前端，非常容易管理Cobbler。可以添加和删除system、distro、profile，可以查看、编辑distros、profiles、subprofiles、systems、repos、kickstart文件<br>cobbler认证方式有两种：</p><p>方式一：</p><p>（1）修在认证方式</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-18_145331.png" alt=""></p><p>（2）创建管理用户<br><code>[root@localhost ~]# htdigest -c /etc/cobbler/users.digest &quot;Cobbler&quot; admin</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-18_145547.png" alt=""></p><p><strong>注意：第一创建是需要加选项“-c”意味着创建文件<code>/etc/cobbler/users.digest</code>文件。</strong></p><p>htdigest命令的使用格式：</p><pre><code>  htdigest [ -c ] passwdfile realm username</code></pre><p>如何修改管理用户的密码呢？<br><code>[root@localhost ~]# htdigest /etc/cobbler/users.digest &quot;Cobbler&quot; admin</code><br>方式二：<br>（a）修改认证方式</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-18_150027.png" alt=""></p><p>（b）创建管理用户</p><p><code>[root@localhost ~]# useradd cobbler</code><br><code>[root@localhost ~]# passwd cobbler</code></p><p>（c）修改文件<code>/etc/cobbler/user.conf</code></p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-18_150352.png" alt=""></p><p>（3）在浏览器地址输入地址</p><p><a href="https://192.168.4.128/cobbler_web" target="_blank" rel="noopener">https://192.168.4.128/cobbler_web</a>并管理用户和密码即可</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-18_150819.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cobbler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>puppet资源</title>
      <link href="/2017/11/28/puppet%E8%B5%84%E6%BA%90/"/>
      <url>/2017/11/28/puppet%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-25_153400.jpg" alt=""></p><p>puppet是一种多系统集中配置管理工具，使用自有的puppet描述语言，可管理配置文件、用户、cron、任务等。puppet设计目的是简化对这些资源的管理以及妥善处理资源间的依赖关系。</p><h2 id="一、Puppet介绍"><a href="#一、Puppet介绍" class="headerlink" title="一、Puppet介绍"></a>一、Puppet介绍</h2><h3 id="1、puppet工作模型"><a href="#1、puppet工作模型" class="headerlink" title="1、puppet工作模型"></a>1、puppet工作模型</h3><ul><li>单机模型：手动应用清单<ul><li>puppet apply</li></ul></li><li>master/agent：由agent周期性地向Master请求清单并自动应用于本地。<ul><li>puppet master</li><li>puppet agent</li></ul></li></ul><h3 id="2、puppet资源"><a href="#2、puppet资源" class="headerlink" title="2、puppet资源"></a>2、puppet资源</h3><h4 id="（1）puppet从三个维度对资源进行抽象："><a href="#（1）puppet从三个维度对资源进行抽象：" class="headerlink" title="（1）puppet从三个维度对资源进行抽象："></a>（1）puppet从三个维度对资源进行抽象：</h4><ul><li>相似的资源被抽象成同一个资源“类型”，如程序包资源、用户资源及服务资源等；</li><li>将资源属性或状态的描述与其实现方式剥离开来，如仅说明安装一个程序包而不用关心起具体是通过什么方式实现；</li><li>仅描述资源的目标状态，即期望其实现的结果，而不是其具体过程。如确定nginx运行起来而不是具体描述为运行nginx命令将其启动。</li></ul><p>它们统称为puppet资源抽象派（RAL）；RAL由type和provider组成。</p><h4 id="（2）puppet资源定义"><a href="#（2）puppet资源定义" class="headerlink" title="（2）puppet资源定义"></a>（2）puppet资源定义</h4><p>向资源类型的属性赋值来实现，可称为资源类型实例化。定义了资源示例的文件即清单（manifest）。</p><p>type{‘title’<br>            attribute1 =&gt; value1<br>            attribute2 =&gt; value2<br>            …<br>}<br><strong>注意：type必须使用小写字母；title是一个字符串并且在同一类型必须唯一。</strong></p><h4 id="（3）资源属性中三个特殊属性"><a href="#（3）资源属性中三个特殊属性" class="headerlink" title="（3）资源属性中三个特殊属性"></a>（3）资源属性中三个特殊属性</h4><ul><li>Namevar，可以简称为name，定义title，name可以使用。</li><li>ensure，资源的目标状态</li><li>Provider，指明资源的管理接口，如果不指定系统选择最优的安装方式。</li></ul><h4 id="（4）puppet查询资源"><a href="#（4）puppet查询资源" class="headerlink" title="（4）puppet查询资源"></a>（4）puppet查询资源</h4><p>puppet describe</p><p>USAGE:</p><pre><code>puppet describe [-h|--help] [-s|--short] [-p|--providers] [-l|--list] [-m|--meta]    --help 帮助信息    --list 列出所有类型    --meta 列出所有元数据    --short 仅仅列出参数没有详细信息</code></pre><h4 id="（5）资源引用"><a href="#（5）资源引用" class="headerlink" title="（5）资源引用"></a>（5）资源引用</h4><p>如果我们在某个资源中定义需要引用别的资源时，这时就需要想想如何引用资源了。</p><p>格式</p><pre><code>Type[‘title’]</code></pre><p><strong>注意：资源引用时，类型的首字母必须大写。</strong></p><h4 id="（6）资源定义依赖关系"><a href="#（6）资源定义依赖关系" class="headerlink" title="（6）资源定义依赖关系"></a>（6）资源定义依赖关系</h4><p>在定义资源时，某个资源可能依赖另外某几个资源，这时就需要依赖别的资源；就像使用yum安装一样，自动解决了依赖关系；只不过这里是我们手动自定而已。</p><h5 id="依赖关系方式"><a href="#依赖关系方式" class="headerlink" title="依赖关系方式"></a>依赖关系方式</h5><ul><li>before<br>#<br>  type{‘A’<pre><code>      attribute1 =&gt; value1      attribute2 =&gt; value2      before =&gt; Type[&#39;B&#39;]</code></pre>  }</li></ul><p>相当于资源类型A在资源类型B完成。</p><ul><li>require<br>#<br>  type{‘A’<pre><code>      attribute1 =&gt; value1      attribute2 =&gt; value2      require =&gt; Type[&#39;B&#39;]</code></pre>  }</li></ul><p>相当资源类型A在资源类型B之后完成。</p><h4 id="（7）资源通过关系"><a href="#（7）资源通过关系" class="headerlink" title="（7）资源通过关系"></a>（7）资源通过关系</h4><p>通知相关的其他资源进行“刷新”操作</p><ul><li><p>notify</p><p>  type{‘A’</p><pre><code>      attribute1 =&gt; value1      attribute2 =&gt; value2      notify =&gt; Type[&#39;B&#39;]</code></pre><p>  }</p></li></ul><p>相当于ansible中的handler触发机制。</p><ul><li><p>subscribe</p><p>  type{‘A’</p><pre><code>      attribute1 =&gt; value1      attribute2 =&gt; value2      subscribe =&gt; Type[&#39;B&#39;]</code></pre><p>  }</p></li></ul><p>相当于资源B发生改变则资源A就进行”刷新”</p><h4 id="（8）puppet-apply介绍"><a href="#（8）puppet-apply介绍" class="headerlink" title="（8）puppet apply介绍"></a>（8）puppet apply介绍</h4><p>格式：</p><pre><code>puppet apply [-h|--help] [-V|--version] [-d|--debug] [-v|--verbose] [-e|--execute] [--detailed-exitcodes] [-l|--logdest &lt;file&gt;] [--noop]  [--catalog &lt;catalog&gt;] [--write-catalog-summary] &lt;file&gt;</code></pre><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-V</td><td>版本信息</td></tr><tr><td>-v</td><td>详细信息</td></tr><tr><td>–noop</td><td>相当于干跑</td></tr><tr><td>–test</td><td>测试</td></tr><tr><td>–debug</td><td>调试模式</td></tr></tbody></table><p>###2、资源类型</p><p>####（1）group 管理组</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>组名</td></tr><tr><td>gid</td><td>组ID</td></tr><tr><td>system</td><td>是否为系统用户  true/false</td></tr><tr><td>ensure</td><td>目标状态 present absent</td></tr><tr><td>members</td><td>成员用户</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@node1~]#vim group.pp</code></p><pre><code>  1 group{&#39;test&#39;:  2         ensure  =&gt; present,  3         name    =&gt; test,  4         gid     =&gt; 1234,  5 }</code></pre><p><code>[root@node1~]#puppet apply -v --noop --test group.pp</code></p><pre><code>Notice: Compiled catalog for node1.magedu.com in environment production in 0.09 secondsInfo: Applying configuration version &#39;1511599693&#39;Notice: /Stage[main]/Main/Group[test]/ensure: current_value absent, should be present (noop)Notice: Class[Main]: Would have triggered &#39;refresh&#39; from 1 eventsNotice: Stage[main]: Would have triggered &#39;refresh&#39; from 1 eventsInfo: Creating state file /var/lib/puppet/state/state.yamlNotice: Finished catalog run in 0.02 seconds</code></pre><p>####（2）user 管理用户</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>用户名</td></tr><tr><td>uid</td><td>用户ID</td></tr><tr><td>groups</td><td>附加组</td></tr><tr><td>comment</td><td>注释</td></tr><tr><td>expiry</td><td>过期时间</td></tr><tr><td>home</td><td>家目录</td></tr><tr><td>shell</td><td>shell的类型</td></tr><tr><td>system</td><td>是否为系统用户</td></tr><tr><td>ensure</td><td>目标状态 present/absent</td></tr><tr><td>password</td><td>加密后的字符串</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@node1~]#vim user.pp</code></p><pre><code>  1 group{&#39;test&#39;:  2         ensure  =&gt; present,  3         name    =&gt; &#39;test&#39;,  4 }  5 user{&#39;tom&#39;:  6         ensure  =&gt; present,  7         name    =&gt; &#39;tom&#39;,  8         uid     =&gt; 2345,  9         system  =&gt; false, 10         shell   =&gt; &#39;/bin/tcsh&#39;, 11         home    =&gt; &#39;/app/tom&#39;, 12         groups  =&gt; &#39;test&#39;, 13         require =&gt; Group[&#39;test&#39;], 14 }</code></pre><p>####（3）package 管理安装包</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>ensure</td><td>目前状态；installed 、present、latest、absent、any</td></tr><tr><td>name</td><td>包名</td></tr><tr><td>source</td><td>程序来源，仅对不会自动下载相关程序包的provider有用，如rpm或dpkg</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@node1~]#vim package.pp</code></p><pre><code>  1 package{&#39;nginx&#39;:  2         ensure  =&gt; latest,  3         name    =&gt; &#39;nginx&#39;,       4 }</code></pre><p>####（4）service 管理服务</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>ensure</td><td>目前状态 stopped/false、running/true</td></tr><tr><td>enable</td><td>是否设置为开机启动</td></tr><tr><td>hasrestart</td><td>判断此服务是否有restart命令，如果没有则先stop然后start</td></tr><tr><td>start</td><td>手动设定命令</td></tr><tr><td>restart</td><td>手动设定启动命令</td></tr></tbody></table><p><code>[root@node1~]#vim service.pp</code></p><pre><code>  1 service{&#39;nginx&#39;:  2         ensure  =&gt; running,  3         enable  =&gt; true,  4         hasrestart      =&gt; true,  5         restart =&gt; &#39;systemctl restart nginx.service&#39;,  6 }</code></pre><p>####（5）file 管理文件</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>ensure</td><td>目前状态；file，类型为普通文件，其内容由contest属性生成或复制由source属性指向文件路径创建；link，类型为符号链接，必须由target属性指明其链接的目标文件；directory，类型为目录，可通过source指向的路径复制生成；recurse属性指明是否递归复制</td></tr><tr><td>path</td><td>文件路径</td></tr><tr><td>source</td><td>源文件路径</td></tr><tr><td>context</td><td>文件内容</td></tr><tr><td>target</td><td>符号链接目标文件</td></tr><tr><td>owner</td><td>所有者</td></tr><tr><td>group</td><td>所属组</td></tr><tr><td>mode</td><td>权限</td></tr><tr><td>atime/ctime/mtime</td><td>时间戳</td></tr></tbody></table><p><strong>示例：</strong></p><pre><code>[root@node1~]#vim file.pp  1 file{&#39;test&#39;:  2         ensure  =&gt; file,  3         path    =&gt; &#39;/tmp/fstab&#39;,  4         source  =&gt; &#39;/etc/fstab&#39;,  5         owner   =&gt; tom,  6         group   =&gt; test,  7 }</code></pre><p>####（6）exec 执行命令</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>cwd</td><td>切换目录</td></tr><tr><td>command</td><td>要运行的命令</td></tr><tr><td>creates</td><td>文件路径，仅此路径表示的文件不存在时，command才执行</td></tr><tr><td>user/group</td><td>运行命令的用户身份</td></tr><tr><td>path</td><td>命令路径</td></tr><tr><td>onlyif</td><td>此属性指定一个命令，此命令正常时运行时，当前commnd才执行</td></tr><tr><td>unless</td><td>此属性指定一个命令，此命令非正常运行时，当前command才会执行</td></tr><tr><td>refresh</td><td>重新执行当前command的替代命令</td></tr><tr><td>refreshonly</td><td>仅接受到订阅的资源的通知时方才执行</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@node1~]#vim exec.pp</code></p><pre><code>  1 exec{&#39;createuser&#39;:  2         command =&gt; &#39;useradd test1&#39;,  3         path    =&gt; &#39;/bin:/sbin&#39;,  4         unless  =&gt; &#39;id test1&#39;,  5 }</code></pre><p>####（7）cron 计划任务</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>command</td><td>执行的任务</td></tr><tr><td>ensure</td><td>目前的状态，present/absent</td></tr><tr><td>hour、minute、monthday、month、weekday</td><td>定义时间</td></tr><tr><td>user</td><td>以哪个用户的身份运行命令</td></tr><tr><td>target</td><td>添加为哪个用户的任务</td></tr><tr><td>name</td><td>计划任务的名称</td></tr></tbody></table><p><strong>示例：</strong></p><p><code>[root@node1~]#vim cron.pp</code></p><pre><code>  1 cron{&#39;time&#39;:  2         command =&gt; &#39;/usr/sbin/ntpdate 172.18.0.1 &amp;&gt; /dev/null&#39;,  3         ensure  =&gt; present,  4         minute  =&gt; &#39;*/3&#39;,  5         user    =&gt; &#39;root&#39;,  6 }</code></pre><p>####（8）notify </p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>message</td><td>信息内容</td></tr><tr><td>name</td><td>信息名称</td></tr></tbody></table><p>·[root@node1~]#vim notify.pp·</p><pre><code>  1 notify{&#39;hello world&#39;:  2         message =&gt; &#39;hello everyone&#39;,  3 }</code></pre><p>###3、数据类型</p><ul><li>布尔型：true和false，不能加引号；if语句的测试条件和比较表达式都会返回布尔型值</li><li>undef：从为被声明的变量的值，直接使用不加引号的undef字符串</li><li>字符型：非结构化的文本字符串，可以使用引号，也可以不使用，单引号中的变量不会替换，而双引号中的能够进行变量替换。字符型值也支持使用转义符</li><li>数值型：可以为整数或浮点数。在puppet只有在数值上下文才把数据当数值型对待，其他情况下一律以字符型处理</li><li>数组：数组值为中括号‘[]’中以逗号分隔项目列表；数组索引从0开始整数，也可以是用负数索引</li><li>hash：外键值数据类型，键和值之间使用“=&gt;”分隔，键值对儿在{}中，彼此间以逗号分隔；</li><li><p>正则表达式：属于puppet的非标准数据类型，不能赋值给变量，仅能用于有限的几个接受正则表达式的地方，即接受使用“=~”及“！~”匹配操作符的位置。</p><p>  (？<enabled option="">:<pattern>)<br>  (? - <disabled option="">:<pattern>)</pattern></disabled></pattern></enabled></p><pre><code>  OPTIONs：      i：忽略字符大小写      m：把“.”当换行符      x：忽略&lt;PATTERN&gt;中的空白字符</code></pre></li></ul><p>####4、puppet变量种类</p><ul><li>内建变量：</li></ul><pre><code>- master端变量：    $servername $serverip $serverversion- agent变量：    $clientcert $clientversion $environment- parser变量    $module_name</code></pre><p>[root@node1~]#facter -p #查看内建命令</p><ul><li>用户自定义变量<br>  $variable_name = value</li></ul><p><strong>注意：不管是定义变量还是引用变量都要使用“$“引用。</strong></p><p><strong>示例：</strong></p><p><code>[root@node1~]#vim package2.pp</code></p><pre><code>  1 $pkgname = &#39;redis&#39;  2 package{&#39;installpkg&#39;:  3         ensure  =&gt; latest,  4         name    =&gt; &#39;$pkgname&#39;,  5 }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> puppet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>puppet流程控制语句</title>
      <link href="/2017/11/28/puppet%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>/2017/11/28/puppet%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="puppet流程控制语句"><a href="#puppet流程控制语句" class="headerlink" title="puppet流程控制语句"></a>puppet流程控制语句</h3><h4 id="（1）if语句"><a href="#（1）if语句" class="headerlink" title="（1）if语句"></a>（1）if语句</h4><p>格式：</p><pre><code>if CONDITION {        ...}  elsif CONDTION {        ...} else{        ...}</code></pre><h5 id="CONDITION类型"><a href="#CONDITION类型" class="headerlink" title="CONDITION类型"></a>CONDITION类型</h5><ul><li>变量</li><li>比较表达式</li><li>有返回值的函数</li></ul><p><strong>示例：</strong></p><pre><code>  1 if $osfamily == &#39;Debian&#39; {  2         $apachename = &#39;apache2&#39;  3 }else{  4         $apachename = &#39;httpd&#39;  5 }  6 package{&#39;$apachename&#39;:  7         ensure  =&gt; latest,  8 }</code></pre><h4 id="（2）case语句"><a href="#（2）case语句" class="headerlink" title="（2）case语句"></a>（2）case语句</h4><p>格式：</p><pre><code>case CONTROL_EXPRESSION {    case1：{}    case2：{}    case3：{}    ..    default:{}}</code></pre><h5 id="CONTROL-EXPRESSION"><a href="#CONTROL-EXPRESSION" class="headerlink" title="CONTROL_EXPRESSION"></a>CONTROL_EXPRESSION</h5><ul><li>变量</li><li>表达式</li><li>有返回值的函数</li></ul><h5 id="各case给定方式"><a href="#各case给定方式" class="headerlink" title="各case给定方式"></a>各case给定方式</h5><ul><li>直接字串</li><li>变量</li><li>有返回值的函数</li><li>正则表达式</li><li>default</li></ul><p><strong>示例：</strong></p><pre><code>  1 case $onfamily {  2         &quot;RedHat&quot;: { $webserver = &#39;httpd&#39; }  3         /(?i-mx:debin)}: { $webserver = &#39;apache2&#39; }  4         default: { $webserver = &#39;httpd&#39; }  5 }  6 package{&#39;$webserver&#39;:  7         ensure  =&gt; latest,  8 }</code></pre><h4 id="（4）selector语句"><a href="#（4）selector语句" class="headerlink" title="（4）selector语句"></a>（4）selector语句</h4><p>格式：</p><pre><code>未知变量 = 可知变量 ? {    case1   =&gt; value1,    case2   =&gt; value2,    ...    default =&gt; value0,}</code></pre><h5 id="CONTROL-VARIABLE的给定方法："><a href="#CONTROL-VARIABLE的给定方法：" class="headerlink" title="CONTROL_VARIABLE的给定方法："></a>CONTROL_VARIABLE的给定方法：</h5><ul><li>变量</li><li>有返回值的函数</li></ul><h5 id="各case的给定方式："><a href="#各case的给定方式：" class="headerlink" title="各case的给定方式："></a>各case的给定方式：</h5><ul><li>直接字串；</li><li>变量 </li><li>有返回值的函数</li><li>正则表达式模式；</li><li>default </li></ul><p><strong>示例：</strong></p><pre><code>  1 $pkgname = $osfamily ? {  2         &quot;RedHat&quot; =&gt; &#39;httpd&#39;,  3         /(?i-mx:debian)/        =&gt; &#39;apache2&#39;,  4         default =&gt; &#39;httpd&#39;,  5 }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> puppet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>puppet类和模块</title>
      <link href="/2017/11/28/puppet%E7%B1%BB/"/>
      <url>/2017/11/28/puppet%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="一、puppet模块"><a href="#一、puppet模块" class="headerlink" title="一、puppet模块"></a>一、puppet模块</h2><p>模块是一个按约定的、预定义的结构存放了多个文件或子目录的目录，目录里的这些文件或子目录必须遵循其命名规范。puppet会按此规范在特定位置查找所需的模块文件，不过，这些特定目录也可以通过puppet的配置参数modulepath定义。</p><h3 id="1、模块目录的结构"><a href="#1、模块目录的结构" class="headerlink" title="1、模块目录的结构"></a>1、模块目录的结构</h3><p>在puppet中，模块本身用一个目录表示，其需要存放于puppet的modulepath参数所定义的目录中。</p><pre><code>MODULE_NAME    manifests        init.pp    files    templates    lib    tests    spec</code></pre><h3 id="2、木块目录结构介绍"><a href="#2、木块目录结构介绍" class="headerlink" title="2、木块目录结构介绍"></a>2、木块目录结构介绍</h3><ul><li>MODULE_NAME：模块名称，即模块目录名；模块名称只能以小写字母开头，可以包含小写字母、数字和下划线，但不能使用“main”和“setttins”作为模块名。</li><li><p>manifests目录：包含当前模块的所有清单文件；每个清单文件包含一个类或一个定义的类型，此文件访问路径格式为“MODELE_NAME::[SubDirectoryName::]ManifestFileName”</p><ul><li>init.pp：只能包含一个单独的类定义，且类的名称必须与模块名称相同。</li></ul></li><li><p>files目录：包含了一组静态文件，这些文件可被节点下载使用；每个文件的访问路径遵循puppet:///modules/MODULE_NAME/filename路径格式</p></li><li>lib目录：插件目录，常用自定义fact及自定义资源类型等</li><li>templates目录：存储了manifest用到的模板文件，其访问路径遵循template(‘ModuleName/TemplateName’)格式</li><li>test目录：当前模块的使用帮助或使用范例文件，类似如何声明当前模块中的类及定义的类型等说明</li><li>spec目录：类似于tests目录的功能，其实为lib目录中的各插件提供使用范例说明。</li></ul><p><strong>注意：</strong></p><p><strong>1、puppet3.8版本以后，资源清单文件的文件名需与文件子类名保持一致，例如某子类名为“base_class::child_class”，其文件名应该为child_class.pp；</strong></p><p><strong>2、无需再资源清单文件中使用import语句；</strong></p><p><strong>manifests目录下可存放多个清单文件，每个清单文件包含一个类，其文件名同类名。</strong></p><h2 id="二、类"><a href="#二、类" class="headerlink" title="二、类"></a>二、类</h2><p>Class是用于通用目标或目的的一组资源，因此，它是命名的代码块，在某未知创建之后可在puppet全局使用。类似于其他编程语言中类的功能，puppet的类可以继承，也可以包含子类。</p><p>格式：</p><pre><code>class my_class {    ...puppet code ...}</code></pre><p><strong>注意：类的名称只能以小写字母开头，可以包含小写字母、或下划线。另外每个类都会引入一个新的变量scope，这意味着在任何时候访问类中的变量时，都得使用期完全限定的名称。不过在本地scope可以重新为top scope 中的变量赋予一个新值。</strong></p><h4 id="（1）类声明"><a href="#（1）类声明" class="headerlink" title="（1）类声明"></a>（1）类声明</h4><ul><li><p>方式一</p><p>  include CLASS_NAME1 ,CLASS_NAME2…</p></li><li>方式二<br>#<br>   class {‘CLASS_NAME’:<pre><code>          attribute   =&gt; value,          ...   }</code></pre></li></ul><p><strong>示例：</strong></p><pre><code>  1 class apache2 {  2         $webpkg = $operationsystem ? {  3                 /(?i-mx:(centos|redhat|fedora))/        =&gt; &#39;httpd&#39;,  4                 /(?i-mx:(ubuntu|debian))/       =&gt; &#39;apache2&#39;,  5                 default =&gt; &#39;httpd&#39;,  6         }  7         package{&#39;$webpkg&#39;:  8                 ensure  =&gt; latest,  9         } 10 }  </code></pre><h4 id="类继承方式"><a href="#类继承方式" class="headerlink" title="类继承方式"></a>类继承方式</h4><p>格式：</p><pre><code>class SUB_CLASS_NAME inherits PARENT_CLASS_NAME {    ...puppet code}</code></pre><p><strong>示例：</strong></p><pre><code>  1 class apache2 {  2         $webpkg = $operationsystem ? {  3                 /(?i-mx:(centos|redhat|fedora))/        =&gt; &#39;httpd&#39;,  4                 /(?i-mx:(ubuntu|debian))/       =&gt; &#39;apache2&#39;,  5                 default =&gt; &#39;httpd&#39;,  6         }  7         package{&#39;$webpkg&#39;:  8                 ensure  =&gt; latest,  9         } 10 } 11 class apache2::web inherits apache2 { 12         file{&#39;file&#39;: 13                 path    =&gt; &#39;/etc/httpd/conf.d/http-v.conf&#39;, 14                 ensure  =&gt; file, 15                 source  =&gt; &#39;root/http-v.conf&#39;, 16         } 17 }</code></pre><h4 id="在子类中为父类的资源新增或覆盖指定的属性的值"><a href="#在子类中为父类的资源新增或覆盖指定的属性的值" class="headerlink" title="在子类中为父类的资源新增或覆盖指定的属性的值"></a>在子类中为父类的资源新增或覆盖指定的属性的值</h4><p>格式：</p><pre><code>Type[&#39;tile&#39;] {    attribute =&gt; value,    ...}</code></pre><h4 id="在子类中为父类的资源的某属性增加心智"><a href="#在子类中为父类的资源的某属性增加心智" class="headerlink" title="在子类中为父类的资源的某属性增加心智"></a>在子类中为父类的资源的某属性增加心智</h4><pre><code>Type[&#39;title&#39;] {    attribute +&gt; value,    ...}</code></pre><h4 id="带参数的类"><a href="#带参数的类" class="headerlink" title="带参数的类"></a>带参数的类</h4><p>在定义在带参数的类时，需要将参数声明在类名后的小括号“（）”，参数可以有默认值，如果使用多个参数，彼此间要使用逗号分隔。在类的内部使用参数的方式同使用本地变量。</p><p>格式：</p><pre><code>    class mysql ($user = &#39;mysql&#39;, $port = 3306) {                ...     }</code></pre><p>向类传递参数时，其方式如同定义资源的属性。<br>格式：</p><pre><code>class http($pkgname=&#39;apache2&#39;) {    package{&#39;$pkgname&#39;:        ensure  =&gt; latest,    }}</code></pre><h3 id="5、puppet模板"><a href="#5、puppet模板" class="headerlink" title="5、puppet模板"></a>5、puppet模板</h3><p>puppet模板时erb（embedded ruby）格式的。</p><h5 id="文本文件中内嵌变量替换机制："><a href="#文本文件中内嵌变量替换机制：" class="headerlink" title="文本文件中内嵌变量替换机制："></a>文本文件中内嵌变量替换机制：</h5><pre><code>&lt;%= @VARIABLE_NAME %&gt;</code></pre><p>格式：</p><p>file{‘title’:<br>        ensure  =&gt; file,<br>        path    =&gt;<br>        content =&gt; template(‘/path/to/ERB_FILE’)<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> puppet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scp、rsync，pssh工具</title>
      <link href="/2017/11/28/scp%E3%80%81rsync%EF%BC%8Cpssh%E5%B7%A5%E5%85%B7/"/>
      <url>/2017/11/28/scp%E3%80%81rsync%EF%BC%8Cpssh%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="复制文件命令介绍"><a href="#复制文件命令介绍" class="headerlink" title="复制文件命令介绍"></a>复制文件命令介绍</h2><h3 id="1、scp命令"><a href="#1、scp命令" class="headerlink" title="1、scp命令"></a>1、scp命令</h3><pre><code>scp：secure copy (remote file copy program)</code></pre><p>格式：<br>        scp [options] [user@]host:/sourcefile /destpath<br>        scp [options] /sourcefile [user@]host:/destpath</p><p>|<br>|选项|含义|<br>|-c|压缩数据流|<br>|-r|递归复制|<br>| -p|保持原文件属性|<br>|-q|静默模式|<br>| -P PORT|指明远程主机的端口|</p><h3 id="2、rsync"><a href="#2、rsync" class="headerlink" title="2、rsync"></a>2、rsync</h3><pre><code>rsync: rsync - a fast, versatile, remote (and local) file-copying tool</code></pre><p> 格式：<br>        Pull: rsync [OPTION…] [USER@]HOST:SRC… [DEST]<br>        Push: rsync [OPTION…] SRC… [USER@]HOST:DEST</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-n</td><td>模拟复制过程</td></tr><tr><td>-v</td><td>显示详细过程</td></tr><tr><td>-r</td><td>递归复制</td></tr><tr><td>-p</td><td>保留权限</td></tr><tr><td>-t</td><td>保留时间戳</td></tr><tr><td>-g</td><td>保留组信息</td></tr><tr><td>-o</td><td>保留所有者信息</td></tr><tr><td>-l</td><td>将软连接文件本身复制</td></tr><tr><td>-L</td><td>将软连接文件指向的文件复制</td></tr><tr><td>-X</td><td>保留SElinux属性</td></tr><tr><td>-a</td><td>存档，但不保留ACL和SElinux属性</td></tr></tbody></table><p><strong>注意：rsync命令只复制原有文件修改的文件或目录。而scp不管是否修改文件属性都复制。</strong></p><h3 id="3、sftp命令"><a href="#3、sftp命令" class="headerlink" title="3、sftp命令"></a>3、sftp命令</h3><pre><code>scp：secure file transfer program，交换式传输工具格式：     sftp [user@]host[:file ...]     sftp [user@]host[:dir[/]]</code></pre><p>如果我们管理几十台或者更多机器，使用起来并不是特别方便，而且还耗时耗力。下面介绍介个轻量级的工具。</p><h3 id="4、pssh"><a href="#4、pssh" class="headerlink" title="4、pssh"></a>4、pssh</h3><pre><code>pssh包是来自于epel源。     /usr/bin/pnuke     /usr/bin/prsync     /usr/bin/pscp.pssh     /usr/bin/pslurp     /usr/bin/pssh</code></pre><p>以上执行的命令。</p><pre><code>pssh命令： parallel ssh program</code></pre><p>格式：</p><pre><code> pssh  [-vAiIP]  [-h hosts_file] [-H [user@]host[:port]] [-l user] [-p par] [-o outdir] [-e errdir] [-t timeout]  [-O  options]  [-x   args] [-X arg] command ...</code></pre><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-h HOST_FILE</td><td>包含IP的文件</td></tr><tr><td>-H [user@]IP[:port]</td><td>连接的主机，如果要接连多个主机用“”引起来，主机之间空格分开</td></tr><tr><td>-l USER</td><td>用户名</td></tr><tr><td>-p</td><td>并发数</td></tr><tr><td>-t</td><td>超时秒数</td></tr><tr><td>-o OUTDIR</td><td>输出目录，在该目录下创建</td></tr><tr><td>-e ERRDIR</td><td>错误输出目录</td></tr><tr><td>-x ARGS</td><td>传递过个命令，多个命令用“”引起来，使用空格分隔</td></tr><tr><td>-X</td><td>同-x意义一样，但每次只传递一个命令</td></tr><tr><td>-i</td><td>将输出结果输出当前终端</td></tr><tr><td>-I</td><td>读取每个输出命令，并传递ssh进程，允许脚本传送到标准输入</td></tr><tr><td>-v</td><td>显示ssh连接时的错误信息</td></tr><tr><td>-P</td><td>打印输出</td></tr><tr><td>-A</td><td>提示输入密码，并把密码传递给ssh服务</td></tr></tbody></table><p><strong>示例</strong></p><pre><code>pslurp：parallel process kill program</code></pre><p>格式：</p><pre><code>          pslurp  [-vAr]  [-h hosts_file] [-H [user@]host[:port]] [-l user]   [-p par] [-o outdir] [-e errdir] [-t timeout]  [-O  options]  [-x   args] [-X arg] [-L localdir] remote local</code></pre><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-L localdir</td><td>复制远程主机文件或目录到本机指定的目录下</td></tr><tr><td>-r</td><td>递归复制</td></tr></tbody></table><pre><code>    其他选项请参考psshprsync  将文件或文件夹从本地同步到远程主机上</code></pre><p> 格式：<br>           prsync [-vAraz] [-h hosts_file] [-H [user@]host[:port]] [-l user]<br>       [-p par] [-o outdir] [-e errdir] [-t timeout]  [-O  options]  [-x<br>       args] [-X arg] [-S args] local remote</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>可以维持文件的属性</td></tr><tr><td>-z</td><td>压缩传输</td></tr></tbody></table><pre><code>pnuke：杀死远程主机上的进程，相当于killall</code></pre>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scp，rsync，pssh，pslurp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sudo</title>
      <link href="/2017/11/28/sudo/"/>
      <url>/2017/11/28/sudo/</url>
      
        <content type="html"><![CDATA[<h2 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h2><p>在生产环境中，一个人的力量总是不够的，我们可以把一些任务分配别的人员协同操作，这样办事效率也提高了。但是我们又不想把所有的权限都分给小伙伴，所以sudo就解决了这样一个问题。sudo能够授权指定用户在指定主机上运行某些命令；如果未授权用户使用sudo尝试登录，会提示管理员。这样方便了我们的管理。</p><h3 id="1、含义"><a href="#1、含义" class="headerlink" title="1、含义"></a>1、含义</h3><p>sudo是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的一个工具，如halt，reboot，su等等。&lt;摘自：百度&gt;</p><h3 id="2、sudo的优点"><a href="#2、sudo的优点" class="headerlink" title="2、sudo的优点"></a>2、sudo的优点</h3><p>（1）提供日志，记录每个用户使用sudo操作</p><p>（2）为系统管理员提供配置文件，允许系统管理员集中地管理用户的使用权限和使用的主机。</p><p>（3）sudo提供用户一个使用时长，相当于“入场券”，如果超时，重新登录。默认为5分钟（如果想修改，只能自己编译安装时候修改）。</p><p>（4）sudo提供专门的修改文件工具visudo，默认是vi界面，如果想使用vim功能，可以自定环境变量<code>“export EDORIT=vim”</code>。</p><p>（5）自己创建文件的权限为440，如果你忘记修改权限，visudo命令可以自动修改完成。</p><p>（6）修改配置文件是同时打开一个，不能打开多个。并且配置文件不建议直接去修改。</p><h3 id="3、配置文件"><a href="#3、配置文件" class="headerlink" title="3、配置文件"></a>3、配置文件</h3><p><code>/etc/sudoers/</code>和<code>/etc/sudoers.d/*</code><br>（1）配置文件支持使用通配符</p><table><thead><tr><th>通配符</th><th>说明</th></tr></thead><tbody><tr><td>？</td><td>任意单个字符</td></tr><tr><td>*</td><td>匹配任意长度</td></tr><tr><td>[]</td><td>匹配单个字符</td></tr><tr><td>[!]</td><td>除了的任意字符</td></tr><tr><td>\</td><td>支持转义</td></tr></tbody></table><p>（2）授权规则格式</p><p> 用户  登入主机=（代表用户） 命令</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>user</td><td>运行命令着的身份</td></tr><tr><td>host</td><td>通过哪些主机</td></tr><tr><td>（runas）</td><td>以哪个用户身份运行</td></tr><tr><td>command</td><td>运行哪些命令</td></tr></tbody></table><p>user和runas格式</p><pre><code>username#uid%group_name%#group_nameUser_AliasRunas_Alias</code></pre><p>host</p><pre><code>ip或hostnamenetworknetwork/prefix(只有CentOS7支持)Host_Alias</code></pre><p>command</p><pre><code>commandNamedirectorysudoedit  可以对文件`/etc/sudoers`修改CMD_Alias</code></pre><p><strong>注意：这里的命令一定要与执行的命令精确匹配，否则不成功。别名定义一定要大写字母开头，构成只能有字母和数字。</strong></p><p>（3）别名</p><p>格式：Alias_Type NAME1 = item1, item2, item3 : NAME2 = item4, item5<br><strong>注意：不同的别名之间需要使用冒号隔开。%wheel是一个组，权限和root一样，使用时一定要小心。如果在添加NOPASSWD不提供口令直接登录。sudo使用时登录需要认证，但是此时认证时运行者的口令。</strong></p><p>时间戳文件<code>/var/db/sudo/</code><br>日志文件<code>/var/log/secure</code></p><p>（4）设定默认值defaults</p><p>示例：Defaults：laowang runas_default=tom</p><h3 id="4、sudo命令"><a href="#4、sudo命令" class="headerlink" title="4、sudo命令"></a>4、sudo命令</h3><p>格式：sudo [-u user] COMMAND</p><table><thead><tr><th>选项</th><th>解释</th></tr></thead><tbody><tr><td>-u</td><td>指定用户，默认root</td></tr><tr><td>-l</td><td>列出用户在主机上可用的和被禁止的命令</td></tr><tr><td>-v</td><td>再延长有效期5分钟，更新时间戳</td></tr><tr><td>-k</td><td>清除时间戳（197–01-01），西祠需要重新输入密码</td></tr><tr><td>-K</td><td>与-k类似，但还要删除时间戳文件</td></tr><tr><td>-b</td><td>在后台执行</td></tr><tr><td>-p</td><td>改变询问密码的提示符号  %p代表用户</td></tr><tr><td>-V</td><td>显示版本信息等配置信息</td></tr></tbody></table><p><strong>注意：在sudoers文件中，如果定义文件后面添加“*”表示所有，即这个文件后面可以添加任意字符 ，言外之意，就是可以看到别的文件。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sudo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcpdump</title>
      <link href="/2017/11/28/tcpdump%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/11/28/tcpdump%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>tcpdump是一个运行在命令行下的嗅探工具，它允许用户拦截和显示发送或收到过网络连接到该计算机的TCP/IP和其他数据包。在linux中需要使用libpcap捕捉数据的库。</p><h2 id="1、tcpdump命令"><a href="#1、tcpdump命令" class="headerlink" title="1、tcpdump命令"></a>1、tcpdump命令</h2><p>SYNOPSIS</p><pre><code>   tcpdump [ -AbdDefhHIJKlLnNOpqStuUvxX# ] [ -B buffer_size ]           [ -c count ]           [ -C file_size ] [ -G rotate_seconds ] [ -F file ]           [ -i interface ] [ -j tstamp_type ] [ -m module ] [ -M secret ]           [ --number ] [ -Q|-P in|out|inout ]           [ -r file ] [ -V file ] [ -s snaplen ] [ -T type ] [ -w file ]           [ -W filecount ]           [ -E spi@ipaddr algo:secret,...  ]           [ -y datalinktype ] [ -z postrotate-command ] [ -Z user ]           [ --time-stamp-precision=tstamp_precision ]           [ --immediate-mode ] [ --version ]           [ expression ]</code></pre><h2 id="2、tcpdump选项类型"><a href="#2、tcpdump选项类型" class="headerlink" title="2、tcpdump选项类型"></a>2、tcpdump选项类型</h2><ul><li>控制tcpdump程序行为</li><li>控制数据怎么样显示</li><li>控制显示什么数据</li><li>过滤命令</li></ul><h3 id="（1）控制程序行为"><a href="#（1）控制程序行为" class="headerlink" title="（1）控制程序行为"></a>（1）控制程序行为</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-w</td><td>直接将抓取的数据写入文件中</td></tr><tr><td>-r</td><td>读取抓取的文件</td></tr><tr><td>-c</td><td>设置捕捉报文数量，当达到数量时程序自动终止，无需使用ctrl+x或kill命令</td></tr><tr><td>-i</td><td>指定网络接口的数据包</td></tr><tr><td>-p</td><td>将网卡接口设置为非混杂模式</td></tr><tr><td>-s</td><td>控制数据的截取长度，默认只抓取68字节</td></tr></tbody></table><h3 id="（2）控制信息如何显示"><a href="#（2）控制信息如何显示" class="headerlink" title="（2）控制信息如何显示"></a>（2）控制信息如何显示</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>强制将网络地址显示为名称，默认显示方式</td></tr><tr><td>-n</td><td>阻止将地址显示为名字</td></tr><tr><td>-N</td><td>阻止将域名转化</td></tr><tr><td>-f</td><td>阻止远端名称解析</td></tr></tbody></table><p><img src="http://owatlfstl.bkt.clouddn.com/2017-12-05_113834.jpg" alt=""></p><h3 id="（3）控制显示什么数据"><a href="#（3）控制显示什么数据" class="headerlink" title="（3）控制显示什么数据"></a>（3）控制显示什么数据</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-v</td><td>将会打印TTL字段</td></tr><tr><td>-q</td><td>静默显示</td></tr><tr><td>-e</td><td>显示链路层头信息</td></tr><tr><td>-x</td><td>将报文以十六进制形式显示</td></tr></tbody></table><blockquote><p>静默显示</p></blockquote><p><code>[root@node1~]#tcpdump -c1 -n -q host 192.168.4.61</code></p><pre><code>tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes11:43:47.290530 IP 192.168.4.61.ssh &gt; 192.168.4.1.12340: tcp 240</code></pre><blockquote><p>显示详细信息</p></blockquote><p><code>[root@node1~]#tcpdump -c1 -n -v host 192.168.4.61</code></p><pre><code>tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes11:43:08.490287 IP (tos 0x10, ttl 64, id 23123, offset 0, flags [DF], proto TCP (6), length 216)    192.168.4.61.ssh &gt; 192.168.4.1.12340: Flags [P.], cksum 0x8a59 (incorrect -&gt; 0x3fc1), seq 2146097888:2146098064, ack 1282888233, win 314, length 176</code></pre><blockquote><p>以十六进制显示</p></blockquote><p><code>[root@node1~]#tcpdump -c1 -n -x host 192.168.4.61</code></p><pre><code>tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes11:45:34.772679 IP 192.168.4.61.ssh &gt; 192.168.4.1.12340: Flags [P.], seq 2146106528:2146106768, ack 1282894761, win 314, length 240        0x0000:  4510 0118 5aa0 4000 4006 55a1 c0a8 043d        0x0010:  c0a8 0401 0016 3034 7fea fca0 4c77 6ba9        0x0020:  5018 013a 8a99 0000 8faa bf5b f02a ae18        0x0030:  ea4a 1102 53ed 2e8d 07bc 3597 2137 39f0        0x0040:  6e0a 91a5 840f 3d52 7036 ef65 42f9 0845        0x0050:  2876 ef14 ea3a 6073 aa4f bdac 63a5 5d3b        0x0060:  c751 4fef d87c 0d45 7a97 328b a88d 39d3        0x0070:  a00d 9c97 7fbf ba6b 0f05 4c89 a574 3b52        0x0080:  5ed6 d9c7 0426 e404 34f7 7eb9 cecf b0d9        0x0090:  aaf4 9e13 2e43 b80e 1f32 198f 6041 2cc4        0x00a0:  b0b5 28e5 f22d d3f0 de35 1ff9 325c 6de8        0x00b0:  8448 1091 306f 7fa3 bf1c 2694 7cfa 38c2        0x00c0:  9812 d4fb 7caf a699 c8cd 56c9 9bb7 9cd5        0x00d0:  4e3a 93c9 00aa 7fae 1543 9da2 560b f088        0x00e0:  6e9e 3701 c2b9 81fc a9d5 f4b3 c7b9 a91e        0x00f0:  ad31 004f 463d fc38 1ded d25d 9fa0 bc6f        0x0100:  047a 65f8 dc7d 3b54 ff1e 2f26 4952 8fba        0x0110:  595c a633 4d59 c1c9</code></pre><blockquote><p>显示头部信息</p></blockquote><p><code>[root@node1~]#tcpdump -c1 -n -e host 192.168.4.61</code></p><pre><code>tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes11:44:00.497912 00:0c:29:40:d6:de &gt; 00:50:56:c0:00:01, ethertype IPv4 (0x0800), length 294: 192.168.4.61.ssh &gt; 192.168.4.1.12340: Flags [P.], seq 2146103472:2146103712, ack 1282892457, win 314, length 240</code></pre><h3 id="（3）过滤"><a href="#（3）过滤" class="headerlink" title="（3）过滤"></a>（3）过滤</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>host</td><td>指定主机，可以通过名称或IP地址指定</td></tr><tr><td>src</td><td>指定数据流的来源</td></tr><tr><td>det</td><td>指定数据流的目的地</td></tr><tr><td>broadcast</td><td>指定广播地址</td></tr><tr><td>multicast</td><td>指定多播地址</td></tr><tr><td>IP、Appletalk、tcp、udp、icmp</td><td>指定抓取的协议</td></tr><tr><td>port</td><td>指定端口</td></tr></tbody></table><h2 id="2、常用的表达式"><a href="#2、常用的表达式" class="headerlink" title="2、常用的表达式"></a>2、常用的表达式</h2><p>非：！或者not<br>且：&amp;&amp;或者and<br>或：||或者or</p><p><strong>示例：</strong></p><p><code>[root@node1~]#tcpdump -c1 port 22 and host 192.168.4.61</code></p><pre><code>tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes12:00:13.938273 IP node1.ssh &gt; 192.168.4.1.12340: Flags [P.], seq 2146131600:2146131840, ack 1282914057, win 314, length 240</code></pre><p><code>[root@node1~]#tcpdump -c1 -nn -i eth0</code></p><pre><code>tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes14:12:39.593263 IP 192.168.4.61.22 &gt; 192.168.4.1.12340: Flags [P.], seq 2146665200:2146665440, ack 1282925385, win 314, length 240    -i：指定接口    -nn：表示IP和port方式显示包，不将IP转为主机名</code></pre>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcpdump </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DHCP</title>
      <link href="/2017/11/28/DHCP/"/>
      <url>/2017/11/28/DHCP/</url>
      
        <content type="html"><![CDATA[<h2 id="一、DHCP服务"><a href="#一、DHCP服务" class="headerlink" title="一、DHCP服务"></a>一、DHCP服务</h2><h3 id="1、DHCP概念"><a href="#1、DHCP概念" class="headerlink" title="1、DHCP概念"></a>1、DHCP概念</h3><p>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一个局域网的网络协议，使用UDP协议工作， 主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段，。DHCP有3个端口，其中UDP67和UDP68为正常的DHCP服务端口，分别作为DHCP Server和DHCP Client的服务端口；546号端口用于DHCPv6 Client，而不用于DHCPv4，是为DHCP failover服务，这是需要特别开启的服务，DHCP failover是用来做“双机热备”的。</p><p>###2、DHCP过程<br>（1）DHCP Client以广播的方式发出DHCP Discover报文。</p><p>（2）所有的DHCP Server都能够接收到DHCP Client发送的DHCP Discover报文，所有的DHCP Server都会给出响应，向DHCP Client发送一个DHCP Offer报文。DHCP Offer报文中“Your(Client) IP Address”字段就是DHCP Server能够提供给DHCP Client使用的IP地址，且DHCP Server会将自己的IP地址放在“option”字段中以便DHCP Client区分不同的DHCP Server。DHCP Server在发出此报文后会存在一个已分配IP地址的纪录。</p><p>（3）DHCP Client只能处理其中的一个DHCP Offer报文，一般的原则是DHCP Client处理最先收到的DHCP Offer报文。DHCP Client会发出一个广播的DHCP Request报文，在选项字段中会加入选中的DHCP Server的IP地址和需要的IP地址。</p><p>（4）DHCP Server收到DHCP Request报文后，判断选项字段中的IP地址是否与自己的地址相同。如果不相同，DHCP Server不做任何处理只清除相应IP地址分配记录；如果相同，DHCP Server就会向DHCP Client响应一个DHCP ACK报文，并在选项字段中增加IP地址的使用租期信息。</p><p>（5）DHCP Client接收到DHCP ACK报文后，检查DHCP Server分配的IP地址是否能够使用。如果可以使用，则DHCP Client成功获得IP地址并根据IP地址使用租期自动启动续延过程；如果DHCP Client发现分配的IP地址已经被使用，则DHCP Client向DHCPServer发出DHCP Decline报文，通知DHCP Server禁用这个IP地址，然后DHCP Client开始新的地址申请过程。</p><p>（6）DHCP Client在成功获取IP地址后，随时可以通过发送DHCP Release报文释放自己的IP地址，DHCP Server收到DHCP Release报文后，会回收相应的IP地址并重新分配。<br><img src="http://owatlfstl.bkt.clouddn.com/5ab5c9ea15ce36d3d5e5e08939f33a87e850b1a1.jpg" alt=""></p><p>###3、DHCP的状态<br>|<br>|状态|解释|<br>|DHCP discover|客户端到服务器端|<br>|DHCP offer|服务器端到客户端|<br>|DHCP request|客户端到服务端|<br>|DHCP nack|服务器端到客户端指示客户端的网络地址是不正确的|<br>|DHCP ack|服务器端到客户端|<br>|DHCP decline|客户端到服务器端，指示地址已经被使用|<br>|DHCP release|客户端到服务器端，放弃网络地址和取消剩余的租约时间|<br>|DHCP inform|客户端到服务器端，只要求本地配置参数，客户端已经具有外部配置的网络地址|</p><p>###4、如何续租呢？<br>当客户端向服务器端取得地址以后得到租期，当租期达到某个期限时，客户端主动向服务器端发起广播请求</p><pre><code>%50：租赁时间达到50%时来续租，刚想DHCP服务器发现新的DHCP request请求。如果dhcp服务没有拒绝的理由，则回应DHCP ack信息。当DHCP客户端收到应答信息后，就重新开始新的租用期限。 87.5%：如果之前DHCP server没有回应，等到租约期的87.5%时，主动再发送一次广播请求。</code></pre><p>###5、DHCP的配置文件<br>主配置文件<br>    /etc/dhcp/dhcpd.conf  /etc/dhcp/dhcpd6.conf<br>启动配置文件<br>    /etc/rc.d/init.d/dhcpd  /etc/rc.d/init.d/dhcpd6<br>中继器<br>    /usr/sbin/dhcrelay   /etc/rc.d/init.d/dhcrelay</p><p>###6、/etc/dhcp/dhcpd.conf配置文档详解</p><pre><code># option definitions common to all supported networks...option domain-name &quot;example.org&quot;;   #searchnameoption domain-name-servers ns1.example.org, ns2.example.org;    #设置DNS服务器地址default-lease-time 600;     #设置租约时长max-lease-time 7200;    #设置客户端最长租期# Use this to enble / disable dynamic dns updates globally.#ddns-update-style none;    #设置DHCP更新# If this DHCP server is the official DHCP server for the local# network, the authoritative directive should be uncommented.#authoritative;# Use this to send dhcp log messages to a different log file (you also# have to hack syslog.conf to complete the redirection).log-facility local7;    #设置日志级别# No service will be given on this subnet, but declaring it helps the # DHCP server to understand the network topology.subnet 10.152.187.0 netmask 255.255.255.0 {}   # This is a very basic subnet declaration.subnet 10.254.239.0 netmask 255.255.255.224 {  range 10.254.239.10 10.254.239.20;    #设置可分配IP的范围  option routers rtr-239-0-1.example.org,   rtr-239-0-2.example.org;    #设置客户端默认网关}filename    #指明引导文件名称next-server #提供引导文件的服务器IP地址</code></pre><p>当我们配置完时候，不知道是否出现问题这时候就需要对配置文件尽心检查 <code>service dhcp configtest</code></p><p><strong>示例：</strong></p><p>（1）安装dhcp服务<br><code>[root@localhost ~]# yum install -y dhcp</code><br>（2）将配置文件复制到<code>/etc/dhcp/</code>目录下<br><code>[root@localhost ~]# cp /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example /etc/dhcp/dhcpd.conf</code><br>（3）编辑配置文件<br><code>[root@localhost ~]# vim /etc/dhcp/dhcpd.conf</code><br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-17_173719.png" alt=""><br>（4）重启dhcp服务<br><code>[root@localhost ~]# systemctl restart dhcpd</code><br>（5）在另外一个机器上测试，是否可以拿到地址。<br><code>[root@localhost ~]#service restart dhcpd</code><br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-17_175020.png" alt=""></p><p><strong>注意：</strong></p><p>1、在进行编辑注意每行完成以后要以“；”结尾。</p><p>2、在配置DHCP服务时，有时获取到地址并不能ping，很有可能dhcp服务IP变化。</p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dhcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Varnish</title>
      <link href="/2017/11/28/varnish/"/>
      <url>/2017/11/28/varnish/</url>
      
        <content type="html"><![CDATA[<p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-02_100411.jpg" alt=""></p><p>Varnish是一款高性能且开源的反向代理服务器和HTTP极速器，其采用全新的软件体系机构和现在的硬件体积紧密配合。</p><h1 id="一、Varnish"><a href="#一、Varnish" class="headerlink" title="一、Varnish"></a>一、Varnish</h1><h2 id="1、varnish系统结构"><a href="#1、varnish系统结构" class="headerlink" title="1、varnish系统结构"></a>1、varnish系统结构</h2><p><img src="http://owatlfstl.bkt.clouddn.com/2017-11-02_094547.jpg" alt=""></p><blockquote><p>varnish主要运行两个进程：Manager进程和Cacher 进程</p></blockquote><h4 id="Manager进程功能："><a href="#Manager进程功能：" class="headerlink" title="Manager进程功能："></a>Manager进程功能：</h4><ul><li>实现应用新的配置</li><li>编译VCL（Varnish Configure Language）</li><li>监控varnish</li><li>初始化varnish</li><li>提供一个命令行接口</li><li>Manager进程每个几秒会探测cache进程是否正常运行，如果在指定的时间内未得到cache进程响应，Manager进程将重启此Cache进程</li></ul><h4 id="Cache进程包含多种类型的线程"><a href="#Cache进程包含多种类型的线程" class="headerlink" title="Cache进程包含多种类型的线程"></a>Cache进程包含多种类型的线程</h4><ul><li>Acceptor进程：接受新的链接请求并响应</li><li>Worker进程：cache进程会为每个会话启动一个worker线程，因此在高并发场景中可能会出现数百个worker进程或者更多</li><li>Expiry进程：从缓存中清理过期内容</li></ul><h4 id="varnish日志"><a href="#varnish日志" class="headerlink" title="varnish日志"></a>varnish日志</h4><p>为了与系统的其他部分进行交互，Cache进程使用了可以通过文件系统接口进行访问的共享内存日志（shared memory log），如果某线程需要记录日志信息，其仅需要持有一个锁，而后向共享内存中的某内存区域写入数据，再释放持有的所即可。</p><p>共享内存日志大小一般为90M，其分为两部分，前一部分为计数器，另一部分为客户端请求的数据。varnish提供了多个不同管理日志工具：varnishlog、varnishncsa、varnishstat等来分析共享内存日志中的信息并能够以指定的方式进行显示</p><h2 id="2、VCL（Varnish-Configuration-Language）"><a href="#2、VCL（Varnish-Configuration-Language）" class="headerlink" title="2、VCL（Varnish Configuration Language）"></a>2、VCL（Varnish Configuration Language）</h2><p>varnish配置缓存策略工具，是一种基于“域（domain specific）”的简单编程语言。支持有限的算术运算和逻辑运算操作、允许使用正则表达式进行字符串匹配、允许用户使用set自定义变量、支持if判断语句、内置函数和变量等。使用VCL编写的缓存策略通常保存至.VCL文件中，其需要变异成二进制格式后才能由varnish调用。不过整个缓存策略由几个特定的子例程如vcl_recv、vcl_fetch等组成，它们分别在不同的位置执行，如果没有实现为某个位置自定义子例程，varnish将会执行默认定义。</p><h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>VCL策略在启用之前，会由manager进程将其转换为C代码，然后再由gcc编译器将C代码编译成二进制程序；编译完成后，manager进程负责将其连接至varnish示例，即Cache进程。</p><p><strong>优点：</strong></p><p>由于编译工作在Cache进程之外完成，避免了装载错误格式VCL风险。因此varnish修改配置的开销非常小，其可以同时保存尚在引用的旧版本配置，也能够让新的配置即刻生效。编译后的旧版本配置通常在varnish重启时才会被丢弃，如果需要手动请求，则可以使用varnishadm中的<code>vcl.discard</code>命令完成。</p><h2 id="3、varnish后端存储"><a href="#3、varnish后端存储" class="headerlink" title="3、varnish后端存储"></a>3、varnish后端存储</h2><p>varnish支持多种不同类型的后端存储，可以在varnishd启动时使用-s选项指定。</p><blockquote><p>后端存储类型</p><h5 id="基于磁盘存储"><a href="#基于磁盘存储" class="headerlink" title="基于磁盘存储"></a>基于磁盘存储</h5><ul><li>file：使用特定的文件存储全部的缓存数据，并通过操作系统的mmap()系统调用将整个缓存文件映射至内存区域（如果条件允许）</li><li>persistent：与file功能相同，但可以持久存储数据（即重启varnish数据时不会被清除），处于测试期<h5 id="基于内存存储"><a href="#基于内存存储" class="headerlink" title="基于内存存储"></a>基于内存存储</h5></li><li>malloc：使用malloc()库调用在varnish启动时向操作系统申请指定大小的内存空间以存储缓存对象；串行存储模式</li><li>jemalloc：并行存储模式</li></ul></blockquote><p>选择使用合适的存储方式有助于提升系统性，从经验的角度看，建议在内存空间足以存储所有的缓存对象时使用malloc方法，反之，file存储将有着更好的性能表现。不过varnish实际上使用的空间比使用-s选项指定的缓存空间更大，一般来说，其需要为每个缓存对象多使用差不多1k左右的存储空间。</p><h1 id="二、varnish状态引擎（Varnish-Finite-State-Machine）"><a href="#二、varnish状态引擎（Varnish-Finite-State-Machine）" class="headerlink" title="二、varnish状态引擎（Varnish Finite State Machine）"></a>二、varnish状态引擎（Varnish Finite State Machine）</h1><p><img src="http://owatlfstl.bkt.clouddn.com/varish.svg" alt=""></p><h2 id="1、VCL状态引擎"><a href="#1、VCL状态引擎" class="headerlink" title="1、VCL状态引擎"></a>1、VCL状态引擎</h2><p>在VCL状态引擎中，状态之间具有相关性，但彼此间互相隔离，每个引擎使用return（action）来退出当前状态并指示varnish进入下一个状态。</p><h4 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h4><p>varnish开始处理一个请求时，首先需要分析HTTP请求本身，如从首部获取请求方法、验证其是否为一个合法的HTTP请求等；当这些基本分析结束后就需要作出第一个决策，即varnish是否从缓存中查找请求的资源（需要由vcl_recv方法完成；如果没有自定义的vcl_recv函数指定其终止操作，其扔将执行默认的vcl_recv函数。）。</p><h2 id="2、VCL语法"><a href="#2、VCL语法" class="headerlink" title="2、VCL语法"></a>2、VCL语法</h2><p>基本语法：</p><p>（1）//、#或/<em>comment</em>/用于注释</p><p>（2）sub $name 定义函数</p><p>（3）不支持循环，有内置变量</p><p>（4）使用终止语句，没有返回值</p><p>（5）域专用</p><p>（6）操作符：=、==、~、！、&amp;&amp;、||</p><p><strong>为什么VCL只有终止语句而没有返回值呢？</strong></p><p>VCL函数不接受参数并没有返回值，并非真正意义上的函数，这也限定了VCL内部的数据传递只能隐藏在HTTP首部内部进行。VCL的return语句用于将控制权从VCL状态引擎返回给varnish，而非默认函数。</p><h2 id="3、VCL内置函数"><a href="#3、VCL内置函数" class="headerlink" title="3、VCL内置函数"></a>3、VCL内置函数</h2><p>VCL提供了几个函数来实现字符串修改，添加bans、重启VCL状态引擎以及将控制权转回varnish等</p><pre><code>regsub（str，regex，sub）和regsuball（str，regex，sub）：这两个用于基于正则表达式搜索指定的字符串并替换为指定的字符串；只替换第一次匹配到的，而regsuball全部替换ban（expression）：ban_url（regex）：bans所有其URL能够有regex匹配的缓存对象purge：从缓存中挑选出某对象以及其相关变种一并删除，这可以通过HTTP协议的PURGE方法完成hash_data（str）：指明哈希计算的数据；减少差异，以提升命中率return（restart）：重新运行整个VCL，即重新从vcl_recv开始进行处理；每一次重启都会增加req-restarts变量中的值，而max_restarts参数则用于限定最大重启次数</code></pre><h2 id="4、vcl-recv"><a href="#4、vcl-recv" class="headerlink" title="4、vcl_recv"></a>4、vcl_recv</h2><p>在varnish完成对请求报文的解码为基础数据结构后的第一个要执行的子例程</p><h5 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h5><p>（1）修改客户端数据已减少缓存对象差异性，如删除URL中的www.等字符</p><p>（2）基于客户端数据选用缓存策略，日入仅缓存特定的URL请求，不缓存POST请求等</p><p>（3）位某web应用程序执行URL重写规则</p><p>（4）挑选合适的后端web服务器</p><h6 id="可以使用下面的终止语句，即通过return（）向varnish返回的指示操作："><a href="#可以使用下面的终止语句，即通过return（）向varnish返回的指示操作：" class="headerlink" title="可以使用下面的终止语句，即通过return（）向varnish返回的指示操作："></a>可以使用下面的终止语句，即通过return（）向varnish返回的指示操作：</h6><ul><li>pass：绕过缓存，即不从缓存中查询内容或不将内容存储至缓存中</li><li>pipe：不对客户端进行检查或作出任何操作，而是在客户端与后端服务器之间建立专用“管道”，并直接将数据在二者之间进行传送；此时，keep-alived连接中后续传送的数据也都将通过此管道进行直接传送，并不会出现在任何日志中</li><li>lookup：在缓存中查找用户请求的对象，如果缓存中没有其请求的对象，后续操作很可能会将其请求的对象进行缓存</li><li>error：由varnish自己合成一个相应报文，一般是响应一个错误类信息、重定向类信息或负载均衡器返回的后端web服务器健康状态检查类信息</li><li>可以通过精巧的策略完成一定意义上的安全功能，以将某些特定的攻击扼杀于摇篮中，同时，它也可以检查出一些拼写错误并将其进行修修正</li></ul><h6 id="varnish默认的vcl-recv专门设计用来实现安全的缓存策略，主要完成两种功能："><a href="#varnish默认的vcl-recv专门设计用来实现安全的缓存策略，主要完成两种功能：" class="headerlink" title="varnish默认的vcl_recv专门设计用来实现安全的缓存策略，主要完成两种功能："></a>varnish默认的vcl_recv专门设计用来实现安全的缓存策略，主要完成两种功能：</h6><p>（1）仅处理可以识别的HTTP方法，并且只缓存GET和HEAD方法</p><p>（2）不缓存任何用户特有的数据</p><p><strong>安全起见，一般在自定义的vcl_recv中不要使用return()终止语句，而是再由默认vcl_recv进行处理，并由其作出相应的处理决策。</strong></p><h2 id="5、vcl-fetch"><a href="#5、vcl-fetch" class="headerlink" title="5、vcl_fetch"></a>5、vcl_fetch</h2><p>根据服务器的响应作出缓存决策；在任何VCL状态引擎中返回的pass操作都将由vcl_fetch进行后续处理。vcl_fetch中有许多可用的内置变量，比如最常用的用于定义某对象缓存时长的beresp.ttl变量</p><h5 id="通过return-返回给varnish的操作指示有："><a href="#通过return-返回给varnish的操作指示有：" class="headerlink" title="通过return()返回给varnish的操作指示有："></a>通过return()返回给varnish的操作指示有：</h5><p>（1）deliver：缓存此对象，并将其发送给客户端（vcl_deliver）</p><p>（2）hit_for_pass：不缓存此对象，但可以导致后续对此对象的请求直接送达到vcl_pass进行处理</p><p>（3）restart：重启整个VCL，并增加重启计数；超过max_restarts限定的最大重启次数后将会返回错误信息</p><p>（4）error code [reason]：返回指定的错误代码给客户端并丢弃此请求</p><p><strong>默认的vcl_fetch放弃了缓存任何使用了Set-Cookie首部的响应。</strong></p><p><strong>两个特殊引擎</strong><br>-</p><ul><li>vcl_init：在处理任何请求之前要执行的vcl代码：主要用于初始化VMODs；</li><li>vcl_fini：所有的请求都已经结束，在vcl配置被丢弃时调用；主要用于倾全力VMODs；</li></ul><h1 id="三、修改缓存对象"><a href="#三、修改缓存对象" class="headerlink" title="三、修改缓存对象"></a>三、修改缓存对象</h1><h2 id="1、缓存内容修剪"><a href="#1、缓存内容修剪" class="headerlink" title="1、缓存内容修剪"></a>1、缓存内容修剪</h2><p>提高缓存命中率的最有效途径之一时增加缓存对象的生存时间（TTL），但是这也可能会带来副作用，比如缓存的内容再到达为其制定的有效期之间已经失效。因此，手动检验缓存对象的有效性或者刷新时缓存很有可能成为服务器管理员的日常工作之一；varnish完成这类的任务提供了三种途径：HTTP修剪(HTTP purging)、禁用某类缓存对象（banning）和强制缓存未命中（forced cache misses）</p><h2 id="2、移除单个缓存对象"><a href="#2、移除单个缓存对象" class="headerlink" title="2、移除单个缓存对象"></a>2、移除单个缓存对象</h2><p>purge用于清理缓存中的某特定对象及其变种，因此在有着明确要修剪的缓存对象时可以使用此中方式。HTTP协议的PURGE方法可以实现purge功能，不过其仅能用于vcl_hit和vcl_miss中，它会释放内存工作并移除指定缓存对象的所有vary（变种），并等待下一个针对此内容客户端请求到达时刷新此内容。起一般要与return（restart）一起使用。</p><h2 id="3、强制缓存未命中"><a href="#3、强制缓存未命中" class="headerlink" title="3、强制缓存未命中"></a>3、强制缓存未命中</h2><p>在vcl_recv中使用return（pass）能够强制到上游服务器取得请求的内容，但这也会导致无法将其缓存。使用purge会移除就的缓存对象，但如果上游服务器宕机而无法取得新版本的内容时，此内容将无法再响应给客户端。使用<code>req.has_always_miss=true</code>，可以让varnish在缓存中搜寻响应的内容但却总是回应“未命中”，于是vcl_miss将后续地负责启动vcl_fetch从上游服务器取得新内容，并以新内容缓存覆盖就内容；此时，如果上游服务器宕机或未响应，旧的内容将保持原状，并能够继续服务器那些为使用<code>req.has_always_miss=true</code>的客户端，直到其过期失效或者由其他方法移除。</p><h2 id="4、banning"><a href="#4、banning" class="headerlink" title="4、banning"></a>4、banning</h2><p>ban（）是一种已缓存对象中过滤出某此特定的对象并将其移除的缓存内容刷新机制，不过它并不足之处新的内容进入缓存或响应于请求。在varnish中，ban的实现是指将一个ban添加至ban列表中，这可以通过命令行接口或VCL实现，他们的使用语法时相同的。ban本身就是一个或多个VCL风格的语句，它会在varnish从缓存哈希（cache hash）中查找某缓存对象时对搜寻的对象进行比较测试，因此，一个ban语句就是类似匹配所有以/downloads开头的URL，或者响应首部中包含nginx的对象。</p><p>示例：</p><pre><code>ban req.http.host == “test。com” &amp;&amp; req.url ~ “\.gif$”</code></pre><p>定义好的ban语句会生成一个ban列表（ban-list），新添加的ban语句会被放置在列表中的首部。缓存中的所有对象在响应给客户端之前都会被ban列表检查至少一次，检查完成将会为每个缓存创建一个指向与其匹配的ban语句的指针。varnish在从缓存中获取对象时，总是会检查此缓存对象的指针是否指向了ban列表的首部；如果没有指向ban列表的首部，其将对使用所有的新添加的ban语句对此缓存对象进行测试，如果没有任何ban语句能够匹配则更新ban列表。</p><h1 id="四、varnish检测后端主机的健康状态"><a href="#四、varnish检测后端主机的健康状态" class="headerlink" title="四、varnish检测后端主机的健康状态"></a>四、varnish检测后端主机的健康状态</h1><p>varnish可以检测后端主机的健康状态，在判定后端主机失效时能够给自动将其从可用后端主机列表中移除，而一旦其重新变得可用还可以自动将其设定为可用。为了避免误判，varnish在探测后端主机的健康状态发生转变时，通常需要连续执行几次探测均为新状态才将其标记为转换后的状态。</p><p>每个后端服务器当前探测的健康状态探测可以使用.probe进行设定，其结果可有req.backend.healthy变量获取；也可以通过varnishlog中的backend_health查看或varnishadm的debug.health查看</p><p>####### .probe的探测常用的指令：</p><ul><li>（1）.url：探测后端主机健康状态时请求的URL，默认为”/“</li><li>（2）.request：探测后端主机健康状态时请求内容的详细格式，定义后，它会替换.url指定的探测方法</li><li>（3）.window：设定在判定后端主机健康状态时基于最近多少次的探测进行，默认为8</li><li>（4）.threshold：在.window中指定的次数中，至少有多少次时成功的才能判定后端主机健康运行，默认为3</li><li>（5）.initial：varnish启动时对后端主机至少需要多少次的成功探测，默认同.threshold</li><li>（6）.expected_response：期望后端主机响应的状态码，默认为200</li><li>（7）.interval：探测请求的发送周期，默认为5s</li><li>（8）.timeout：每次探测请求的过期时长，默认为2s</li></ul><p>如果varnish在某时刻没有任何可用的后端主机，它将尝试使用缓存对象的“宽容副本（graced copy）”，此时VCL中的各种规则亦然有效。因此更好的办法时在VCL规则中判断req.backend.health变量显示某后端主机不可用时，为此后端主机增大req.grace变量的值以设定使用的宽容期限长度。</p><h1 id="五、varnish使用多台后端主机"><a href="#五、varnish使用多台后端主机" class="headerlink" title="五、varnish使用多台后端主机"></a>五、varnish使用多台后端主机</h1><p>varnish中可以使用的director指令将一个或多个近似的后端主机定义为一个逻辑组，并可以指定的调度方式来轮流将请求发送至这些主机上。不同的director可以使用同一个后端主机，而某director也可以使用“匿名”后端主机（在direcotr中直接进行定义）。每个director都必须有专用名，且在定义后必须在VCL中进行调用，VCL中任何可以指定后端主机的位置均可以按需将其替换为调用已定义的director。</p><p><strong>使用前需要导入directors模块</strong></p><p>示例：</p><pre><code>import directors;backend server1 {    .host = 192.168.4.60    .port = 80}backend server2 {    .host = 192.168.4.61    .port = 80}sub vcl_init {    new testgrp = direcotrs.round_robin();    testgrp.add_backend(server1);    testgrp.add_backend(server2);}sub vcl_recv {    set req.backend_hint = testgrp.backend();}</code></pre><h1 id="六、varnish参数"><a href="#六、varnish参数" class="headerlink" title="六、varnish参数"></a>六、varnish参数</h1><p>varnish有许多参数，但是在某些场合我们需要修改他们提高性能。可以在管理接口中使用param.show命令查看这些参数，而使用param.set则能修改这些参数的值。当时，在命令行接口进行的修改不会保存至任何位置，重启varnish后这些设定会消失。可以通过启动脚本使用-p选项在varnishd启动时为其设定参数的值。</p><h3 id="1、线程模型"><a href="#1、线程模型" class="headerlink" title="1、线程模型"></a>1、线程模型</h3><ul><li>cache-worker线程：每连接一个用于处理请求，</li><li>cache-main线程：全局只有一个，用于启动cache</li></ul><h3 id="2、线程相关的参数"><a href="#2、线程相关的参数" class="headerlink" title="2、线程相关的参数"></a>2、线程相关的参数</h3><ul><li>thread_pools：工作线程池，最好小于或等于CPU核心数量</li><li>thread_pool_max：每线程池最大线程数</li><li>thread_pool_min：每线程池最小线程数，即最大空闲线程数</li><li>thread_pool_timeout：每线程的超时时长</li><li>thread_pool_add_delay：添加线程的延迟时间</li><li>thread_pool_destory_delay：每线程销毁时长</li></ul><h3 id="3、timer相关的参数"><a href="#3、timer相关的参数" class="headerlink" title="3、timer相关的参数"></a>3、timer相关的参数</h3><ul><li>send_timeout：客户端连接超时时长</li><li>timeout_idle：Idle timeout for client connections.</li><li>timeout_req：请求超时时长</li><li>cli_timeout：Timeout for the childs replies to CLI requests from the mgt_param.</li></ul><h1 id="七、varnish命令行工具"><a href="#七、varnish命令行工具" class="headerlink" title="七、varnish命令行工具"></a>七、varnish命令行工具</h1><h3 id="1、varnishadm命令"><a href="#1、varnishadm命令" class="headerlink" title="1、varnishadm命令"></a>1、varnishadm命令</h3><p>通过命令行的方式连接至varnishd进行管理操作的工具。</p><p>语法：</p><pre><code>varnishadm [-t timeout] [-S secret_file] [-T address:port] [-n name] [command [...]]</code></pre><h5 id="指定要连接的varnish示例的方法："><a href="#指定要连接的varnish示例的方法：" class="headerlink" title="指定要连接的varnish示例的方法："></a>指定要连接的varnish示例的方法：</h5><pre><code>-n name 连接至名称为“name”的示例-T address:port  连接至指定套接字上的示例</code></pre><p>配置文件相关：</p><pre><code>vcl.list：vcl.load：装载，加载并编译vcl.use：激活vcl.discard：删除vcl.show [-V] &lt;configname&gt;：查看指定的配置文件的详细信息</code></pre><p>运行时参数：</p><pre><code>param.show -1：显示列表param.show &lt;PARAM&gt;param.set &lt;PARAM&gt; &lt;VALUE&gt;</code></pre><p>缓存存储：</p><pre><code>storage.list</code></pre><p>后端服务器：</p><pre><code>backend.list</code></pre><h3 id="2、varnish-param"><a href="#2、varnish-param" class="headerlink" title="2、varnish.param"></a>2、varnish.param</h3><p>选项</p><pre><code>-a address[:port][,address[:port]...]，默认为6081端口-T address[:port]，默认为6082-s [name=]type[,options]，定义缓存存储机制-u user-g group-f config，VCL配置文件-F 运行在前台-p param=value：设定运行参数即数值，可重复使用多次-r param[,param]：设定指定的参数为只读状态</code></pre><h3 id="3、varnishstat"><a href="#3、varnishstat" class="headerlink" title="3、varnishstat"></a>3、varnishstat</h3><p>varnish缓存统计信息</p><pre><code>-l：列出-f：指定字段名称列表    MAIN.cache_hit    MAIN.cache_miss</code></pre><h3 id="4、varnishtop"><a href="#4、varnishtop" class="headerlink" title="4、varnishtop"></a>4、varnishtop</h3><p>varnish日志全部等级</p><pre><code>-l-i taglist，可以同时使用多个-i选项，也可以一个选项跟上多个标签-I &lt;[targlist:]regex&gt;-x taglist:排除列表-X &lt;[taglist:]regex&gt;</code></pre><h1 id="八、varnish配置文件"><a href="#八、varnish配置文件" class="headerlink" title="八、varnish配置文件"></a>八、varnish配置文件</h1><p>配置varnish服务进程的工作特性，例如监听的地址和端口，缓存机制</p><pre><code>/etc/varnish/varnish.params</code></pre><p>配置各Child/cache线程的缓存策略</p><pre><code>/etc/varnish/default.vcl</code></pre><p>主程序</p><pre><code>/usr/sbin/varnishd</code></pre><p>share memory log交互工具</p><pre><code>/usr/bin/varnishhist/usr/bin/varnishlog/usr/bin/varnishncsa/usr/bin/varnishstat/usr/bin/varnishtop</code></pre><p>测试工具程序</p><pre><code>/usr/bin/varnishtest</code></pre><p>VCL配置文件重载程序</p><pre><code>/usr/sbin/varnish_reload_vcl</code></pre><p>systemd unit file</p><pre><code>/usr/lib/systemd/system/varnish.service/usr/lib/systemd/system/varishlog.service/usr/lib/systemd/system/varnishncsa.service</code></pre>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Varnish </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于数据库验证vsftpd虚拟用户</title>
      <link href="/2017/11/28/%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AA%8C%E8%AF%81vsftpd%E8%99%9A%E6%8B%9F%E7%94%A8%E6%88%B7/"/>
      <url>/2017/11/28/%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AA%8C%E8%AF%81vsftpd%E8%99%9A%E6%8B%9F%E7%94%A8%E6%88%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="基于数据库验证vsftpd虚拟用户"><a href="#基于数据库验证vsftpd虚拟用户" class="headerlink" title="基于数据库验证vsftpd虚拟用户"></a>基于数据库验证vsftpd虚拟用户</h2><p>CentOS7 环境</p><p>（1）编译安装pam_mysql,提供pam_mysql.so模块<br><code>[root@localhost/usr/local/src/pam_mysql-0.7RC1]#yum install -y mariadb-devel pam-devel</code><br><code>[root@localhost/usr/local/src/pam_mysql-0.7RC1]#./configure --with-mysql=/usr --with-pam=/usr --with-pam-mods-dir=/lib64/security</code><br><code>[root@localhost/usr/local/src/pam_mysql-0.7RC1]#make &amp;&amp; make install</code></p><p>（2）准备数据库和相关表</p><p><code>[root@localhost~]#mysql -uroot -p</code></p><pre><code>MariaDB [(none)]&gt; CREATE DATABASE ftpdb;MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON ftpdb.* TO ftpuser@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;MariaDB [(none)]&gt; USE ftpdb;MariaDB [ftpdb]&gt; CREATE TABLE vuser (ID int unsigned auto_increment primary key,username char(40),password char(50));</code></pre><p><code>[root@localhost~]#useradd -d /app/ftproot -s /sbin/nologin ftpuser</code><br><code>[root@localhost~]#chmod 555 /app/ftproot/</code> #修改目录权限，因为CentOS7中默认不允许父目录有写权限</p><p>（3）添加虚拟用户</p><pre><code>MariaDB [ftpdb]&gt; INSERT INTO vuser(username,password) VALUES(&#39;joah&#39;,password(&#39;123456&#39;));MariaDB [ftpdb]&gt; INSERT INTO vuser(username,password) VALUES(&#39;li&#39;,password(&#39;123456&#39;));</code></pre><p>（4）建立pam认证所需文件</p><p><code>[root@localhost~]#vim /etc/pam.d/vsftpd.mysql</code><br>    1 auth reuqired pam_mysql.so user=ftpuser passwd=123456 host=localhost db=ftpdb table=vu<br>    ser usercolumn=username passwdcolumn=password crypt 2<br>    2 account reuqired pam_mysql.so user=ftpuser passwd=123456 host=localhost db=ftpdb table    =vuser usercolumn=username passwdcolumn=password crypt 2</p><pre><code>选线说明：auth 表示认证account 验证账号密码正常使用reuqired 表示认证通过user 为登录mysql的用户passwd  登录mysql的密码host    mysql服务器的主机名或IP地址db 指定连接mysql的数据库名称table   指定连接数据库中的表名usercolumn  当做用户名的字段passwdcolumn    当做用户名字段的密码crypt   表示加密方式，0表示不加密；1表示crypt（3）加密；2表示使用mysql password（）函数加密；3表示md5加密；4表示sha1加密</code></pre><p>（5）创建虚拟用户配置文件</p><p><code>[root@localhost/etc/vsftpd]#mkdir vdocs</code><br><code>[root@localhost/etc/vsftpd]#cd vdocs/</code><br><code>[root@localhost/etc/vsftpd/vdocs]#vim joah</code></p><p><code>[root@localhost/etc/vsftpd/vdocs]#vim li</code></p><p>（6）修改<code>/etc/vsftpd/vsftpd.conf</code></p><p>在配置文件中添加如下内容</p><pre><code>128 guest_enable=YES129 guest_username=ftpuser130 pam_service_name=vsftpd.mysql131 user_config_dir=/etc/vsftpd/vdocs</code></pre><p>（7）重启服务并测试</p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中五种I/O模型</title>
      <link href="/2017/11/28/%E6%A8%A1%E5%9E%8BIO/"/>
      <url>/2017/11/28/%E6%A8%A1%E5%9E%8BIO/</url>
      
        <content type="html"><![CDATA[<p>linux中五种I/O模型<br>-</p><h1 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h1><p>关注的是消息通信机制</p><h3 id="同步（synchronous）：调用者自己主动等待被调用者返回消息，才能继续执行下面操作。"><a href="#同步（synchronous）：调用者自己主动等待被调用者返回消息，才能继续执行下面操作。" class="headerlink" title="同步（synchronous）：调用者自己主动等待被调用者返回消息，才能继续执行下面操作。"></a>同步（synchronous）：调用者自己主动等待被调用者返回消息，才能继续执行下面操作。</h3><h3 id="异步（asynchronous）：被调用者通过状态、通知或回调机制主动通知调用者被调用者运行的状态。"><a href="#异步（asynchronous）：被调用者通过状态、通知或回调机制主动通知调用者被调用者运行的状态。" class="headerlink" title="异步（asynchronous）：被调用者通过状态、通知或回调机制主动通知调用者被调用者运行的状态。"></a>异步（asynchronous）：被调用者通过状态、通知或回调机制主动通知调用者被调用者运行的状态。</h3><h1 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h1><p>关注调用者在等待结果返回之前所处的状态</p><h3 id="阻塞（blocking）：指I-O操作需要彻底完成后才能返回到用户空间，调用结果返回之前，调用者被挂起。"><a href="#阻塞（blocking）：指I-O操作需要彻底完成后才能返回到用户空间，调用结果返回之前，调用者被挂起。" class="headerlink" title="阻塞（blocking）：指I/O操作需要彻底完成后才能返回到用户空间，调用结果返回之前，调用者被挂起。"></a>阻塞（blocking）：指I/O操作需要彻底完成后才能返回到用户空间，调用结果返回之前，调用者被挂起。</h3><h3 id="非阻塞（nonblocking）：指I-O操作被调用后立即返回给用户一个状态值，无需等到I-O操作彻底完成，最终的调用结果返回之前，调用者不会被挂起。"><a href="#非阻塞（nonblocking）：指I-O操作被调用后立即返回给用户一个状态值，无需等到I-O操作彻底完成，最终的调用结果返回之前，调用者不会被挂起。" class="headerlink" title="非阻塞（nonblocking）：指I/O操作被调用后立即返回给用户一个状态值，无需等到I/O操作彻底完成，最终的调用结果返回之前，调用者不会被挂起。"></a>非阻塞（nonblocking）：指I/O操作被调用后立即返回给用户一个状态值，无需等到I/O操作彻底完成，最终的调用结果返回之前，调用者不会被挂起。</h3><h1 id="程序空间与内核空间"><a href="#程序空间与内核空间" class="headerlink" title="程序空间与内核空间"></a>程序空间与内核空间</h1><p>在linux中，对于一次I/O操作数据并不会直接拷贝到程序空间的程序缓冲区；数据首先被拷贝到操作系统内核的缓冲区中，然后丛操作系统内核的缓冲区拷贝到程序空间的缓冲区。</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-29_095218.jpg" alt=""></p><h2 id="blocking-IO（阻塞IO）"><a href="#blocking-IO（阻塞IO）" class="headerlink" title="blocking IO（阻塞IO）"></a>blocking IO（阻塞IO）</h2><p><img src="http://owatlfstl.bkt.clouddn.com/4003106-68d99e1afac8711a.jpg" alt=""></p><h3 id="工作机理"><a href="#工作机理" class="headerlink" title="工作机理"></a>工作机理</h3><p>用户进程通过系统调用read发起IO读操作，由用户空间转到内核空间；内核等待数据包到达后，然后将接受的数据拷贝到用户空间，完成read操作。</p><p>但是用户需要等待read将数据读取到buffer后才能继续处理接受接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情去，对CPU的资源利用率不够。</p><h2 id="nonblocking（非阻塞IO）"><a href="#nonblocking（非阻塞IO）" class="headerlink" title="nonblocking（非阻塞IO）"></a>nonblocking（非阻塞IO）</h2><p><img src="http://owatlfstl.bkt.clouddn.com/4003106-a0de8a23aaded772.jpg" alt=""></p><h3 id="工作机理-1"><a href="#工作机理-1" class="headerlink" title="工作机理"></a>工作机理</h3><p>用户进程发起IO请求立即返回，但并未读取到任何数据，用户进程需要不断地发起IO请求，直到数据到达之后，才能真正读取数据，继续执行。即“轮询”机制。</p><p>这个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍然需要不断地轮询、重复请求，消耗了大量CPU资源</p><h1 id="IO-multiplexing（IO-复用）"><a href="#IO-multiplexing（IO-复用）" class="headerlink" title="IO multiplexing（IO 复用）"></a>IO multiplexing（IO 复用）</h1><p><img src="http://owatlfstl.bkt.clouddn.com/4003106-ccb00f9c5ffe706c.jpg" alt=""></p><h2 id="工作机理-2"><a href="#工作机理-2" class="headerlink" title="工作机理"></a>工作机理</h2><p>用户首先将需要进行IO操作添加到select中，继续执行做其他的工作，同时等待select系统调用返回。当数据到达后，IO被激活，select函数返回。</p><p>用户线程正式发起read请求，读取数据并继续执行。从流程上看，使用了select函数进行IO请求和同步阻塞模型没有太大的区别，甚至多了监视IO，以及调用select函数的额外操作，效率更差。而且模型阻塞了两次，第一次阻塞在select上时，select可以监视多个IO上是否已有IO操作准备就绪，即可达到在同一个线程内同时处理多个IO请求的目的。如果用户线程只是注册自己需要的IO请求，然后去做自己的事情去，等待数据到来时再进行处理则可以提高CPU的利用率。</p><h3 id="IO费用使用场合："><a href="#IO费用使用场合：" class="headerlink" title="IO费用使用场合："></a>IO费用使用场合：</h3><p>（1）当客户处理多个描述符时（一般是交互式输入和网络套接字），必须使用IO复用。</p><p>（2）当一个客户同时处理多个套接字</p><p>（3）当一个TCP服务器既要处理多个套接口时，又要处理已经连接套接口</p><p>（3）当一个服务器即要处理TCP，又要处理UDP</p><p>（4）当一个服务器要处理多个服务或多个协议</p><h2 id="singal-driven-IO-（信号驱动IO）"><a href="#singal-driven-IO-（信号驱动IO）" class="headerlink" title="singal driven IO （信号驱动IO）"></a>singal driven IO （信号驱动IO）</h2><p><img src="http://owatlfstl.bkt.clouddn.com/4003106-4418b060727308d6.jpg" alt=""></p><h3 id="工作机理-3"><a href="#工作机理-3" class="headerlink" title="工作机理"></a>工作机理</h3><p>用户进程可以通过sigaction系统调用注册一个信号处理程序，然后主程序可以继续向下执行，当有IO操作准备就绪时，由内核通知触发一个SINGO信号处理程序执行，然后将用户进程所需要的数据从内核空间拷贝到用户空间。</p><h2 id="asynchronous-IO-（异步IO）"><a href="#asynchronous-IO-（异步IO）" class="headerlink" title="asynchronous IO （异步IO）"></a>asynchronous IO （异步IO）</h2><p><img src="http://owatlfstl.bkt.clouddn.com/4003106-df81a11b0248421f.jpg" alt=""></p><h3 id="工作机理-4"><a href="#工作机理-4" class="headerlink" title="工作机理"></a>工作机理</h3><p>异步IO直接在第二阶段完成后内核直接通知可以进行后续操作。</p><p>小结<br>-</p><p><img src="http://owatlfstl.bkt.clouddn.com/4003106-155daa4f0d0b7e49.jpg" alt=""></p><h2 id="I-O模型具体实现"><a href="#I-O模型具体实现" class="headerlink" title="I/O模型具体实现"></a>I/O模型具体实现</h2><p>select<br>-</p><p>POSIX所规定，本质上是通过设置或者检查存放FD标志位数据结构来处理进行下一步处理</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>(1)当个进程可监视FD数量被限制，即能监听端口的数量有限 <code>cat /proc/sys/fs/file-max</code></p><p>(2)对socket是线性扫描，即采用轮询的方法，效率低</p><p>(3)select采取内存拷贝方法来实现内核将FD消息通知给用户空间，这样一个用来存放大量FD的数据结构，会使得用户空间和内核空间在传递该结构时复制开销大</p><p>poll<br>-</p><p>本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个FD对应的设备状态</p><p>（1）没有最大连接数的限制，原因是基于链表来存储的</p><p>（2）大量的FD的数组被整体复制与用户态和内核地址空间之间，而不管这样的复制是不是有意义</p><p>（3）poll特点是“水平触发”，如果报告了FD后，没有处理那么下次poll时会再次报告该FD</p><p>（4）边缘触发：只通知一次</p><p>epoll<br>-</p><p>支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些FD刚刚变为就绪态，并且只会通知一次。使用“事件”的就绪通知方式，通过epoll_ctl注册FD，一旦该FD就绪，内核就会采用类似callback的回调机制来激活该FD，epoll_wait便可以收到通知。</p><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p>（1）没有最大并发连接的限制：能打开的FD上线远大于1024</p><p>（2）效率提升，非轮询方式，不会随着FD数目的增加而效率下降；只有活跃可用的FD才会调用callback函数，即epoll最大的优点在于它只管理“活跃”的链接，而根连接总数无关。</p><p>（3）内存拷贝，利用mmap（）文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销</p>]]></content>
      
      
      <categories>
          
          <category> I/O模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库类型</title>
      <link href="/2017/11/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/11/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、数据库"><a href="#一、数据库" class="headerlink" title="一、数据库"></a>一、数据库</h2><h3 id="1、数据库的概念"><a href="#1、数据库的概念" class="headerlink" title="1、数据库的概念"></a>1、数据库的概念</h3><p>数据库(Database)是按照数据结构来组织、存储和管理数据的建立在计算机存储设备上的仓库；它以一定的组织形式存于存储介质上。</p><h3 id="2、数据库管理系统-Database-Management-System"><a href="#2、数据库管理系统-Database-Management-System" class="headerlink" title="2、数据库管理系统(Database Management System)"></a>2、数据库管理系统(Database Management System)</h3><p>一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS。它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。用户通过DBMS访问数据库中的数据，数据库管理员也通过dbms进行数据库的维护工作。它可使多个应用程序和用户用不同的方法在同时或不同时刻去建立，修改和询问数据库。大部分DBMS提供数据定义语言DDL（Data Definition Language）和数据操作语言DML（Data Manipulation Language），供用户定义数据库的模式结构与权限约束，实现对数据的追加、删除等操作。 &lt;摘自：百度&gt;</p><h3 id="3、数据库管理系统与文件管理系统对比"><a href="#3、数据库管理系统与文件管理系统对比" class="headerlink" title="3、数据库管理系统与文件管理系统对比"></a>3、数据库管理系统与文件管理系统对比</h3><p>|<br>|编写应用程序不方便|编写应用程序方便，好管理<br>|数据冗余不可避免|较少的数据冗余<br>|应用程序依赖性|程序与数据相互独立<br>|不支持对文件并发访问|数据可以被并发访问；并保证一致性<br>|数据之间联系弱|相互关联的数据集合<br>|难以按用户要求使用视图表示|可以按用户的需求使用视图表示<br>|无安全控制功能|可以保证数据的安全性、可靠性</p><h3 id="4、数据库的种类"><a href="#4、数据库的种类" class="headerlink" title="4、数据库的种类"></a>4、数据库的种类</h3><h4 id="（1）非关系型数据库"><a href="#（1）非关系型数据库" class="headerlink" title="（1）非关系型数据库"></a>（1）非关系型数据库</h4><h4 id="（2）关系型数据库（RDBM）"><a href="#（2）关系型数据库（RDBM）" class="headerlink" title="（2）关系型数据库（RDBM）"></a>（2）关系型数据库（RDBM）</h4><p>创建在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。标准数据查询语言SQL就是一种基于关系数据库的语言。这种语言执行对关系数据中数据的检索和操作。关系模型由关系数据结构、关系操作集合和关系完整性约束三部分组成。</p><ul><li>数据结构 包括两类：一类是与数据类型、内容和性质有关的对象，比如关系型中的域、属性和关系等；另一类是与数据之间有关的对象，它从数据组织层表达数据记录于字段的结构。</li><li>数据的操作集合 数据提取，在数据集合中提取感兴趣的内容。（SELECT）；数据更新，更改数据库中的数据（INSERT、DELETE和UPDATE）。</li><li>数据完整性约束 是一组完整性规则的集合。如实体完整性（Entity Integrity）、域完整性（Doamin Integrity）和参考完整性（Referential Integrity）。</li></ul><h5 id="（a）关系实体模型（Entity-Relationship-Model，E-R-Model）"><a href="#（a）关系实体模型（Entity-Relationship-Model，E-R-Model）" class="headerlink" title="（a）关系实体模型（Entity-Relationship Model，E-R Model）"></a>（a）关系实体模型（Entity-Relationship Model，E-R Model）</h5><p><img src="http://owatlfstl.bkt.clouddn.com/ER_Diagram_MMORPG.png" alt=""></p><p>注：</p><ul><li>矩形代表实体</li><li>椭圆代表关系</li><li>菱形代表关系</li></ul><p> 实体表示一个离散对象。客观存在并可以相互区分的客观事物或抽象时间被称为实体（Entity）；每个实体必须有一个唯一表示的最小化集合。这个集合叫实体的主键。</p><p>关系 描述了两个或多个实体之间是如何关联。如有关两个实体<br><img src="http://owatlfstl.bkt.clouddn.com/Erd-entity-relationship-example1.png" alt=""></p><h5 id="（b）构建数据库步骤"><a href="#（b）构建数据库步骤" class="headerlink" title="（b）构建数据库步骤"></a>（b）构建数据库步骤</h5><p>①收集数据，得到字段</p><p>②字段分类，归入表并建立表的关联</p><p>③规范化数据库</p><h5 id="（c）关系型数据库正规化"><a href="#（c）关系型数据库正规化" class="headerlink" title="（c）关系型数据库正规化"></a>（c）关系型数据库正规化</h5><p>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为范式。各种范式呈递次规范，越高的范式数据库冗余越小。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、Boyce-Codd范式（BCNF）、第四范式（4NF）和第五范式（5NF）<br><img src="http://owatlfstl.bkt.clouddn.com/a.jpg" alt=""></p><ul><li>1NF：无重复的列，每一列都是不可分割的基本数据项；同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。除去同类型的字段，简言之：无重复的列。</li><li>2NF：要求实体的属性完全依赖于关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。如果存在这个属性和主关键字的这一部分应该分离出来形成一个新的实体。新实体与原来实体之间是一对多关系。为实现区分通常需要为表加上一个列，以存储各个实体的唯一标识（primary key）。简言之，非主属性分非部分依赖于主关键字。</li><li>3NF：属性不依赖于其他非主属性。简言之，要求一个数据库不包含已在其他表中已包含的非主关键字信息。非PK（primary key）的字段不能有从属关系。</li></ul><p>注意：不过这个不是必要遵守的，有时候在生产中，为了提升效能，刻意而为之。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站访问量计算方式</title>
      <link href="/2017/11/28/%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E9%87%8F%E8%AE%A1%E7%AE%97/"/>
      <url>/2017/11/28/%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E9%87%8F%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="网站访问量计算方式"><a href="#网站访问量计算方式" class="headerlink" title="网站访问量计算方式"></a>网站访问量计算方式</h2><ul><li><p>IP(独立IP)：即Internet Protocol,指独立IP数。一天内来自相同客户机IP地址只计算一次，记录远程客户机IP地址的计算机访问网站的次数，是衡量网站流量的重要指标。</p></li><li><p>PV(访问量)： 即Page View, 页面浏览量或点击量，用户每次刷新即被计算一次，PV反映的是浏览某网站的页面数，PV与来访者的数量成正比，PV并不是页面的来访者数量，而是网站被访问的页面数量。</p></li><li><p>UV(独立访客)：即Unique Visitor,访问网站的一台电脑为一个访客。一天内相同的客户端只被计算一次。可以理解成访问某网站的电脑的数量。网站判断来访电脑的身份是通过来访电脑的cookies实现的。如果更换了IP后但不清除cookies，再访问相同网站，该网站的统计中UV数是不变的</p></li></ul><p><a href="http://www.alexa.cn/rank/" target="_blank" rel="noopener">http://www.alexa.cn/rank/</a>可以查看全球网站的统计量</p><p><strong>示例：</strong></p><p>小明在家用ADSL拨号上网，早上8点访问了www.baidu.com下的2个页面，下午2点又拨号访问了www.baidu.com3个页面。那么，对于www.baidu.com来讲，今天的PV、UV、VV、IP各项指标该如何计算呢 ？</p><pre><code>IP 2        PV  5       UV  1</code></pre>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 访问量计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集群介绍</title>
      <link href="/2017/11/28/%E9%9B%86%E7%BE%A4%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/11/28/%E9%9B%86%E7%BE%A4%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>参考：</p><p><a href="http://www.linuxvirtualserver.org/zh/lvs1.html" target="_blank" rel="noopener">http://www.linuxvirtualserver.org/zh/lvs1.html</a></p><h1 id="一、服务器集群系统"><a href="#一、服务器集群系统" class="headerlink" title="一、服务器集群系统"></a>一、服务器集群系统</h1><h2 id="1、对称多处理"><a href="#1、对称多处理" class="headerlink" title="1、对称多处理"></a>1、对称多处理</h2><p>对称多处理（symmctric multi-processor，SMP）是由多个对称的处理器和通过总线共享的内存和I/O不见所组成的计算机系统。由于SMP的可扩展能力有限，SMP服务器显然不能满足高可伸缩、高可用网络服务器的负载处理能力不断增长需求。</p><h3 id="SMP的缺点"><a href="#SMP的缺点" class="headerlink" title="SMP的缺点"></a>SMP的缺点</h3><p>（1）升级过程繁琐，机器切换会使服务中断并造成原有计算资源的浪费。</p><p>（2）高端的服务器所花费的代价大</p><p>（3）SMP服务器是单一故障点（Single Point of Failure），一旦该服务器或应用软件失效，会导致整个服务的中断。</p><h2 id="2、集群服务器"><a href="#2、集群服务器" class="headerlink" title="2、集群服务器"></a>2、集群服务器</h2><p>集群，英文名称为Cluster，通俗地说，集群是一种技术：它将多个系统连接到一起，使多台服务器能够像一台机器那样工作或者看起来好像一台机器。采用集群系统通常是为了提高系统的稳定性和网络中心的数据处理能力及服务能力。</p><h2 id="3、linux-cluster类型"><a href="#3、linux-cluster类型" class="headerlink" title="3、linux cluster类型"></a>3、linux cluster类型</h2><p>1.LB Load Balancing（负载均衡集群），为了提高服务的并发能力</p><p>2.HA High Availability（高可用性集群），为了提供7*24小时服务的能力，通过冗余服务器，来防止宕机造成服务器终端</p><p>3.HPC High Performance Computing（高性能集群），为了在短期内解决大量复杂的计算</p><h2 id="4、Cluster分类"><a href="#4、Cluster分类" class="headerlink" title="4、Cluster分类"></a>4、Cluster分类</h2><h3 id="LB-Cluster实现方法"><a href="#LB-Cluster实现方法" class="headerlink" title="LB Cluster实现方法"></a>LB Cluster实现方法</h3><p>硬件</p><pre><code>F5 Big-IPCitrix NetscalerA10</code></pre><p>软件</p><pre><code>lvs：Linux Virtual ServerNginx：支持四层调度Haproxy：支持四层调度ats：apache traffic server，是一个高性能的、模块化的HTTP代理和缓存服务器</code></pre><h3 id="Cluster分类"><a href="#Cluster分类" class="headerlink" title="Cluster分类"></a>Cluster分类</h3><p>基于工作的协议层划分</p><h4 id="传输层：DPORT"><a href="#传输层：DPORT" class="headerlink" title="传输层：DPORT"></a>传输层：DPORT</h4><h4 id="应用层：针对特定协议，自定义的请求模型分类"><a href="#应用层：针对特定协议，自定义的请求模型分类" class="headerlink" title="应用层：针对特定协议，自定义的请求模型分类"></a>应用层：针对特定协议，自定义的请求模型分类</h4><h2 id="5、会话保持：负载均衡"><a href="#5、会话保持：负载均衡" class="headerlink" title="5、会话保持：负载均衡"></a>5、会话保持：负载均衡</h2><p>（1）session sticky：同一用户调度固定服务器</p><p>（2）session replication ：每台服务器拥有全部内容</p><p>（3）session server：专门的session服务器memcached，redis等</p>]]></content>
      
      
      <categories>
          
          <category> 常用服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络防火墙</title>
      <link href="/2017/11/28/%E7%BD%91%E7%BB%9C%E9%98%B2%E7%81%AB%E5%A2%99/"/>
      <url>/2017/11/28/%E7%BD%91%E7%BB%9C%E9%98%B2%E7%81%AB%E5%A2%99/</url>
      
        <content type="html"><![CDATA[<h1 id="网络防火墙"><a href="#网络防火墙" class="headerlink" title="网络防火墙"></a>网络防火墙</h1><p>网络防火墙可以充当网关；使用filter表中的FORWARD链。如果要启用conntrack机制，建议将双方向的状态为ESTABLISHED的报文直接放行。</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-20_161601.jpg" alt=""></p><p>如图所示：现在我们的需求是内网可以ping外网但是外网ping不了内网如何实现？</p><p>环境：</p><pre><code>CentOS 6 192.168.4.55CentOS 6 172.18.4.61 充当路由器（两块网卡）CentOS 7 172.18.4.56</code></pre><p>（1）在CentOS 6 (192.168.4.56)可以路由转发功能并添加规则</p><p><code>[root@localhost ~]# vim /etc/sysctl.conf</code></p><pre><code>net.ipv4.ip_forward = 1</code></pre><p><code>[root@localhost ~]# sysctl -p</code> 使其生效 </p><p>（2）将两台主机的网关指定路由器</p><p><code>[root@localhost ~]# route add default gw 192.168.4.61</code></p><p><code>[root@localhost ~]# route add default gw 172.18.4.61</code></p><p>（3）测试没有假规则之前是否可以ping通</p><p>（4）在路由上添加规则</p><p><em>方式一：</em></p><p><code>[root@localhost~]#iptables -A FORWARD -s 192.168.4.0/24 -d 172.18.4.0/24 -p icmp --icmp-type 8 -j ACCEPT</code></p><p><code>[root@localhost~]#iptables -A FORWARD -s 172.18.4.0/24 -d 192.168.4.0/24 -p icmp --icmp-type 0 -j ACCEPT</code></p><p><code>[root@localhost~]#iptables -A FORWARD -j REJECT</code></p><p><em>方式二：</em></p><p><code>[root@localhost~]#iptables -A FORWARD -m state --state ESTABLISHED -j ACCEPT</code></p><p><code>[root@localhost~]#iptables -A FORWARD -s 192.168.4.0/24 -d 172.18.4.0/24 -p icmp --icmp-type 8 -j ACCEPT</code></p><p><code>[root@localhost~]#iptables -A FORWARD -j REJECT</code></p><p><em>方式三：</em></p><p><code>[root@localhost~]#iptables -A FORWARD -m state --state ESTABLISHED -j ACCEPT</code></p><p><code>[root@localhost~]#iptables -A FORWARD -s 192.168.4.0/24 -d 172.18.4.0/24 -m state --state NEW -j ACCEPT</code></p><p><code>[root@localhost~]#iptables -A FORWARD -j REJECT</code></p><p>（5）测试是否成功</p><p><strong>问题：如何开放被动模式的ftp模式？</strong></p><p>（1）需要查看是否已经加载了ftp追踪的模块</p><p>跟踪模块路径：<code>/lib/modules/2.6.32-696.el6.x86_64/kernel/net/netfilter/</code></p><p><code>[root@localhost ~]# lsmod |grep ftp</code></p><p>如果没有记载此模块需要安装模块</p><p><code>[root@localhost ~]# modprobe nf_conntrack_ftp</code></p><p>（2）放行请求报文</p><p><code>[root@localhost ~]# iptables -A INPUT -d 192.168.4.55 -p tcp --dport 21 -m state --state NEW -j ACCEPT</code><br><code>[root@localhost ~]# iptables -A INPUT -d 192.168.4.55 -p tcp -m state --state RELATED,ESTABLISHED</code> #</p><p>（3）放行响应报文</p><p><code>[root@localhost ~]# iptables -A OUTPUT -s 192.168.4.55 -p tcp -m state --state ESTABLISHED -j ACCEPT</code>  #如果没有别的定义OUTPTU 可以不定义此规则</p><h1 id="NAT：Network-Address-Translation（网络地址转换）"><a href="#NAT：Network-Address-Translation（网络地址转换）" class="headerlink" title="NAT：Network Address Translation（网络地址转换）"></a>NAT：Network Address Translation（网络地址转换）</h1><p>NAT工作在PREROUTING、INPUT、OUTPUT、POSTROUTING</p><ul><li>SNAT :Source Network Address Translation</li></ul><p>应用在PREROUTING、INPUT链上，让本地网络中的主机通过某一特定地址访问外部网络，实现地址伪装。</p><pre><code>请求报文：修改源IP</code></pre><p>-J SNAT </p><pre><code>--to-source [ipaddr[-ipaddr]][:port[-port]]--random</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-20_200429.jpg" alt=""></p><p>如上图所示，就是SNAT。</p><p>实现此功能只需添加一条规则即可</p><p><code>[root@localhost~]#iptables -t nat -A POSTROUTING -s 192.168.4.0/24 -j SNAT --to-source 172.18.4.56</code></p><p><strong>注意：地址转换不需要双方互指网关，只需本地网络指定内网网关即可</strong></p><p>###如果我们不知道外网IP地址或者范围如何实现SNAT呢？</p><p>MASQUERADE :伪装，动态IP ，如以前拨号网络</p><pre><code>--to-ports[-port]--random</code></pre><p><code>[root@localhost~]#iptables -t nat -A POSTROUTING -s 192.168.4.0/24 -j MASQUERADE</code></p><ul><li>DNAT ：Destination Network Address Translation</li></ul><p>应用在PREROUTING、OUTPUT链上。把本地网络中的主机上的某服务开放给外部网络访问，但可以隐藏真实IP </p><pre><code>请求报文：修改目标IP</code></pre><p><img src="http://owatlfstl.bkt.clouddn.com/2017-10-20_203115.jpg" alt=""></p><p><code>[root@localhost~]#iptables -t nat -A PREROUTING -s 172.18.4.56 -p tcp --dport 80 -j DNAT --to-destination 192.168.4.55</code></p><p>PNAT：Port Network Address Translation </p><p>端口号和IP都进行修改。</p><p><strong>注意：我们在工作环境中一般把本地网络设置为私网地址，如果设置为公网地址，假设某天您访问的某个网站的IP和你设置的一样可能导致您访问不了。</strong></p><ul><li>REDIRECT转发</li></ul><p>可用于PREROUTING、 OUTPUT链上。通过改变目标IP和端口，将接受的包转发至不同地址</p><pre><code>--to-ports port[-port]</code></pre><p><code>[root@localhost~]#iptables -t nat -A PREROUTING -d 192.168.4.55 -p tcp --dport 80 -j REDIRECT --to-ports 8000</code></p><p>实现多端口转发</p><p><code>[root@localhost~]#iptables -t nat -A PREROUTING -d 192.168.4.55 -p tcp -m multiport –dports 1234,9527,8000 -j REDIRECT –to-ports 80</code></p>]]></content>
      
      
      <categories>
          
          <category> 防火墙 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统安装</title>
      <link href="/2017/11/28/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
      <url>/2017/11/28/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>为什么我们要自动化安装系统呢？管理一些重复性的操作呢，这样可以减轻自己的操作，并且提高了工作效率，假如公司中又有十几台甚至更多的服务器，不可能自己一台一台的安装，这样就需要自动化安装。</p><h2 id="一、光盘内容简介"><a href="#一、光盘内容简介" class="headerlink" title="一、光盘内容简介"></a>一、光盘内容简介</h2><h3 id="1、CentOS系统的启动流程"><a href="#1、CentOS系统的启动流程" class="headerlink" title="1、CentOS系统的启动流程"></a>1、CentOS系统的启动流程</h3><p>POST–&gt;boot Sequence–&gt;bootloader(MBR)–&gt;kernel(initramdisk)–&gt;rootfs–&gt;/sbin/init/</p><h3 id="2、光盘内容"><a href="#2、光盘内容" class="headerlink" title="2、光盘内容"></a>2、光盘内容</h3><p>（1）<code>[root@centos7/media/cdrom/isolinux]#ls</code></p><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>boot.cat</td><td>相当于启动菜单显示内容 </td></tr><tr><td>grub.conf</td><td>启动系统启动与boot.cat显示内容配置文件</td></tr><tr><td>isolinux.bin</td><td>相当于系统安装的stage2阶段</td></tr><tr><td>memtest</td><td>内存检测，这是个独立程序</td></tr><tr><td>vmlinuz</td><td>内核映像</td></tr><tr><td>boot.msg</td></tr><tr><td>initrd.img</td><td>虚拟文件系统 </td></tr><tr><td>isolinux.cfg</td><td>isolinux.cat的配置文件</td></tr><tr><td>splash.png</td><td>背景图片</td></tr><tr><td>vesamenu.c32</td><td>显示背景界面</td></tr></tbody></table><p>（2）isolinux.cfg详解</p><pre><code>default vesamenu.c32      #支持菜单功能timeout 600    #菜单倒计时，十分之算display boot.msg    #显示一条信息# Clear the screen when exiting the menu, instead of leaving the menu displayed.# For vesamenu, this means the graphical background is still displayed without# the menu itself for as long as the screen remains in graphics mode.menu clear  #清除菜单选项menu background splash.png  #显示背景图片menu title CentOS Linux 7   #显示titlemenu vshift 8   menu rows 18menu margin 8#menu hidden    menu helpmsgrow 15# Border Areamenu color border * #00000000 #00000000 none# Selected itemmenu color sel 0 #ffffffff #00000000 none# Title barmenu color title 0 #ff7ba3d0 #00000000 none# Press [Tab] messagemenu color tabmsg 0 #ff3a6496 #00000000 none# Unselected menu itemmenu color unsel 0 #84b8ffff #00000000 none# Unselected hotkeymenu color hotkey 0 #ffffffff #00000000 none# Help textmenu color help 0 #ffffffff #00000000 none# A scrollbar of some type? Not sure.menu color scrollbar 0 #ffffffff #ff355594 none# Timeout msgmenu color timeout 0 #ffffffff #00000000 nonemenu color timeout_msg 0 #ffffffff #00000000 none# Command prompt textmenu tabmsg Press Tab for full configuration options on menu items.     #键入TAB进入配置模式menu separator # insert an empty linemenu separator # insert an empty linelabel linux     #相当于标签  menu label ^Install CentOS Linux 7        #安装linux  kernel vmlinuz    #内核文件  append initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 quiet     #向内核传递参数label check  menu label Test this ^media &amp; install CentOS Linux 7  menu default      #默认启动项  kernel vmlinuzmenu separator # insert an empty line# utilities submenumenu begin ^Troubleshooting  menu title Troubleshootinglabel vesa  menu indent count 5  menu label Install CentOS Linux 7 in ^basic graphics mode  text help        Try this option out if you&#39;re having trouble installing        CentOS Linux 7.  endtext  kernel vmlinuz  append initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 xdriver=vesa nomodeset quietlabel rescue  menu indent count 5  menu label ^Rescue a CentOS Linux system  text help        If the system will not boot, this lets you access files        and edit config files to try to get it booting again.  endtext  kernel vmlinuz  append initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rescue quietlabel memtest  menu label Run a ^memory test  text help        If your system is having issues, a problem with your        system&#39;s memory may be the cause. Use this utility to        see if the memory is working correctly.  endtext  kernel memtestmenu separator # insert an empty linelabel local  menu label Boot from ^local drive  localboot 0xffffmenu separator # insert an empty linemenu separator # insert an empty linelabel returntomain  menu label Return to ^main menu  menu exitmenu end</code></pre><p>配置文件中有“^”相当于快捷键。</p><h3 id="3、anaconda程序"><a href="#3、anaconda程序" class="headerlink" title="3、anaconda程序"></a>3、anaconda程序</h3><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><pre><code>anaconda是系统安装程序。启动系统安装过程。</code></pre><h4 id="（2）anaconda安装过程"><a href="#（2）anaconda安装过程" class="headerlink" title="（2）anaconda安装过程"></a>（2）anaconda安装过程</h4><p>anaconda安装分为三个阶段：</p><p>（a）安装前配置阶段</p><pre><code>安装过程使用的语言键盘类型安装目标存储设备    basic storage 本地磁盘    特殊设备 iscsI设定主机名配置网络接口时区设置管理员密码设定分区方式及MBR的安装位置创建一个普通用户选定要安装的程序包</code></pre><p>（b）安装阶段在目标磁盘</p><pre><code>创建分区，执行格式化操作等选定的程序包安装至目标位置安装BootLoader和initramfs</code></pre><p>（c）图形模式首次启动</p><pre><code>iptablesselinuxcore dump</code></pre><h4 id="（3）安装程序包的选择"><a href="#（3）安装程序包的选择" class="headerlink" title="（3）安装程序包的选择"></a>（3）安装程序包的选择</h4><pre><code>（a）本地光盘（b）本地硬盘（c）NFS（d）URL    ftp server :yum repository    http server:yum repository（e）手动指定安装源    在系统启动选项菜单界面进入TAB键，进入boot命令行模式输入`linux askmethod`，如果需要网络后续会跳出来一个对话框填入IP即可。</code></pre><h4 id="（4）anaconda配置方式"><a href="#（4）anaconda配置方式" class="headerlink" title="（4）anaconda配置方式"></a>（4）anaconda配置方式</h4><pre><code>（a）交互式配置（b）通过读取事先给定的配置文件自动完成配置（kickstart文件）</code></pre><h3 id="4、kickstart文件"><a href="#4、kickstart文件" class="headerlink" title="4、kickstart文件"></a>4、kickstart文件</h3><h4 id="（1）配置文件详解"><a href="#（1）配置文件详解" class="headerlink" title="（1）配置文件详解"></a>（1）配置文件详解</h4><pre><code>#version=DEVEL  #指明版本# System authorization information   auth --enableshadow --passalgo=sha512 # Install OS instead of upgradeinstall# Use text installtext# Firewall configurationfirewall --disabledfirstboot --disableignoredisk --only-use=sda# Keyboard layoutskeyboard --vckeymap=cn --xlayouts=&#39;cn&#39;# System languagelang en_US.UTF-8# Use network installation#url --url=&quot;http://172.16.0.1/cblr/links/CentOS-7-1511-x86_64&quot;#repo --name=&quot;source-1&quot; --baseurl=http://172.16.0.1/cobbler/ks_mirror/CentOS-7-1511-x86_64#url --url=&quot;http://172.16.0.1/cobbler/ks_mirror/7/&quot;url --url=$tree# Network informationnetwork  --bootproto=dhcp --device=ens33 --onboot=yes  --ipv6=autonetwork  --hostname=localhost.localdomain# Reboot after installationreboot# SELinux configurationselinux --disabled# Do not configure the X Window Systemskipx# Root passwordrootpw --iscrypted $6$dGARWYghrvhD9W7P$4af2uw8A4tHvNLe2F6bDrk0J69dt.uYoV4SneKG4kzIsc/nF3JpfnuHg7D5lVE.jxC3p6.K29FCjwtom9VXWf.# System timezonetimezone Asia/Shanghaiuser --groups=wheel --name=wang --password=$6$S0t9SxXkvSI0Npz5$YDVonz69YGGGkGyZDy/KesO4CI1HUBLNThcHj6PXDntQGS0Cl0SNpN6zGASuzYE.z5veu1XAzMvO4xLWbKE.n0 --iscrypted --gecos=&quot;123456&quot;# System bootloader configurationbootloader --location=mbr --boot-drive=sda# Partition clearing informationclearpart --all --initlabel# Disk partitioning informationpart /boot --fstype=&quot;xfs&quot; --ondisk=sda --size=500part swap --fstype=&quot;swap&quot; --ondisk=sda --size=2049part / --fstype=&quot;xfs&quot; --ondisk=sda --size=40960part /app --fstype=&quot;xfs&quot; --ondisk=sda --size=20480%postsystemctl set-default multi-user.target[ ! -d /root/.ssh ] &amp;&amp; mkdir /root/.ssh &amp;&amp; chmod og=--- /root/.sshcat &gt;&gt; /root/.ssh/authorized_keys &lt;&lt; EOFssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAlmq1z0G/7wbGuSUewfXlFnwzqCg/myqTi/AwP8LP+JJ49xzIKMzpeWXHD8RWIf5RlDzo+6N7uPK5O22x/QtMosi0egz4shavEJeUkO0EH+KygXXgBIGuMWmAsL+yzbgWXT9H3zdzXi/qWcrBeBv2nYB5mpYSf7o0xqdhCst1MTfcYLD8qxvkwC8RiqBA/1u9N6jeDFbHO+UzZYYCr9zgk9uz4Rrhb9BU7c1GhjUCgRwBDAuo47IHw/OT6KS9lb8lT2R/ujVoDARy/eOhw8cAFXo+QcvzNSW2qKf/Qo21uR/wz2u9SRV0lvUDNSvC2PYtR+iPlDwHY81md430yiNf9w== root@172.16.0.1EOFClientName=`ifconfig enoens33 | awk &#39;/inet\&gt;/{print $2}&#39; | awk -F. &#39;{print $NF}&#39;`hostnamectl set-hostname &quot;stu$ClientName.wang.com&quot;#mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak#wget http://172.18.0.1/repos/CentOS-Base.repo -O /etc/yum.repos.d/CentOS-Base.repo%end%packages@base@core@fonts@input-methods@kde-apps@kde-desktop@network-file-system-client@networkmanager-submodules@x11lftpscreen%end%addon com_redhat_kdump --disable --reserve-mb=&#39;auto&#39;%end</code></pre><h4 id="（2）kickstart文件格式"><a href="#（2）kickstart文件格式" class="headerlink" title="（2）kickstart文件格式"></a>（2）kickstart文件格式</h4><p>（a）命令端：指明各种安装前配置，如果键盘类型，时区等<br>    必备命令<br>        authconfig：认证方式配置<br>            authconfig –useshadow –passalgo=sha512<br>        bootloader:bootloader的安装位置及相关配置<br>            bootloader –location=mbr –driverorder=sda –append=“crashkernel=auto rhgb quiet”<br>        keyboard：设定键盘类型<br>        lang：语言类型<br>        part：创建分区<br>        rootpw：指明root的密码<br>        timezone：时区<br>    可选命令<br>        install OR update<br>        text :文本界面安装<br>        network 设定网络<br>        firewall 设置防火墙<br>        selinux 设置selinux<br>        halt<br>        poweroff<br>        reboot<br>        repo<br>        user：安装完成后为系统创建新用户<br>        url：指明安装源<br>        key -skip：跳过安装号码，适用于rhel版本</p><p>（b）程序包段：指明要安装的程序包或程序包组，不安装的包等</p><pre><code>%packages #表明开始安装程序包或包组@group_name #安装包组package #安装程序包-package #不安装程序包%end 指明安装结束</code></pre><p>（c）脚本段：指明运行的脚本</p><pre><code>%pre #安装前脚本    运行环境：运行于安装介质上的微型linux环境%post   #安装后脚本    运行环境：运行于安装完成后的系统</code></pre><p><strong>注意：在每段中一定要有开始有结束%end表明结束安装。</strong></p><h4 id="（3）kickstart文件创建方式"><a href="#（3）kickstart文件创建方式" class="headerlink" title="（3）kickstart文件创建方式"></a>（3）kickstart文件创建方式</h4><p>（a）直接手动编辑，可以依赖模板进行自行修改</p><p>（b）可使用创建工具：system-config-kickstart命令，依赖某模板修改并生成新的配置文件<br><strong>注意：在CentOS7中，如果要使用此命令必须把yum仓库光盘的名称修改为development。</strong><br>    检查ks文件的语法错误：ksvalidator<br>        格式：ksvalidator /PATH/TO/SOMEFILE</p><h4 id="（4）指明kickstart位置"><a href="#（4）指明kickstart位置" class="headerlink" title="（4）指明kickstart位置"></a>（4）指明kickstart位置</h4><pre><code>DVD drive:ks=cdrom:/PATH/TO/KICKSTART_FILEHard drive:ks=hd:/PATH/TO/KICKSTART_FILEFTP server:ks=ftp://host:port/PATH/TO/KICKSTART_FILEHTTP server:ks=http://host:port/PATH/TO/KICKSTART_FILEHTTPS server:ks=https://host:port/PATH/TO/KICKSTART_FILENFS server:ks=nfs:host:/PATH/TO/KICKSTART_FILE</code></pre><p>如果想理解更多，请查考详细内容《Installation Guide》。</p><h4 id="（5）系统启动的不同方式"><a href="#（5）系统启动的不同方式" class="headerlink" title="（5）系统启动的不同方式"></a>（5）系统启动的不同方式</h4><p>（a）text：文本安装模式</p><p>（b）askmethod：手动指定安装方法<br>    在系统启动界面，键入ESC进入boot命令行模式：输入linux askmethod<br>    与网络相关的引导选项：<br>        ip=IPADDR<br>        netmask=NETMAKS<br>        gateway=GATEWAY<br>        dns=DNS_SERVER_IP<br>        ifname=NAME:MAC_ADDR<br>（c）与远程功能相关的引导选项<br>    vns<br>    vncpassword=“PASSWORD”</p><p><strong>实战</strong></p><p>手动指定kickstart文件安装系统</p><p>方式一：</p><p>（1）在CentOS7上搭建ftp服务</p><p><code>[root@centos7~]#cd /var/ftp/pub/</code><br><code>[root@centos7/var/ftp/pub]#cp /root/ks*.cfg .</code><br><code>[root@centos7/var/ftp/pub]#ls</code></p><pre><code>ks6.cfg  ks7.cfg</code></pre><p>（2）创建一块虚拟机</p><p>（3）手动指定按启动，选定光盘启动</p><p><img src="http://owatlfstl.bkt.clouddn.com/2017-09-15_183233.png" alt=""><br>当出现上面图示时，我们手动指定kickstart启动。</p><p>方法一：<br>按TAB键，输入ks=ftp://192.168.4.135/pub/ks6.cfg；回车启动<br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-15_183559.png" alt=""><br>方法二：<br>按ESC键进入boot命令行，输入linux ks=ftp://192.168.4.135/pub/ks6.cfg</p><p>方式二：</p><p>在CentOS7搭建http服务</p><p><code>[root@centos7/var/www/html]#mkdir ks</code><br><code>[root@centos7/var/www/html]#mv ks*.cfg ks</code></p><p>其余步骤同上述方法类似。</p><p><strong>注意：上述过程必须使ks文件权限为644.上述方法前提为桥接模式。</strong></p><p>上述方法是没有办法安装包等后续工作的，我们可以搭建网络yum源进行安装。</p><p>方式一：创建网络yum源安装</p><p>（1）安装vsftpd服务，并启动服务</p><p>（2）将ks7.cfg文件复制到    <code>/var/ftp/pub</code>目录下</p><p>（3）在<code>/var/ftp/pub</code>目录下创建centos/7</p><p><code>[root@centos7/var/ftp/pub]#mkdir centos/7 -pv</code></p><p>（4）将光盘挂载到centos/7上</p><p><code>[root@centos7/var/ftp/pub]#mount  /dev/sr0 /var/ftp/pub/centos/7/</code><br>（5）测试是否能在网页中打开</p><p>输入地址ftp://192.168.4.135/pub<br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-15_192911.png" alt=""></p><p>（6）新建一台虚拟机测试</p><p>按ESC键进入boot命令行，输入linux ks=ftp://192.168.4.135/pub/ks6.cfg  ip=192.168.4.138 netmask=255.255.255.0</p><p>或<br>按TAB键在行后追加<br>ks=ftp://192.168.4.135/pub/ks6.cfg  ip=192.168.4.138 netmask=255.255.255.0</p><p>（7）出现下面说明成功<br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-15_193257.png" alt=""></p><p>方式二：</p><p>（1）在CentOS7上搭建http服务</p><p>（2）在<code>/var/www/html</code>目录下创建ks目录和centos/7目录</p><p><code>[root@centos7/var/www/html]#mkdir testcentos/7 -pv</code></p><p>（3）将光盘挂载至centos/7目录下<br><code>[root@centos7/var/www/html]#mount /dev/sr0 testcentos/7/</code></p><p>（4）重启服务测试<br>在网站输入<a href="http://192.168.4.135/test" target="_blank" rel="noopener">http://192.168.4.135/test</a><br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-15_194000.png" alt=""><br>（5）新建一台虚拟机重新测试，出现下面内容说明成功</p><p>按ESC键进入boot命令行，输入linux ks=ftp://192.168.4.135/pub/ks7.cfg  ip=192.168.4.138 netmask=255.255.255.0</p><p>或</p><p>按TAB键在行后追加<br>ks=ftp://192.168.4.135/pub/ks7.cfg  ip=192.168.4.138 netmask=255.255.255.0<br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-15_193257.png" alt=""></p><h2 id="二、制作光盘或U盘"><a href="#二、制作光盘或U盘" class="headerlink" title="二、制作光盘或U盘"></a>二、制作光盘或U盘</h2><p>在日常的生产活动中，使用光驱的已经很少了，但是U盘自身的特点得到了大多数人的使用，这样让我掌握如何制作U盘变得特别重要，如果我们公司有的服务器没有光盘咋办，？U盘就很好的帮我们解决了这个问题。</p><h3 id="1、如何制作光盘"><a href="#1、如何制作光盘" class="headerlink" title="1、如何制作光盘"></a>1、如何制作光盘</h3><p>（1）mkisofs命令有关包genisoimage<br>制作光盘需要使用命令才能执行。</p><p>|<br>|选项|解释|<br>|-o|指定影响文件的名称|<br>|-b|指定在制作可开机光盘是所需要的开机映像文件|<br>|-c|制作可开机光盘时，会将开机映像文件中的no-eltorito-catalog全部内容做成一个文件|<br>|-no-emul-boot|非模拟模式启动|<br>|-boot-load-size 4|设置载入部分的数量|<br>|-boot-info-table|在启动的图像中显示信息|<br>|-R，-rock|使用Rock RidgeExtensions|<br>|-J，-joliet|使用Joliet格式的目录与文件名称|<br>|-v，-verbose|执行时显示过程|<br>|-T，-translation-table|建立文件名的装换表，适用于不支持Rock RidgeExtensions的系统上|</p><p>（2）制作光盘过程</p><p>（a）在CentOS7主机上搭建yum源，并绑定到ftp服务上。</p><p>（b）创建光盘引导文件</p><p><code>[root@centos7~]#mkdir /tmp/testiso</code><br><code>[root@centos7~]#mkdir /tmp/testiso/isolinux</code><br><code>[root@centos7~]#cp /media/cdrom/isolinux/* /tmp/testiso/isolinux</code><br><code>[root@centos7/tmp/testiso]#cp /var/ftp/pub/ks7.cfg .</code><br><code>[root@centos7/tmp/testiso]#vim ks7.cfg</code> #编辑配置文件<br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-15_200110.png" alt=""><br><code>[root@centos7/tmp/testiso]#tree</code></p><pre><code>.├── isolinux│   ├── boot.cat│   ├── boot.msg│   ├── grub.conf│   ├── initrd.img│   ├── isolinux.bin│   ├── isolinux.cfg│   ├── memtest│   ├── splash.png│   ├── TRANS.TBL│   ├── vesamenu.c32│   └── vmlinuz└── ks7.cfg</code></pre><p><strong>注意：此处创建使用的是相对路径，而和工作目录无关。必须在isolinux下。</strong></p><p>（c）创建光盘<br><code>[root@centos7/tmp]#mkisofs -R -J -T -v --no-emul-boot --boot-load-size 4 --boot-info-table -V &quot;CentOS 6.9 x86_64 boot&quot; -b isolinux/isolinux.bin -c isolinux/boot.cat -o /root/boot.iso myiso/</code></p><p>（d）将光盘下载至本机，安装到虚拟中尝试启动<br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-15_202146.png" alt=""></p><p>说明我们制作的光盘成功</p><p>（3）制作U盘</p><p>（a）我们这里虚拟一块U盘，添加一块硬盘</p><p>（b）将光盘拷贝至硬盘中</p><p><code>[root@centos7~]#dd if=boot.iso of=/dev/sdb</code></p><p>（c）新建虚拟机挂载此光盘启动<br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-15_202146.png" alt=""><br>出现上述情况说明我们安装成功。但是这种方法还需要通过网络才能安装，如果我们去到一个地方没有网络，怎么办呢？有没有想过我们把rpm包到拷贝至一个U盘或光盘上呢？这样是不是很方便我们办公呢？</p><h3 id="（4）制作完整的光盘和U盘"><a href="#（4）制作完整的光盘和U盘" class="headerlink" title="（4）制作完整的光盘和U盘"></a>（4）制作完整的光盘和U盘</h3><p>（a）创建一个临时目录并拷贝文件至此目录下<br><code>[root@localhost ~]#mkdir /tmp/fulliso</code><br><code>[root@localhost ~]# cp -a /media/cdrom/* /tmp/fulliso/</code><br><code>[root@localhost ~]# cd /tmp/fulliso/</code><br><code>[root@localhost fulliso]# cp /media/cdrom/.treeinfo .</code><br><code>[root@localhost fulliso]# cp /media/cdrom/.discinfo .</code></p><p>（b) 删除repodate目录非<em>comps.xml结尾的文件。<br>`[root@localhost fulliso]# find repodata/ -not -name </em>-comps.xml -delete<code>`[root@localhost fulliso]# find -name TRANS.TBL -delete</code></p><p>（c）以上述那个文件制作仓库<br><code>[root@localhost fulliso]# ls repodata/d918936f5019be3fb66e9981a28cb2a41477a2963d741d454f79377a22214f43-c7-x86_64-comps.xml</code></p><p>（d）编辑kickstart配置文件，并复制fulliso目录下<br><code>[root@localhost fulliso]# vim ks7.cfg</code></p><pre><code>auth --enableshadow --passalgo=sha512# Use graphical installgraphical# Run the Setup Agent on first bootfirstboot --enableignoredisk --only-use=sda# Keyboard layoutskeyboard --vckeymap=us --xlayouts=&#39;us&#39;# System languagelang en_US.UTF-8# Network informationnetwork  --bootproto=dhcp --device=ens33 --onboot=on --ipv6=auto network  --hostname=localhost.localdomain# Root password# System servicesservices --disabled=&quot;chronyd&quot;# System timezonetimezone Asia/Shanghai# X Window System configuration informationxconfig  --startxonboot# System bootloader configurationbootloader --append=&quot; crashkernel=auto&quot; --location=mbr --boot-drive=sdazerombrreboot# Partition clearing informationclearpart --allpart /boot --fstype=&quot;xfs&quot; --ondisk=sda --size=1024part swap --fstype=&quot;swap&quot; --ondisk=sda --size=2048part / --fstype=&quot;xfs&quot; --ondisk=sda --size=50000part /app --fstype=&quot;xfs&quot; --ondisk=sda --size=50000%packages@^gnome-desktop-environment@base@core@desktop-debugging@dial-up@directory-client@fonts@gnome-desktop@guest-agents@guest-desktop-agents@input-methods@internet-browser@java-platform@multimedia@network-file-system-client@networkmanager-submodules@print-client@x11kexec-toolsautofslftpdhcpvsftpd%end%post#Create repomkdir /media/cdrommkdir /etc/yum.repos.d/bakmv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bakcat &gt; /etc/yum.repos.d/base &lt;&lt;EOF[base]name=centos 7baseurl=file:///media/cdromgpgcheck=0enabled=1EOFcat &gt;&gt; /etc/fstab &lt;&lt; EOF/dev/sr0        /media/cdrom    iso9660 defaults 0 0cat &gt;&gt; /root/.bashrc &lt;&lt; EOFalias cdnet=&quot;cd /etc/sysconfig/network-scripts/&quot;EOFcat &gt;&gt; /etc/profile.d/env.shexport PS1=&#39;\[\e[31m\][\u@\h\w]\$\[\e[0m\]&#39;EOFsed -i &#39;s/quiet/&amp; net.ifnames=0/&#39; /etc/default/grubgrub2-config -o /boot/grub2/grub.cfg%end</code></pre><p>（e）编辑isolinux.cfg文件<br><code>[root@localhost fulliso]# vim isolinux/isolinux.cfg</code></p><pre><code>default vesamenu.c32timeout 600display boot.msg# Clear the screen when exiting the menu, instead of leaving the menu displayed.# For vesamenu, this means the graphical background is still displayed without# the menu itself for as long as the screen remains in graphics mode.menu clearmenu background splash.pngmenu title CentOS Linux 7menu vshift 8menu rows 18menu margin 8#menu hiddenmenu helpmsgrow 15menu tabmsgrow 13# Border Area# Selected itemmenu color sel 0 #ffffffff #00000000 none# Title barmenu color title 0 #ff7ba3d0 #00000000 none# Press [Tab] messagemenu color tabmsg 0 #ff3a6496 #00000000 none# Unselected menu itemmenu color unsel 0 #84b8ffff #00000000 none# Selected hotkeymenu color hotsel 0 #84b8ffff #00000000 none# Unselected hotkeymenu color hotkey 0 #ffffffff #00000000 none# Help textmenu color help 0 #ffffffff #00000000 none# A scrollbar of some type? Not sure.menu color scrollbar 0 #ffffffff #ff355594 none# Timeout msgmenu color timeout 0 #ffffffff #00000000 nonemenu color timeout_msg 0 #ffffffff #00000000 none# Command prompt textmenu color cmdmark 0 #84b8ffff #00000000 nonemenu color cmdline 0 #ffffffff #00000000 none# Do not display the actual menu unless the user presses a key. All that is displayed is a timeout message.menu tabmsg Press Tab for full configuration options on menu items.menu separator # insert an empty linemenu separator # insert an empty linelabel desktop  menu label desktop Linux 7  kernel vmlinuz  append initrd=initrd.img ks=cdrom:/ks7.cfglabel mini  menu label mini linux 7  menu default  kernel vmlinuz  append initrd=initrd.img ks=cdrom:/ks7mini.cfgmenu end</code></pre><p>（f）制作光盘<br><code>[root@localhost ~]# mkisofs -R -T -J -v --no-emul-boot --boot-load-size 4 --boot-info-table -V &quot;CentOS 7 custom&quot; -b isolinux/isolinux.bin -c isolinux/boot.cat -o /root/centos7.iso /tmp/fulliso/</code></p><p>（g）测试是否可成功,新建一台虚拟机，测试<br><img src="http://owatlfstl.bkt.clouddn.com/2017-09-17_171832.png" alt=""><br>出现上述界面，表明制作光盘已经成功。</p>]]></content>
      
      
      <categories>
          
          <category> 自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统安装 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
