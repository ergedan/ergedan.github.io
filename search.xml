<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HAproxy]]></title>
    <url>%2F2017%2F11%2F29%2FHAproxy%2F</url>
    <content type="text"><![CDATA[一、HAProxyHAProxy（High Available Proxy）是基于四层和七层的高可用负载均衡代理服务器，对客户端10000以上的同时连接的高性能的TCP和HTTP负载均衡器。 1、HAProxy功能 TCP/HTTP反向代理服务器，尤其适合于高可用性环境 可以针对HTTP请求添加cookie，进行路由后端服务器 可平衡负载至后端服务器，并支持持久连接 支持基于cookie进行调度 支持所有主服务器故障切换至备用服务器 支持专用端口实现监控服务 支持不影响现有连接情况下停止接受新连接请求 可以在双向添加、修改或删除HTTP报文首部 支持基于PATTERN实现连接请求的访问控制 通过特定的URI为授权用户提供详细的状态信息 2、HAProxy工作原理 HAProxy和lvs的工作类似，只不过是在名称上有所改变。 HAProxy由前段（frontend）和后端（backend）过程，前后端都可以有多个，并且可以实现交叉调度。如果前段和后端是一对一的情况可以使用listen来实现。frontend区域根据Client的请求调度到backend服务器上。不过frontend可以根据HTTP请求的header信息来定义一些规则，将符合规则的请求转发至backend服务器上去。 3、HAProxy安装及配置文件详解[root@localhost~]#yum install -y haproxy HAProxy主配置文件 /etc/haproxy/haproxy.cfg 定义错误页面文件 /usr/share/haproxy/400.http /usr/share/haproxy/403.http /usr/share/haproxy/408.http /usr/share/haproxy/500.http /usr/share/haproxy/502.http /usr/share/haproxy/503.http /usr/share/haproxy/504.http /etc/haproxy/haproxy.cfg配置文件详解配置段- global：全局配置段 定义进程及安全配置相关的参数 性能调整相关参数 debug参数 proxies：代理配置段 default：为frontend、backend、listen提供默认配置 frontend：定义一组接受客户端侦听的套接字连接 backend：定义代理将连接的一组服务器转发连接 listen：同时拥有前后端，适用于一对一环境；通常用于TCP中。 配置指令详解- global配置参数 nbproc ：要启动的haproxy的进程数量，系统默认单进程，要求使用daemon模式 ulimit-n：每个haproxy进程可打开的最大文件数，系统自动会自定，不建议设置 daemon：后端方式运行，建议使用 log：定义全局syslog服务器；最多可以定义两个 格式： log &lt;address&gt; [len &lt;length&gt;] &lt;facility&gt; [max level [min level]] &lt;address&gt;：日志服务器地址 [len &lt;length&gt;]：最大长度，默认1024 &lt;facility&gt;：日志设施 [max level [min level]]：指定日志级别 no log 不启用日志 log global 如果需要使用日志，引用global日志 log-format ：定义日志格式 示例： （1）配置日志服务器 [root@log~]#yum install -y mariadb-server #安装数据库 [root@log~]#systemctl restart mariadb.service [root@log~]#systemctl enable mariadb.service #设置为开机启动 [root@log~]#yum install -y rsyslog-mysql #安装基于mysql的模块 [root@log~]#mysql -uroot -p &lt; /usr/share/doc/rsyslog-8.24.0/mysql-createDB.sql #创建日志数据库 MariaDB [(none)]&gt; GRANT ALL ON Syslog.* TO joah@&apos;192.168.4.65&apos; IDENTIFIED BY &apos;123456&apos;; #授权用户 74 local2.* :ommysql:192.168.4.65,Syslog,joah,123456 将特定信息记录在日志中 capture cookie len ：捕获请求和响应报文中的cookie并记录日志 capture request header len ：捕获请求报文中指定的首部并记录日志 capture response header len ：捕获响应报文中的首部并记录日志 示例：[root@haproxy/etc/haproxy]#vim haproxy.cfg [root@node1~]#vim /etc/httpd/conf/httpd.conf 重启服务测试 [root@client~]#curl http://172.18.4.62 node1 上述的定义均需在httpd.conf选项Log_Format中定义 ：例如{X-Forwarded-For} 如果有多个需要使用“|”分隔。- 性能优化指令 maxconn ：设定每个haproxy进程所能接受的最大并发连接数 maxconnrate ：设置每个进程每秒种所能建立的最大连接数量 maxsessrate：设置每个进程每秒钟所能建立的最大会话数量；一个连接里面可以有多个会话 maxsslconn ：每个进程支持SSL的最大连接数量 spread-checks ：健康监测延迟时长比；建议2-5之间，默认为0 配置段 defaults ：默认配置段 frontend ：指定接受客户端连接侦听套接字设置 backend ：指定将连接请求转发至后端服务器的相关设置 listen ：指定完整前后端设置，只对TCP有效，只有前后端一对一时使用。 bind：指定一个或多个前段侦听地址和端口 格式： bind [&lt;address&gt;]:&lt;port_range&gt; [, ...] [param*] bind /&lt;path&gt; [, ...] [param*] [param*]常用选项 user：设置用户 mode：设置权限 accept-proxy：接受代理 示例： [root@haproxy/etc/haproxy]#vim haproxy.cfg 68 frontend web 69 bind 172.18.4.62:80 70 default_backend websrvs balance配置 balance：后端服务器组内调度算法 格式： balance &lt;algorithm&gt; [ &lt;arguments&gt; ] balance url_param &lt;param&gt; [check_post] \类型 roundrobin：基于权重轮询，动态算法，支持权重的运行时调整，支持慢启动；每个后端backend中最多支持4095个server static-rr：基于权重轮询，静态算法，不支持权重的运行时调整及慢启动；后端主机数量无上限 leastconn：加权最少连接，动态算法，最少连接的后端服务器优先分配接受新连接，相同连接时轮询；推荐在较长会话场景使用，如mysql、LDAP等 first：根据服务器中列表中的位置，自上而下进行调度；前面服务器的连接数达到上限，新请求才会分配给下一台服务器 source：源地址hash，新连接先按权重分配，后续连接按source分配请求 uri：对于URI的左半部分或整个URI做hash计算，并除以服务器总权重取模，以后派发至挑出的服务器，仅适用于后端缓存服务器；只要会话是同一个URI则一直访问同一台服务器 示例： &lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt; 左半部分：/&lt;path&gt;;&lt;params&gt; 整个URI：/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt; url_param：对用于请求的URI听&lt;params&gt;部分中的参数的值做hash计算，并由服务器总权重相除以后派发至某挑选的服务器；通常用于追踪用户，以确保俩字同一个用户的请求始终发往同一个backend server hadr （&lt;name&gt;）：对于每个http请求，此处由&lt;name&gt;指定的http首部将会被取出做hash计算；并由服务器总权重相除以后派发至某跳出的服务器；无有效值的会被轮询调度 rdp-cookie：远程桌面相关 hash-type：哈希算法 格式： hash-type &lt;method&gt; &lt;function&gt; &lt;modifier&gt; \ map-based：除权取余法，哈希数据结构时静态数组 consistent：一致性哈希，哈希数据结构是一棵树 default_backend：无use_backend匹配时，使用默认的backend，用于frontend中 格式： default_backend &lt;backend&gt; default-server ：backend中的各server设定默认选项 格式： default-server [param*] 示例： default_backend websrvs server ：定义后端服务器机器选项 格式： server &lt;name&gt; &lt;address&gt;[:[port]] [param*] &lt;name&gt;：服务器在haproxy上的内部名称；出现在日志及警告信息 &lt;address&gt;：服务器地址，支持使用主机名 [:[port]]：端口映射；省略时表示同bind中绑定的端口 [param*]：定义参数 weight &lt;weight&gt;：权重，默认为1 maxconn&lt;maxconn&gt;：当前server的最大并发连接数 backlog&lt;backlog&gt;：当server的连接数达到上限后的后援队列长度 backup：设定当前server为备用服务器 check：对当前server做健康状态检测，只用于四层检测;注意：httpchk、smtpchk、mysql-check、pgsql-check和ssl-hello-chk用于定义应用层检测方法 addr：针对此IP地址 port：针对此端口进行检测 inter &lt;delay&gt;：连续两次检测之间的时间间隔，默认为2000ms rise &lt;conunt&gt;：连续多少次检测结果为“成功”才标记服务器为可用；默认为2 fall &lt;count&gt;：连续多少次检测结果为“失败”才标记位不可用；默认为3 cookie &lt;value&gt;：为当前server指定cookie值，实现基于cookie的会话粘性 disabled：标记位不可用；用于服务器维护，更换 redir &lt;prefix&gt;：将发往此server的所有GET和HEAD类的请求重定向到指定的URL 示例： [root@haproxy/etc/haproxy]#vim haproxy.cfg 73 backend websrvs 74 balance roundrobin 75 server srv1 192.168.4.63:80 check weight 1 addr 192.168.4.163 port 80 inter 3000 rise 2 fall 3 76 server srv2 192.168.4.64:80 check disabled 重启服务测试 [root@client~]#curl http://172.18.4.62 node1 [root@client~]#curl http://172.18.4.62 node1 通过上述测试出的结果只能调度到node1中。接下来把192.168.4.163 down掉 [root@client~]#curl http://172.18.4.62 &lt;html&gt;&lt;body&gt;&lt;h1&gt;503 Service Unavailable&lt;/h1&gt; No server is available to handle this request. &lt;/body&gt;&lt;/html&gt; [root@client~]#curl http://172.18.4.62 &lt;html&gt;&lt;body&gt;&lt;h1&gt;503 Service Unavailable&lt;/h1&gt; No server is available to handle this request. &lt;/body&gt;&lt;/html&gt; 此时再次测试访问不到页面出现503错误 cookie配置 cookie：基于cookie长连接用于backend 格式： cookie &lt;name&gt; [ rewrite | insert | prefix ] [ indirect ] [ nocache ] [ postonly ] [ preserve ] [ httponly ] [ secure ] [ domain &lt;domain&gt; ]* [ maxidle &lt;idle&gt; ] [ maxlife &lt;life&gt; ] &lt;name&gt;：cookie名称，用于实现持久连接 rewrite：重写 insert：插入 prefix：前缀 示例：基于cookie的session sticky的实现 [root@haproxy/etc/haproxy]#vim haproxy.cfg 73 backend websrvs 74 balance roundrobin 75 cookie SRV insert nocache indirect 76 server srv1 192.168.4.63:80 check weight 2 cookie service1 77 server srv2 192.168.4.64:80 check cookie service2 统计接口启用相关参数- stats enable：启动统计也；基于默认的参数启动stats page 默认设置 stats uri：/ haproxy？stats stats realm：“HAProxy Statistics” stats auth：no authentication stats scope：no restriction stats uri ：自定义stats page URI stats auth :：认证账户和密码，可定义多个 stats realm ：认证时的提示信息 stats hide-version：隐藏版本 stats refresh ：设定自动刷新时间间隔 stats admin {if|unless} ：启用stats page中管理功能，如果stats auth认证成功才可以启用管理功能 示例： [root@haproxy/etc/haproxy]#vim haproxy.cfg 73 listen stats 74 bind 192.168.4.62:9000 75 stats enable 76 stats uri /hastats 77 stats auth ha1:123456 78 stats realm &quot;testhaproxy&quot; 79 stats hide-version 80 stats refresh 2s 81 stats admin if TRUE 重启服务 工作模式 maxconn ：为指定的frontend定义其最大并发连接数，默认为2000 mode {tcp|http|health}：定义haproxy工作模式 tcp：基于L4实现代理，可代理mysql，pgsql，ssh，ssl等协议，https时使用此模式，默认模式 http：仅当代理协议为http时使用，CentOS默认模式 health：工作为健康状态检查的响应模式，当连接请求到达时回应ok后即断开连接，较少使用 示例： 82 listen ssh 83 bind :220 84 balance leastconn 85 mode tcp 86 server sshsrv1 192.168.4.63:22 check 87 server sshsrv2 192.168.4.64:22 check 健康状态检测 对后端服务器做http协议的健康状态检测 option httpchk 默认为：/OPTIONS HTTP/1.0 option httpchk &lt;uri&gt; option httpchk &lt;method&gt; &lt;uri&gt; option httpchk &lt;method&gt; &lt;uri&gt; &lt;version&gt; 定义基于http协议的L7健康状态检测机制 http-check expect [!] &lt;match&gt; &lt;pattern&gt;：http协议健康状态检测响应内容或指定响应码 示例： 89 backend websrvs 90 balance roundrobin 91 server srv1 192.168.4.63:80 check weight 2 92 server srv2 192.168.4.64:80 check 93 option httpchk GET /index.html HTTP/1.1 \r\n host: forwardfor配置 在由haproxy发往后端主机请求报文中添加“X-Forwardde-For”首部，其值为前端客户端的地址，用于向后端主发送真实客户端IP 格式 option forwardfor [ except &lt;network&gt; ] [ header &lt;name&gt; ] [ if-none ] [except &lt;network&gt;]：请求报文来自此处指定的网络是不予添加此首部 [header &lt;name&gt;]：使用自定义首部名称，而非“X-Forwarded-For” [if-none]：如果没有首部才添加首部，如果有使用默认值； 示例： 48 option forwardfor except 127.0.0.0/8 header test 指定MIME类型启用压缩传输功能 compression algo ：启用http协议的压缩机制，指明压缩算法gzip、deflate compression type ：指明压缩的MIME类型 注意：如果添加首部，需要在http服务的日志中定义。 错误页配置 errorfile ：自定义错误页 :HTTP status；支持200、400、403、408、500、502、503、504 ：错误页文件路径 errorloc ：相当于errorloc02 ，利用302重定向指定URL 示例： errorloc 503 http://www.magedu.com/error_pages/503.html 报文首部 reqadd [{if|unless} ]：修改请求报文尾部添加指定首部 rspadd [{if|unless} ]：在响应首部尾部添加指定首部 reqdel [{if|unless} ]：从请求报文中删除匹配正则表达式的首部 reqidel [{if|unless} ]（ignore case）：从请求报文中删除匹配正则表达式的首部（不区分大小写） rspdel [{if|unless} ] rspidel [{if|unless} ]（ignore case）：从响应报文汇总删除正则表达式的首部 连接超时 time client ：客户端最长空闲连接超时时长，默认单位为毫秒 timeout server ：后端服务器最长空闲连接超时时长 timeout http-keep-alive ：持久连接的持久时长 timeout http-request ：一次完整的HTTP请求的最大等待时长 timeout connect ：成功连接后端服务器的最大等待时长 timeout client-fin ：客户端半连接的空闲时长 timeout server-fin ：后端服务器半连接得空闲时长 ACL 访问控制列表的使用提供了一个灵活的解决方案来执行内容交换，并且通常基于从请求中提取的内容、响应或任何环境状态进行决策。 格式： acl &lt;aclname&gt; &lt;criterion&gt; [flags] [operator] &lt;value&gt; ... &lt;value&gt;的类型 boolean integer or integer range IP address /network string hex block &lt;flags&gt; -i ：不区分大小写 -m：使用指定的pattern匹配方法 -n：不做DNS解析 -u：强制每个ACL必须唯一ID，否则多个同名ACL为“或”的关系 -- ：强制flag结束，当字符串和某个flag相似时使用 [operator] 匹配整数值：eq、ge、gt、le、lt 匹配字符串： -exact match （-m str）：字符串必须完全匹配模式 -substring mathc （-m sub）：在提取的字符串查找模式，如果其中任何一个被发现，ACL将匹配 -suffix match （-m end）：将模式与提取字符串的尾部进行比较，如果其中任何一个匹配，则ACL进行匹配 -prefix match （-m beg）：在提取的字符串首部中查找模式，如果其中任何一个被发现，ACL将匹配 -subdir mathc （-m dir）：查看提取出来的用斜线分隔的字符串，如果其中任何一个匹配，则ACL进行匹配 -domain match （-m dom）：查找提取的用“.”分隔字符串，如果其中任何一个匹配，则ACL进行匹配 acl作为条件时的逻辑关系： 与：隐式（默认）使用 或：使用“or”或”||“ 否定：使用“！”使用 &lt;aclname&gt;：ACL名称，可使用字母数字，区分字符大小写 &lt;criterion&gt;：比较的标准和条件 dst：目标IP dst_port：目标port src：源IP src_port：源port base string 返回第一个主机头和请求的路径部分的链接，该请求从第一个斜杠开始，并在问好之前结束，对虚拟主机有用 示例： \:/\:\@*:/\;\&lt; params&gt;*?\#\ base : exact string match base_beg : prefix match base_dir : subdir match base_dom : domain match base_end : suffix match base_len : length match base_reg : regex match base_sub : substring match 同acl类似 path ：string 提取请求的URL路径，该路径从第一个斜杠开始，并在问号之前结束 示例： \:/\:\@\:/\;\&lt; params&gt;?\#\ path : exact string match path_beg : prefix match path_dir : subdir match path_dom : domain match path_end : suffix match path_len : length match path_reg : regex match path_sub : substring match url：string 提取请求中的URL。一个典型的应用是具有预取能力的缓存，以及需要从数据库聚合多个信息并将它们保存在缓存中的网页门户入口 url : exact string match url_beg : prefix match url_dir : subdir match url_dom : domain match url_end : suffix match url_len : length match url_reg : regex match url_sub : substring match req.har（[[.]]）:string 提取在一个HTTP请求报文的首部 hdr([&lt;name&gt;[,&lt;occ&gt;]]) : exact string match hdr_beg([&lt;name&gt;[,&lt;occ&gt;]]) : prefix match hdr_dir([&lt;name&gt;[,&lt;occ&gt;]]) : subdir match hdr_dom([&lt;name&gt;[,&lt;occ&gt;]]) : domain match hdr_end([&lt;name&gt;[,&lt;occ&gt;]]) : suffix match hdr_len([&lt;name&gt;[,&lt;occ&gt;]]) : length match hdr_reg([&lt;name&gt;[,&lt;occ&gt;]]) : regex match hdr_sub([&lt;name&gt;[,&lt;occ&gt;]]) : substring match status：integer 返回在响应报文中的状态码 预定义ACL ACL名称 等价于 说明 TRUE always_true 总是匹配 FALSE always_false 从不匹配 HTTP req_proto_http 匹配HTTP协议 HTTP_1.0 req_ver 1.0 匹配HTTP协议1.0 HTTP_1.1 req_ver 1.1 匹配HTTP协议1.1 HTTP_CONTENT hdr_val(content-length) gt 0 匹配已经存在内容长度 HTTP_URL_ABS url_reg ^[^/:]*:// 匹配URL的绝对路径 HTTP_URL_SLASH url_beg / 匹配URL相对路径 HTTP_URL_STAR url * 匹配URL等于“*” LOCALHOST src 127.0.0.1/8 匹配从localhost来的链接 METH_CONNECT method CONNECT 匹配HTTP CONNECT 方法 METH_GET method GET HEAD 匹配GET和HEAD方法 METH_HEAD method HEAD 匹配head方法 METH_OPTONS method OPTIONS 匹配OPTIONS方法 METH_POST method POST 匹配POST方法 METH_TRACE method TRACE 匹配TRACE方法 RDP_COOKIE req_rdp_cookie_cnt gt 0 match presence of an RDP cookie REQ_CONNTENT req_len gt 0 匹配数据在请求缓存中 WAIT_END wait_end 等待内容分析 use_backend [{if|unless}] 当if|unless一个基于ACL的条件匹配时切换指定 backend {if|unless} 阻止L7请求if|unless一个条件匹配 http-request {allow|deny|add-header |set-header }[{if|unless} ] 对L7层请求的访问控制 tcp-request connection {accept|reject} [{if|unless} ]根据L4条件对传入连接执行操作 示例： 72 frontend mysql 73 bind 172.18.4.62:3306 74 mode tcp 75 default_backend mysqlsrv 76 backend mysqlsrv 77 mode tcp 78 server mysqlsrv1 192.168.4.63:3306 check 79 server mysqlsrv2 192.168.4.64:3306 check 这时我们查看下是谁发起的链接 由此我们可知，真正发起的是代理服务器 支持https协议 （1）支持ssl会话 bind *:443 ssl crt /PATH/TO/SOME_PEM_FILE 注意：crt文件的后缀为PEM格式，且同时包含证书和所有私钥内容 （2）把80端口请求重定向到443 bind *:80 redirect scheme https if!{ssl_fc} （3）向后端传递用户请求的协议和端口 http_request set-header X-Forwarded-Port %[dst_port] http_request add-header X-Forwarded-Proto https if { ssl_fc } 示例： （1）生成证书文件 [root@haproxy/etc/pki/tls/certs]#make httpd.pem [root@haproxy/etc/pki/tls/certs]#cp httpd.pem /root （2）修改haproxy.cfg文件 68 frontend web 69 bind 172.18.4.62:330 ssl crt /root/httpd.pem 70 redirect scheme https if !{ ssl_fc }]]></content>
      <categories>
        <category>服务</category>
        <category>HAproxy</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[firewalld]]></title>
    <url>%2F2017%2F11%2F29%2Ffirewalld%2F</url>
    <content type="text"><![CDATA[firewalldfirewalld是CentOS 7新退出的管理netfilter的工具。firewalld 提供了支持网络 / 防火墙区域 (zone) 定义网络链接以及接口安全等级的动态防火墙管理工具。它支持 IPv4, IPv6 防火墙设置以及以太网桥接，并且拥有运行时配置和永久配置选项。它也支持允许服务或者应用程序直接添加防火墙规则的接口。以前的 iptables 防火墙是静态的，每次修改都要求防火墙完全重启。这个过程包括内核 netfilter 防火墙模块的卸载和新配置所需模块的装载等。而模块的卸载将会破坏状态防火墙和确立的连接。 1、firewalld zone分类 zone名称 默认配置 trusted 允许所有流量 home 拒绝除和传出流量相关的，以及ssh、mdsn、ipp-client、samba-client、dhcpv6-client预定于服务之外其他所有传入流量 internal 允许所有流量 work 拒绝除和传出流量相关的，以及ssh、ipp-client、dhcpv6-client预定于服务之外的其他所有传入流量 public 拒绝除和传出流量相关的，以及ssh、dhcpv6-client预定于服务之外的其他所有传入流量，新家的网卡默认属于public zone external 拒绝除和传出流量相关的，以及ssh预定义服务之外的其他所有传入流量，属于external zone的传出ipv4流量的源地址将被伪装为传出网卡的地址 dmz 拒绝除和传出流量相关的，以及ssh预定义服务之外的其他所有传入流量 block 拒绝除和传出流量相关的所有传入流量 drop 拒绝除和传出流量的所有传入流量 2、预定于服务 服务名称 配置 ssh Local SSH server. Traffic to 22/tcp dhcpv6-client Local DHCPv6 client. Traffic to 546/udp on the fe80::/64 IPv6 network ipp-client Local IPP printing. Traffic to 631/udp. samba-client Local Windows file and print sharing client. Traffic to 137/udp and 138/udp. Multicast DNS (mDNS) local-link name resolution. Traffic to mdns 5353/udp to the 224.0.0.251 (IPv4) or ff02::fb (IPv6) multicast addresse ##3、firewalld-cmd命令选项 选项 说明 –get-zones 列出所有可用区域 –get-default-zone 查询默认区域，只能有一种策略可以使用 –set-default-zone= 设置默认区域 –get-active-zones 列出当前所使用的区域 –add-source=[–zone=] 添加源地址的流量到指定区域，如果无–zone选项，使用默认区域 –remove-source=[–zone=] 从指定区域中删除源地址的流量，如无–zone选项，使用默认区域 –add-interface=[–zone=] 添加来自于指定接口的流量到特定区域，如无–zone选项使用默认区域 –change-interface=[–zone=] 改变指定接口至新的区域，如无–zone选项使用默认区域 –list-all [–zone=] 列出指定区域的所有配置信息，包括接口、源地址、端口、服务等，如无–zone选项使用默认区域 –add-service=[–zone=] 允许指定端口和协议的流量，如无–zone选项使用默认区域 –add-port=[–zone=] 允许指定端口和协议流量如无–zone选项使用默认区域 –remove-port=[–zone=] 从区域中删除指定端口和协议，禁止该端口的流量，如无–zone选项使用默认区域 –reload 删除当前运行时的配置，应用加载永久配置 ##4、其他规则 当基本firewalld语法规则不能满足要求时，可以使用以下更复杂的规则；rich-rules富规则。rich规则比基本的firewalld语法实现更强的功能，不仅实现允许/拒绝，还可以实现日志syslog和auditd，也可以实现端口转发、伪装和限制速率。 ###1、rich语法 [source] [destination] service|port|protocol|icmp-block|masquerade|forward-port [log] [audit] [accept|reject|drop] ###2、规则实施顺序 该区域的端口转发，伪造规则 该区域的日志规则 该区域的允许规则 该区域的拒绝规则 注意：每个区域的规则生效，所有规则都不匹配，该区域默认规则生效。 ###3、rich规则选线 选项 描述 –add-rich-rule=’‘ Add to the specified zone, or the default zone if no zone is specified. –remove-rich-rule=’‘ Remove to the specified zone, or the default zone if no zone is specified. –query-rich-rule=’‘ Query if has been added to the specified zone, or the default zone if no zone is specified. Returns 0 if the rule is present, otherwise 1. –list-rich-rules Outputs all rich rules for the specified zone, or the default zone if no zone is specified. 当选项使用source或destination时，必须用rule [family=”ipv4|ipv6”] 需要制定服务时使用 service name=”service name” Port port port=&quot;port value&quot; protocol=&quot;tcp|udp&quot; Protocol protocol value=&quot;protocol value&quot; ICMP-Block icmp-block name=&quot;icmptype name&quot; Masquerade masquerade firewall-cmd --permanent --zone=&lt;ZONE&gt; --add-rich-rule=&#39;rule family=ipv4 source address=192.168.0.0/24 masquerade&#39; Source-Port source-port port=&quot;port value&quot; protocol=&quot;tcp|udp&quot; Log log [prefix=&quot;prefix text&quot;] [level=&quot;log level&quot;] [limit value=&quot;rate/duration&quot;] Audit audit [limit value=&quot;rate/duration&quot;] Action An action can be one of accept, reject, drop or mark. Limit limit value=&quot;rate/duration&quot; Destination destination [not] address=&quot;address[/mask]&quot; Source source [not] address=&quot;address[/mask]&quot;|mac=&quot;mac-address&quot;|ipset=&quot;ipset&quot; ##端口转发：将发往本机的特定端口的流量转发到本机或不同机器的另一个端口。 格式 firewall-cmd --permanent --zone=&lt;ZONE&gt; --add-forward port=port=&lt;PORTNUMBER&gt;:proto=&lt;PROTOCOL&gt;[:topor t=&lt;PORTNUMBER&gt;][:toaddr=&lt;IPADDR&gt;] 注意：toport和toaddr至少指定一个 示例： firewall-cmd --permanent --zone=public --add-forward-port=port=513:proto=tcp:toport=132:toaddr=192.168.0.25]]></content>
      <categories>
        <category>防火墙</category>
        <category>firewalld</category>
      </categories>
      <tags>
        <tag>firewalld</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP工作方式]]></title>
    <url>%2F2017%2F11%2F28%2FPHP%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[CGI和FastCGI1、CGICGI（Common Gateway Interface，通用网关接口），HTTP服务器与你的货其他机器上的程序进行交谈的工具，其程序一般运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。 2、FastCGIFastCGI像是一个常驻型的CGI，它可以一直执行，只要激活后，不会每次都要花费时间去fork一次。 工作原理 （1）Web Server启动时载入FastCGI进程管理器（IIS ISAPI或Apache Module) （2）FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web Server的连接。 （3）当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。 Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。 （4）FastCGI 子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时， 请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。 3、php-fpm和FastCGI（1）两者之间有何联系php的解析器是php-cgi，只能解析请求，返回结果，不会对进程管理；为了能调用php-cgi进程程序，php-fpm就诞生了。 #####在CentOS 6 中： PHP-5.3.2之前，默认不支持fpm机制，需要自行打补丁并编译安装； httpd-2.2：默认不支持fcgi协议，需要自行编译此模块； 为了能在CentOS 6 中支持此功能，编译安装http和php即可。 在CentOS 7中：httpd-2.4：rpm包默认编译支持了fcgi模块 php-fpm包：专用于将php运行于fpm模式 （2）配置文件这里在CentOS7中对php-fpm配置文件进行讲解 [root@localhost~]#yum install -y php-fpm #直接使用yum源安装即可 主配置文件： /etc/php-fpm.conf 和 /etc/php-fpm.d/*.conf 选项介绍： pm = static(固定数量的子进程)|dynamic（以动态模式管理） pm.max_children 最大子进程 pm.start_servers 初始化时开启的子进程 pm.min_spare_servers 最小空闲子进程 pm.max_spare_servers 最大空闲子进程 pm.max_requests 每个子进程最大请求数量 php_value[session.save_handler] 设置类型 php_value[session.save_path] 文件的存储位置 为了确保运行php-fpm进程的用户对session目录有读写权限 mkdir /var/lib/php/session chown apache.apache /var/lib/php/session 如果想支持远程主机：修改配置文件/etc/php-fpm.d/www.conf listen 格式： ip.add.re.ss:port port listen.allowed_clients 允许远程who连接，默认any listen.backlog 等待队列的长度，-1表示无限制 （3）使http支持php-fpm确认httpd程序是否已经加载了proxy_fcgi_module [root@localhost/etc/php-fpm.d]#httpd -M |grep fcgi #必须加载了这个模块才能支持php-fpm 进行配置[root@localhost/etc/httpd/conf.d]#vim fastcgi.conf DirectoryIndex index.php #设置默认索引文件 ProxyRequests off #是否开启正向代理 ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/var/www/html/$1 #路径匹配 [root@localhost/etc/httpd/conf.d]#ss -tnl #查看端口是否开启 下面我们来测试下性能如何？ [root@localhost/etc/httpd/conf.d]#ab -c 10 -n 100 http://192.168.4.60/wordpress/ #测试我们在CentOS 7 搭建的博客 独立运行的php跟模块方式运行的php的性能略有提升。]]></content>
      <categories>
        <category>服务</category>
        <category>LAMP</category>
        <category>PHP工作方式</category>
      </categories>
      <tags>
        <tag>lphp，工作模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AIDE]]></title>
    <url>%2F2017%2F11%2F28%2FAIDE%2F</url>
    <content type="text"><![CDATA[一、AIDE当一个入侵者进入了你的系统并且种植了木马，通常会想办法来隐蔽这个木马（除了木马自身的一些隐蔽特性外，他会尽量给你检查系统的过程设置障碍），通常入侵者会修改一些文件，比如管理员通常用ps -aux来查看系统进程，那么入侵者很可能用自己经过修改的ps程序来替换掉你系统上的ps程序，以使用ps命令查不到正在运行的木马程序。如果入侵者发现管理员正在运行crontab作业，也有可能替换掉crontab程序等等。所以由此可以看出对于系统文件或是关键文件的检查是很必要的。目前就系统完整性检查的工具用的比较多的有两款：Tripwire和AIDE，前者是一款商业软件，后者是一款免费的但功能也很强大的工具。 1、AIDE 概念AIDE(Adevanced Intrusion Detection Environment)高级入侵检测环境)是一个入侵检测工具，主要用途是检查文件的完整性，审计计算机上的那些文件被更改过了。 2、工作机制AIDE能够构造一个指定文件的数据库，它使用aide.conf作为其配置文件。AIDE数据库能够保存文件的各种属性，包括：权限(permission)、索引节点序号(inode number)、所属用户(user)、所属用户组(group)、文件大小、最后修改时间(mtime)、创建时间(ctime)、最后访问时间(atime)、增加的大小以及连接数。AIDE还能够使用下列算法：sha1、md5、rmd160、tiger，以密文形式建立每个文件的校验码或散列号。 建议：这个数据库不应该保存那些经常变动的文件信息，例如：日志文件、邮件、/proc文件系统、用户起始目录以及临时目录。 二、AIDE使用介绍1、安装AIDE包[root@centos6~]#yum install -y aide 2、AIDE的配置文件/etc/aide.conf The location of the database to be read. aide检查是从下面的文件中读取database=/var/lib/aide/aide.db.gz The location of the database to be written.aide更新数据库是写到下面文件中database_out=/var/lib/aide/aide.db.new.gz 设定选项 解释 p permissions i inode n number of links u user g group s size b block count m mtime a atime c ctime S check for growing size acl Access Control Lists selinux SELinux security context xattrs Extended file attributes md5 md5 checksum sha1 sha1 checksum sha256 sha256 checksum sha512 sha512 checksum rmd160 rmd160 checksum tiger tiger checksum 定义检测属性时可以组合定义，相当于alias作用。 3、aide命令介绍 选项 解释 -i，–init 初始化数据库 -C，–check 检查数据库 -u，–update 更新数据库 初始化数据库： [root@centos6~]#aide --init 查看/var/lib/aide/目录下是否生成数据库 检查数据库时，必须把命令该为aide.db.gz才能检查数据库。 [root@centos6/var/lib/aide]#mv aide.db.new.gz aide.db.gz[root@centos6~]#aide -C 更新数据库 [root@centos6~]#aide -u]]></content>
      <categories>
        <category>安全</category>
        <category>AIDE</category>
      </categories>
      <tags>
        <tag>AIDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CURL、elinks工具]]></title>
    <url>%2F2017%2F11%2F28%2FCURL%E3%80%81elinks%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[CURL工具curl是居于URL语法在命令行方式下工作的文件传输工具，它支持FTP,FTPS,HTTP,HTTPS,GOPHER,TELNET,DICT,FILE及LDAP等协议。curl支持HTTPS认证，并且支持HTTP的POST、PUT等方法，FTP上传，kerberos认证，HTTP上传，代理服务器，cookies，用户名/密码认证，下载文件断电续传，上传文件断电续传，httpd代理服务器通道，还支持IPv6，socket5代理服务器，通过http代理服务器上传文件到FTP服务器等。 格式： curl [OPTIONSS] [URL...] -A/--user-agent &lt;string&gt;:设置用户代理发送给服务器 -e/-referer &lt;URL&gt;:查看此网址从那个网址转发过来 --cacert &lt;file&gt;:CA证书 -k/--insecure:允许忽略证书进行SSL连接 --compressed:要求返回时压缩的格式 --H/--header &lt;line&gt;：自定义首部信息传递给服务器，构造请求首部 -i：显示页面内容，包括报文首部信息 -I/--head：只显示响应报文首部信息 -D/--dump-header &lt;file&gt;：将url的header信息存放在指定文件中 --limit-rate &lt;rate&gt;：设置传输速度，默认为k --basic：使用HTTP基本认证 -u/--user&lt;user[:passwd]&gt;:设置服务器的用户和密码 -L：如果有3XX响应吗，重新发请求到新位置 -o &lt;file&gt;：将网络文件保存为指定的文件中 -O：使用url中默认的文件名保存文件到本地 -0/--http1.0：使用http1.0协议 -C：选项可对文件使用断电续传功能 -c/--cookie-jar &lt;filename&gt; :将url中cookie存放在指定文件中 -x/--proxy&lt;proxyhost[:port]&gt;：指定代理服务器地址 -X/--request &lt;command&gt;：向服务器发送指定请求方法 -U/--proxy-user &lt;user:password&gt;：代理服务器用户和密码 -T：将指定本地文件上传到FTP服务器上 --date/-d:指定使用POST方式传递数据 elinks命令格式：elinks [option] [url]… -dump:非交互式模式，将URL的内容输出至标准输出 -source：打印源码]]></content>
      <categories>
        <category>命令</category>
        <category>网页工具</category>
      </categories>
      <tags>
        <tag>命令使用，curl，elinks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cobbler]]></title>
    <url>%2F2017%2F11%2F28%2FCobbler%2F</url>
    <content type="text"><![CDATA[一、cobbler1、cobbler概念Cobbler是一个Linux服务器快速网络安装的服务，而且在经过调整也可以支持网络安装windows。该工具使用python开发，小巧轻便（才15k行python代码），可以通过网络启动(PXE)的方式来快速安装、重装物理服务器和虚拟机，同时还可以管理DHCP，DNS，TFTP、RSYNC以及yum仓库、构造系统ISO镜像。Cobbler可以使用命令行方式管理，也提供了基于Web的界面管理工具(cobbler-web)，还提供了API接口，可以方便二次开发使用。Cobbler是较早前的kickstart的升级版，优点是比较容易配置，还自带web界面比较易于管理。Cobbler内置了一个轻量级配置管理系统，但它也支持和其它配置管理系统集成，如Puppet，暂时不支持SaltStack。Cobbler客户端Koan支持虚拟机安装和操作系统重新安装，使重装系统更便捷。 2、工作流程 （a）client裸机配置了从网络启动后，开机后会广播包请求DHCP服务器（cobbler server）发送其分配好的一个IP （b）DHCP服务器（cobbler server）收到请求后发送responese，包括其ip地址 （c）client裸机拿到ip后再向cobbler server发送请求OS引导文件的请求 （d）cobbler server告诉裸机OS引导文件的名字和TFTP server的ip和 port （e）client裸机通过上面告知的TFTP server地址通信，下载引导文件 （f）client裸机执行执行该引导文件，确定加载信息，选择要安装的os， （g）期间会再向cobbler server请求kickstart文件和os image （h）cobbler server发送请求的kickstart和os iamgeclient裸机加载kickstart文件 （i）client裸机接收os image，安装该os image 3、cobbler包介绍cobbler包集成了dhcp，pxe服务，rsync，http，dns，kiskstart，IPMI电源管理。 cobbler命令格式：cobbler command [subcommand] [–arg1=value1] [–arg2=value2] cobbler check 核对当前设置是否有问题cobbler list 列出所有的cobbler元素cobbler repo 列出元素的详细信息 cobbler sync 同步配置到数据目录，更改配置 cobbler reposync 同步yum仓库 cobbler distro 查看导入的发行版系统信息 cobbler distro add cobbler distro copy cobbler distro edit cobbler distro find cobbler distro list cobbler distro remove cobbler distro rename cobbler distro report cobbler system 查看添加的系统信息 cobbler profile 查看配置信息 cobbler profile add --name=NAME --distro=DISTRO --kickstart=KICKSTART cobbler profile list #列出配置文件信息 cobbler profile remove cobbler profile rename 修改配置文件名称 cobbler profile report #列出某个配置文件的报告 --name=NAME cobbler improt | | –arch=ARCH | OS architecture being imported | –breed=BREED | the breed being imported | –os-version=OS_VERSION |the version being imported | –path=PATH | local path or rsync location | –name=NAME | name, ex ‘RHEL-5’ | –available-as=AVAILABLE_AS | tree is here, don’t mirror | –kickstart=KICKSTART_FILE | assign this kickstart file | –rsync-flags=RSYNC_FLAGS | pass additional flags to rsync 3、cobbler目录介绍/etc/cobbler/settings : cobbler 主配置文件 /etc/cobbler/iso/: iso模板配置文件 /etc/cobbler/pxe: pxe模板文件 /etc/cobbler/power: 电源配置文件 /etc/cobbler/user.conf: web服务授权配置文件 /etc/cobbler/users.digest: web访问的用户名密码配置文件 /etc/cobbler/dhcp.template : dhcp服务器的的配置模板 /etc/cobbler/dnsmasq.template : dns服务器的配置模板 /etc/cobbler/tftpd.template : tftp服务的配置模板 /etc/cobbler/modules.conf : 模块的配置文件 数据目录 /var/lib/cobbler/config/: 用于存放distros，system，profiles 等信息配置文件 /var/lib/cobbler/triggers/: 用于存放用户定义的cobbler命令 /var/lib/cobbler/kickstart/: 默认存放kickstart文件 /var/lib/cobbler/loaders/: 存放各种引导程序 镜像目录 /var/www/cobbler/ks_mirror/: 导入的发行版系统的所有数据 /var/www/cobbler/images/ : 导入发行版的kernel和initrd镜像用于远程网络启动 /var/www/cobbler/repo_mirror/: yum 仓库存储目录 日志目录 /var/log/cobbler/installing: 客户端安装日志 /var/log/cobbler/cobbler.log : cobbler日志 4、相关术语发行版：表示一个操作系统。它承载了内核和initrd信息，以及内核参数等其他数据。 配置文件：包含一个发行版、一个kickstart文件以及可能的存储库，还包含更多特定的内核参数等其他数据。 系统：表示要配给的机器。它包含一个配置文件或一个镜像，还包含IP和MAC地址、电源管理以及更专业的数据信息。 存储库：保存一个yum或rsync存储库的镜像信息。镜像：可替换一个包含不属于此类别的文件的发行版对象。（例如，无法分为内核和initrd对象） 二、cobbler实战（1）安装cobbler安装包和dhcp[root@localhost ~]# yum install -y cobbler [root@localhost ~]# yum install -y dhcp （2）将服务设为开机启动并启动服务[root@localhost ~]# systemctl enable tftp #将tftp服务设为开机启动，并启动它 [root@localhost ~]# systemctl start tftp [root@localhost ~]# systemctl enabel httpd #将http服务设为开机启动并启动 [root@localhost ~]# systemctl enable httpd [root@localhost ~]# systemctl start httpd [root@localhost ~]# systemctl enable cobblerd #将cobbler设为开机启动并启动 [root@localhost ~]# systemctl start cobblerd （3）运行cobbler check命令解决问题为了确保出现不必要的问题，禁用iptables和setenforce [root@localhost ~]# iptables -F#清空防火墙规则[root@localhost ~]# setenforce 0 #将selinux设为permissiving [root@localhost ~]# cobbler check #检查cobbler环境是否配置正确 当运行cobbler check命令时出现上述的问题，我们通过一个一个解决就可以慢慢的实现cobbler自动化安装CentOS 系统。下面我们一个一个的解决这些文件 （a）修改cobbler服务端地址选项server [root@localhost ~]# vim /etc/cobbler/settings [root@localhost ~]# cobbler sync #将修改过的文件同步 （b）修改next_server 此选项是修改tftp的地址[root@localhost ~]# vim /etc/cobbler/settings [root@localhost ~]# cobbler sync （c）修改mange_dhcp 此选项是要cobbler管理dhcp[root@localhost ~]# vim /etc/cobbler/settings [root@localhost ~]# cobbler sync （d）获取启动菜单方法一：如果有网络的话使用如下方式 [root@localhost ~]# cobbler get-loaders方法二： 如果没有网络/var/lib/tftpboot/目录下的pxelinux.0和menu.c32文件复制到/var/lib/cobbler/loaders [root@localhost ~]# cp /var/lib/tftpboot/{pxelinux.0,menu.c32} /var/lib/cobbler/loaders/[root@localhost ~]# cobbler sync （e）修改用户口令 [root@localhost ~]# openssl passwd -1 #生成加密口令 Password: Verifying - Password: $1$gMx01QUD$eo5dQGlEDGh9o0fY8dgnr. [root@localhost ~]# cobbler sync （f）配置dhcp服务 [root@localhost ~]# vim /etc/cobbler/dhcp.template [root@localhost tftpboot]# cobbler sync #将修改后内容太同步到/etc/dhcp/dhcpd.conf文件中 （4）导入yum源 [root@localhost ~]# cobbler import --path=/media/cdrom --name=centos7.3 --arch=x86_64 --path：指明yum源的路径 --name：指明复制到`/var/www/cobbler`目录下 --arhc：指明架构类型 （5）编辑ks文件并导入 默认的ks位置/var/lib/cobbler/kickstarts/sample.ks 首先将ks文件复制到/var/lib/cobbler/kickstarts目录下，然后将ks文件导入 [root@localhost kickstarts]# cobbler profile edit/add --name=centos7.3-x86_64 --distro=centos7.3-x86_64 --kickstart=/var/lib/cobbler/kickstarts/ks7.cfg #编辑原有的ks文件 [root@localhost tftpboot]# cobbler sync （6）编辑菜单文件 默认的菜单文件/etc/cobbler/pxe/pxedefault.template #默认菜单模板 启动菜单存放位置/var/lib/tftpboot/pxelinux.cfg/default [root@localhost tftpboot]# cobbler sync （7）新建一台虚拟机测试 另外cobbler也提供web管理。Cobbler web界面是一个很好的前端，非常容易管理Cobbler。可以添加和删除system、distro、profile，可以查看、编辑distros、profiles、subprofiles、systems、repos、kickstart文件cobbler认证方式有两种： 方式一： （1）修在认证方式 （2）创建管理用户[root@localhost ~]# htdigest -c /etc/cobbler/users.digest &quot;Cobbler&quot; admin 注意：第一创建是需要加选项“-c”意味着创建文件/etc/cobbler/users.digest文件。 htdigest命令的使用格式： htdigest [ -c ] passwdfile realm username 如何修改管理用户的密码呢？[root@localhost ~]# htdigest /etc/cobbler/users.digest &quot;Cobbler&quot; admin方式二：（a）修改认证方式 （b）创建管理用户 [root@localhost ~]# useradd cobbler[root@localhost ~]# passwd cobbler （c）修改文件/etc/cobbler/user.conf （3）在浏览器地址输入地址 https://192.168.4.128/cobbler_web并管理用户和密码即可]]></content>
      <categories>
        <category>自动化运维</category>
        <category>Cobbler</category>
      </categories>
      <tags>
        <tag>cobbler，自动化安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DHCP]]></title>
    <url>%2F2017%2F11%2F28%2FDHCP%2F</url>
    <content type="text"><![CDATA[一、DHCP服务1、DHCP概念DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一个局域网的网络协议，使用UDP协议工作， 主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段，。DHCP有3个端口，其中UDP67和UDP68为正常的DHCP服务端口，分别作为DHCP Server和DHCP Client的服务端口；546号端口用于DHCPv6 Client，而不用于DHCPv4，是为DHCP failover服务，这是需要特别开启的服务，DHCP failover是用来做“双机热备”的。 ###2、DHCP过程（1）DHCP Client以广播的方式发出DHCP Discover报文。 （2）所有的DHCP Server都能够接收到DHCP Client发送的DHCP Discover报文，所有的DHCP Server都会给出响应，向DHCP Client发送一个DHCP Offer报文。DHCP Offer报文中“Your(Client) IP Address”字段就是DHCP Server能够提供给DHCP Client使用的IP地址，且DHCP Server会将自己的IP地址放在“option”字段中以便DHCP Client区分不同的DHCP Server。DHCP Server在发出此报文后会存在一个已分配IP地址的纪录。 （3）DHCP Client只能处理其中的一个DHCP Offer报文，一般的原则是DHCP Client处理最先收到的DHCP Offer报文。DHCP Client会发出一个广播的DHCP Request报文，在选项字段中会加入选中的DHCP Server的IP地址和需要的IP地址。 （4）DHCP Server收到DHCP Request报文后，判断选项字段中的IP地址是否与自己的地址相同。如果不相同，DHCP Server不做任何处理只清除相应IP地址分配记录；如果相同，DHCP Server就会向DHCP Client响应一个DHCP ACK报文，并在选项字段中增加IP地址的使用租期信息。 （5）DHCP Client接收到DHCP ACK报文后，检查DHCP Server分配的IP地址是否能够使用。如果可以使用，则DHCP Client成功获得IP地址并根据IP地址使用租期自动启动续延过程；如果DHCP Client发现分配的IP地址已经被使用，则DHCP Client向DHCPServer发出DHCP Decline报文，通知DHCP Server禁用这个IP地址，然后DHCP Client开始新的地址申请过程。 （6）DHCP Client在成功获取IP地址后，随时可以通过发送DHCP Release报文释放自己的IP地址，DHCP Server收到DHCP Release报文后，会回收相应的IP地址并重新分配。 ###3、DHCP的状态||状态|解释||DHCP discover|客户端到服务器端||DHCP offer|服务器端到客户端||DHCP request|客户端到服务端||DHCP nack|服务器端到客户端指示客户端的网络地址是不正确的||DHCP ack|服务器端到客户端||DHCP decline|客户端到服务器端，指示地址已经被使用||DHCP release|客户端到服务器端，放弃网络地址和取消剩余的租约时间||DHCP inform|客户端到服务器端，只要求本地配置参数，客户端已经具有外部配置的网络地址| ###4、如何续租呢？当客户端向服务器端取得地址以后得到租期，当租期达到某个期限时，客户端主动向服务器端发起广播请求 %50：租赁时间达到50%时来续租，刚想DHCP服务器发现新的DHCP request请求。如果dhcp服务没有拒绝的理由，则回应DHCP ack信息。当DHCP客户端收到应答信息后，就重新开始新的租用期限。 87.5%：如果之前DHCP server没有回应，等到租约期的87.5%时，主动再发送一次广播请求。 ###5、DHCP的配置文件主配置文件 /etc/dhcp/dhcpd.conf /etc/dhcp/dhcpd6.conf启动配置文件 /etc/rc.d/init.d/dhcpd /etc/rc.d/init.d/dhcpd6中继器 /usr/sbin/dhcrelay /etc/rc.d/init.d/dhcrelay ###6、/etc/dhcp/dhcpd.conf配置文档详解 # option definitions common to all supported networks... option domain-name &quot;example.org&quot;; #searchname option domain-name-servers ns1.example.org, ns2.example.org; #设置DNS服务器地址 default-lease-time 600; #设置租约时长 max-lease-time 7200; #设置客户端最长租期 # Use this to enble / disable dynamic dns updates globally. #ddns-update-style none; #设置DHCP更新 # If this DHCP server is the official DHCP server for the local # network, the authoritative directive should be uncommented. #authoritative; # Use this to send dhcp log messages to a different log file (you also # have to hack syslog.conf to complete the redirection). log-facility local7; #设置日志级别 # No service will be given on this subnet, but declaring it helps the # DHCP server to understand the network topology. subnet 10.152.187.0 netmask 255.255.255.0 { } # This is a very basic subnet declaration. subnet 10.254.239.0 netmask 255.255.255.224 { range 10.254.239.10 10.254.239.20; #设置可分配IP的范围 option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org; #设置客户端默认网关 } filename #指明引导文件名称 next-server #提供引导文件的服务器IP地址 当我们配置完时候，不知道是否出现问题这时候就需要对配置文件尽心检查 service dhcp configtest 示例： （1）安装dhcp服务[root@localhost ~]# yum install -y dhcp（2）将配置文件复制到/etc/dhcp/目录下[root@localhost ~]# cp /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example /etc/dhcp/dhcpd.conf（3）编辑配置文件[root@localhost ~]# vim /etc/dhcp/dhcpd.conf（4）重启dhcp服务[root@localhost ~]# systemctl restart dhcpd（5）在另外一个机器上测试，是否可以拿到地址。[root@localhost ~]#service restart dhcpd 注意： 1、在进行编辑注意每行完成以后要以“；”结尾。 2、在配置DHCP服务时，有时获取到地址并不能ping，很有可能dhcp服务IP变化。]]></content>
      <categories>
        <category>服务</category>
        <category>DHCP</category>
      </categories>
      <tags>
        <tag>dhcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS实战]]></title>
    <url>%2F2017%2F11%2F28%2FDNS%E5%AE%9E%E6%88%98%E4%B8%80%2F</url>
    <content type="text"><![CDATA[实战（1）搭建主DNS服务器（a）[root@localhost ~]# yum install -y bind #安装包（b）[root@localhost ~]# vim /etc/named.conf #修改主配置文件 方式一： 方式二： （c）[root@localhost ~]# vim /etc/ named.rfc1912.zones #修改zone文件 zone &quot;test.com&quot; IN { type master; file &quot;test.com.zone&quot; #此地方可以写绝对路径和相对路径，如果写相对路径，默认为`/var/named/test.com.zone`，因此在`/var/named`目录下文件名一定要与这里的文件名一致。 }; （d）[root@localhost ~]# named-checkconf #使用命令对配置文件检查 /etc/named.rfc1912.zones:27: missing &apos;;&apos; before &apos;}&apos; #此时检查为27行处没有加&quot;;&quot;修改完再检查即可。 注意：修改rfc1912.zones文件时，要以“；”结尾；参数与选项之间必须有空格隔开。 （e）修改zone文件[root@localhost named]# cp named.localhost test.com.zone 但是这里有一个问题，bind程序是以who的身份运行呢？下面通过命令查询看下：[root@localhost named]# ps aux |grep named named 4002 0.2 1.2 161124 13028 ? Ssl 09:55 0:00 /usr/sbin/named -u named 通过命令查看我们看到是以name身份运行的，但是我们在复制文件时，文件名时root，如下图；所以在复制过来以后记得修改文件的权限。 方法一：修改文件的所属组 [root@localhost named]# chgrp named test.com.zone 方法二：复制模板文件时，直接加“-p” [root@localhost named]# cp -p named.localhost test.com.zone[root@localhost named]# vim test.com.zone #修改ZONE文件 $TTL 1D @ IN SOA dns1 mail.test.com. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 dns1 A 192.168.4.132 （f）加载zone文件 [root@localhost named]# rndc reload （g）查看是否可以解析 [root@localhost named]# dig-t ns test.com @192.168.4.132 #在本机测试 在另外一台机器上测试 修改这台机器上的DNS 测试 [root@localhost/etc/sysconfig/network-scripts]#dig -t ns test.com @192.168.4.132 （2）搭建从DNS服务器在主机IP地址为192.168.4.144搭建从服务器 （a）安装bind包 （b）编辑/etc/named.conf （c）编辑配置zone文件/etc/named.rfc1912zones zone &quot;test.com&quot; IN { type slave; #修改类型 masters { 192.168.4.132; }; #主DNS服务器的地址 file &quot;slaves/test.com.slave.zone&quot;; #从DNS服务文件存放的位置 }; （d）启动bind服务，使其生效 [root@localhost~]#systemctl restart named[root@localhost~]#ls /var/named/slaves/test.com.slave.zone （e）测试 [root@localhost~]#dig www.test.com @192.168.4.144 （3）实现转发功能假如一个公司有三台DNS服务器，A,B,C并且这三台主机不在同一个位置；A机器可以直接连接互联网，而B，C不可以直接连接互联网。用户使用电脑想访问www.qq.com，只能通过专线先到C再到A，然后才能访问www.qq.com，通过C转发到A。 方式一：全局转发 （1）分别在CentOS 6和CentOS 7 主机上设置，CentOS 7为转发 (A)在CentOS 6主机上配置 [root@localhost ~]# vim /etc/named.conf [root@localhost ~]# vim /etc/named.rfc1912.zones zone &quot;test.com&quot; IN { type master; file &quot;test.com.zone&quot;; }; 重启服务 [root@localhost ~]# service named restart (B)在CentOS 7主机上配置 [root@localhost~]#vim /etc/named.conf 切记，做这个实验室一定要关闭dnssec功能；dnssec-enable no; dnssec-validation no。 重启服务 [root@localhost~]#systemctl restart named (C)修改客户端机器的dns [root@localhost~]#vim /etc/sysconfig/network-scripts/ifcfg-ens33 (D)在客户端机器上测试 [root@localhost~]#dig www.test.com @192.168.4.148 在这里给大家提个醒：自己搞这个明明很简单的搞了一个多小时都没有成功，原因在于没有关闭dnssce功能。 方式二：特定区域转发 在CentOS 主机上配置 [root@localhost~]#vim /etc/named.rfc1912.zones zone &quot;test.com&quot; IN { type forward; forward first; forwarders {192.168.4.132;}; }; [root@localhost~]#systemctl restart named #重启服务 在客户端主机上测试 （4）实现父域与子域的关系在前面实验的基础上，执行如下操作： （A）在CentOS 7主机上 [root@localhost~]#vim /etc/named.rfc1912.zones 创建zone zone &quot;do.test.com&quot; IN { type master; file &quot;do.test.com.zone&quot;; }; [root@localhost/var/named]#vim do.test.com.zone #配置解析库 $TTL 1D @ IN SOA dns1 rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 dns1 A 192.168.4.148 webserver A 192.168.4.148 www CNAME webserver (B)[root@localhost named]# vim test.com.zone #在CentOS 6主机上修改解析库 [root@localhost named]# service named restart #重启服务 (C)重启服务测试 （5）主从服务器案例前提：准备4台虚拟机 （A）CentOS6主机作为主DNS服务器，同上面的配置类似，这里就不再阐述。 （B）在CentOS 7两台主机上做从DNS服务器，进行如下配置： [root@localhost ~]# vim /etc/named.conf [root@localhost~]#vim /etc/named.rfc1912.zones#创建zone zone &quot;test.com&quot; IN { type slave; masters {192.168.4.132;}; file &quot;slaves/test.com.slave.zone&quot;; }; 启动bind的服务即可以同步到/var/named/slaves目录下 [root@localhost~]#systemctl restart named[root@localhost~]#ll /var/named/slaves/test.com.slave1.zone -rw-r--r--. 1 named named 382 Sep 20 19:08 /var/named/slaves/test.com.slave1.zone 如果主从服务器想指定从DNS服务器，可以在/etc/named.conf配置文件中添加选项 allow-transfer {IP;}； 在从服务器上添加“allow-transfer {none;};”在主DNS服务器上“allow-transfer {IP;};”这样就限制了。 注意：通过以上几个实验总结出需要注意的一些地方 1、在做实验过程中一定要关闭dnssec功能； 2、复制文件/var/named/named.localhost做模板时，一定要加选项“-a”或“-p”选项。复制完成后一定看所有者、所属组和权限。]]></content>
      <categories>
        <category>服务</category>
        <category>DNS</category>
        <category>DNS实战一</category>
      </categories>
      <tags>
        <tag>主从，转发，子域和父域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS实战]]></title>
    <url>%2F2017%2F11%2F28%2FDNS%E5%AE%9E%E6%88%98%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[实战二 如何实现上述的拓扑图呢？先从底部网上一步一步的搭建 （1）实现主从DNS服务器 （a）修改主DNS服务器 [root@localhost~]#vim /etc/named.conf #修改主配置文件 [root@localhost~]#vim /etc/named.rfc1912.zones #创建zone zone &quot;test.com&quot; IN { type master; file &quot;test.com.zone&quot;; }; [root@localhost ~]# vim /var/named/test.com.zone #创建解析库文件 $TTL 1D @ IN SOA dns1 test.com. ( 2 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum IN NS dns1 dns1 A 192.168.4.132 webserver IN A 192.168.4.132 www IN CNAME webserver [root@localhost~]#vim /var/named/named.ca #修改根服务器文件 [root@localhost ~]# service named restart #重启bind服务 （b）配置从DNS服务器 主配置文件和配置从服务器一样，这里就不再阐述[root@localhost~]#vim /etc/named.rfc1912.zones zone &quot;localhost&quot; IN { type master; file &quot;named.localhost&quot;; allow-update { none; }; }; [root@localhost~]#systemctl restart named#重启服务[root@localhost~]#ll /var/named/slaves/test.com.slave.zone #查看是否成功 （2）配置子域 [root@localhost~]#vim /etc/named.rfc1912.zones #创建zone zone &quot;com&quot; { type master; file &quot;com.zone&quot;; }; [root@localhost~]#vim /var/named/com.zone #创建解析库 $TTL 1D @ IN SOA dns1 rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 test NS dns2 dns1 A 192.168.4.147 dns2 A 192.168.4.132 www A 192.168.4.66 [root@localhost~]#systemctl restart named #重启bind服务 （3）根 [root@localhost~]#vim /etc/named.rfc1912.zones zone &quot;.&quot; IN { type master; file &quot;root.zone&quot;; }; 删除配置文件中/etc/named.conf如下内容 [root@localhost/var/named]#vim root.zone #创建解析库 $TTL 1D @ IN SOA dns1 rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 com NS dns2 dns1 A 192.168.4.146 dns2 A 192.168.4.147 [root@localhost/var/named]#systemctl restart named重启服务 这样我们搭建完成了。是否是很有成就感呢？哈哈。当大家看到这里的时候是不是发现我们没有对从DNS服务器做设置呢？如果主DNS挂了，那么从DNS能工作么？下面我们就来说道说道。 假设主DNS服务器down（IP 192.168.4.132 ） [root@localhost ~]# ifconfig eth0 down #将主DNS服务器down掉 [root@localhost ~]# rndc flush #清除主DNS服务器的缓存 在Client客户机测试 （IP 192.168.4.149） [root@localhost~]#dig www.test.com @192.168.4.147 如图所示，没有解析成功，说明我们的从DNS服务器没有起作用，没有实现负载均衡作用。有没有想过为什么出现这种情况呢？因为我们没有在com域中没有添加这条域，下面我们在com域中添加此从DNS服务器的dns记录测试 在com域中添加如下记录 [root@localhost/var/named]#vim com.zone [root@localhost/var/named]#rndc flush #清除缓存 在client客户机上测试 [root@localhost~]#dig www.test.com @192.168.4.148 这样说明我们从DNS服务器起到了，达到了容错功能。是不是有点小小的成就感呢？]]></content>
      <categories>
        <category>服务</category>
        <category>DNS</category>
        <category>DNS实战二</category>
      </categories>
      <tags>
        <tag>主从，转发，子域和父域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS简单介绍]]></title>
    <url>%2F2017%2F11%2F28%2FDNS%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、DNS1、DNS概念DNS（Domain Name System，域名系统）是互联网的一项服务。它将域名和IP地址相互映射的一个分布式数据库，能够使人方便地访问互联网。 2、使用的端口（1）53/TCP 53/UDP （2）不同协议的端口作用是什么呢？ 53/UDP:提供客户端查询功能 53/TCP和53/UDP:实现dns主从复制功能 3、DNS域名开头我们述说DNS是分布式数据库，想必大家猜到了DNS是层级结构的。 从图中可以看出DNS的层级结构 （1）根域（Top Level Domain，tld） （2）顶级域 （a）组织域， com，org，gov，mil等 （b）国家域，cn，ca，hk，tw等 （c）反向域，arpa （3）二级域 … 4、DNS服务器类型（1）主DNS服务器 作用：管理和维护负责解析的域内解析库的服务器 。（2）从DNS服务器 作用：从主服务器或从服务器“复制”（区域间传输）解析库副本。 这里我们需要注意一下，区域传输分为两种 （a）完全传输（axfr）：传送整个解析库； （b）增量传输（ixfr）：传递解析库变化的内容； 是不是大家想，主从DNS服务器时如何工作的呢？ 有两种工作机制“PUSH”和“PULL”。当主DNS服务器配置文件中序列号发生递增，重新DNS服务；主DNS服务器会主动向从DNS服务器同步信息；这个过程称为&apos;PUSH&apos;。如果区域传输终端，没有同步成功，从服务器会根据配置文件中的”retry“指定的时间重新尝试同步信息，这个过程称为“PULL”。 5、DNS解析DNS解析分为两种 （a）正向解析：FQDN--&gt;IP （b）反向解析: IP--&gt;FQDN 注意：正向解析是两个不同的名称空间，是两个不同的解析树，如果为子域则写DNS服务IP。 DNS查询类型： （a）递归查询 （b）迭代查询 一次完整的DNS查询请求的过程：Client–&gt;host文件–&gt;DNS server Local Cache –&gt;DNS server（recursion）–&gt;Server Cache–&gt;Iteration（迭代）–&gt;Root–&gt;TLD–&gt;二级域名–&gt;… 6、DNS资源类型区域解析库由众多的RR（resource record）组成。存在不同的类型：A,AAAA,SOA,CNAME,MX,PTR,NS。 资源记录的格式： NAME [TTL] IN RR_TYPE VALUE 下面有几点需要注意的： （a）$TTL变量，全局继承此处的缓存周期，默认单位为秒。 （b）@代替/etc/named.rfc1912.zones配置的ZONE_NAME. （c）同一个名字可以通过多条记录定义多个不同的值，此时DNS服务器会以轮询方式进行相应。 （d）同一个值可能有多个不同定义的名字；通过多个不同的名字指向同一个值进行定义。此仅表示通过多个不同的名字可以找到同一个主机。 （1）SOA：Start Of Authority，起始授权记录。value的构成： （a）当前区域的主DNS服务器的 FQDN，也可以使用/etc/named.rfc1912.zones配置的ZONE_NAME。 （b）当前区域管理员的邮箱地址，但地址中不能使用”@“，一般使用“.”替代。因为在配置文件中“@”表示特殊含义。 （c）主从服务区域传输相关定义以及否定的答案的同一TTL。 @ IN SOA @ rname.invalid. ( 0 ; serial #解析库序列号，主服务器解析库变化时，递增，最长只能为十位数组成，一般为了方便管理这样管理“当前日期+版本号” 1D ; refresh #刷新时间，从服务器从主服务器请求同步解析库的时间 1H ; retry #重试时间，从服务器从主DNS服务器请求失败时，再次尝试的时间 1W ; expire #过期时长，从服务器联系不到主服务器时，多久后停止服务 3H ) ; minimum #错误解析存活时长 注意：一个区域解析库只能有且仅有一个SOA记录，必须位于解析库的第一条记录。 （2）NS，Name Server ，名称服务value：当前区域的某DNS服务器名称 注意： （a）相邻的两个资源记录的NAME相同时，后续可省略。 （b）任何一个NS记录后面的服务器名字，都应该在后续有一个A记录。 （3）MX，Mail eXchange，邮件转换value：当前区域的某邮件服务器的主机名 注意： （1）在一个区域内可以有多个MX记录,但是每个MX记录前应该有一个数字（0-99），表示服务器的优先级，数字越小优先级越高。 （2）任何一个MX记录后应该有一个A记录。 （4）A 记录value：主机名对应的IP地址 对于A记录有以下几种定义格式: (a)可以使用FQDN (b)可以使用泛域名 *.ZONE_NAME,这种方式的好处是避免用户写错名称时给错误答案，将错误答案指向某特性的地址。 (c)如果一个网段中地址不确定可以是使用 $GGENERATE #-# NAME$ 后面对应的地址也是，网段加$ 示例：$GENERATE 100-150 host$ IN A 192.168.4.$ (5)AAAA记录(6)PTR PoinTeR IP，反向域名解析格式：IP PTR FQDN 完整格式：135.4.168.192-in.adder.arpa IN PTR dns1 如果192.168.4为网络地址，可以这样写 135 IN PTR DNS1 注意:主机地址要反着写。 （7）CNAME 别名有时候我们访问一个网站是www主机不一定是真正的主机。有可能使用了这种别名机制 示例： www IN CNAME websrv 我们在访问一个网址时，有可能为如下地址www.test.server.com对整个地址来说真正的，test为server的子域。server为com的子域。n那么父域如何对子域进行授权呢？ 子域授权：每个域的名称服务器，都是通过父域服务器在解析库进行授权。 如图所述：想必大家多DNS的名称，过程有了一定的了解，下面通过看上面这张图，可以看出子域与父域的管理。通过观察图中，一个zone可有多个RR组成。可以粗略的看出DNS的容错功能，实现负载的作用。父域通过委派子域进行管理。 如图所示：DNS是工作在内核中的，用户是没有办法直接管理DNS服务，那要如何管理DNS服务呢？前人想出了Bind进行管理DNS服务。这样用户通过用户空间借助于Bind管理工具或配置文件就可以管理DNS服务了。]]></content>
      <categories>
        <category>服务</category>
        <category>DNS</category>
        <category>DNS简单介绍</category>
      </categories>
      <tags>
        <tag>dns，bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS访问控制和智能DNS]]></title>
    <url>%2F2017%2F11%2F28%2FDNS%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E6%99%BA%E8%83%BDDNS%2F</url>
    <content type="text"><![CDATA[DNS的管理功能你是不是有这样的想法，只想让某个IP或者某个IP端的地址进行访问，实现访问控制功能。DNS服务给我们提供了很好的解决方法。 1、选项||allow-query {}；| 允许查询的主机，相当于白名单|allow-transfer {}；|允许区域传送的主机|allow-recursion{};|允许递归的主机，这个选项建议在options中使用|allow-update{}；|允许更新区域数据库中的内容 2、acl acl：是把某个IP或IP端合并为一个集合，通过一个统一的名称调用；可以把这个理解为bash函数的功能。 （1）acl内置的选项 ||none|没有一个主机||any|任意主机||localhost|本机||localnet|本机的IP同掩码运算后得到的网络地址| 注意：acl只能先定义再使用；建议一般定义再options的前面。 （2）示例 [root@localhost ~]# vim /etc/named.conf 重新启动服务然后在本机测试[root@localhost ~]# dig www.test.com @127.0.0.1 由于我们设置了acl功能，所有本机也不能访问了。实现我们的预期效果。 view大家小时候去网吧的时候有没有遇到这样一个问题，如果你玩问道在电信1玩，而你的网络是联通的网络，这样开始玩游戏的过程中，我们的屏反应会迟钝，频很高；但是网络提供一个网络转换程序，如果你切换到电信网络，问道游戏运行流畅；这相当于我们这里view的功能。实现只能DNS解析，不过不需要我们手动切换网络。 （1）一个bind服务器可以定义多个view；每个view可以定义多个zone。每个view匹配一组客户端。 （2）如果多个view对同一个zone进行解析时，使用不同的zone解析库文件。 实战如果我们在北京和广州有两台DNS服务器，北京和广州用户通过访问www.test.com的时候，我希望北京访问直接在北京DNS解析并返回，广州与它相同，如何实现嗯？ 在一台由于我电脑有两个不同的IP段，在一台机器上实现这个功能 （a）修改/etc/named.conf文件 （b)创建/etc/named.rfc1912.zones.test和/etc/named.rfc1912.zones.app分别修改 （3）创建zone文件 /var/named/app.com.zone和/var/named/app.com.zone分别修改 （4）重启dns服务[root@localhost named]# service named restart 在Clinet客户机上测试（IP 192.168.4.148和172.18.253.86）]]></content>
      <categories>
        <category>服务</category>
        <category>DNS</category>
        <category>DNS访问控制和智能DNS</category>
      </categories>
      <tags>
        <tag>acl，view，智能DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FTP简单介绍]]></title>
    <url>%2F2017%2F11%2F28%2FFTP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、FTP1、FTP介绍用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。”下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。 2、FTP的工作模式（1）主动模式 Client（PORT/TCP）向Server（22/TCP）发送连接请求，建立三次握手 Client告知Server数据连接端口为PORT+1 Server（20/TCP）主动向Client发送连接请求，建立数据通信。 （2）被动模式 Client（PORT/TCP）和Server建立三次握手 Client向Server发起PASSIVE请求 Server告知Client数据端口 Client（PORT+1/TCP）再次向Server发送数据连接请求 这里需要注意一下，Server数据端口需要计算得出来的一个随机端口号 示例： 192,168,4,60,140,28 服务器数据端口为：140*256+28=35868即此端口为数据连接端口 TCP三次握手过程被动模式下通信过程，产生随机端口通信。 3、FTP服务状态码 状态码 说明 1XX 信息 2XX 成功类响应码 3XX 提示需进一步提供补充类信息的状态码 4XX 客户端错误 5XX 服务器端错误 4、FTP服务用户认证方式 匿名用户：ftp，anonymous，对应linux用户为ftp 匿名用户映射为ftp用户共享资源位置:/var/ftp/pub 系统用户：linux用户，用户/etc/passwd,密码/etc/shadow 系统用户通过ftp访问的资源的位置：用户自己的家目录 虚拟用户：特定服务的专用用户，独立于用户/密码的文件;仅用于访问某特定功能的资源 虚拟用户通过ftp访问资源的位置：给虚拟用户指定的映射成系统用户的家目录 二、vsftpd服务1、vsftpd服务配置文件用户认证配置文件 /etc/pam.d/vsftpd 服务脚本 /usr/lib/systemd/system/vsftpd.service (CentOS 7) /etc/rc.d/init.d/vsftpd 配置文件 /etc/vsftpd/vsftpd.conf 2、主配置文件/etc/vsftpd/vsftpd.conf 匿名了用户配置 anonymous_enable 是否启用匿名用户 anon_upload_enable 是否允许匿名用户上传 anon_mkdir_write_enable 是否允许匿名用户创建目录 anon_other_write_enable 是否允许匿名用户删除目录 系统用户配置 local_enable 是否开启系统用户 write_enable 是否允许创建、删除文件 local_mask 控制本地上传文件权限 chroot_local_user 锁定所有用户在家目录中 chroot_list_enable 运行列表中的用户切换为家目录 chroot_list_file 指定用户文件存放位置 dirmessage_enable 在指定目录下创建.message文件提示用户登录信息 local_root 非匿名了用户登录所有目录 guest_enable 所有系统用户都映射成guest用户 guest_username 指定guest用户，一定要与guest_enable使用 nopriv_user vsftpd指定用户身份运行 日志 xferlog_enable 是否开启传输日志 xferlog_std_format 是否开启标准格式 xferlog_file 指定存放日志文件 dual_log_enable 使用vsftpd日志格式，默认不启用 vsftpd_log_fiel=/var/log/vsftpd.log 可自动生成 改变上传文件的所有者 chown_uploads 是否开启改变上传并修改所有者 chown_username 设置修改为who 欢迎信息 ftpd_banner 设置欢迎信息 vsftpd使用pam完成认证使用的pam配置文件 pam_service_name 是否启用控制用户登录的列表文件 userlist_enable 是否启用用户列表 userlist_deny 是否允许这个文件中的用户可以登录 连接限制 max_client 最大并发连接数 max_per_ip 每个IP可同时发起的并发请求数 传输速率 anon_max_rate 匿名用户最大传输率，单位为字节/秒 local_max_rate 本地用户最大传输速率 -主动模式端口 connect_from_port_20 主动模式端口为20 ftp_data_port 指定主动模式端口 此处注意：一定不能把connect_from_port设置为NO 被动模式端口 pasv_min_port 被动模式最小端口，0为随机端口 pasv_max_port 被动模式最大端口 是否使用当地时间，即系统时间 use_localtime 连接时间 connect_timeout 主动模式数据连接超时时长 accept_timeout 被动模式数据连接超时时长 data_connection_timeout 数据无数据传输超时时长 idle_session_timeout 无命令超时时长-优先以文本传输 ascii_upload_enable 是否开启文本传输 ascii_download_enable 注意：vsftpd默认不允许直接修改根目录权限。 3、CentOS 6如何使vsftpd以非独立服务方式运行（1）修改/etc/vsftpd/vsftpd.conf listen=NO 将此项设置为NO ，即关闭自己监听 （2）安装xinetd服务 [root@localhost ~]# yum install -y xinetd （3）复制模板并修改启动xinetd服务 [root@localhost xinetd.d]# cp rsync vsftpd[root@localhost xinetd.d]# vim vsftpd service vsftpd #修改服务名称 { disable = no 是否开启 flags = IPv6 socket_type = stream wait = no user = root server = /usr/sbin/vsftpd server_args = --daemon log_on_failure += USERID } [root@localhost xinetd.d]# service xinetd restart （4）验证是否成为非独立服务 [root@localhost xinetd.d]# ss -tnl LISTEN 0 64 :::21 :::* users:((&quot;xinetd&quot;,48493,5)) 4、实现基于SSL的FTPS（1）确认是否支持ssl [root@localhost ~]# lddwhich vsftpd|grep ssl libssl.so.10 =&gt; /usr/lib64/libssl.so.10 (0x00007f56e8de8000) （2）创建证书 [root@localhost/etc/pki/tls/certs]#make vsftpd.pem[root@localhost/etc/pki/tls/certs]#openssl x509 -in vsftpd.pem -noout -text #查看证书内容[root@localhost/etc/pki/tls/certs]#mv vsftpd.pem /etc/vsftpd/ #将证书移动至此目录下方便管理 （3）配置vsftpd服务支持SSL [root@localhost~]#vim /etc/vsftpd/vsftpd.conf #在文件下追击如下几行 128 ssl_enable=YES #是否开启SSL 129 allow_anon_ssl=NO #是否允许匿名用户支持SSL 130 force_local_logins_ssl=YES #本地用户登录加密 131 force_local_data_ssl=YES #本地用户数据传输加密 132 rsa_cert_file=/etc/vsftpd/vsftpd.pem #证书存放的位置 （4）测试是否使用加密传输 [root@localhost ~]# ftp 192.168.4.60 Connected to 192.168.4.60 (192.168.4.60). 220 (vsFTPd 3.0.2) Name (192.168.4.60:root): wang 530 Non-anonymous sessions must use encryption. #禁止匿名用户登录 Login failed. 421 Service not available, remote server has closed connection 使用Fileilla工具测试 三、vsftpd虚拟用户1、虚拟用户介绍所有虚拟用户会被统一映射为一个指定的系统账号，访问的共享位置即此系统账号的目录； 每个虚拟用户可被赋予不同的访问权限，通过匿名用户的权限控制参数进行指定； ##2、虚拟用户账号的存储方式 文本存储：编辑文本文件，此文件需要被编码为hash格式 格式：奇数行为账户，偶数行为密码 不过需要对此文件加密，使用的工具为db_load db_load -T -t hash -f Filename.txt Filename.db -T 转换 -t 指定类型 -f 指定文件 存储在关系型数据库表中，可以实现查询数据库完成用户认证 #四、实现不同方式存储的方式 ##1、基于文本文件存储（1）创建用户并写入一个文本文件中 [root@localhost/etc/vsftpd]#vim vusers 1 joah 2 123456 3 wang 4 123456 （2）创建用户数据库文件 [root@localhost/etc/vsftpd]#db_load -T -t hash -f vusers vusers.db[root@localhost/etc/vsftpd]#chmod 600 vusers.db #修改文件权限 （3）创建用户和访问的目录[root@localhost~]#useradd -s /sbin/nologin -d /app/ftproot vuser[root@localhost~]#chmod +rx /app/ftproot/[root@localhost~]#chmod -w /app/ftproot/ #由于CentOS 7 上不允许系统用户直接修改家目录所有需要去掉此权限[root@localhost~]#mkdir /app/ftproot/upload[root@localhost~]#setfacl -m u:vuser:rwx /app/ftproot/upload/ （4）创建pam配置文件 [root@localhost~]#ls /usr/lib64/security/ |grep userdb #查看是否已有此模块 pam_userdb.so [root@localhost/etc/pam.d]#vim vsftpd.db 1 auth required pam_userdb.so db=/etc/vsftpd/vusers 2 account required pam_userdb.so db=/etc/vsftpd/vusers （5）创建虚拟用户独立的配置文件 [root@localhost/etc/vsftpd]#mkdir vdocs[root@localhost/etc/vsftpd]#cd vdocs/[root@localhost/etc/vsftpd/vdocs]#vim wang[root@localhost/etc/vsftpd/vdocs]#vim joah 1 anon_upload_enable=YES 2 anon_mkdir_write_enable=YES 3 anon_other_write_enable=YES 注意：默认不创建用户文件，只有下载权限。 （6）修改/etc/vsftpd/vsftpd.conf文件 133 guest_enable=YES #所有系统用户映射为guest用户 134 guest_username=vuser #指定guest用户 135 pam_service_name=vsftpd.db #pam服务的名称 136 user_config_dir=/etc/vsftpd/vdocs #文本文件用户的配置文件所在位置 （7）测试]]></content>
      <categories>
        <category>文件管理</category>
        <category>FTP</category>
        <category>FTP简单介绍</category>
      </categories>
      <tags>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dropbear]]></title>
    <url>%2F2017%2F11%2F28%2FDropbear%2F</url>
    <content type="text"><![CDATA[dropbearDropbear是一个相对较小的SSH服务器和客户端。它运行在一个基于POSIX的各种平台。 Dropbear是开源软件，在麻省理工学院式的许可证。 Dropbear是特别有用的“嵌入”式的Linux（或其他Unix）系统，如无线路由器。 &lt;摘自：百度&gt; 1、安装dropbear工具包（a）从官网上下载dropbear源码包并安装有关编译的环境包组 （b）编译安装源码包 [root@centos7/usr/src]#tar xvf dropbear-2017.75.tar.bz2[root@centos7/usr/src/dropbear-2017.75]#./configure[root@centos7/usr/src/dropbear-2017.75]#make PROGRAMS=&quot;dropbear dbclient dropbearkey dropbearconvert scp&quot;[root@centos7/usr/src/dropbear-2017.75]#make PROGRAMS=&quot;dropbear dbclient dropbearkey dropbearconvert scp&quot; install （c）有关命令的存放位置 /usr/local/sbin和/usr/local/bin （d）生成key存放的位置 dss /etc/dropbear/dropbear_dss_host_key rsa /etc/dropbear/dropbear_rsa_host_key ecdsa /etc/dropbear/dropbear_ecdsa_host_key （e）创建目录并生成密钥 [root@centos7/usr/local/sbin]#mkdir /etc/dropbear[root@centos7/usr/local/bin]#dropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key -s 2048 Generating key, this may take a while... Public key portion is: ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDCfn+syhEMRgkxQ1Y/8Hzu54aTv23hLKyiDOTNVAqpZD+kS63TOcD4r5wCQsARNhl4e0kKWz9CLl6y3cWPxO+BbxCcZ+Ue2HqGQO2vhltzD2voL5xuOOg50nv1nrMrudS3kIYkg3gmVhn0Z0nKntJFdbzihzbLU0c1MgstTscu0PpX7q9j2c0mUHuYFqTmj2X4AJB0qjj8VZs93KTn3YyzVBph7mub8FQkS+fLjMvzan66+GjAtafeR+ezoFP6NAC7BuVaHaKoUNyP/myZgA3wkM4LL8OuoSk3uJia5ZDzDEsUNcHsmwaDVlJDGbjMRx+Djoafj9JNE7su+TmLMl2z root@centos7 Fingerprint: md5 bf:3b:0a:85:94:85:e1:af:91:74:14:d3:e2:0c:6e:d0 （f）启动dropbeardropbear选项 选项 说明 -F Don’t fork into background前台执行 -E Log to stderr rather than syslog输出信息在屏幕上 -p [address:]port Listen on specified tcp port (and optionally address),up to 10 can be specified(default port is 22 if none specified) [root@centos7/usr/local/bin]#dropbear -p 2222 -F -E （g）使用dbclinet远程连接 [root@centos6/usr/local/bin]#dbclient 192.168.159.139 （h）拷贝文件 [root@centos6/usr/local/bin]#scp /etc/fstab 192.168.159.139:/ /usr/bin/dbclient: No such file or directory lost connection 此时连接会报错，说我们没有/usr/bin/dbclient [root@centos6/usr/local/bin]#hash通过hash命令查看确实是使用我们刚刚创建的路径程序，所有解决此问题创建一个软连接即可。 [root@centos6/usr/local/bin]#ln -sv /usr/local/bin/dbclient /usr/bin/dbclient `/usr/bin/dbclient&apos; -&gt; `/usr/local/bin/dbclient&apos; [root@centos6/usr/local/bin]#scp /etc/fstab 192.168.159.139:/]]></content>
      <categories>
        <category>服务</category>
        <category>dropbear</category>
      </categories>
      <tags>
        <tag>dropbear</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP安装及配置文件介绍]]></title>
    <url>%2F2017%2F11%2F28%2FHTTP%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Http安装及文件介绍1、文件类型 主配置文件 /etc/httpd/conf/httpd.conf /etc/httpd/conf.d/*.conf 服务脚本文件 /etc/rc.d/init.d/httpd /etc/sysconfig/httpd #脚本配置文件 站点网页文档默认目录 /var/www/html 模块文件路径 /etc/httpd/modules /usr/lib64/httpd/modules 主程序文件 /usr/sbin/httpd /usr/sbin/httpd.worker /usr/sbin/httpd.event 主进程文件 /etc/httpd/run /httpd.pid #如果这个文件之前存在，系统重启之后会覆盖此配置文件。如果没有会自动创建之。 日志文件目录 /var/log/httpd/access_log /var/log/httpd/err_log 帮助文档包 httpd-manual #如果需要使用可以安装，访问示例http:192.168.4.135/manual 2、/etc/httpd/conf/httpd.conf文件选项介绍 httpd.conf文件的主要分类 [root@localhost ~]# grep &#39;###&#39; /etc/httpd/conf/httpd.conf ### Section 1: Global Environment #全局配置 ### Section 2: &apos;Main&apos; server configuration #主机配置 ### Section 3: Virtual Hosts #虚拟主机配置 选项介绍 （1）ServerTokens 显示服务器版本信息 syntax：ServerTokens Major|Minor|Min[imal]|Prod[uctOnly]|OS|Full ServerTokens Prod[uctOnly] #仅显示类型 Server sends (e.g.): Server: Apache ServerTokens Major #显示版本及主版本号 Server sends (e.g.): Server: Apache/2 ServerTokens Minor #显示类型主板本号及此版本号 Server sends (e.g.): Server: Apache/2.0 ServerTokens Min[imal] Server sends (e.g.): Server: Apache/2.0.41 ServerTokens OS #显示类型版本号及系统类型 Server sends (e.g.): Server: Apache/2.0.41 (Unix) ServerTokens Full (or not specified) #全部显示 #系统默认# Server sends (e.g.): Server: Apache/2.0.41 (Unix) PHP/4.2.2 MyMod/1.2 建议使用ServerTokens prod，防止此版本有漏洞被入侵。建议一般不要显示版本号。 （2）Listen 修改监听的IP和Port Syntax: Listen [IP-address:]portnumber [protocol] 省略IP 表示为0.0.0.0 Listen指令至少一个，可重复出现多次 修改监听socket，重启或重新加载服务进程方可生效 示例： Listen 80 Listen 8080 Listen 192.168.4.150:80 （3）持久连接建立连接，每个资源获取完成后不断开连接，而好似继续等待其他的请求完成，默认关闭 KeepAlive Syntax: KeepAlive On|Off #默认为关闭 MaxKeepAliveRequests Synatax:MaxKeepAliveRequests number #默认最大连接请求100 KeepAliveTimeout Syntax：KeepAliveTimeout seconds #默认持久连接超时时间为5秒 缺点：对并发量较大的服务器，持久连接功能会使其它有些请求得不到回应。 解决方法：使用较短的持久时间设置。 （4）MPM（Multi-Processing Module） 多进程处理模块 MPM的类型在前面已经详细的介绍，这里来说说在配置文件中怎么配置 prefork配置 &lt;IfModule prefork.c&gt; StartServer number #初始化开启几个进程 MinSpareServers number #最小空闲进程 MaxSpareServers number #最大空闲进程 ServerLimit number #最大开启的进程数 ，最大为20000个 MaxClients number #最大并发量 MaxRequestsPerChild number #最多处理的请求数量 默认为10000。在子进程请求之后，子进程会被父进程终止，子进程占用的内容就会释放（为0是永远释放）。 &lt;/IfModule&gt; worker配置 &lt;IfModule worker.c&gt; StartServers number #初始化开启几个进程 MaxClients number #最大并发量 MinSpareThreads number #最小空闲线程 MaxSpareThreads number #最大空闲进程 ThreadsPerChild number #一个子进程最多开启几个线程 MaxRequestsPerChild number #一个子进程最多有多个访问请求 默认10000 &lt;/IfModule&gt; 配置文件默认内容 &lt;IfModule worker.c&gt; StartServers 4 MaxClients 300 MinSpareThreads 25 MaxSpareThreads 75 ThreadsPerChild25 MaxRequestsPerChild 0 &lt;/IfModule&gt; 这里需要注意: StartServers*ThreadsPerChild&gt;MaxSpareThreads 所以系统初始时会少开一个进程。 如何更改工作模式呢？ [root@localhost ~]# vim /etc/sysconfig/httpd 如何计算PV的值呢？ 假设每秒中开启256进程，持久连接，每个进程能处理5个资源；每个网页有100个资源，如何计算PV？ pv：256586400/100=1105920 带宽10245256/1024/1024*8=8M 网络中计算是以位为单位 （5）DSO：Dynamic Shared Object 动态加载模块 httpd -M #查看动态加载模块 httpd -l #查看静态加载模块 格式： LoadModule &lt;mod_name&gt; &lt;mod_path&gt; mod_path写路径时要写相对路径：相对于ServerRoot （6）DocumentRoot 定义Main server 中文档页面路径 Syntax: DocumentRoot directory-path 文档路径映射：DocumentRoot指向的路径为URL路径的起始位置。 示例： # http://HOST:PORT/test/index.html \|/ /app/data/test/index.html （7）DirectoryIndex 定义站点页面 Syntax: DirectoryIndex local-url [local-url] … /etc/httpd/conf.d/welcome.conf如果主站点出错可以跳转至此页面 （8）站点访问控制常见机制 可基于两种机制指明对哪些资源进行何种访问控制 文件系统路径： &lt;directory &quot;/PATH&quot;&gt; ... &lt;/directory&gt; &lt;File &quot;/PATH/FILE&quot;&gt; ... &lt;/File&gt; &lt;FileMatch&gt; ... &lt;/FileMatch&gt; URL路径： &lt;Location URL-path|URL&gt; ... &lt;/Location&gt; &lt;LocationMatch regex&gt; ... &lt;/LocationMatch&gt; 其上的路径都可以使用正则表达式和通配符 通配符： 通配符 说明 * 匹配任意长度字符 ? 匹配任意单个字符 [] 匹配中括号内的任意单个字符 [^] 除中括号里的都匹配 正则表达式： 符号 说明 . 匹配任意单个字符 * 匹配前一个字符任意长度，0次或多次 ？ 匹配前一个字符一次或0次 + 匹配前一个字符一次或多次 [] 匹配括号里的任意单个字符 … 示例： &lt;FilesMatch &quot;\.(gif|jpe?g|png)$&quot;&gt; &lt;Files “?at.*”&gt; &lt;Location /status&gt; &lt;LocationMatch &quot;/(extra|special)/data&quot;&gt; 注意：使用正则表达式比较耗费资源，会遍历整个路径去寻找，建议不要使用。 （9）中“基于源地址”实现访问控制 Options Syntax: Options [+|-]option [[+|-]option] … 常见选项： 选项 说明 Indexes 指明的URL路径下不存在于定义的主页面资源相符的资源文件时，返回索引列表给用户 FollowSymlinks 允许访问符号链接文件所指向的源文件，默认支持软连接。 None 全部禁用 All 全部允许，系统默认选项 MultiViews 允许使用多视图 注意：Options只对有效。 示例： （1）在/etc/httpd/conf.d/目录下创建custom.conf文件 [root@localhost conf.d]# vim custom.conf &lt;Directory &quot;/app/testweb&quot;&gt; Options None #全部禁用 &lt;/Directory&gt; （2）把welcome.conf文件删除或修改名字 [root@localhost conf.d]# mv welcome.conf welcome.conf.bak （3）重启服务测试 现在我们再修改配置文件修改为Options Indexes &lt;Directory &quot;/app/testweb&quot;&gt; Options Indexes &lt;/Directory&gt; 重启服务测试 AllowOverride 与访问控制相关的的指令可以放在指定目录下.htaccess文件中，覆盖之前配置指令。 常见选项： 选项 说明 AuthConfig 允许使用与认证授权相关的指令 FileInfo 允许使用控制文档类型的指令 Indexes 允许使用控制目录索引的指令 Limit 允许使用控制主机访问的指令 Options[=Option,…] 允许使用控制指定目录功能的指令 None .htaccess文件失效 示例 在上面的基础上我们再/app/testweb.htaccess此文件 [root@localhost testweb]# vim .htaccess Options Indexes 在custom.conf编辑 [root@localhost conf.d]# vim custom.conf &lt;Directory &quot;/app/testweb&quot;&gt; Options None AllowOverride All &lt;/Directory&gt; 由于我们在上面测试的时候如果Options为None时候网页出现如下情况 先我们再测试 这时你会不会想到放到站点目录下会不会被访问到呢？这样显然就不安全了，开发人员已经想到了这点如下： &lt;Files ~ &quot;^\.ht&quot;&gt; Order allow,deny Deny from all Satisfy All &lt;/Files&gt; 现在我们真正了解了AllowOverride选项作用了。使用这种方法我们控制一些内容。 Order 和allow 、deny 定义生效次序；写在后面的表示默认规则，优先级高。 匹配次序 条件 结果 Match Allow,Deny result Deny,Allow result Match Allow only Request allowed Request allowed Match Deny only Request denied Request denied No match Default to second directive: Denied Default to second directive: Allowed Match both Allow &amp; Deny Final match controls: Denied Final match controls: Allowed 格式： A (partial) domain-name Example: Allow from apache.org deny from .net example.edu A full IP address Example: Allow from 10.1.2.3 deny from 192.168.1.104 192.168.1.205 A partial IP address Example: Allow from 10.1 deny from 10 172.20 192.168.2 A network/netmask pair Example: Allow from 10.1.0.0/255.255.0.0 deny from 20.1.0.0/255.255.0.0 A network/nnn CIDR specification Example: Allow from 10.1.0.0/16 deny from 20.1.0.0/16 示例 编辑custom.conf文件 &lt;Directory &quot;/app/testweb&quot;&gt; Options Indexes Order allow,deny Deny from 192.168 &lt;/Directory&gt; 重启服务测试 如果修改为Allow &lt;Directory &quot;/app/testweb&quot;&gt; Options Indexes Order allow,deny Allow from 192.168 &lt;/Directory&gt; （10）日志设定 LogLevel 设定日志级别 LogFormat 定义日志格式 示例 LogFormat “%h %l %u %t \”%r\” %&gt;s %b \”%{Referer}i\” \”%{User-Agent}i\”” combined Syntax: CustomLog file|pipe format|nickname [env=[!]environment-variable 示例 CustomLog logs/access_log combined /var/log/error_log 错误日志存放位置 /var/log/access_log 访问成功日志存放位置 选项 说明 %h 客户端IP地址 %L 远程用户，启动mod_ident才有效，通常为“-” %u 验证远程用户，非登录访问时，为一个“-” %t 服务器收到请求时的时间 %r 表示请求报文的首行，记录了此次请求的方法、URL以及协议版本 %&gt;s 响应状态码 %b 响应报文的大小，单位为字节；不包括响应报文http首部 %{Referer}i 请求报文中首部“referer”的值，即从哪个页面中的超链接跳转至当前页面 %{User-Agent}i 请求报文中首部“User-Agent”的值，即发出请求的应用程序 示例： 192.168.4.1 - - [18/Sep/2017:17:14:09 +0800] “GET / HTTP/1.1” 403 281 “-“ “Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:56.0) Gecko/20100101 Firefox/56.0” （11）AddDefaultCharset 设定默认字符集 Syntax: AddCharset charset extension [extension] … 常用类型：UTF-8 GBK GB2312 GB18030 （12）定义路径别名 Syntax: Alias URL-path file-path|directory-path Syntax: AliasMatch regex file-path|directory-path #可以使用通配符和正则表达式 示例 修改custom.conf文件 Alias /test /app/testweb &lt;Directory &quot;/app/testweb&quot;&gt; Options Indexes &lt;/Directory&gt; 重启服务测试 [root@localhost testweb]# curl -I 192.168.4.132/test HTTP/1.1 301 Moved Permanently Date: Mon, 18 Sep 2017 09:38:50 GMT Server: Apache/2.2.15 (CentOS) Location: http://192.168.4.132/test/ Connection: close Content-Type: text/html; charset=iso-8859-1 （13）基于用户的访问控制 认证质询：WWW-Authenticate Authorization：客户端用户填入账号和密码后再次发送请求报文；认证通过时，服务器发送响应的资源。 认证方式类型： basic：明文 digest：消息摘要认证，兼容性查 安全域：需要用户认证后才能访问的路径；通过名称对齐进行标识，以便于告知用户认证原因。 虚拟账户：仅用于访问某服务时用到的认证标识。创建文件的位置在/etc/httpd/conf.d/目录下。 basic认证示例（1）定义安全域 &lt;Directory “/PATH”&gt; AuthType #认证类型 AuthName #提示信息 AuthUserFile #认证文件位置 Require user UserName1 UserName2 .. #从认证文件中挑选出的用户可以访问 Requie vaild-user #允许账户文件中的所有用户登录访问 AuthGroupFile 组文件存放的位置 Require group GrpName1 GrpName1.. #允许指定组用户登录访问 &lt;/Directory&gt; （2）提供账号和密码存储的位置，一般为隐藏文件 #####htpasswd命令 htpasswd ：Manage user files for basic authentication 选项： -c：自动创建文件，仅在文件不存在创建时使用 -m：使用md5加密 -s：使用sha格式加密 -D：删除指定用户 （3）创建组账号文件 组名称：user1 user2 ... 远程客户端和用户验证的控制Satisfy： Interaction between host-level access control and user authentication 主机访问控制和用户认证之间的交互 ||All|客户机IP和用户验证都需要通过才能访问|Any|客户机IP和用户验证有一个满足就可以访问 示例一 基于用户认证控制 （1）创建存放密码的配置文件 [root@localhost conf.d]# htpasswd -c .htusers wang[root@localhost conf.d]# htpasswd -s .htusers li[root@localhost conf.d]# htpasswd -s .htusers joah （2）修改custom.conf配置文件 Alias /test /app/testweb &lt;Directory &quot;/app/testweb&quot;&gt; Options Indexes AuthType basic AuthName &quot;welcom visit...&quot; AuthUserFile &quot;/etc/httpd/conf.d/.htusers&quot; Require user wang &lt;/Directory&gt; （3）重启服务测试 输入wang账户后 示例二 基于组账户认证 在上述基础之上进行如下操作 （1）将上述用户加入组中[root@localhost conf.d]# groupmems -a wang -g webtest [root@localhost conf.d]# groupmems -a li -g webtest [root@localhost conf.d]# groupmems -a joah -g webtest （2）创建组用户文件 [root@localhost conf.d]# vim .htgrps webtest:wang li （3）修改custom.conf文件Alias /test /app/testweb &lt;Directory &quot;/app/testweb&quot;&gt; Options Indexes AuthType basic AuthName &quot;welcom visit...&quot; AuthUserFile &quot;/etc/httpd/conf.d/.htusers&quot; AuthGroupFile &quot;/etc/httpd/conf.d/.htgrps&quot; Require group webtest &lt;/Directory&gt; （4）重启服务测试 输入li账户后 （14）虚拟主机 虚拟主机有三种实现方式： 基于IP，为每个虚拟主机准备至少一个IP地址 基于Port，为每个虚拟主机使用至少一个独立的Port 基于FQDN，为每个虚拟主机使用至少一个FQDN 注意：一般虚拟主机不要与Main主机混用；如果要使用虚拟主机，一般先禁用Main主机。如果要禁用Main主机，直接禁用DocumentRoot即可。 示例一：基于IP的虚拟主机 （1）编辑配置文件custom.conf &lt;VirtualHost 192.168.4.132:80&gt; DocumentRoot &quot;/app/a.com/htdocs&quot; &lt;/VirtualHost&gt; &lt;VirtualHost 192.168.4.133:80&gt; DocumentRoot &quot;/app/b.net/htdocs&quot; &lt;/VirtualHost&gt; &lt;VirtualHost 192.168.4.134:80&gt; DocumentRoot &quot;/app/c.org/htdocs&quot; &lt;/VirtualHost&gt; （2）创建所需文件 [root@localhost conf.d]# mkdir /app/a.com/htdocs -pv [root@localhost conf.d]# mkdir /app/b.net/htdocs -pv [root@localhost conf.d]# mkdir /app/c.org/htdocs -pv [root@localhost conf.d]# echo www.a.com &gt; /app/a.com/htdocs/index.html [root@localhost conf.d]# echo www.b.net&gt; /app/b.net/htdocs/index.html [root@localhost conf.d]# echo www.c.org&gt; /app/c.org/htdocs/index.html （3）添加IP地址 [root@localhost conf.d]# ip addr add 192.168.4.133/24 dev eth0 [root@localhost conf.d]# ip addr add 192.168.4.134/24 dev eth0 （4）重启服务测试 示例二：基于Port的虚拟主机 （1）编辑custom.com文件 Listen 192.168.4.132:81 Listen 192.168.4.132:82 Listen 192.168.4.132:83 &lt;VirtualHost 192.168.4.132:80&gt; DocumentRoot &quot;/app/a.com/htdocs&quot; &lt;/VirtualHost&gt; &lt;VirtualHost 192.168.4.132:81&gt; DocumentRoot &quot;/app/b.net/htdocs&quot; &lt;/VirtualHost&gt; &lt;VirtualHost 192.168.4.132:82&gt; DocumentRoot &quot;/app/c.org/htdocs&quot; &lt;/VirtualHost&gt; （2）重启服务器测试 示例三：基于FQDN的虚拟主机 我们准备三台虚拟主机，一台CentOS 6 配置3个FQDN，一台CentOS 7配置DNS，一台CentOS 7测试 第一步：在CentOS 6 上配置3个FQDN NameVirtualHost *:80 #注意这项配置在CentOS 6 中必须开启，切记！！！ NameVirtualHost *:80 &lt;VirtualHost *:80&gt; ServerName &quot;www.a.com&quot; DocumentRoot &quot;/app/a.com&quot; &lt;/VirtualHost&gt; &lt;VirtualHost *:80&gt; ServerName &quot;www.b.com&quot; DocumentRoot &quot;/app/b.com&quot; &lt;/VirtualHost&gt; &lt;VirtualHost *:80&gt; ServerName &quot;www.c.com&quot; DocumentRoot &quot;/app/c.com&quot; &lt;/VirtualHost&gt; 第二步：在CentOS 7上配置DNS服务器 [root@localhost~]#yum install -y bind [root@localhost/etc/named]#vim /etc/named.conf #修改图中方框内容 [root@localhost/etc/named]#vim /etc/named.rfc1912.zones [root@localhost/var/named]#vim a.com.zone #b.com.zone 和c.com.zone类似这里就不累述。 1 $TTL 1D 2 @ IN SOA dns1 mail.a.com. ( 3 0 ; serial 4 1D ; refresh 5 1H ; retry 6 1W ; expire 7 3H ) ; minimum 8 NS dns1 9 dns1 A 192.168.4.164 10 www A 192.168.4.132 重启服务 第三步：在另一台CentOS 7 主机上测试 [root@localhost~]#vim /etc/resolv.conf #修改DNS 1 # Generated by NetworkManager 2 search localdomain 3 nameserver 192.168.4.164 （15）status页面 要实现这个功能需要加载模块mod_status.so 格式： LoadModule status_module modules/mod_status.so &lt;Location /server-status&gt; SetHandler server-status Order allow,deny Allow 192.168.4 &lt;/Location&gt; ExtendedStatus On #开启此选项显示更多内容 建议：不要开启此选项，如果处于测试状态可以开启拍错。 （16）mod_deflate模块 压缩页面优化传输速度 适用场景： 节约带宽，额外消耗CPU； 压缩适于压缩的资源，如文本文件 如何启用压缩功能？ SetOutputFilter DEFLATE AddOutputFilterByType DEFLATE text/plain AddOutputFilterByType DEFLATE text/html AddOutputFilterByType DEFLATE application/xhtml+xml AddOutputFilterByType DEFLATE text/xml AddOutputFilterByType DEFLATE application/xml AddOutputFilterByTypeDEFLATE application/x-javascript AddOutputFilterByType DEFLATE text/javascript AddOutputFilterByType DEFLATE text/css Level of compression 指定压缩比 （1-9），默认为9 （17）mod_ssl模块 认证模块 http基于ssl认证过程： （1）客户端发送可供选择的加密方式，并向服务器请求证书 （2）服务器端发送证书以及选定的加密方式给客户端 （3）客户端取得证书并进行证书验证如果信任给其发证书的CA 验证证书的来源的合法性：用CA的公钥解密证书上数字签名 验证证书内容的合法性：完整性验证 验证证书有效期限 检查证书是否被吊销 （4）客户端生成临时会话密钥，并使用服务器端的公钥加密此数据发送给服务器，完成密钥交换 （5）服务用此密钥加密用户请求的资源，响应客户端。 注意：SSL是基于IP地址实现，单IP的主机仅可以使用一个HTTPS虚拟主机。 实现https的过程： （1）先建立私有CA；在CentOS 7上 [root@localhost~]#cd /etc/pki/CA/ [root@localhost/etc/pki/CA]#(umask 066；openssl genrsa -out private/cakey.pem 2048） [root@localhost/etc/pki/CA]#openssl req -new -x509 -key private/cakey.pem -out casert.pem -days 4650 [root@localhost/etc/pki/CA]#echo 01 &gt; serial [root@localhost/etc/pki/CA]#touch index.txt （2）在CentOS 6上创建请求认证证书 [root@localhost ssl]# (umask 066；openssl genrsa -out httpd.key 2048） [root@localhost ssl]# openssl req -new -key httpd.key -out httpd.csr [root@localhost ssl]# scp httpd.csr 192.168.4.163:/etc/pki/CA/certs/ （3）CentOS 7对收到的证书签证并返回 [root@localhost/etc/pki/CA/certs]#openssl ca -in httpd.csr -out httpd.crt -days 300 [root@localhost/etc/pki/CA/certs]#scp httpd.crt 192.168.4.132:/etc/httpd/conf/ssl （4）在CentOS 6上安装此 模块并修改配置文件 [root@localhost conf.d]# yum install -y mod_ssl [root@localhost conf.d]# vim ssl.conf （5）将证书拷贝到本地添加至浏览器中 当我们每次输入http://192.168.4.132时想要直接https://192.168.4.132访问网页怎么做呢？ 将http请求转发至https的URL，可以使用重定向 Redirect [status] URL-path URL status分类： Permanent:Returns a permanent redirect status(301) indicating that the resource has moved permanently Temp:Returns a temporary redirect status (302). This is the default 示例： Redirect temp / https://www.a.com/ Redirect permanent / https://www.a.com/ 注意：设置跳转时，根下的目录也会自动跳转。 [root@localhost conf.d]# vim custom.conf Redirect temp / https://192.168.4.132/ 测试 [root@localhost conf.d]# curl --cacert -L 192.168.4.132/ &lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt; &lt;html&gt;&lt;head&gt; &lt;title&gt;302 Found&lt;/title&gt; #由于之前我们已经介绍了状态码，所以看到302代表临时跳转。 &lt;/head&gt;&lt;body&gt; &lt;h1&gt;Found&lt;/h1&gt; &lt;p&gt;The document has moved &lt;a href=&quot;https://192.168.4.132/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;hr&gt; &lt;address&gt;Apache/2.2.15 (CentOS) Server at 192.168.4.132 Port 80&lt;/address&gt; &lt;/body&gt;&lt;/html&gt; （18）HSTS:HTTP Strict Transport Security 如果我们使用HTTPS 访问一个网站，我们大多数情况习惯按http://这样的方式去访问，在配置文件中添加Redirect temp / https:// 或Redirect permanent / https://这种方式解决；其工作方式如下 当浏览器第一次发出HTTP请求时是明文发送的，这种容易被攻击者拦截下来，攻击者作为代理，把当前请求转发至钓鱼网站，钓鱼网站返回假冒的网页内容，攻击者把假冒的网页返回给浏览器；如下图 为了解决这个文件就有人提出了HSTS方案：服务器端配置支持HSTS后，会在给浏览器返回的HTTP首部中携带HSTS字段。浏览器获取到该信息后，会将所有HTTP访问请求在内部做307跳转到HTTPS，而无需任何网络过程；从而使得中间人攻击失效。 如何设置HSTS呢？ Strict-Transport-Security: [; includeSubDomains][; preload] max-age：过期时间，默认单位为秒，你每次访问它都会在访问时间之后的值时间。 includeSubDomains：是可选参数，如果包含它意味着当前域名或子域均开启HSTS保护 preload：是可选参数，只有当你申请将自己的加入到浏览器内置列表的时候才需要使用到它。 重定向的另外一种方式：使用模块mod_rewrite 在使用这种方式之前我们先确认mod_rewrite是否被加载 格式： 示例 Header always set Strict-Transport-Security &quot;max-age=15768000&quot; RewriteEngine on #是否开启重启引擎 RewriteRule ^(/.*)$ https://%{HTTP_HOST}$1 [redirect=301] （19）httpd自带的工具程序 ab命令：压力测试工具 usage：ab [OPTIONS] URL -n：总请求数 -c：模拟的并行数 -k：以持久连接模式测试 htpasswd：基于认证basci时，用到的账户密码文件生成工具 usage： htpasswd [ -c ] [ -m ] [ -D ] passwdfile username -c：如果passwdfile文件不存在使用 -D：删除用户 -m：使用md5加密，默认 -s：使用SHA格式加密]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>HTTP安装及配置文件介绍</category>
      </categories>
      <tags>
        <tag>httpd，配置文件，认证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache分析工具和日志管理工具]]></title>
    <url>%2F2017%2F11%2F28%2FApache%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%92%8C%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[一、cronologcronolog 是一个简单的过滤程序，读取日志文件条目从标准输入和输出的每个条目并写入指定的日志文件的文件名模板和当前的日期和时间。cronolog 旨在和一个Web服务器一起使用，如Apache，分割访问日志为每天或每月的日志。 1、cronolog特点cronolog主要和web服务器配置使用，特别是apache服务器；apache默认日志文件是不分割的，因此如果我们要查找某天的内容会浏览一个整体文件去寻找，显然降低了我们的工作效率。cronolog可以将日志文件按时间分隔，易于管理和分析。 https://directory.fsf.org/wiki/Cronolog 官网，不过点击下载跳转至别的页面了…. 注意：在进行日志前首先更新下系统时间，以免当我们分析日志时，日志记录的时间是错误的。 [root@localhost~]#yum install -y ntpdate[root@localhost~]#ntpdate 172.18.0.1 #更新时间指令 2、源码安装cronolog（1）编译前先准备好编译环境 [root@localhost/usr/local/src/cronolog-1.6.2]#yum groupinstall -y &quot;development tools&quot; （2）编译安装 [root@localhost/usr/local/src/cronolog-1.6.2]#./configure [root@localhost/usr/local/src/cronolog-1.6.2]#make &amp;&amp; make install [root@localhost~]#which cronolog /usr/local/sbin/cronolog #查看命令路径 3、cronolog命令[root@localhost~]#cronolog -h 格式： usage: cronolog [OPTIONS] logfile-spec 选项 说明 -H NAME, –hardlink=NAME maintain a hard link from NAME to current log -S NAME, –symlink=NAME maintain a symbolic link from NAME to current log -P NAME, –prev-symlink=NAME maintain a symbolic link from NAME to previous log -l NAME, –link=NAME same as -S/–symlink -h, –help print this help, then exit -p PERIOD, –period=PERIOD set the rotation period explicitly -d DELAY, –delay=DELAY set the rotation period delay -o, –once-only create single output log from template (not rotated) -x FILE, –debug=FILE write debug messages to FILE ( or to standard error if FILE is “-“) -a, –american American date formats -e, –european European date formats (default) -s, –start-time=TIME starting time -z TZ, –time-zone=TZ use TZ for timezone -V, –version print version number, then exit 注意：cronolog一般采取管道的方式工作。 4、cronolog格式定义时间定义： 选项 说明 H 小时（00..23） I 小时(01..12) p 该locale下的AM或PM标识 M 分钟(00..59) S 秒 (00..61, which allows for leap seconds) X 该locale下时间表示符(e.g.: “15:12:47”) Z 时区。若时区不能确定，则无意义 a 该locale下的工作日简名(e.g.: Sun..Sat) A 该locale下的工作日全名(e.g.: Sunday .. Satur-ay) b 该locale下的月份简称(e.g.: Jan .. Dec) B 该locale下的月份全称(e.g.: January .. December) c 该locale下的日期和时间(e.g.: “Sun Dec 15 14:12:47 GMT 1996”) d 当月中的天数 (01 .. 31) j 当年中的天数 (001 .. 366) m 月数 (01 .. 12) U 当年中的星期数，以周日作为一周开始,其中第一周为首个含星期天的星期(00..53) W 当年中的星期数，以星期一作为一周的开始,其中第一周为首个含星期天的星期(00..53) w 工作日数(0 .. 6, 0表示星期天) x 该locale下的日期表示(e.g. “13/04/97”) y 两位数的年份(00 .. 99) Y 四位数的年份(1970 .. 2038) 5、cronolog结合apache使用编辑配置文件，也可以单独定义某个虚拟主机的日志[root@localhost~]#vim /etc/httpd/conf/httpd.conf 重启服务并测试[root@localhost~]#ab -c 10 -n 1000 http://www.test.com/ 查看是否生成日志文件 二、AWstat工具Awstats是一个免费非常简洁而且强大有个性的网站日志分析工具。 1、AWstat优势（1）界面友好：可以根据浏览器直接调用相关语言界面 （2）基于perl：解决了跨平台问题；分析日志直接支持apache格式 （3）效率比较高 （4）配置、定制方便 （5）提供了很多扩展参数统计功能 2、AWstat运行原理apache将访问情况记录到日志中，AWstats每次执行更新时读取这些日志，分析日志数据；将结果存储到数据库中（纯文本）。最后AWstats提供一个cgi程序通过web页面显示数据库中所统计的数据。 3、源码编译安装AWstat下载地址：http://www.awstats.org/#DOWNLOAD （1）源码编译安装AWstat [root@localhost/usr/local]#tar xf awstats-7.6.tar.gz [root@localhost/usr/local]#mv awstats-7.6 awstats [root@localhost/usr/local]#cd awstats/ 注意：此处需在/usr/local目录下安装 （2）修改文件权限 [root@localhost/usr/local/awstats]#chmod -R +x tools/* [root@localhost/usr/local/awstats]#chmod -R +x wwwroot/cgi-bin/* [root@localhost/usr/local/awstats]#chown -R root.root /usr/local/awstats 由于上传文件是不是以root身份，否则后面*.pl将无法运行。 （3）创建所需目录 [root@localhost/usr/local/awstats]#mkdir /etc/awstats #存放站点日志分析的配置文件 （4）生成AWstats配置文件 [root@localhost/usr/local/awstats/tools]#./awstats_configure.pl ----- AWStats awstats_configure 1.0 (build 20140126) (c) Laurent Destailleur ----- This tool will help you to configure AWStats to analyze statistics for one web server. You can try to use it to let it do all that is possible in AWStats setup, however following the step by step manual setup documentation (docs/index.html) is often a better idea. Above all if: - You are not an administrator user, - You want to analyze downloaded log files without web server, - You want to analyze mail or ftp log files instead of web log files, - You need to analyze load balanced servers log files, - You want to &apos;understand&apos; all possible ways to use AWStats... Read the AWStats documentation (docs/index.html). -----&gt; Running OS detected: Linux, BSD or Unix -----&gt; Check for web server install Enter full config file path of your Web server. Example: /etc/httpd/httpd.conf Example: /usr/local/apache2/conf/httpd.conf Example: c:\Program files\apache group\apache\conf\httpd.conf Config file path (&apos;none&apos; to skip web server setup): &gt; /etc/httpd/conf/httpd.conf - This file does not exists. Config file path (&apos;none&apos; to skip web server setup): &gt; /etc/httpd/conf/httpd.conf #输入web服务配置文件的地址，如果是Nginx输入“none” -----&gt; Check and complete web server config file &apos;/etc/httpd/conf/httpd.conf&apos; Add &apos;Alias /awstatsclasses &quot;/usr/local/awstats/wwwroot/classes/&quot;&apos; Add &apos;Alias /awstatscss &quot;/usr/local/awstats/wwwroot/css/&quot;&apos; Add &apos;Alias /awstatsicons &quot;/usr/local/awstats/wwwroot/icon/&quot;&apos; Add &apos;ScriptAlias /awstats/ &quot;/usr/local/awstats/wwwroot/cgi-bin/&quot;&apos; Add &apos;&lt;Directory&gt;&apos; directive AWStats directives added to Apache config file. -----&gt; Update model config file &apos;/usr/local/awstats/wwwroot/cgi-bin/awstats.model.conf&apos; File awstats.model.conf updated. -----&gt; Need to create a new config file ? Do you want me to build a new AWStats config/profile file (required if first install) [y/N] ? y #是否创建一个新的配置文件 -----&gt; Define config file name to create What is the name of your web site or profile analysis ? Example: www.mysite.com Example: demo Your web site, virtual server or profile name: &gt; www.test.com #网站域名名称 -----&gt; Define config file path In which directory do you plan to store your config file(s) ? Default: /etc/awstats Directory path to store config file(s) (Enter for default): &gt; #配置文件存放在哪个位置，这里选择默认即可；回车 -----&gt; Create config file &apos;/etc/awstats/awstats.www.test.com.conf&apos; Config file /etc/awstats/awstats.www.test.com.conf created. -----&gt; Restart Web server with &apos;/sbin/service httpd restart&apos; Redirecting to /bin/systemctl restart httpd.service -----&gt; Add update process inside a scheduler Sorry, configure.pl does not support automatic add to cron yet. You can do it manually by adding the following command to your cron: /usr/local/awstats/wwwroot/cgi-bin/awstats.pl -update -config=www.test.com Or if you have several config files and prefer having only one command: /usr/local/awstats/tools/awstats_updateall.pl now Press ENTER to continue... #提示不能自动加入crontab任务，需要稍后自己添加，回车即可 A SIMPLE config file has been created: /etc/awstats/awstats.www.test.com.conf You should have a look inside to check and change manually main parameters. You can then manually update your statistics for &apos;www.test.com&apos; with command: &gt; perl awstats.pl -update -config=www.test.com You can also read your statistics for &apos;www.test.com&apos; with URL: &gt; http://localhost/awstats/awstats.pl?config=www.test.com Press ENTER to finish... #提示配置文件创建完成，回车即可 （5）修改刚生成的配置文件 [root@localhost/etc/awstats]#vim awstats.www.test.com.conf 50 LogFile=&quot;/var/log/httpd/access_log&quot; 此选项的位置必须和http位置一致 156 SiteDomain=&quot;www.test.com&quot; 此选项设置站点域名 171 HostAliases=&quot;test.com www.test.com 127.0.0.1 localhost&quot; 此选项设置主机别名 220 DirData=&quot;/var/lib/awstats&quot; 此选项设置存放日志数据的位置 （6）修改httpd.conf文件 [root@localhost/etc/awstats]#vim /etc/httpd/conf/httpd.conf 如果apache是2.2版本如下格式366 &lt;Directory &quot;/usr/local/awstats/wwwroot&quot;&gt; 367 Options None 368 AllowOverride None 369 Order allow,deny 370 Allow from all 371 &lt;/Directory&gt; 如果apache是2.4版本如下格式366 &lt;Directory &quot;/usr/local/awstats/wwwroot&quot;&gt; 367 Options None 368 AllowOverride None 369 Require all granted 370 &lt;/Directory&gt; 上述根据自己的实际情况进行修改 （7）重启http服务 [root@localhost~]#systemctl restart httpd （8）创建存放日志数据信息目录 [root@localhost/usr/local/awstats]#mkdir /var/lib/awstats [root@localhost~]#chmod 755 /var/lib/awstats/#修改权限 （9）更新awstats数据库 语法： Syntax: awstats.pl -config=virtualhostname [options] 注意： 配置文件 (awstats.virtualhostname.conf or awstats.conf) 必须在/etc/awstats,/usr/local/etc/awstats, /etc 或 same directory than awstats.pl script file. 如果AWSTATS_FORCE_CONFIG环境变量被定义，AWstat将使用定义环境变量作为配置值。 [root@localhost~]#/usr/local/awstats/wwwroot/cgi-bin/awstats.pl -update -config=www.test.com Create/Update database for config &quot;/etc/awstats/awstats.www.test.com.conf&quot; by AWStats version 7.6 (build 20161204) From data in log file &quot;/var/log/httpd/access_log&quot;... Phase 1 : First bypass old records, searching new record... Searching new records from beginning of log file... Jumped lines in file: 0 Parsed lines in file: 0 Found 0 dropped records, Found 0 comments, Found 0 blank records, Found 0 corrupted records, Found 0 old records, Found 0 new qualified records. （10）测试 http://192.168.4.65/awstats/awstats.pl?config=www.test.com 小结： （1）AWstats数据库不能及时更新，如果想定时更新可以写计划任务。 （2）安装过程中可能会访问时出现403错误，可能是权限不够，看看/var/lib/awstat1目录权限 （3）AWstat工作时基于apache日志工作的，配置文件的日志目录与apache中的日志路径相同 （4）在生成配置文件时必须在/usr/local/awstat目录下创建，否则会报错找不到路径 如果配置多站点监控？- 和上述配置的过程一样。 [root@localhost/usr/local/awstats/tools]#ls /etc/awstats/ awstats.www.test2.com.conf awstats.www.test.com.conf 三、ASstats扩展1、ASstats默认是不显示访客的国家的，若果需要可以添加插件http://geolite.maxmind.com/download/geoip/database 下载地址 GeoIP 是国家数据 GeoLiteCity 是城市数据 GeoIPASNum 是组织数据 （1）安装过程 [root@localhost~]#gunzip GeoIP.dat.gz [root@localhost~]#gunzip GeoLiteCity.dat.gz [root@localhost~]#mkdir /var/GeoIP [root@localhost~]#mv Geo* /var/GeoIP [root@localhost~]#cd /var/GeoIP [root@localhost/var/GerIP/GeoIP-1.4.8]#tar xf GeoIP-1.4.8.tar.gz 编译安装GeoIP[root@localhost/var/GerIP/GeoIP-1.4.8]#yum install -y zlib-devel [root@localhost/var/GerIP/GeoIP-1.4.8]#./configure ;make &amp;&amp; make install 编译安装Geo-IP[root@localhost/var/geoip/Geo-IP-1.40]#yum install perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker [root@localhost/var/geoip/Geo-IP-1.40]#perl Makefile.PL LIBS=&#39;-L/usr/local/lib&#39; [root@localhost/var/geoip/Geo-IP-1.40]#make &amp;&amp; make install 修改AWstats配置文件[root@localhost/var/geoip-city]#vim /etc/awstats/awstats.www.test.com.conf 1460 LoadPlugin=&quot;geoip GEOIP_STANDARD /var/geoip/GeoIP.dat&quot; 1466 LoadPlugin=&quot;geoip_org_maxmind GEOIP_STANDARD /var/genip/GeoIPOrg.dat&quot; 1479 LoadPlugin=&quot;geoip_city_maxmind GEOIP_STANDARD /var/geoip/GeoIPCity.dat&quot; 测试（2）中文乱码问题 [root@localhost~]#vim /etc/awstats/awstats.www.test.com.conf #LoadPlugin=&quot;decodeutfkeys&quot; #1300 行 LoadPlugin=&quot;decodeutfkeys&quot; 不过修改编码以后还会出错缺少perl的URI模块，下面是解决方法： [root@localhost/usr/local/src]#tar xf URI-1.60.tar.gz [root@localhost/usr/local/src]#cd URI-1.60/ [root@localhost/usr/local/src/URI-1.60]#perl Makefile.PL [root@localhost/usr/local/src/URI-1.60]#make &amp;&amp; make install 小结： 显示国家扩展模块安装时有顺序的 GeoIP C库--&gt;Geo-IP perl库]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>Apache分析工具和日志管理工具</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP的工作机制]]></title>
    <url>%2F2017%2F11%2F28%2FHTTP%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[HTTP的工作机制当我们去访问一个网站是一个网页并不是单单的一个资源，是由多个资源展示出来；每个资源都要单独的请求。 现在我们需要区分两个概念静态文件和动态文件 静态文件：无需服务端做出额外处理，说白了就是写死的，任何人访问此资源时，都显示同一个页面内容。文件后缀：.jpg .html .txt .js .css .mp3 .avi 动态文件：服务端执行程序之后，返回执行结果。说白了就是不同的人、不同时候访问此页面，显示的内容可能不同。文件后缀：.asp .php .jsp 非持久连接和持久连接 非持久连接：一个请求与服务器连接传输完成之后，端口。如果下一个请求过来，再建立连接。 缺点 (1)客户为每个待请求的对象建立并维护一个新得连接。对于每个这个的连接，TCP必须同时在客户端和服务器端分配TCP缓冲区，并维护TCP变量。对于有可能同时为来自数百个不同客户的请求提供服务的Web服务器来说，这会严重增加服务器的负担； (2)对每个对象请求都有2个RTT(Round-Trip Time 往返时延)的响应延迟：一个RTT用于建立TCP连接，另一个RTT用于请求和接收对象；http://blog.csdn.net/jackywangjia/article/details/27643379 (3)每个对象都要经历 TCP 缓启动，因为每个TCP连接都要起始于slow start 阶段。并行TCP连接的使用能够部分减轻RTT延迟和缓启动的影响。 持久连接：当完成一次请求之后，服务器在发出响应后让TCP连接继续打开着。同一对客户/服务器之间的后续请求和响应可以通过这个连接发送。 缺点：服务器送出一个对象后开始等待下一个请求，而这个新请求却不能马上到达。这段时间服务器资源便闲置了。 如何提高HTTP连接性能呢？ 并行连接：通过多条TCP连接发起并发的HTTP请求 持久连接：keep-alive,长连接，重用TCP连接，以消除连接和关闭的时延,以事务个数和时间来决定是否关闭连接 管道化连接：通过共享TCP连接发起并发的HTTP请求 复用的连接：交替传送请求和响应报文（实验阶段） Web响应模型介绍 单进程I/O模型：启动一个进程处理用户请求，而且一次只处理一个，当发出多个请求时，被串联响应。 多进程I/O模型：并行启动多个进程，每个进程响应一个连接请求。 复用I/O请求：启动一个进程，同时响应N个连接请求。 复用多进程I/O模型：启动M个进程，每个进程响应N个请求，同时接受M*N个请求。]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>HTTP的工作机制</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP请求报文]]></title>
    <url>%2F2017%2F11%2F28%2FHTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%2F</url>
    <content type="text"><![CDATA[HTTP请求报文在之前我们介绍了Web请求的过程里面说了当Client向Serve发送建立请求时即发送请求报文。Server处理完成之后向Client发送响应报文，即响应报文。下面我们来具体说说这两个的结构。 请求报文语法格式： &lt;Method&gt;&lt;Request-URL&gt;&lt;VERSION&gt; &lt;Headers&gt; &lt;Entity-body&gt; 响应报文语法格式： &lt;Version&gt;&lt;Status-code&gt;&lt;Reson-phrase&gt; &lt;Headers&gt; &lt;Entity-body&gt; 具体解释说明 method方法类型： method方法类型 说明 GET 从服务器获取一个资源 HEAD 只从服务器获取文档的响应头部 POST 向服务器输入数据，通常会再由网关程序继续处理 PUT 将请求的主体部分存储在服务器上，如上传文件 DELETE 请求删除服务器上指定的文档 TRACE 追踪请求到达服务器中间经过的代理服务器 OPTIONS 请求服务器返回对指定资源支持使用的请求方法 VERSION构成： HTTP/&lt;major&gt;.&lt;minor&gt; Header 每个请求或响应报文可包含任意首部；每个首部都有首部名称，后面跟一个冒号，而后跟一个可选空格，接着一个值。 Entity-body 请求时附加的数据或响应时附加的数据 Reson-phrase 状态码所标记状态简要描述 状态码种类 HTTP状态码分类 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 状态码详解说明 状体码 描述 简要描述 200 成功，请求数据通过响应报文的Eentity-body部分发送 ok 301 请求的URL指向的资源已经删除；但在响应报文中通过首部Location指明了资源现有资源所处的新位置 Moved Permanently 302 响应报文Location指明资源临时位置 Moved Temporarily 304 客户端发出了条件式请求，但服务器上的资源未曾发生改变，则通过此响应状态码通知客户端 Not Modified 401 需要填入账号和密码认证才能访问资源 Unautorized 403 访问被禁止 Forbidden 404 服务器无法找到客户端请求资源 Not Found 500 服务器内部错误 Internal Server Error 502 代理服务器从后端服务器收到了一条伪响应，如无法连接网关 Bad Gateway 503 服务不可用，临时服务器维护或过载，服务器无法处理请求 Service Unavailable 504 网关超时 Gateway Timeout 505 服务器不支持请求的HTTP协议的版本，无法完成处理 HTTP Version Not Support 示例： [root@localhost ~]# curl -i www.360buy.com #响应报文示例 HTTP/1.1 301 Moved Permanently Age: 2822 Content-Type: text/html Date: Thu, 28 Sep 2017 13:23:54 GMT Location: http://www.jd.com/ Server: JDWS Via: BJ-H-NX-112(), http/1.1 LA-1-JCS-40 ( [cRs f ]) Content-Length: 272 &lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt; &lt;body bgcolor=&quot;white&quot;&gt; &lt;h1&gt;301 Moved Permanently&lt;/h1&gt; &lt;p&gt;The requested resource has been assigned a new permanent URI.&lt;/p&gt; &lt;hr/&gt;Server: JDWS&lt;/body&gt; &lt;/html&gt; http协议头部 通用首部 首部信息 说明 Date 报文的创建时间 Connnection 连接状态，如keep-alive，close Via 显示报文经过的中间节点 （代理、网关） Cache-Control 控制缓存，如缓存时长 MIME-Version 发送端使用的MIME版本 请求首部 请求首部信息 说明 Accept 通知服务器自己可接受的媒体类型 Accept-Charset 客户端可接受的字符集 Accept-Encoding 客户端可接受编码格式 Accept-Language 客户端可接受的语言 Client-IP 请求客户端IP Host 请求服务器名称和端口号 Referer 跳转至当前URL的前一个URL User-Agent 客户端代理，浏览器版本 条件式请求首部 条件请求首部信息 说明 Expect 允许客户端列出某请求所要求的服务器行为 If-Modified-Since 自从指定的时间之后，请求的资源是否发生过修改 If-Unmodified-Since 自从指定的时间之后，请求的资源是否没有发生过修改 If-None-Match 本地缓存中存储的文档的ETag标签是否与服务器文档的ETag不匹配 If-Match 本地缓存中的存储文档ETag标签是否与服务器文档的ETag匹配 安全请求首部 安全请求首部 说明 Authorization 向服务器发送认证信息，如账号和密码 Cookie 客户端向服务器发送cookie Cookie2 用于说明请求端支持的cookie版本 代理服务请求首部 Proxy-Authorization 向代理服务器认证 响应首部 响应首部信息 说明 Age 从最初创建开始响应持续时长 Server 服务器程序软件名称和版本 Accept-Ranges 服务器可接受的请求范围类型 Vary 服务器查看的其他首部列表 安全响应首部 安全首部信息 说明 Set-Cookie 向客户端设置cookie Set-Cookie 向客户端发送cookie2版本 WWW-Authenticate 来自服务器对客户端的质询列表 实体首部： 实体首部信息 说明 Allow 列出对此资源实体可使用的请求方法 Location 告诉客户端真正的实体位于何处 Content-Encoding 对主体执行的编码 Content-Language 文本使用的语言 Content-Location 实体真正所处的位置 Content-type 主体的对象类型 ETag 实体的扩展标签 Expires 实体的过期时间 Last-Modified 最后一次修改时间]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>HTTP请求报文</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Httpd-2.4特性]]></title>
    <url>%2F2017%2F11%2F28%2FHttpd-2.4%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[新特性 MPM支持运行为DSO机制，以模块形式按需加载 event MPM生产环境可用 异步读写机制 支持每模块及每目录的单独自制级别定义 每请求相关的专用配置 增强版的表达式分析式 毫秒级持久连接时长定义 基于FQDN的虚拟主机不需要NameVirtualHost指令 新指令，AllowOverList 支持用户自定义变量 更低的内存消耗 不再支持使用Order，Deny,Allow来做基于IP的访问控制新模块 httpd-2.4文件介绍-配置文件 /etc/httpd/conf/httpd/conf /etc/httpd/conf.d/*.conf 模块相关的配置文件 /etc/httpd/conf.modules.d/*.conf 系统启动文件 /usr/lib/systemd/system/httpd/service 主程序文件 /usr/sbin/httpdd 日志文件 /var/log/httpd/access_log /var/log/httpd/error_log 站点文档 /var/www/html 模块文件路径 /usr/lib64/httpd/moudles /etc/httpd/modules 相关设置介绍（1）切换使用MPM [root@localhost/etc/httpd/conf.modules.d]#vim 00-mpm.conf 如上图所示，如果要使用其他MPM将注释取消重启即可。 （2）认证方式 无明确授权的记录，默认拒绝 允许所有主机访问：Require all granted 拒绝所有主机访问：Require all denied 控制特定的IP访问 Require ip IPADDR :授权指定来源的IP访问 Require not ip IPADDR：拒绝特定的IP访问 控制特定的主机访问 Require host HOSTNAME :授权特定主机访问 Require not host HOSTNAME：拒绝特定主机访问 HOSTNAME: FQDN:特定主机 domain.tld：指定域名下的所有主机 使用示例 &lt;RequireAll&gt; Require all granted Require not ip 192.168.4.150 &lt;/RequireAll&gt; 不能又失败，至少有一个成功匹配。 &lt;RequireAny&gt; Require all deny Require not ip 192.168.4.150 &lt;/RequireAny&gt; 多个语句有一个成功，即成功优先。 （3）虚拟主机 注意：基于FQDN的虚拟主机也不需要NameVirtualHost指令 示例 &lt;VirtualHost *:80&gt; ServerName www.x.com DocumentRoot &quot;/app/www/x.com&quot; &lt;Document &quot;/app/www/x.com&quot;&gt; Option None AllowOverride None Require all granted &lt;/Document&gt; &lt;/VirtualHost&gt; 注意：任意目录下的页面只有显示授权才能被访问。 （4）Sendfile机制 不使用Sendfile的过程 1、系统调用read()产生一个上下文切换：从user mode 切换到Kernel mode，然后DMA(Direct Memory Access，直接内存存取)执行拷贝，把文件数据从硬盘读到一个Kernel buffer里。 2、数据从Kernel buffer拷贝到user buffer，然后系统调用read()返回，这时又产生一个上下文切换：从kernel mode 切换到user mode 3、系统调用write()产生一个上下文切换：从user mode 切换到kernel mode，然后把步骤2读到user buffer的数据拷贝到kernel buffer，不过关这次是相关联的。 4、系统调用write()返回，产生一个上下文切换：从Kernel mode 切换到User mode，然后DMA从kernel buffer拷贝数据到协议栈。 使用Sendfile机制过程 1、系统调用sendfile()通过DMA把硬盘数据拷贝到Kernel buffer，然后数据被kernel直接拷贝到另一个与socket相关的kernel buffer。这里没有user mode和kernel mode 之间的切换。在kernel中直接完成了从一个buffer到另一个buffer的拷贝。 2、DMA把数据从kernel buffer直接拷贝给协议栈，没有切换也不需要把数据从user mode拷贝到kernel mode，以为数据就在Kernel 里。 （5）方向代理功能 ProxyPass “/” &quot;http://www.example.com/&quot; ProxyPassReverse &quot;/&quot; &quot;http://www.example.com/&quot; 特定URL反向代理 ProxyPass “/image” &quot;http://www.example.com/&quot; ProxyPassReverse &quot;/image&quot; &quot;http://www.example.com&quot; 示例 &lt;VirtualHost *:80&gt; ServerName www.x.com ProxyPass / http://localhost:8080 ProxyPassReserver / http://localhost:8080 &lt;/VirtualHost&gt; 准备三台虚拟注意，CentOS 7 做web服务器，CentOS 7做代理服务器，另一台CentOS 6 做客户端 （5）APR（Apache Portalbe Run-time Libararies，Apache 可移植运行库） 主要为上层的应用程序提供一个可以跨越多操作系统平台使用的底层支持接口库。在早起的Apache版本中，应用程序本身必须能够处理各种具体操作系统平台的细节，并针对不同的平台调用不同的处理函数。]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>Httpd-2.4特性</category>
      </categories>
      <tags>
        <tag>httpd，2.4版本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP介绍]]></title>
    <url>%2F2017%2F11%2F28%2FHttpd%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[HTTP概念及相关术语1、概念HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 2、HTTP协议介绍 http/0.9 1991，原型版本，功能简陋，只有一个命令GET。GET /index.html ,服务器只能回应HTML格式字符串，不能回应别的格式 http/1.0 1996年5月,支持cache, MIME, method每个TCP连接只能发送一个请求，发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。（1）引入了POST命令和HEAD命令头信息是 ASCII 码，后面数据可为任何格式。服务器回应时会告诉客户端，数据是什么格式，即Content-Type字段的作用。这些数据类型总称为MIME 多用途互联网邮件扩展，每个值包括一级类型和二级类型，预定义的类型，也可自定义类型。 http/1.1 1997年1月（1）引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。对于同一个域名，大多数浏览器允许同时建立6个持久连接。（2）引入了管道机制（pipelining），即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率。新增方法：PUT、PATCH、OPTIONS、DELETE。 同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只能顺序处理回应，前面的回应慢，会有许多请求排队，造成”队头堵塞”（Head-of-line blocking）。为避免这种问题出现：一是减少请求数，二是同时多开持久连接。 网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等。 HTTP 协议不带有状态，每次请求都必须附上所有信息。请求的很多字段都是重复的，浪费带宽，影响速度Spdy：2009年,谷歌研发,解决 HTTP/1.1 效率不高问题。 http/2.0 2015年头信息和数据体都是二进制，称为头信息帧和数据帧。（1）复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免了“队头堵塞“,此双向的实时通信称为多工（Multiplexing）。（2）引入头信息压缩机制（header compression）,头信息使用gzip或compress压缩后再发送；客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，不发送同样字段，只发送索引号，提高速度。（3）HTTP/2 允许服务器未经请求，主动向客户端发送资源，即服务器推送（server push）。 3、MIME（Multiprocess Internet Mail Extensions）1、概念多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。 2、MIME类型 魔法分类：Apache web服务器可以扫描每个资源的内容，并将其与一个已知模式表(被称为魔法文件)进行匹配，以决定每个文件的MIME类型。这样做可能比较慢，但很方便，尤其是文件没有标准扩展名的时候 显式分类：可以对Web服务器进行配置，使其不考虑文件的扩展名或内容，强制特定文件或目录内容拥有某个MIME类型 类型协商： 有些Web服务器经过配置，可以以多种文档格式来存储资源。在这种情况下，可以配置Web服务器，使其可以通过与用户的协商来决定使用哪种格式(及相关的MIME类型)”最好” 3、MIME格式Content-Type: [type]/[subtype]; parameter type类型 类型 说明 Text 用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的； Multipart 用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据； Application 用于传输应用程序数据或者二进制数据； Message 用于包装一个E-mail消息； Image 用于传输静态图片数据； Audio 用于传输音频或者音声数据； Video 用于传输动态影像数据，可以是与音频编辑在一起的视频数据格式 subtype类型 subtype是用于指定type详细形式。 子类型 说明 text/plain 纯文本，文件扩展名.txt text/html HTML文，文件扩展名.html 或.htm application/xhtml+xml XHTML文 image/gif GIF图像 image/jpeg JPEG图像 image/png PNG图像 video/mpeg MPEG动画 application/octet-stream 任意的二进制数据 application/pdf PDF文档 application/msword Microsoft Word文件 application/vnd.wap.xhtml+xml wap1.0+ application/xhtml+xml wap2.0+ message/rfc822 RFC 822形式 multipart/alternative HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示 application/x-www-form-urlencoded 使用HTTP的POST方法提交的表单 multipart/form-data 同上，但主要用于表单提交时伴随文件上传的场合 parameter 可用来指定附加的信息，更多情况下是用于指定text/plain和text/html等的文字编码方式的charset参数。 Content-Transfer-Encoding: [mechanism] 内容传输编码，指定ASCII意外的字符编码方式，用来对附件进行解码。 编码格式 说明 7bit 用在US ASCII字符集上 8bit和binary 一般不使用 quoted printable 可读的标准文本，如果传输要经过对格式有影响的网关时对其进行保护 base64 通用方法，通常在二进制中，非文本数据 如果想查看MIME的类型可以查看文件/etc/mime.types 4、URI统一资源标识符（Uniform Resource Identifier，或URI）是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对网络中（一般指万维网）的资源通过特定的协议进行交互操作。分为两种URL（Uniform Resource Location）和URN（Uniform Resource Name）。URL用于描述某服务器某特定资源位置。URN其目的是通过提供一种途径，用于在特定的命名空间资源的标识，以补充网址并不指定地址。说白了URL就是一个人的住址，URN是一个人的名字。URN定义某事物的身份，而URL提供查找该事物的方法。 URL组成 hierarchical part ┌───────────────────┴─────────────────────┐ authority path ┌───────────────┴───────────────┐┌───┴────┐ abc://username:password@example.com:123/path/data?key=value&amp;key2=value2#fragid1 └┬┘ └───────┬───────┘ └────┬────┘ └┬┘ └─────────┬─────────┘ └──┬──┘ scheme user information host port query fragment urn:example:mammal:monotreme:echidna └┬┘ └──────────────┬───────────────┘ scheme path 解释 种类 说明 scheme 方案，访问服务器以获取资源时要使用哪种协议 user 用户，某些方案访问资源时需要用户名 password 用户对应的密码；user:password host 资源宿主机主机名或IP地址 part 资源宿主机正在监听的端口号，很多方案都有默认的端口号 path 服务器资源的本地名，有一个/将其与前面的URL组件分割 params 指定输入的参数，参数为名/值对，用“；”分隔 query 查询，传递参数给程序，用”?”分隔，多个查询使用“&amp;”分隔 frag 片段，一小片或一部分资源的名字，此组件在客户端使用，用“#”分隔 示例： http://www.test.com:8080/images/logo.jpg ftp://xiaoming:password@192.168.4.150/pub/linux.ppt rtsp://videoserver/video_demo/Real Time Streaming Protocol http://wwwtest.com/bbs/hello;gender=f/send;type=title https://list.jd.com/list.html?cat=670,671,672&amp;ev=149 _2992&amp;sort=sort_totalsales15_desc&amp;trans=1 http://apache.org/index.html#projects-list]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>Httpd</category>
      </categories>
      <tags>
        <tag>HTTP，https，web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LAMP源码编译安装]]></title>
    <url>%2F2017%2F11%2F28%2FLAMP%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[编译安装LAMP环境在实际环境中我们经常根据自己所处的公司环境进行配置，适合自己公司的配置。下面我们来介绍如何进行编译安装 安装前提在CentOS7 系统: 关闭iptables 将selinux设置为disabled apr-1.6.2.tar.gz httpd-2.4.27.tar.bz2 php-7.1.10.tar.xz apr-util-1.6.0.tar.gz mariadb-10.2.8-linux-x86_64.tar.gz wordpress-4.8.1-zh_CN.tar.gz 安装工具包development tools 注意：这里安装需要按顺序进行的mariadb–&gt;httpd–&gt;php，mariadb和httpd安装顺序没有关系 源码编译httpd服务在之前的apache博客中讲过为什么要安装apr和apr-util包，如果不懂请查看apache博客。 （1）源码编译安装apr[root@localhost/usr/local/src]#tar xvf apr-1.6.2.tar.gz[root@localhost/usr/local/src/apr-1.6.2]#./configure --prefix=/app/apr[root@localhost/usr/local/src/apr-1.6.2]#make &amp;&amp; make install （2）源码编译安装apr-util[root@localhost/usr/local/src]#tar xf apr-util-1.6.0.tar.gz[root@localhost apr-util-1.6.0]# yum install -y expat-devel[root@localhost/usr/local/src/apr-util-1.6.0]#./configure --prefix=/app/apr-util --with-apr=/app/apr[root@localhost/usr/local/src/apr-util-1.6.0]#make &amp;&amp; make install （3）源码安装httpd首先确认系统上是否有apache用户，如果没有需要创建 [root@localhost/usr/local/src]#useradd -r -m -d /app/website -s /sbin/nologin apache[root@localhost/usr/local/src]#tar xf httpd-2.4.27.tar.bz2 在编译安装httpd之前需要安装几个依赖包 [root@localhost/usr/local/src/httpd-2.4.27]#yum install -y pcre-devel apr-devel apr-util-devel openssl-devel [root@localhost/usr/local/src/httpd-2.4.27]#./configure --prefix=/app/httpd24 --enable-so --enable-ssl --enable-cgi --enable-rewrite --with-zlib --with-pcre --with-apr=/app/apr/ --with-apr-util=/app/apr-util/ --enable-modules=most --enable-mpms-shared=all --with-mpm=prefork [root@localhost/usr/local/src/httpd-2.4.27]#make -j 4 &amp;&amp; make install （4）设置环境变量[root@localhost/etc/profile.d]#vim httpd24.sh export PATH=/app/httpd24/bin:$PATH [root@localhost/etc/profile.d]#source httpd24.sh （5）设置man手册位置[root@localhost/etc]#vim /etc/man_db.conf 23 MANDATORY_MANPATH /app/httpd24/man （6）配置启动脚本[root@localhost/app/httpd24]#cp bin/apachectl /etc/init.d/httpd24 （7）测试服务是否正常启动已经监听80端口说明可以启动 http://192.168.4.60/ ###二进制安装mariadb（1）二进制安装mariadb[root@localhost/usr/local]#useradd -r -m -d /app/mysqldb -s /sbin/nologin mysql[root@localhost/usr/local/src]#tar xf mariadb-10.2.8-linux-x86_64.tar.gz -C /usr/local/[root@localhost/usr/local]#ln -sv mariadb-10.2.8-linux-x86_64/ mysql （2）添加环境变量[root@localhost/etc/profile.d]#vim mysql.sh PATH=/usr/local/mysql/bin:$PATH （3）配置man手册[root@localhost/usr/local/mysql/bin]#vim /etc/man_db.conf 24 MANDATORY_MANPATH /usr/local/mysql/man （4）创建启动脚本 [root@localhost/usr/local/mysql]#cp support-files/mysql.server /etc/init.d/mysqld[root@localhost/usr/local/mysql]#chkconfig --add mysqld （5）配置主配置文件[root@localhost/usr/local/mysql]#mkdir /etc/mysql[root@localhost/usr/local/mysql]#cp support-files/my-large.cnf /etc/mysql/my.cnf[root@localhost/usr/local/mysql]#vim /etc/mysql/my.cnf 27 [mysqld] 28 datadir = /app/mysqldb （6）创建日志目录[root@localhost/usr/local/mysql]#mkdir /var/log/mariadb[root@localhost/usr/local/mysql]#setfacl -Rm u:mysql:rwx /var/log/mariadb/（7）安装数据库[root@localhost/usr/local/mysql]#scripts/mysql_install_db --user=mysql --datadir=/app/mysqldb （8）初始化数据库[root@localhost~]#mysql_secure_installation（9）测试数据库是否安装成功 [root@localhost~]#mysql -u root -p MariaDB [(none)]&gt; CREATE DATABASE wpdb; Query OK, 1 row affected (0.00 sec) MariaDB [(none)]&gt; GRANT ALL ON wpdb.* TO &apos;joah&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;; Query OK, 0 rows affected (0.00 sec) MariaDB [(none)]&gt; GRANT ALL ON wpdb.* TO &apos;joah&apos;@&apos;127.0.0.1&apos; IDENTIFIED BY &apos;123456&apos;; 源码安装php（1）解压缩并编译安装[root@localhost/usr/local/src/php-7.1.10]#yum install -y libxml2-devel bzip2-devel libmcrypt-devel[root@localhost/usr/local/src/php-7.1.10]#./configure --prefix=/app/php --enable-mysqlnd -- with-mysqli=mysqlnd --with-openssl --with-pdo-mysql=mysqlnd --enable-mbstring --with freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml --enable-sockets -- with-apxs2=/app/httpd24/bin/apxs --with-mcrypt -- with-config-file-path=/etc --with-config-file-scan-dir=/etc/php.d --enable-maintainer-zts --disable-fileinfo[root@localhost/usr/local/src/php-7.1.10]#make &amp;&amp; make install（2）配置主配置文件[root@localhost/usr/local/src/php-7.1.10]#cp php.ini-production /etc/php.ini（3）修改/etc/httpd/conf/httpd.conf 259 &lt;IfModule dir_module&gt; 260 DirectoryIndex index.php index.html 261 &lt;/IfModule&gt; 512 AddType Application/x-httpd-php .php 513 AddType Application/x-httpd-php-source .phps （4）测试能否与httpd连接成功[root@localhost/app/httpd24/htdocs]#vim index.php 1 &lt;?php 2 phpinfo(); 3 ?&gt; （5）测试是否能否可以和mariadb连接成功[root@localhost/app/httpd24/htdocs]#vim index.php &lt;?php $mysqli=new mysqli(&quot;localhost&quot;,&quot;root&quot;,&quot;centos&quot;); if(mysqli_connect_errno()){ echo &quot;连接数据库失败!&quot;; $mysqli=null; exit; } echo &quot;连接数据库成功!&quot;; $mysqli-&gt;close(); phpinfo(); ?&gt; 安装wordpress（1）解压缩[root@localhost/usr/local/src]#tar xf wordpress-4.8.tar.gz -C /app/httpd24/htdocs （2）配置主配置文件[root@localhost/app/httpd24/htdocs/wordpress]#cp wp-config-sample.php wp-config.php[root@localhost/app/httpd24/htdocs/wordpress]#vim wp-config.php 23 define(&apos;DB_NAME&apos;, &apos;wpdb&apos;); 24 25 /** MySQL database username */ 26 define(&apos;DB_USER&apos;, &apos;joah&apos;); 27 28 /** MySQL database password */ 29 define(&apos;DB_PASSWORD&apos;, &apos;123456&apos;); 30 31 /** MySQL hostname */ 32 define(&apos;DB_HOST&apos;, &apos;localhost&apos;); http://192.168.4.59/wordpress/wp-admin/setup-config.php 测试其性能如何[root@localhost/app/httpd24/htdocs/wordpress]#ab -c 10 -n 100 http://192.168.4.60/wordpress/ HTML transferred: 5209700 bytes Requests per second: 25.25 [#/sec] (mean) #在没有加速器性能还不错 Time per request: 396.061 [ms] (mean) CentOS 6 源码编译安装前环境准备 apr-1.6.2.tar.gz httpd-2.4.27.tar.bz2 php-5.6.31.tar.xz xcache-3.2.0.tar.bz2 apr-util-1.6.0.tar.gz mariadb-5.5.57-linux-x86_64.tar.gz wordpress-4.8.1-zh_CN.tar.gz 二进制安装mariadb（1）二进制安装mariadb[root@localhost/usr/local]#useradd -r -m -d /app/mysqldb -s /sbin/nologin mysql[root@localhost/usr/local/src]#tar xf mariadb-10.2.8-linux-x86_64.tar.gz -C /usr/local/[root@localhost/usr/local]#ln -sv mariadb-10.2.8-linux-x86_64/ mysql （2）添加环境变量[root@localhost/etc/profile.d]#vim mysql.sh PATH=/usr/local/mysql/bin:$PATH （3）配置man手册[root@localhost/usr/local/mysql/bin]#vim /etc/man_db.conf 24 MANDATORY_MANPATH /usr/local/mysql/man （4）创建启动脚本 [root@localhost/usr/local/mysql]#cp support-files/mysql.server /etc/init.d/mysqld[root@localhost/usr/local/mysql]#chkconfig --add mysqld （5）配置主配置文件[root@localhost/usr/local/mysql]#mkdir /etc/mysql[root@localhost/usr/local/mysql]#cp support-files/my-large.cnf /etc/mysql/my.cnf[root@localhost/usr/local/mysql]#vim /etc/mysql/my.cnf 27 [mysqld] 28 datadir = /app/mysqldb （6）创建日志目录[root@localhost mysql]# touch /var/log/mysqld.log （7）安装数据库[root@localhost/usr/local/mysql]#scripts/mysql_install_db --user=mysql --datadir=/app/mysqldb （8）初始化数据库 [root@localhost~]#mysql_secure_installation （9）测试数据库是否安装成功 [root@localhost~]#mysql -u root -p MariaDB [(none)]&gt; CREATE DATABASE wpdb; Query OK, 1 row affected (0.00 sec) MariaDB [(none)]&gt; GRANT ALL ON wpdb.* TO &apos;joah&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;; Query OK, 0 rows affected (0.00 sec) MariaDB [(none)]&gt; GRANT ALL ON wpdb.* TO &apos;joah&apos;@&apos;127.0.0.1&apos; IDENTIFIED BY &apos;123456&apos;; 编译安装httpd服务（1）解压缩httpd源码包[root@localhost httpd-2.4.27]# yum install -y apr-devel apr-util-devel openssl-devel pcre-devel[root@localhost httpd-2.4.27]# tar xf apr-1.6.2.tar.gz[root@localhost httpd-2.4.27]# tar xf apr-util-1.6.0.tar.gz[root@localhost httpd-2.4.27]# mv apr-1.6.2 httpd-2.4.27/srclib/[root@localhost httpd-2.4.27]# mv apr-util-1.6.0 httpd-2.4.27/srclib/apr-util[root@localhost httpd-2.4.27]# ./configure --prefix=/app/httpd24 --enable-so --enable-ssl --enable-rewrite --with-zlib --with-pcre --with-included-apr --enable-modules=most --enable-mpms-shared=all --with-mpm=prefork[root@localhost httpd-2.4.27]# make &amp;&amp; make install （2）配置环境变量 [root@localhost httpd24]# vim /etc/profile.d/httpd24.sh PATH=/app/httpd24/bin:$PATH（3）配置启动脚本 [root@localhost httpd24]# cp /etc/init.d/httpd /etc/init.d/httpd24[root@localhost httpd24]# vim /etc/init.d/httpd24 apachectl=/app/httpd24/bin/apachectl httpd=${HTTPD-/app/httpd24/bin/apachectl} prog=httpd pidfile=${PIDFILE-/app/httd24/logshttpd.pid} lockfile=${LOCKFILE-/var/lock/subsys/httpd24} RETVAL=0 STOP_TIMEOUT=${STOP_TIMEOUT-10} （4）测试是否配置成功 [root@localhost httpd24]# service httpd24 start 编译安装php安装方式一：基于php模块安装（1）解压缩并编译安装[root@localhost php-5.6.4]#yum install libxml2-devel bzip2-devel libmcrypt-devel[root@localhost php-5.6.31]# ./configure --prefix=/app/php --with-mysql=/usr/local/mysql --with-openssl --with-mysqli=/usr/local/mysql/bin/mysql_config --enable-mbstring --with-png-dir --with-jpeg-dir --with-freetype-dir --with-zlib --with-libxml-dir=/usr --enable-xml --enable-sockets --with-apxs2=/app/httpd24/bin/apxs --with-mcrypt --with-config-file-path=/etc --with-config-file-scan-dir=/etc/php.d --with-bz2 [root@localhost php-5.6.4]# make &amp;&amp; make install （2）配置主配置文件 [root@localhost php-5.6.31]# cp php.ini-production /etc/php.ini （3）在httpd.conf中配置 259 &lt;IfModule dir_module&gt; 260 DirectoryIndex index.php index.html 261 &lt;/IfModule&gt; 512 AddType Application/x-httpd-php .php 513 AddType Application/x-httpd-php-source .phps 接下的步骤和CentOS 7中的配置类似，请参考上述配置。 （4）配置环境变量 [root@localhost php]# vim /etc/profile.d/php.sh PATH=/app/php/bin:$PATH [root@localhost php]# source /etc/profile.d/php.sh （5）测试是否可以与apache通信 [root@localhost htdocs]# vim index.php &lt;?php phpinfo(); ?&gt; （6）测试是否可以与mysql通信 &lt;?php $msyqli=new mysqli(&quot;192.168.4.132&quot;,&quot;root&quot;,&quot;123456&quot;); if(mysqli_connect_errno()){ echo &quot;failure&quot;; $mysqli=null; exit; } echo &quot;ok&quot;; $mysqli-&gt;close; phpinfo(); ?&gt; （7）安装wordpress 步骤和CentOS7安装一样可以参考 （8）源码编译安装加速器 [root@localhost xcache-3.2.0]# phpize #生成configure[root@localhost xcache-3.2.0]# ./configure --enable-xcache --with-php-config=/app/php/bin/php-config[root@localhost xcache-3.2.0]# make &amp;&amp; make install 安装方式二：基于php-fpm模块安装[root@localhost php-5.6.31]# ./configure --prefix=/app/php5 --with-mysql=/usr/local/mysql --with-openssl --with-mysqli=/usr/local/mysql/bin/mysql_config --enable-mbstring --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml --enable-sockets --enable-fpm --with-mcrypt --with-config-file-path=/etc/php5 --with-config-file-scan-dir=/etc/php5.d --with-bz2[root@localhost php-5.6.31]# make &amp;&amp; make install （2）准备启动脚本文件 [root@localhost php-5.6.31]# cp sapi/fpm/init.d.php-fpm.in /etc/rc.d/init.d/php-fpm[root@localhost php-5.6.31]# chmod +x /etc/rc.d/init.d/php-fpm[root@localhost php-5.6.31]# chkconfig --add php-fpm （3）配置环境变量 [root@localhost php-5.6.31]# vim /etc/profile.d/php-fpm.sh[root@localhost php-5.6.31]# source /etc/profile.d/php-fpm.sh （4）创建主配置文件 [root@localhost etc]# mkdir /etc/php5[root@localhost etc]# cp /usr/local/src/php-5.6.31/php.ini-production /etc/php5/php.ini （5）准备服务配置文件 [root@localhost etc]# cp php-fpm.conf.default php-fpm.conf （6）编辑/app/httpd24/conf/httpd.conf 取消注释，启用此模块 LoadModule proxy_module modules/mod_proxy.so LoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so 在配置文件末尾追加如下 AddType Application/x-httpd-php .php AddType Application/x-httpd-php-source .phps ProxyRequests off ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/app/httpd24/htdocs/$1 （7）启动php-fpm服务 [root@localhost etc]# service php-fpm start （8）测试是否可以与mysql和httpd连接成功 http://192.168.4.132/ （9）安装wordpress 安装过程和CentOS 7中安装一样，可以参考上述过程 （10）测试性能如何 Requests per second: 579.84 [#/sec] (mean) Time per request: 17.246 [ms] (mean) Time per request: 1.725 [ms] (mean, across all concurrent requests) Transfer rate: 37900.46 [Kbytes/sec] received]]></content>
      <categories>
        <category>服务</category>
        <category>LAMP</category>
        <category>LAMP源码编译安装</category>
      </categories>
      <tags>
        <tag>LAMP，lamp，php，php-fpm，源码编译安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LNMT、LAMT环境]]></title>
    <url>%2F2017%2F11%2F28%2FLNMT%E3%80%81LAMT%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[LNMT环境搭建 安装mysql数据库 （1）安装mysql并配置环境 [root@mysql ~]# yum install -y mysql-server [root@mysql ~]# service httpd start #启动服务 [root@mysql ~]# mysql_secure_installation #mysql安全初始化 （2）创建数据库并授权用户 [root@mysql ~]# mysql -uroot -p mysql&gt; CREATE DATABASE testprocess； mysql&gt; GRANT ALL ON testprocess.* TO &apos;joah&apos;@&apos;192.168.4.61&apos; IDENTIFIED BY &apos;123456&apos;; tomcat （1）安装jdk环境 [root@tomcat/etc/tomcat]#yum install -y java-1.8.0-openjdk-src （2）安装tomcat [root@tomcat~]#yum install -y tomcat tomcat-lib tomcat-admin-webapps tomcat-docs tomcat-webapps （3）启动服务测试是否成功 [root@tomcat~]#systemctl enable tomcat #设置为开机自动启动 [root@tomcat~]#systemctl start tomcat #启动服务 使tomcat与mysql可以连接 MySQL Connector / J是一个本地Java驱动程序，可以将JDBC（Java Database Connectivity）调用MySQL数据库使用的网络协议。 （1）安装mysql-connector-java [root@tomcat~]#yum install -y mysql-connector-java #用于使用java连接mysql数据库 [root@tomcat~]#cp /usr/share/java/mysql-connector-java.jar /usr/share/tomcat/lib/ 将此压缩包复制到此目录下，自动安装部署 [root@tomcat~]#systemctl restart tomcat #重启服务 （2）修改mysql中的配置文件 [root@mysql ~]# vim /etc/my.cnf [root@mysql ~]# service mysqld restart #重启服务 查看是否生效 创建数据库并授权 mysql&gt; CREATE DATABASE tomcat; mysql&gt; CREATE TABLE tom(id int,name varchar(40)); mysql&gt; insert into tom values(1,&apos;test&apos;); mysql&gt; GRANT ALL ON tomcat.* TO &apos;joah&apos;@&apos;192.168.4.61&apos; IDENTIFIED BY &apos;123456&apos;; 测试是否成功 [root@tomcat~]#mysql -ujoah -p -h 192.168.4.56 编辑test.jsp文件 [root@tomcat/usr/share/tomcat/webapps/ROOT]#vim test.jsp 1 &lt;%@ page contentType=&quot;text/html;charset=utf-8&quot;%&gt; 2 &lt;%@ page import=&quot;java.sql.*&quot;%&gt; 3 &lt;html&gt; 4 &lt;body&gt; 5 &lt;%Class.forName(&quot;org.gjt.mm.mysql.Driver&quot;).newInstance(); 6 String url =&quot;jdbc:mysql://192.168.4.56（此处需要换成mysql的地址）/tomcat?user=joah（连接数据库使用的名字）&amp;password=123456（连接数据库的密码）&amp;useUnicode=tr ue&amp;characterEncoding=utf-8&quot;; 7 Connection conn= DriverManager.getConnection(url); 8 Statement stmt=conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_ UPDATABLE); 9 String sql=&quot;select * from tom（连接数据库中的表）&quot;; 10 ResultSet rs=stmt.executeQuery(sql); 11 while(rs.next()) {%> 12 step: 13 context:]]></content>
      <categories>
        <category>服务</category>
        <category>Tomcat</category>
        <category>LNMT、LAMT环境</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LNMT实现Jsprun论坛]]></title>
    <url>%2F2017%2F11%2F28%2FLNMT%E5%AE%9E%E7%8E%B0Jsprun%E8%AE%BA%E5%9D%9B%2F</url>
    <content type="text"><![CDATA[LNMT实现Jsprun论坛mariadb- [root@mysql~]#yum install -y mariadb-server #安装mariadb服务 [root@mysql~]#systemctl enable mariadb.service #设置为开机启动 [root@mysql~]#systemctl start mariadb #启动服务 [root@mysql~]#mysql_secure_installation #安全初始化 [root@mysql~]#mysql -uroot -p #创建使用的数据库 MariaDB [(none)]&gt; CREATE DATABASE jsprun; MariaDB [(none)]&gt; GRANT ALL ON jsprun.* TO joah@&apos;192.168.4.63&apos; IDENTIFIED By &apos;123456&apos;; tomcat [root@tomcat~]#yum install -y java-1.8.0-openjdk #安装java运行环境 [root@tomcat~]#java -version #查看是否安装成功 [root@tomcat~]#yum install -y tomcat tomcat-admin-webapp tomcat-docs-webapp tomcat-lib tomcat-webapps #安装所需要的包 [root@tomcat~]#unzip JspRun\!_6.0.0_Source_UTF8.zip #解压此包 [root@tomcat~]#cp JspRun\!_6.0.0_Source_UTF8/source/WebRoot/ /usr/share/tomcat/webapps/jsprun -a #将此目录下的文件复制到指定目录下 [root@tomcat/usr/share/tomcat/webapps/jsprun]#vim config.properties #修改数据库信息 [root@tomcat/etc/tomcat]#vim server.xml #修改server.xml文件 [root@tomcat/etc/tomcat]#vim tomcat-users.xml #开启管理功能 [root@tomcat/etc/tomcat]#systemctl enable tomcat.service #设置为开机启动 [root@tomcat/etc/tomcat]#systemctl start tomcat.service #启动tomcat服务 nginx 安装并启动服务 [root@nginx~]#yum install -y nginx [root@nginx~]#systemctl enable nginx [root@nginx~]#systemctl start nginx 修改配置文件 [root@nginx/etc/nginx/conf.d]#vim nginx-tomcat.conf 1 server { 2 listen 80; 3 server_name www.test.com; 4 root /usr/share/tomcat/webapps/jsprun; 5 location / { 6 index index.jsp; 7 proxy_pass http://192.168.4.63:8080; 8 } 9 location ~* \.(jsp|do)$ { 10 proxy_pass http://192.168.4.63:8080; 11 } 12 } [root@nginx/etc/nginx/conf.d]#nginx -t #语法检测 重启服务测试 点击下一步等 会出现图中红框的内容表示不可写 修改配置文件并使其文件有写权限和执行权限 [root@tomcat/usr/share/tomcat/webapps/jsprun]#chmod 777 config.properties templates/ attachments/ customavatars/ forumdata/ -R 图中显示数据库的内容我们已经在config.properties配置文件中修改了，所以这里不需要修改了，如果安装之前没有修改此内容要正确填写即可，点击下一步安装完成 我们去数据库查看生成的表 如何实现动静分离呢？ [root@nginx/etc/nginx/conf.d]#vim nginx-tomcat.conf 1 server { 2 listen 80; 3 server_name www.test.com; 4 root /usr/share/tomcat/webapps/jsprun; 5 location ~* \.(gif|png|jpeg|bmp|jpg|html|htm)$ { 6 proxy_pass http://192.168.4.65:80; 7 } 8 location ~* \.(jsp|do)$ { 9 proxy_pass http://192.168.4.63:8080; 10 } 11 } [root@nginx/etc/nginx/conf.d]#systemctl restart nginx.service 将jsprun中image拷贝到apache中/var/www/html目录下 [root@tomcat/usr/share/tomcat/webapps/jsprun]#scp -pr images/* 192.168.4.65:/var/www/html 测试 这里的动静分离其实是将图片和html等结尾的文件专门存放在apache服务器上，而不是实现真正的分离。]]></content>
      <categories>
        <category>服务</category>
        <category>Tomcat</category>
        <category>LNMT实现Jsprun论坛</category>
      </categories>
      <tags>
        <tag>tomcat，jsprun，lnmt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LAMP简单介绍]]></title>
    <url>%2F2017%2F11%2F28%2FLAMP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、LAMP1、概念LAMP指的Linux（操作系统）、ApacheHTTP 服务器，MySQL（有时也指MariaDB，数据库软件） 和PHP（有时也是指Perl或Python） 的第一个字母，一般用来建立web应用平台。 2、web资源的类型静态资源：原始形式与相应内容一致。 动态资源：原始形式通常为程序文件，需要在服务器端执行之后哦，将执行结果返回给客户端。 3、LAMP结构 CGI：Commom Gateway Interface可以让一个客户端从网页浏览器通过http服务器向执行在网络服务器上的程序传输数据；CGI描述了客户端与服务器程序之间传输的一种标准。 程序=指令（代码文件）+数据（数据存储系统、文件） 请求过程： Client--(http协议)--&gt;httpd--&gt;(CGI)--&gt;application server（program file）--&gt;（mysql）--&gt;mysql 二、PHP1、PHP简介PHP（PHP: Hypertext Preprocessor）是通用服务器端脚本编程语言，主要用于web开发实现动态web页面，也是最早实现将脚本嵌入HTML源码文档中的服务器端脚本语言之一。同时，php还提供了一个命令行接口，因此，其也可以在大多数系统上作为一个独立的shell来使用 2、PHP配置（1）配置文件 /etc/php.ini /etc/php.d/*.ini 配置文件在php解释器启动时被读取。 （2）配置文件格式 directive = value 注释符： #：纯粹的注释信息 ;：用于注释可启用的directive；较新的版本中，已经全部使用“；”进行注释。 （3）php.ini配置文件设置 max_execution_time = 30 #最长执行时间30s memory_limit 128 #内存限制，但是实际生产中不够，可调大此值 display——startup_errors off #显示启动时出错信息，建议关闭，如果不关闭，会有可能显示一些重要信息 post_max_size 8M #最大上传数据大小，生产环境中可能临时调大 upload_max_filesize 2M #最大上传文件大小，生产环境中可能要调大。但是要比post_max_size值要小。 max_file_uploads = 20 #同时上传最多文件数 date.timezone = Aisa/shanghai #指定时区 short_open_tag = on 开启端标签，如&lt;?phpinfo()&gt; 如果想了解更多请查看http://php.net/manual/zh/ini.core.php （4）PHP的加速器php的加速器：基于PHP的特殊扩展机制如opcode缓存扩展也可以将opcode缓存于php的共享内存中，从而可以让同一段代码的后续重复执行时跳过编译阶段以提高性能。这些加速器并非真正提高了opcode的运行速度，而仅是通过分析opcode后并将它们重新排列以达到快速执行的目的。 类型 APC (Alternative PHP Cache)遵循PHP License的开源框架，PHP opcode缓存加速器，目前的版本不适用于PHP 5.4 项目地址http://pecl.php.net/package/APC eAccelerator源于Turck MMCache，早期的版本包含了一个PHP encoder和 PHP loader，目前encoder已经不在支持。项目地址 http://eaccelerator.net/ XCache快速而且稳定的PHP opcode缓存，经过严格测试且被大量用于生产环境。项目地址：http://xcache.lighttpd.net/,收录EPEL源 Zend Optimizer和Zend Guard Loader Zend Optimizer并非一个opcode加速器，它是由ZendTechnologies为PHP5.2及以前的版本提供的一个免费、闭源的PHP扩展，其能够运行由Zend Guard生成的加密的PHP代码或模糊代码。 而Zend Guard Loader则是专为PHP5.3提供的类似于Zend Optimizer功能的扩展。项目地址 http://www.zend.com/en/products/guard/runtime-decoders 加速器，它支持装载通过NuSphere PHP Encoder编码的PHP程序文件，并能够实现对常规PHP文件的执行加速。项目地址，http://www.nusphere.com/products/phpexpress.htm 三、LAMP构建我们在构建LAMP服务时，需要每一个服务都要测试成功，必须在安装完此服务之后，测试服务是否工作正常；与其他服务是否能测试成功。在安装之前我们必须得知道php是依赖于mysql\mariadb和apache服务的，所有我们必须按前两个服务再安装php。如果先安装php也不是不可，慢慢的拍错，想必一定会成功的。 下面的过程在CentOS 6 中进行配置。 1、httpd安装（1）使用yum源安装[root@localhost ~]# yum install -y httpd （2）配置主配置文件/etc/httpd/conf/httpd.conf[root@localhost ~]# vim /etc/httpd/conf/httpd.conf ServerTokens prod #修改响应报文显示系统信息 ServerName www.example.com:79 #如果不开启这项，启动会提示如下内容： Starting httpd: httpd: Could not reliably determine the server&apos;s fully qualified domain name, using localhost.localdomain for ServerName （3）设为开机启动并启动httpd服务[root@localhost ~]# chkconfig httpd on[root@localhost ~]# service httpd start[root@localhost ~]# ss -tnl #建议启动后查看端口是否启动 （4）测试是否成功 2、mysql安装（1）使用yum源安装[root@localhost ~]# yum install -y mysql-server （2）设置为开机启动并启动mysql服务[root@localhost ~]# chkconfig mysqld on[root@localhost ~]# chkconfig --list mysqld mysqld 0:off 1:off 2:on 3:on 4:on 5:on 6:off [root@localhost ~]# service mysqld start （3）初始化数据库[root@localhost ~]# mysql_secure_installation详细的内容向看mysql配置http://merit.blog.51cto.com/10757694/1968557 （4）创建用户mysql&gt; CREATE DATABASE wpdb; #创建数据路 mysql&gt; GRANT ALL PRIVILEGES ON wpdb.* TO joah@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;; #授权用户对wpdb权限 mysql&gt; GRANT ALL PRIVILEGES ON wpdb.* TO joah@&#39;127.0.0.1&#39; IDENTIFIED BY &#39;123456&#39;; #授权用户对wpdb权限 mysql&gt; SELECT user,host,password FROM mysql.user; +------+-----------+-------------------------------------------+ | user | host | password | +------+-----------+-------------------------------------------+ | root | localhost | *6B8CCC83799A26CD19D7AD9AEEADBCD30D8A8664 | | root | 127.0.0.1 | *6B8CCC83799A26CD19D7AD9AEEADBCD30D8A8664 | | joah | 127.0.0.1 | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 | | joah | localhost | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 | +------+-----------+-------------------------------------------+ 4 rows in set (0.00 sec) （5）测试是否成功[root@localhost ~]# mysql -ujoah -p 3、php安装（1）使用yum源安装php[root@localhost ~]# yum install -y php php安装相当于添加了一份配置文件在/etc/httpd/conf.d/目录，如果要使其生效重新启动httpd服务即可。 4、测试php和httpd是否配置成功（1）在/var/www/html目录下创建文件测试[root@localhost html]# vim index.php &lt;?php echo &quot;&lt;h&gt;success&lt;/h&gt;&quot;; phpinfo(); ?&gt; [root@localhost html]# service httpd restart #重启测试是否成功 5、测试php是否可以和数据库连接成功（1）php-mysql安装不过在测试之前需安装一个程序包使其能相互关联作用。 The php-mysql package contains a dynamic shared object that will add MySQL database support to PHP. MySQL is an object-relational database management system. PHP is an HTML-embeddable scripting language. If you need MySQL support for PHP applications, you will need to install this package and the php package. 提供了一个动态分享库使mysql数据库支持php [root@localhost ~]# yum install -y php-mysql （2）编辑index.php文件测试方法一： &lt;?php $conn = mysql_connect(&apos;localhost&apos;,&apos;joah&apos;,&apos;123456&apos;); if($conn) echo &quot;ok&quot;; else echo &quot;failure&quot;; mysql_close(); ?&gt; 测试方法二： 编辑index.php文件 &lt;?php $mysqli=new mysqli(&quot;localhost&quot;,&quot;joah&quot;,&quot;123456&quot;); if(mysqli_connect_errno()){ echo &quot;failure&quot;; $mysqli=null; exit; } echo &quot;ok&quot;; $mysqli-&gt;close(); ?&gt; 此时我们就可以使用这个环境构建一些软件等；下面我们从phpMyadmin和wordpress这两个软件进行说明。 安装phpMyadmin（1）上传软件包并进行编译安装[root@localhost ~]# mv phpMyAdmin-4.3.5-all-languages.zip /usr/local/src/ #将上传的软件包移到到此目录下方便管理源码编译的安装包 [root@localhost src]# unzip phpMyAdmin-4.3.5-all-languages.zip -d /var/www/html/ #将此包解压至/var/www/html目录下 （2）配置配置文件[root@localhost html]# ln -sv phpMyAdmin-4.3.5-all-languages/ pma #创建软连接 [root@localhost pma]# cp config.sample.inc.php config.inc.php #准备配置文件[root@localhost pma]# vim config.inc.php #编辑配置文件在下面行输入随机数即可 重启服务测试，测试几次也不行。通过官网上查看原来php此不支持phpMyadim这个版本。 重新下载一个较低版本安装 [root@localhost html]# unzip phpMyAdmin-4.0.5-all-languages.zip [root@localhost html]# ln -sv phpMyAdmin-4.0.5-all-languages pem #创建软连接 [root@localhost pem]# cp config.sample.inc.php config.inc.php [root@localhost pem]# vim config.inc.php 重启服务测试 此时会出现错误提示，安装mbsting包即可 [[root@localhost src]# rpm -ivh php-mbstring-5.3.3-22.el6.x86_64.rpm --force #由于在CentOS6中属于epel所以需要配置epel源，但是由于本机上不了网，所以这种方式安装 重启httpd服务测试是否成功 成功，接下来就是自己配置过程了 ，此时登录的用户名和密码是数据库授权的用户和密码。 wordpress安装WordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。WordPress是一款个人博客系统，并逐步演化成一款内容管理系统软件，它是使用PHP语言和MySQL数据库开发的。用户可以在支持 PHP 和 MySQL数据库的服务器上使用自己的博客。&lt;摘自：百度&gt; （1）解压缩安装[root@localhost src]# tar xvf wordpress-4.8.tar.gz -C /var/www/html/ （2）准备配置文件方式一：[root@localhost wordpress]# cp wp-config-sample.php wp-config.php [root@localhost wordpress]# vim wp-config.php #编辑此配置文件 方式二： [root@localhost wordpress]# setfacl -Rm u:apache:rwx wordpress #由于是基于apache用户运行所有给apache用户对此文件rwx权限即可 （3）测试是否成功http://192.168.4.59/wordpress/wp-admin/setup-config.php 然后下面就可以搭建自己的博客啦！ 注意在装完数据库之后切记一定要把刚刚授权的权限删除[root@localhost html]# setfacl -b blog/]]></content>
      <categories>
        <category>服务</category>
        <category>LAMP</category>
        <category>LAMP简单介绍</category>
      </categories>
      <tags>
        <tag>LAMP，lamp，php，php-fpm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVS实战]]></title>
    <url>%2F2017%2F11%2F28%2FLVS%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[实例lvs-nat模型实现http负载集群（VS和RS之间直连）- （1）构建网络拓扑 （2）搭建网络环境 配置路由器 [root@VS~]#vim /etc/sysctl.conf #开启路由转发功能 11 net.ipv4.ip_forward=1 RS1主机上添加路由规则 [root@RS1~]#route add default gw 192.168.4.63 RS2主机上也是如上添加规则即可 配置客户端 [root@RS1~]#route add default gw 172.18.4.63 切记：配置完以后一定要检测网络是否可以相互ping 通。 （3）添加规则 [root@VS~]#ipvsadm -A -t 172.18.4.63:80 -s rr [root@VS~]#ipvsadm -a -t 172.18.4.63:80 -r 192.168.4.64 -m [root@VS~]#ipvsadm -a -t 172.18.4.63:80 -r 192.168.4.65 -m （4）测试 lvs-nat模型实现http负载集群（VS和RS之间使用路由相连）- （1）搭建网络环境 配置VS [root@VS~]#vim /etc/sysconfig/network-scripts/ifcfg-eth0 1 DEVICE=eth0 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=172.18.4.63 5 PREFIX=16 [root@VS~]#vim /etc/sysconfig/network-scripts/ifcfg-eth1 1 DEVICE=eth1 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=192.168.4.63 5 PREFIX=24 6 GATEWAY=192.168.4.64 配置router2 [root@route2~]#vim /etc/sysconfig/network-scripts/ifcfg-eth0 1 DEVICE=eth0 2 BOOTPROTO=static 3 ONBOOT=yes 4 IPADDR=192.168.4.64 5 PREFIX=24 6 GATEWAY=192.168.4.63 [root@route2~]#vim /etc/sysconfig/network-scripts/ifcfg-eth1 1 DEVICE=eth1 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=192.168.100.63 5 PREFIX=24 配置RS1和RS2 [root@RS1~]#vim /etc/sysconfig/network-scripts/ifcfg-eth1 1 DEVICE=eth1 2 BOOTPROTO=none 3 IPADDR=192.168.100.64 4 PREFIX=24 5 GATEWAY=192.168.100.63 [root@RS2~]#vim /etc/sysconfig/network-scripts/ifcfg-eth1 1 DEVICE=eth1 2 BOOTPROTO=none 3 IPADDR=192.168.100.65 4 PREFIX=24 5 GATEWAY=192.168.100.63 务必测试环境是否ping通。 （2）添加规则 [root@VS~]#ipvsadm -A -t 172.18.4.63:80 -s rr[root@VS~]#ipvsadm -a -t 172.18.4.63:80 -r 192.168.100.64 -m[root@VS~]#ipvsadm -a -t 172.18.4.63:80 -r 192.168.100.65 -m [root@VS~]#ipvsadm -ln #查看添加的规则 IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConn TCP 172.18.4.63:80 rr -&gt; 192.168.100.64:80 Masq 1 0 0 -&gt; 192.168.100.65:80 Masq 1 0 0 （3）测试 lvs-nat模型实现https和http负载集群以第二个环境为基础进行 （1）每天RS1上增加证书 [root@RS1~]#cd /etc/pki/tls/certs/ [root@RS1/etc/pki/tls/certs]#make httpd.crt [root@RS1/etc/pki/tls/certs]#mv httpd.* /etc/httpd/conf.d/ #将证书存放在此目录下 由于证书key是加密存在的，每次都要输入密码，为了方便对key文件解密 root@RS1/etc/httpd/conf.d]#openssl rsa -in httpd.key -out httpd.key [root@RS1/etc/httpd/conf.d]#yum install -y mod_ssl #安装模块使其支持加密 修改ssl.conf配置文件 [root@RS1/etc/httpd/conf.d]#vim ssl.conf （2）测试本机是否可以正常访问 [root@RS1/etc/httpd/conf.d]#curl -k https://192.168.100.64 RS1 （3）在VS上添加规则 [root@VS~]#iptables -t mangle -A PREROUTING -d 172.18.4.63 -p tcp -m multiport --dports 80,443 -j MARK --set-mark 10 [root@VS~]#ipvsadm -A -f 10 -s rr [root@VS~]#ipvsadm -a -f 10 -r 192.168.100.64 -m [root@VS~]#ipvsadm -a -f 10 -r 192.168.100.65 -m [root@VS~]#ipvsadm -ln IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConn FWM 10 rr -&gt; 192.168.100.64:0 Masq 1 0 0 -&gt; 192.168.100.65:0 Masq 1 0 0 （4）测试 lvs-nat模型实现https负载集群以第二个环境为基础进行 （1）在RS1和RS2上添加证书 [root@RS1~]#cd /etc/pki/tls/certs/ [root@RS1/etc/pki/tls/certs]#make httpd.crt [root@RS1/etc/pki/tls/certs]#mv httpd.* /etc/httpd/conf.d/ #将证书存放在此目录下 由于证书key是加密存在的，每次都要输入密码，为了方便对key文件解密 root@RS1/etc/httpd/conf.d]#openssl rsa -in httpd.key -out httpd.key [root@RS1/etc/httpd/conf.d]#yum install -y mod_ssl #安装模块使其支持加密 修改ssl.conf配置文件 [root@RS1/etc/httpd/conf.d]#vim ssl.conf （2）测试本机是否可以正常访问 [root@RS1/etc/httpd/conf.d]#curl -k https://192.168.100.64 RS1 （3）VS添加规则 [root@VS~]#ipvsadm -A -t 172.18.4.63:443 -s rr[root@VS~]#ipvsadm -a -t 172.18.4.63:443 -r 192.168.100.64:443 -m[root@VS~]#ipvsadm -a -t 172.18.4.63:443 -r 192.168.100.65:443 -m[root@VS~]#ipvsadm -ln IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConn TCP 172.18.4.63:443 rr -&gt; 192.168.100.64:443 Masq 1 0 0 -&gt; 192.168.100.65:443 Masq 1 0 0 （4）测试是否成功 lvs-dr模型实现http负载集群- （1）搭建网络环境 路由器： [root@router/etc/sysconfig/network-scripts]#vim ifcfg-eth0 1 DEVICE=eth0 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=172.18.4.61 5 PREFIX=24 [root@router/etc/sysconfig/network-scripts]#vim ifcfg-eth1 1 DEVICE=eth1 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=192.168.4.61 5 PREFIX=24 客户端 [root@client/etc/sysconfig/network-scripts]#vim ifcfg-eth0 1 DEVICE=eth0 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=172.18.4.55 5 PREFIX=24 [root@client ~]#route add default gw 172.18.4.61 VS [root@VS/etc/sysconfig/network-scripts]#vim ifcfg-eth0 1 DEVICE=eth0 2 BOOTPROTO=static 3 ONBOOT=yes 4 IPADDR=192.168.4.62 5 PREFIX=24 6 GATEWAY=192.168.4.61 [root@VS/etc/sysconfig/network-scripts]#vim ifcfg-eth0:0 1 DEVICE=eth0:0 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=192.168.4.63 5 PREFIX=24 -RS1和RS2 [root@RS1/etc/sysconfig/network-scripts]#vim ifcfg-eth0 1 DEVICE=eth0 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=192.168.4.64 5 PREFIX=24 6 GATEWAY=192.168.4.61 [root@RS1/etc/sysconfig/network-scripts]#vim ifcfg-eth1 1 DEVICE=eth1 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=192.168.4.63 5 PREFIX=32 关闭arp广播 [root@RS1~]#echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore [root@RS1~]#echo 1 &gt; /proc/sys/net/ipv4/conf/eth1/arp_ignore [root@RS1~]#echo 1 &gt; /proc/sys/net/ipv4/conf/eth1/arp_announce [root@RS1~]#echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_announce RS2和RS1配置类似就不陈述 注意：如果配置VIP地址在lo网卡上需要关闭如下选项 net.ipv4.conf.lo.arp_ignore = 1 net.ipv4.conf.lo.arp_announce = 2 net.ipv4.conf.all.arp_ignore = 1 net.ipv4.conf.all.arp_announce = 2 如果配置VIP地址在真实网卡需要关闭如下 net.ipv4.conf.ethN.arp_ignore = 1 net.ipv4.conf.ethN.arp_announce = 2 （N 为网卡接口） net.ipv4.conf.all.arp_ignore = 1 net.ipv4.conf.all.arp_announce = 2 （2）VS添加规则 [root@VS~]#ipvsadm -A -t 192.168.4.63:80 -s rr [root@VS~]#ipvsadm -a -t 192.168.4.63:80 -r 192.168.4.64:80 -g [root@VS~]#ipvsadm -a -t 192.168.4.63:80 -r 192.168.4.65:80 -g [root@VS~]#ipvsadm -ln IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConn TCP 192.168.4.63:80 rr -&gt; 192.168.4.64:80 Route 1 0 0 -&gt; 192.168.4.65:80 Route 1 0 0 （3）在客户端测试 问题1：如果RS中VIP的子网掩码不是32结果怎么样呢？ 修改RS1和RS2VIP [root@RS1/etc/sysconfig/network-scripts]#vim ifcfg-eth1 1 DEVICE=eth1 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=192.168.4.63 5 PREFIX=24 重启网络服务测试 [root@RS1/etc/sysconfig/network-scripts]#systemctl restart network 小结- 1、当客户端发起访问VIP 对应的域名的请求时，根据网络通信原理会产生ARP 广播，因为负载均衡器和真实的服务器在同一网络并且VIP设置在集群中的每个节点上，此时集群内的真实服务器会尝试回答来自客户端计算机的查找VIP的ARP广播，这就会产生问题，大家都说我是”VIP”。 为了达到负载均衡的目的，必须想法办让真实服务器忽略来自客户端计算机的ARP广播请求。所以要修改arp_igonre和arp_announce这两个内核参数 2、RS中VIP的子网掩码不一定要为255.255.255.255。但是通过查询资料可知，因为若干机器要使用同一个IP地址，用本身做广播地址和把子网掩码设置为255.255.255.255就不会造成IP地址冲突。 3、如果是这种框架：RShe Director必须在同一个物理网段中。 lvs-dr集群web服务-]]></content>
      <categories>
        <category>调度器</category>
        <category>LVS实战</category>
      </categories>
      <tags>
        <tag>lvs，实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVS简单介绍]]></title>
    <url>%2F2017%2F11%2F28%2FLVS%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[LVS1、lvs（Linux Virtual Server）概念 将一组服务器通过高速的局域网地理分布的广域网相互连接，在他们前段有一个负载调度器（Load Balancer），将网络请求调度到真实的服务器上，客户访问集群系统提供的网络服务就像一台高性能、高可用的服务器一样。 工作原理 VS根据请求报文的目标IP、目标协议和端口将其调度转发至某RS，根据调度算法来挑选RS。 2、lvs集群的特点 适用性，后端服务器可运行任何支持TCP/IP的操作系统 具有良好的伸缩性 可靠性 3、lvs集群类型 LVS/NAT 通过网络地址转换，调度器重写请求报文的目标地址，根据预设的调度算法，将请求分派给后端的真实服务器；真实服务器的响应报文通过调度器时，报文的源地址呗重写再返回给客户，完成整个负载调度过程。 LVS/DR 通过改写请求报文的MAC地址，将请求发送到真是服务器，而真实服务器将响应直接返回给客户；可极大地提高集群系统的伸缩性。不过LVS/DR模型要求调度器和诊室服务器都有一块网卡连在同一个物理网段上。 LVS/TUN 由于LVS/NAT请求和响应报文都必须经过调度器地址重写，当客户端越来越多时，调度器的处理能力将成为瓶颈。为了解决这个问题，调度器把请求报文通过IP隧道转发至真实服务器，而真实服务器将响应直接返回给客户，所以调度器至处理请求报文。 4、负载调度算法###静态调度算法：根据其调度时是否考虑个RS 当前的负载状态 RR（Round Robin）轮叫 调度器通过“轮叫”调度算法将外部请求按顺序轮流分配到集群中的真实服务器上，它均等地对待每一台服务器，而不管服务器上的实际连接数和系统负载。 WRR（Weighted Round Robin）加权轮叫 调度器通过“加权轮叫”调度算法根据真实服务器的不同处理能力来调度访问请求。可以保证处理能力较强的服务器处理更多的访问流量。调度器可以自动问询真实服务器的负载情况，并动态的调整其权值。 DH（Destination Hashing）目标地址散列 根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到服务器，否则返回空。将发往同一个目标地址的请求始终转发至第一次挑中的RS，典型使用场景是正向代理缓存场景中的负载均衡，如：宽带运营商。 SH（Source Hashing）源地址散列 根据请求的源IP地址，作为散列键（Hask Key）从静态分配的散列表找出对应的服务器，若服务器时可用且未超载，将请求发送到服务器，否则返回空。也可以这样理解，实现session sticky，源IP地址Hash将来自于同一个IP地址的请求始终发往第一次挑中的RS，从而实现会话绑定。 动态调度算法；根据每RS当前的负载及调度算法进行调度 LC（Lesat Connextions）最小连接 将网络请求调度到已经建立的链接数最少的服务器上。如果集群系统的真实服务器具有相近的系统性能，采用LC可以较好地均衡负载 overhead=activeconns*256+inactiveconns WLC（Weighted Least Connections）加权最小连接 在集群系统中的服务器性能差异较大的情况下，调度器采用WLC优化均衡性能，具有在较高权值的服务器将承受较大比例的活动连接负载。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。 overhead=（activeconns*256+inactiveconns）/weight 如果第一次调度采用随机调度 LBLC（Locality-Based Least Connections）基于局部性的最少连接 LBLC针对目标IP地址的负载均衡。根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器时可用的且没有超载，将请求发送到服务器；若服务器不存在，或该服务器超载且有服务器处于一半的工作负载，则用LBLC选择出一个可用的服务器，将请求发送到该服务器。 LBLCR（Locality-Based Least Connections with Replication）带复制的基于局部性最少连接 LBLCR要维护从一个目标IP 到一组服务器的映射；根据请求的目标IP地址找出该目标IP地址对应的服务器组。按“最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按最小连接原则从这个集群中选出一台服务器，将该服务器假如到服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。 -SED（Shortest Expection Delay）初始化连接高权重优先 overhead=(activeconns+1)256/weight NQ（Never Queue） 第一轮均匀分配，后续SED算法计算调度 5、LVS集群通用结构体系 如图所示LVS采用三层结构 负载调度器：它是整个集群对外面的前段机，负责将客户的请求发送到一组服务器上执行，而客户认为服务时来自一个IP地址上的。 服务器池：一组真正执行客户请求的服务器，执行的服务如http ftp等 共享存储：为服务器池提供一个共享的存储区，使得服务器池拥有相同的内容，提供向同的服务。通常是数据库、网络文件系统或者分布式文件系统 ##6、IPVS（IP Virtual Server）是运行在LVS下的提供负载均衡功能的一种技术。IPVS软件实现了IP负载均衡技术：LVS/NAT 、LVS/TUN 、LVS/DR。 ###工作机理在基于IP负载调度技术中心，当一个TCP连接的初始SYN报文到达时，调度器就选择一台服务器，将报文转发给它。伺候通过查发报文的IP和TCP报文头地址，保证此连接的后继报文被转发到该服务器。这样，IPVS无法检查到请求的内容再选择服务器，这就要求后端的服务器组是提供相同的服务器，不管请求被发送到哪一台服务器，返回结果都应该是一样。 PS：LVS分成了两个部分，一部分工作在内核空间的一个IPVS模块（工作在Netfilter框架的input链上），另一部分工作在用户空间的一个用来定义集群服务的一个工具ipvsadm，主要定义集群服务传送给工作在内核的IPVS模块。 ipvsadm包构成配置文件 /etc/sysconfig/ipvsadm-config 服务名称 /usr/lib/systemd/system/ipvsadm.service 管理工具 /usr/sbin/ipvsadm /usr/sbin/ipvsadm-restore /usr/sbin/ipvsadm-save ipvsadm命令 管理集群服务 ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]] 选项 说明 -A，–add-service 添加VS（Virtual Server） -E,–edit-service 更改VS -D，–delete-service 删除VS -C,–clear 清空定义的所有内容 -R，–restore 重载VS表 -S,–save 保存VS规则 -t,–tcp-service TCP协议的端口，VIP:TCP_PORT -u, –udp-service UDP协议的端口 -f, –fwmark-service firemall mark标记， -p, –persistent 持久连接，指定timeout，默认为360秒 -s, –scheduler scheduling-method 指定调度算法 -Z,–zero 清空计数器 管理集群上的RS ipvsadm -a|e -t|u|f service-address -r server-address [-g|i|m] [-w weight] 选项 说明 -a, –add-server 将RS添加到VS -e, –edit-server 编辑RS -d, –delete-server 移除RS从VS -r, –real-server server-address 指定RS服务器IP -g, –gatewaying 使用网关（direct routing） -i, –ipip 使用ipip封装（tunneling） -m, –masquerading 使用伪装（NAT） -w, –weight weight 指定权重 查看 选项 说明 -L，-l，–list 列出定义规则 –numeric，-n 以数字形式输出地址和端口号 –exact 扩展信息，精确值 –connection，-c 当前IPVS连接输出 –stats 统计信息 –rate 输出速率信息 保存及重载规则 保存建议保存至/etc/sysconfig/ipvsadm ipvsadm-save &gt;/PATH/TO/IPVSADM_FILE ipvsadm -S &gt; /PATH/TO/IPVSADM_FILE systemctl stop ipvsadm.service 重载 ipvsadm-restore &lt; /PATH/FROM/IPVSADM_FILE ipvsadm -R &lt; /PATH/FROM/IPVSADM_FILE systemctl restart ipvsadm.service]]></content>
      <categories>
        <category>调度器</category>
        <category>LVS简单介绍</category>
      </categories>
      <tags>
        <tag>lvs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVS简单介绍二]]></title>
    <url>%2F2017%2F11%2F28%2FLVS%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Firewall Mark借助于防火墙类分类报文，而后基于标记定义集群服务；可将多个不同应用使用同一个集群服务进行调度 步骤： （1）在Director主机打标记： iptables -t mangle -A PREROUTING -d $vip -p $proto –m multiport --dports $port1,$port2,… -j MARK --set-mark NUMBER （2）在Director主机基于标记定义集群服务 ipvsadm -A -f NUMBER [options] ipvsadm -a -f NUMBER -r RIP -m 持久连接session绑定：对共享同一组RS的多个集群服务，需要统一进行绑定，lvs中sh算法无法实现。 持久连接：实现无论使用任何调度算法，在一段时间内（默认360s），能够实现将来自同一个地址的请求始终发往同一个RS。 ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]] 持久连接实现方式 每端口持久（PPC ）：每个端口对应定义为一个集群服务，每集群服务单独调度 每防火墙标记持久（PFWMC）:基于防火墙标记定义集群服务；可实现将多个端口上的应用同一调度，即所谓port affinity 每客户端持久（PCC）：基于0端口（表示所有服务）定义集群服务，即将客户端对所有应用的请求都调度至后端主机，必须定义为持久模式 LVS高可用性如果Director不可用，整个系统将不可用，SPOF（单点故障）；如果RS不可用时，Director依然会调度请求到RS上。 解决方案：由Director对个RS健康状态进行检查，失败时禁用，成功时启用。 检查方式： （1）网络层检测，icmp （2）传输层检查：端口探测 （3）应用层检测：请求某关键资源 如果RS全不能使用时，back server，sorry server ldirector：监控远程服务和控制LVS主配置文件 /etc/ha.d/ldirectord.cf 配置模版 /usr/share/doc/ldirectord-3.9.6/ldirectord.cf 服务 /usr/lib/systemd/system/ldirectord.service 主程序 /usr/sbin/ldirectord 日志 /var/log/ldirectord.log pid文件 /var/run/ldirectord.ldirectord.pid ldirectord配置文件 [root@localhost~]#cp /usr/share/doc/ldirectord-3.9.5/ldirectord.cf /etc/ha.d/ 选项 说明 checktimeout 判断RS出错的时间间隔 checkinterval 指定ldirectord在每次检查之间的间隔时间 fallback 当所有的RS不能工作时，web服务重定向的地址 autoreload 是否自动重载配置文件 logfile 指定ldirectord日志文件路径 quiescent（静态） 当选择no时，如果一个节点在checktimeout设置的时间周期内没有响应，ldirectord将会从LVS的路由表中移除RS，将终端现有的客户端连接，并是LVS丢掉所有的链接跟中记录和持续连接模板；如果选择yes，当某个RS失效时，ldirectord将失效节点的权值设置为0，新的链接不能到达，但是并不从LVS路由表清除此节点，同时连接跟踪记录和持久连接模板仍然保留在Director上。 virtual 指定虚拟的IP和端口号必须在行后面指定RS和端口号同时设置LVS工作模式 real 指定RS service 指定服务的类型 request ldirectord将根据指定的RS结合该选项给出的请求路径，发送访问请求，检查RS上的服务是否正常运行；确保这里给出的页面地址是可访问的，不然ldirectord会误从此节点已经失效，发生错误监控现象 receive 指定请求和应答字串 scheduler 指定调度算法 protocol 指定协议类型 checktype 指定ldirectord的检测类型，默认为negotiate checkport 指定监控的端口号 virtualhost 虚拟服务器的名称]]></content>
      <categories>
        <category>调度器</category>
        <category>LVS简单介绍二</category>
      </categories>
      <tags>
        <tag>lvs，firewall mark，持久连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVS集群类型]]></title>
    <url>%2F2017%2F11%2F28%2FLVS%E9%9B%86%E7%BE%A4%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[LVS集群类型1、lvs-nat模式 本质是多目标IP 的DNAT，通过将请求报文中的目标地址和目标端口修改为某跳出的RS的RIP和PORT实现转发。 小结 （1）RIP和DIP不一定在同一个IP网络,如果VS和RS中间是相连的路由器，RS的网关需指向路由器的网关；如果VS和RS中间是相连的是交换机，RS的网关要指向DIP。应该使用私网IP（也可以使用公网IP） （2）请求报文和响应报文都必须经由Director 转发，Director容易成为系统瓶颈。 （3）支持端口映射，可以修改请求报文的目标端口 （4）VS必须是Linux系统，RS可以是任意OS系统 2、lvs-dr模式 lvs-dr：Director Routing，直接路由，LVS默认模式应用最广泛，通过为请求报文重新封装一个MAC首部进行转发，源MAC是DIP所在的接口MAC，目标MAC是某挑选出的RS的RIP所在接口的MAC地址；源IP/PORT，以及目标IP/PORT均保持不变。 lvs-dr模式，各主机上均需要配置VIP，解决地址冲突的方式有三种： 在前段网关做静态绑定，这种方法的弊端是如果后端OS坏掉，重新静态绑定 在各RS使用arptables arptables -A IN -d $VIP -j DROP arptables -A OUT -s $VIP -j mangle –mangle-ip-s $RIP 在各RS修改内核参数，来限制arp响应和通告的级别 限制响应级别：arp_ignore 0：默认值，表示可使用本地任意接口上配置的任意地址进行响应 1：仅在请求的目标IP配置在本地主机的接收到请求报文的接口上时，才给予响应 限制通告级别：arp_announce 0：默认值，把本机所有接口的所有信息向每个接口的网络进行通告 1：尽量避免将接口信息向非直接连接网络进行通告 2：必须避免将接口信息向非本网络进行通告 小结 （1）确保前段路由器将目标IP为VIP的请求报文发往Director。在前段网关做静态绑定VIP和DIrector的MAC地址 （2）RS的RIP可以使用私网地址，也可以使用公网地址；RIP的网关不能指向DIP，以确保响应报文不会经由Director。RIP与DIP可以不再同一个IP网络 （3）RS和Director如果中间是路由相连，要在同一个物理网络，逻辑上可以不再一个网段。路由器可以转发。 （4）请求报文要经由Director，但响应报文不经由Director，而由RS直接发往Client （5）不支持端口映射 （6）RS可以使用大多数OS系统 注意：RS必须配置VIP地址，如果不配置CIP接收到的响应报文不是自己目标的响应报文，拒收。 3、lvs-tun模式不修改请求报文的IP首部（源IP为CIP，目标IP为VIP），而在源IP报文之外再封装一个IP首部（源IP是DIP，目标IP是RIP），将报文发往挑选出的目标RS；RS直接响应给客户端（源IP是VIP，目标IP是CIP）。支持源距离通信。 小结 （1）DIP、VIP、RIP都应该是公网地址，也可以是私网地址（如果拉的是专线） （2）RS的网关不能指向DIP （3）请求报文要经由DIrector，但响应报文不能经由Director （4）不支持端口映射 （5）RS的OS 系统必须支持隧道功能]]></content>
      <categories>
        <category>调度器</category>
        <category>LVS集群类型</category>
      </categories>
      <tags>
        <tag>lvs，集群类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MHA+Keepalived+MySQL主从]]></title>
    <url>%2F2017%2F11%2F28%2FMHA%2BKeepalived%2BMySQL%E4%B8%BB%E4%BB%8E%2F</url>
    <content type="text"><![CDATA[MHA+Keepalived+mysql主从 主机名 mysql keepalived MHA IP manager — — master-0.56 192.168.4.64 master mariadb-5.5.56 √ node-0.56 192.168.4.61 slave1 mariadb-5.5.56 √ node-0.56 192.168.4.62 slave2 mariadb-5.5.56 — node-0.56 192.168.4.63 各节点时间同步[root@manager~]#ntpdate 172.18.0.1 [root@manager~]#vim /etc/chrony.conf server 172.18.0.1 iburst [root@manager~]#systemctl start chronyd.service 各节点可通过主机名互相访问[root@manager~]#vim /etc/hosts 192.168.4.64 manager 192.168.4.61 master 192.168.4.62 slave1 192.168.4.63 slave2 各节点基于无密钥交叉通信（基于同一密钥认证）[root@manager~]#ssh-keygen -t rsa -P &#39;&#39; [root@manager~]#ssh-copy-id -i /root/.ssh/id_rsa.pub manager [root@manager~/.ssh]#scp authorized_keys id_rsa{,.pub} master:/root/.ssh [root@manager~/.ssh]#scp authorized_keys id_rsa{,.pub} slave1:/root/.ssh [root@manager~/.ssh]#scp authorized_keys id_rsa{,.pub} slave2:/root/.ssh 确保每个节点iptables和seline关闭配置主从复制master节点[root@master~]#vim /etc/my.cnf.d/server.cnf [server] innodb_file_per_table = ON skip_name_resolve = ON max_connections = 2000 server_id = 1 relay_log = relay-log log_bin = master-log [root@master~]#systemctl start mariadb 授权用户MariaDB [(none)]&gt; GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO joah@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39;; MariaDB [(none)]&gt; FLUSH PRIVILEGES; 查看二进制日志MariaDB [(none)]&gt; SHOW MASTER STATUS; +-------------------+----------+--------------+------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | +-------------------+----------+--------------+------------------+ | master-log.000003 | 414 | | | +-------------------+----------+--------------+------------------+ 1 row in set (0.00 sec) MariaDB [(none)]&gt; SHOW BINLOG EVENTS IN &apos;master-log.000003&apos;; +-------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------------------------------------+ | Log_name | Pos | Event_type | Server_id | End_log_pos | Info | +-------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------------------------------------+ | master-log.000003 | 4 | Format_desc | 1 | 245 | Server ver: 5.5.56-MariaDB, Binlog ver: 4 | | master-log.000003 | 245 | Query | 1 | 414 | GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO joah@&apos;192.168.4.%&apos; IDENTIFIED BY &apos;centos&apos; | +-------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------------------------------------+ slave节点[root@slave1~]#vim /etc/my.cnf.d/server.cnf [server] innodb_file_per_table = ON skip_name_resolve = ON max_connections = 2000 server_id = 2 relay_log = relay-log log_bin = master-log relay_log_purge = 0 read_only = ON [root@slave2~]#vim /etc/my.cnf.d/server.cnf [server] innodb_file_per_table = ON skip_name_resolve = ON max_connections = 2000 server_id = 3 #此处注意一定不能相同 relay_log = relay-log log_bin = master-log relay_log_purge = 0 read_only = ON 修改master为自己的主为了以后从升为主节点以后有授权，因此从二进制日志245开始 MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_USER=&#39;joah&#39;,MASTER_HOST=&#39;192.168.4.61&#39;,MASTER_PASSWORD=&#39;centos&#39;,MASTER_LOG_FILE=&#39;master-log.000003&#39;,MASTER_LOG_POS=245; MariaDB [(none)]&gt; SELECT User FROM mysql.user; 查看是否已经同步成功 MariaDB [(none)]&gt; FLUSH PRIVILEGES; 在mariadb所有节点授权用户此用户可在本地网络中又其他节点上远程访问。 MariaDB [(none)]&gt; GRANT ALL ON *.* TO mhaadmin@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39;; keepalived安装master上安装keepalived[root@master~]#yum install -y keepalived 修改配置[root@master/etc/keepalived]#cp keepalived.conf{,.bak} [root@master/etc/keepalived]#vim keepalived.conf global_defs { 4 notification_email { 5 root@localhost 6 } 7 notification_email_from keepalived@localhost 8 smtp_server 127.0.0.1 9 smtp_connect_timeout 30 10 router_id master 11 vrrp_mcast_group4 224.0.100.100 12 } 13 14 vrrp_script chk_mysql { 15 script &quot;killall -0 mysqld &amp;&amp; exit 0 ||exit 1&quot; 16 interval 1 17 weight -30 18 fall 2 19 rise 1 20 } 21 vrrp_instance VI_1 { 22 state MASTER 23 interface eth0 24 virtual_router_id 4 25 priority 100 26 advert_int 1 27 authentication { 28 auth_type PASS 29 auth_pass 152369 30 } 31 virtual_ipaddress { 32 192.168.4.55 33 } 34 track_script { 35 chk_mysql 36 } 37 } 添加IP地址[root@master/etc/keepalived]#ip addr add 192.168.4.55/24 dev eth0 启动服务[root@master/etc/keepalived]#systemctl start keepalived slave1上安装keepalived[root@slave1~]#yum install -y keepalived 3 global_defs { 4 notification_email { 5 root@localhost 6 } 7 notification_email_from keepalived@localhost 8 smtp_server 127.0.0.1 9 smtp_connect_timeout 30 10 router_id slave1 11 vrrp_mcast_group4 224.0.100.100 12 } 13 14 vrrp_script chk_mysql { 15 script &quot;killall -0 mysqld &amp;&amp; exit 0 ||exit 1&quot; 16 interval 1 17 weight -30 18 fall 2 19 rise 1 20 } 21 vrrp_instance VI_1 { 22 state SLAVE 23 interface eth0 24 virtual_router_id 4 25 priority 80 26 advert_int 1 27 authentication { 28 auth_type PASS 29 auth_pass 152369 30 } 31 virtual_ipaddress { 32 chk_mysql 33 } 34 } 添加IP地址[root@slave1/etc/keepalived]#ip addr add 192.168.4.55/24 dev eth0 启动服务MHA搭建Manager主机上安装[root@manager~]#yum install mha4mysql-manager-0.55-0.el6.noarch.rpm mha4mysql-node-0.56-0.el6.noarch.rpm mysql各节点上都安装[root@master~]#yum install mha4mysql-node-0.56-0.el6.noarch.rpm 注意：CentOS7可以直接使用适用于el6的程序包；MHA manger和MHA node程序包的版本不强制要求一样。 初始化MHAmanager节点需要为每个监控的master/slave集群提供一个专用的配置文件，并可以共享全局配置/etc/masterha_default.cnf。如果仅监控一个application，也可以直接通过application的配置来提供个服务器的默认配置信息。每个application的配置文件路径为自定义。 [root@manager~]#mkdir /etc/masterha/ [root@manager/etc/masterha]#vim app1.cnf [server default] #全局配置 user=mhaadmin password=centos manager_workdir=/data/masterha/app1 #这些目录会自动创建 manager_log=/data/masterha/app1/manager.log remote_workdir=/data/masterha/app1 ssh_user=root #基于密钥的用户 repl_user=joah #授权主从复制用户 repl_password=centos ping_interval=1 #间隔时长 [server1] hostname=192.168.4.61 ssh_port=22 candidate_master=1 [server2] hostname=192.168.4.62 ssh_port=22 candidate_master=1 [server3] hostname=192.168.4.63 ssh_port=22 no_master=1 检测各节点ssh互相配置是否成功[root@manager/etc/masterha]#masterha_check_ssh app1.cnf --conf=app1.cnf 检查管理的mysql复制集群的连接配置参数是否成功[root@manager/etc/masterha]#masterha_check_repl --conf=app1.conf 启动MHA[root@manager/etc/masterha]#masterha_manager --conf=app1.cnf 启动成功后，查看master状态[root@manager~]#masterha_check_status --conf=/etc/masterha/app1.cnf app1 (pid:38704) is running(0:PING_OK), master:192.168.4.61]]></content>
      <categories>
        <category>数据库</category>
        <category>MHA+Keepalived+MySQL主从</category>
      </categories>
      <tags>
        <tag>keepalived，mha，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MHA]]></title>
    <url>%2F2017%2F11%2F28%2FMHA%2F</url>
    <content type="text"><![CDATA[MHA-MHA（Master HA）是一款开源的mysql的高可用程序，为mysql主从复制架构提供了automating master failover功能。MHA在监控到master节点故障时，会提升其中拥有最新数据的slave节点成为新的master节点，在此期间，MHA会通过与其他从节点获取额外信息来避免一致性方面的问题。MHA还提供了master节点在线切换功能。 MHA服务角色： MHA manager：通常单独部署在一台独立机器上管理多个master/slave集群，每个master/slave称为一个application MHA node：运行在每台mysql服务器，通过监控具备解析和清理logs功能的脚本来加快故障转移。 mysql复制集群中的master故障时，MHA转移 MHA组件 Manager节点 masterha_check_ssh：MHA依赖的SSH环境监测工具 masterha_check_repl：mysql复制环境监测工具 masterha_manager：MHA服务主程序 masterha_check_status：MHA运行状态探测工具 masterha_master_monitor：mysql master节点可用性探测工具 masterha_master_switch：master节点切换工具 masterha_conf_host：添加或删除配置的节点 masterha_stop：关闭MHA服务的工具 Node节点 save_binary_logs：保存和复制master的二进制日志 apply_diff_relay_logs：识别差异的中继日志并应用于其他slave purge——relay_logs：清除中继日志（不会阻塞SQL线程） 自定义扩展 secondary_check_script：通过多条网络路由检测master的可用性 master_ip_failover_script：更新application使用的masterip shutdown_script：强制关闭master节点 report_script：发送报告 init_conf_load_script：加载初始配置参数 master_ip_online_change_script：更新master节点ip地址 注意：MHA对mysql复制环境有特殊要求，各节点都要开启二进制日志及中继日志；各从节点必须显示启用其read-only属性；关闭relay_log_purege功能。 MHA实现- 各节点时间同步[root@manager~]#ntpdate 172.18.0.1 [root@manager~]#vim /etc/chrony.conf server 172.18.0.1 iburst [root@manager~]#systemctl start chronyd.service 各节点可通过主机名互相访问[root@manager~]#vim /etc/hosts 192.168.4.64 manager 192.168.4.61 master 192.168.4.62 slave1 192.168.4.63 slave2 各节点基于无密钥交叉通信（基于同一密钥认证）[root@manager~]#ssh-keygen -t rsa -P &#39;&#39; [root@manager~]#ssh-copy-id -i /root/.ssh/id_rsa.pub manager [root@manager~/.ssh]#scp authorized_keys id_rsa{,.pub} master:/root/.ssh [root@manager~/.ssh]#scp authorized_keys id_rsa{,.pub} slave1:/root/.ssh [root@manager~/.ssh]#scp authorized_keys id_rsa{,.pub} slave2:/root/.ssh 确保每个节点iptables和seline关闭配置主从复制master节点[root@master~]#vim /etc/my.cnf.d/server.cnf [server] innodb_file_per_table = ON skip_name_resolve = ON max_connections = 2000 server_id = 1 relay_log = relay-log log_bin = master-log [root@master~]#systemctl start mariadb 授权用户MariaDB [(none)]&gt; GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO joah@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39;; MariaDB [(none)]&gt; FLUSH PRIVILEGES; 查看二进制日志MariaDB [(none)]&gt; SHOW MASTER STATUS; +-------------------+----------+--------------+------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | +-------------------+----------+--------------+------------------+ | master-log.000003 | 414 | | | +-------------------+----------+--------------+------------------+ 1 row in set (0.00 sec) MariaDB [(none)]&gt; SHOW BINLOG EVENTS IN &apos;master-log.000003&apos;; +-------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------------------------------------+ | Log_name | Pos | Event_type | Server_id | End_log_pos | Info | +-------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------------------------------------+ | master-log.000003 | 4 | Format_desc | 1 | 245 | Server ver: 5.5.56-MariaDB, Binlog ver: 4 | | master-log.000003 | 245 | Query | 1 | 414 | GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO joah@&apos;192.168.4.%&apos; IDENTIFIED BY &apos;centos&apos; | +-------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------------------------------------+ slave节点[root@slave1~]#vim /etc/my.cnf.d/server.cnf [server] innodb_file_per_table = ON skip_name_resolve = ON max_connections = 2000 server_id = 2 relay_log = relay-log log_bin = master-log relay_log_purge = 0 read_only = ON [root@slave2~]#vim /etc/my.cnf.d/server.cnf [server] innodb_file_per_table = ON skip_name_resolve = ON max_connections = 2000 server_id = 3 #此处注意一定不能相同 relay_log = relay-log log_bin = master-log relay_log_purge = 0 read_only = ON 修改master为自己的主为了以后从升为主节点以后有授权，因此从二进制日志245开始 MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_USER=&#39;joah&#39;,MASTER_HOST=&#39;192.168.4.61&#39;,MASTER_PASSWORD=&#39;centos&#39;,MASTER_LOG_FILE=&#39;master-log.000003&#39;,MASTER_LOG_POS=245; MariaDB [(none)]&gt; SELECT User FROM mysql.user; 查看是否已经同步成功 MariaDB [(none)]&gt; FLUSH PRIVILEGES; 在mariadb所有节点授权用户此用户可在本地网络中又其他节点上远程访问。 MariaDB [(none)]&gt; GRANT ALL ON *.* TO mhaadmin@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39;; MHA搭建Manager主机上安装[root@manager~]#yum install mha4mysql-manager-0.55-0.el6.noarch.rpm mha4mysql-node-0.56-0.el6.noarch.rpm mysql各节点上都安装[root@master~]#yum install mha4mysql-node-0.56-0.el6.noarch.rpm 注意：CentOS7可以直接使用适用于el6的程序包；MHA manger和MHA node程序包的版本不强制要求一样。 初始化MHAmanager节点需要为每个监控的master/slave集群提供一个专用的配置文件，并可以共享全局配置/etc/masterha_default.cnf。如果仅监控一个application，也可以直接通过application的配置来提供个服务器的默认配置信息。每个application的配置文件路径为自定义。 [root@manager~]#mkdir /etc/masterha/ [root@manager/etc/masterha]#vim app1.cnf [server default] #全局配置 user=mhaadmin password=centos manager_workdir=/data/masterha/app1 #这些目录会自动创建 manager_log=/data/masterha/app1/manager.log remote_workdir=/data/masterha/app1 ssh_user=root #基于密钥的用户 repl_user=joah #授权主从复制用户 repl_password=centos ping_interval=1 #间隔时长 [server1] hostname=192.168.4.61 ssh_port=22 candidate_master=1 [server2] hostname=192.168.4.62 ssh_port=22 candidate_master=1 [server3] hostname=192.168.4.63 ssh_port=22 no_master=1 检测各节点ssh互相配置是否成功[root@manager/etc/masterha]#masterha_check_ssh app1.cnf --conf=app1.cnf 检查管理的mysql复制集群的连接配置参数是否成功[root@manager/etc/masterha]#masterha_check_repl --conf=app1.conf 启动MHA[root@manager/etc/masterha]#masterha_manager --conf=app1.cnf 启动成功后，查看master状态[root@manager~]#masterha_check_status --conf=/etc/masterha/app1.cnf app1 (pid:38704) is running(0:PING_OK), master:192.168.4.61 测试故障转移假设master宕机 [root@master~]#systemctl stop mariadb.service 此时会检测到master down，但是此时的MHA也会停止工作，如果要使其正常工作需要将master重新上线。 查看日志[root@manager/etc/masterha]#cat /data/masterha/app1/manager.log 通过查看日志，已经顺利转移到slave1节点上了。 查看此时的状态[root@manager/etc/masterha]#masterha_check_status --conf=app1.cnf app1 is stopped(2:NOT_RUNNING). 故障恢复此时只能做从节点，需要加入从节点的配置信息 [root@master~]#vim /etc/my.cnf.d/server.cnf relay_log_purge = OFF read_only = ON [root@master~]#systemctl start mariadb.service MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_USER=&#39;joah&#39;,MASTER_HOST=&#39;192.168.4.62&#39;,MASTER_PASSWORD=&#39;centos&#39;,MASTER_LOG_FILE=&#39;master-log.000003&#39;,MASTER_LOG_POS=395; MariaDB [(none)]&gt; START SLAVE; manager再次检测[root@manager~]#nohup masterha_manager --conf=/etc/masterha/app1.cnf &amp;&gt; /data/masterha/app1/manager.log &amp; #后台运行 [root@manager~]#jobs [1]+ Running nohup masterha_manager --conf=/etc/masterha/app1.cnf &amp;&gt;/data/masterha/app1/manager.log &amp; 注意：如果主节点down必须进行重新设置。 问题：（1）提供额外的检测机制，以明对master的监控作出误判 （2）在master节点上提供虚拟ip地址向外提供服务，以名master节点转换时，客户端的请求无法正确送达。 （3）进行故障转移时对原有master节点执行STONITH操作以避免脑裂；可通过制定的shutdwon_script实现。 （4）必要时，进行在线master节点转换。]]></content>
      <categories>
        <category>数据库</category>
        <category>MHA</category>
      </categories>
      <tags>
        <tag>mha，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MPM工作模式]]></title>
    <url>%2F2017%2F11%2F28%2FMPM%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[MPM（MultiProcess Modules ）工作模式 prefork 多进程I/O模型，每个进程响应一个请求，默认模型一个主进程生成N个子进程，创建套接字，每个子进程响应一个请求；而主进程不响应请求，只负责管理接受请求。系统初始化时，预先生成多个空闲进程，等待请求，多大不超过1024个（由pam.limits.so控制，可使用ulimit -n # 设置） worker 复用多进程I/O模型，多进程多线程。一个主进程生成m个子进程，每个子进程负责生产n个线程，每个线程响应一个请求，并发响应请求为m*n。 event 一个主进程生成m个子进程，每个进程直接响应n个请求；并发响应请求为m*n。event中有专门的线程来管理这些Keep-Alive类型的线程，当有真实请求时，将请求传递给服务线程，执行完毕后，又允许释放，增强了高并发场景下的处理请求能力。]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>MPM（MultiProcess Modules ）工作模式</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL主从复制]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[实战：实现主从复制 node1为主，node2为从 在node1操作[root@node1~]#vim /etc/my.cnf.d/server.cnf [root@node1~]#systemctl start mariadb 在node2操作[root@node2~]#vim /etc/my.cnf.d/server.cnf [root@node2~]#systemctl start mariadb 在node1进行授权 MariaDB [(none)]&gt; GRANT REPLICATION CLIENT,REPLICATION SLAVE ON *.* TO &apos;joah&apos;@&apos;192.168.4.62&apos; IDENTIFIED BY &apos;123456&apos;; 在node2 MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_HOST=&apos;192.168.4.61&apos;,MASTER_USER=&apos;joah&apos;,MASTER_PASSWORD=&apos;123456&apos;,MASTER_LOG_FILE=&apos;master-log.000004&apos;,MASTER_LOG_POS=417; MariaDB [(none)]&gt; START SLAVE; #启动从服务器 MariaDB [(none)]&gt; SHOW SLAVE STATUS\G; #查看从服务器状态 测试[root@node1~]#mysql &lt; hellodb.sql 在node1中查看 在node2中查看]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL主从复制</category>
      </categories>
      <tags>
        <tag>主从复制，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL主从复制读写分离]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[mysql主从复制读写分离 master和slave时间同步[root@master~]#ntpdate 172.18.0.1 [root@master~]#vim /etc/chrony.conf [root@master~]#systemctl start chronyd.service slave步骤同上 确保关闭了iptables和selinux功能 ##配置主从复制 master 配置： 修改配置文件 [root@master~]#vim /etc/my.cnf.d/server.cnf 授权用户 MariaDB [(none)]&gt; GRANT REPLICATION SLAVE,REPLICATION CLIENT ON . TO ‘joah’@’192.168.4.%’ IDENTIFIED BY ‘123456’; MariaDB [(none)]&gt; FLUSH PRIVILEGES; 查看二进制日志 MariaDB [(none)]&gt; SHOW MASTER STATUS; MariaDB [(none)]&gt; SHOW BINLOG EVENTS IN ‘log-bin.000001’; slave配置 修改配置文件[root@slave1~]#vim /etc/my.cnf.d/server.cnf slave1和slave2配置相同，不过需要修改下server_id 修改主节点 MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_USER=’joah’,MASTER_HOST=’192.168.4.61’,MASTER_PASSWORD=’123456’,MASTER_LOG_FILE=’log-bin.000001’,MASTER_LOG_POS=245; MariaDB [(none)]&gt; START SLAVE; MariaDB [(none)]&gt; SHOW SLAVE STATUS\G; 实现半同步复制master节点配置 安装semisync插件 MariaDB [(none)]&gt; INSTALL PLUGIN rpl_semi_sync_master SONAME ‘semisync_master’; 查看变量 MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES LIKE ‘rpl_semi%’;+————————————+——-+| Variable_name | Value |+————————————+——-+| rpl_semi_sync_master_enabled | OFF || rpl_semi_sync_master_timeout | 10000 || rpl_semi_sync_master_trace_level | 32 || rpl_semi_sync_master_wait_no_slave | ON |+————————————+——-+ 启动此插件功能 MariaDB [(none)]&gt; SET GLOBAL rpl_semi_sync_master_enabled=ON; 显示状态 MariaDB [(none)]&gt; SHOW GLOBAL STATUS LIKE ‘%rpl%’; Slave1 配置 安装插件 MariaDB [(none)]&gt; INSTALL PLUGIN rpl_semi_sync_slave SONAME ‘semisync_slave’; 查看semi变量 MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES LIKE ‘%rpl_semi%’;+———————————+——-+| Variable_name | Value |+———————————+——-+| rpl_semi_sync_slave_enabled | OFF || rpl_semi_sync_slave_trace_level | 32 |+———————————+——-+ 启动semi功能 MariaDB [(none)]&gt; SET @@global.rpl_semi_sync_slave_enabled=ON;重启IO线程，如果不重启当执行时会超时MariaDB [(none)]&gt; STOP SLAVE IO_THREAD; MariaDB [(none)]&gt; START SLAVE IO_THREAD; proxysqlhttp://www.proxysql.com/ 下载地址 ###安装proxysql [root@proxysql~]#yum install proxysql-1.4.3-1-centos7.x86_64.rpm ###修改配置文件/etc/proxysql.cnf[root@proxysql~]#cp /etc/proxysql.cnf{,.bak} [root@proxysql~]#vim /etc/proxysql.cnf datadir=&quot;/var/lib/proxysql&quot; #存放数据地址 10 11 admin_variables= 12 { 13 admin_credentials=&quot;admin:123456&quot; 14 mysql_ifaces=&quot;127.0.0.1:6032;/tmp/proxysql_admin.sock&quot; #为了安全可见仅在本地使用 15 } 16 17 mysql_variables= 18 { 19 threads=4 20 max_connections=2048 21 default_query_delay=0 22 default_query_timeout=36000000 23 have_compress=true 24 poll_timeout=2000 25 interfaces=&quot;0.0.0.0:3306;/tmp/proxysql.sock&quot; 26 # interfaces=&quot;0.0.0.0:6033&quot; 27 default_schema=&quot;information_schema&quot; 28 stacksize=1048576 29 server_version=&quot;5.5.30&quot; 30 connect_timeout_server=3000 31 monitor_username=&quot;joah&quot; 32 monitor_password=&quot;joah&quot; 33 monitor_history=600000 34 monitor_connect_interval=60000 35 monitor_ping_interval=10000 36 monitor_read_only_interval=1500 37 monitor_read_only_timeout=500 38 ping_interval_server_msec=120000 39 ping_timeout_server=500 40 commands_stats=true 41 sessions_sort=true 42 connect_retries_on_failure=10 43 } 44 45 46 # defines all the MySQL servers 47 mysql_servers = 48 ( 49 { 50 address = &quot;192.168.4.61&quot; 51 port = 3306 52 hostgroup = 0 53 status = &quot;ONLINE&quot; 54 weight = 1 55 compression = 0 56 }, 57 { 58 address = &quot;192.168.4.62&quot; 59 port = 3306 60 hostgroup = 1 61 status = &quot;ONLINE&quot; 62 weight = 1 63 compression = 0 64 }, 65 { 66 address = &quot;192.168.4.63&quot; 67 port = 3306 68 hostgroup = 1 69 status = &quot;ONLINE&quot; 70 weight = 1 71 compression = 0 72 } 73 ) 74 75 # defines all the MySQL users 76 mysql_users: 77 ( 78 { 79 username = &quot;joah&quot; 80 password = &quot;123456&quot; 81 default_hostgroup = 0 82 max_connections=1000 83 default_schema=&quot;hellodb&quot; 84 active = 1 85 } 86 ) 87 88 #defines MySQL Query Rules 89 mysql_query_rules: 90 ( 91 ) 92 93 scheduler= 94 ( 95 ) 96 97 98 mysql_replication_hostgroups= 99 ( 100 { 101 writer_hostgroup=0 102 reader_hostgroup=1 103 comment=&quot;joah mysql&quot; 104 } 105 ) 注意：配置文件中{}如果没有后续内容没有逗号。 本地管理[root@proxysql~]#mysql -S /tmp/proxysql_admin.sock -uadmin -p123456 测试是否能支持读写分离授权在上述文件中设定的mysql_user MariaDB [hellodb]&gt; GRANT ALL ON . TO ‘joah’@’192.168.4.%’ IDENTIFIED BY ‘123456’; [root@proxysql~]#mysql -ujoah -p -h192.168.4.64]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL主从复制读写分离</category>
      </categories>
      <tags>
        <tag>读写分离，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL半同步复制]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[mysql半同步复制- 半同步复制是基于异步复制基础之上进行的。从Slave节点中选取一个节点进行半同步复制，当master节点提交一个事物将受到阻塞，直到得知一个已开启半同步复制功能的Slave同步完成之后返回ack包，master才会向用户返回事物提交。 1、半同步流程图： 2、半同步潜在的问题当master down时，有可能半同步复制没有完成，并没有提交给客户；切换到Slave时，数据有可能和master的数据不一致，此时需要使用binlog恢复 3、半同步复制概念（1）当slave节点连接到master时，能够查看是否处于半连接同步复制的机制；如果只有开启一侧，它依然为异步复制。 （2）当master节点开启半同步复制的功能时，至少有一个Slave节点开启此功能。 ###4、mysql插件 ####查询插件存放的位置： MariaDB [(none)]&gt; SHOW VARIABLES LIKE ‘plugin_dir’;+—————+————————–+| Variable_name | Value |+—————+————————–+| plugin_dir | /usr/lib64/mysql/plugin/ |+—————+————————–+ 安装插件：格式： INSTALL PLUGIN plugin_name SONAME &apos;shared_library_name&apos;； 卸载插件格式： UNINSTALL PLUGIN plg_name； 查看当前已经安装的插件格式： SHOW PLUGINS; 查看插件的详细信息格式： SELECT * FROM information_schema.plugins WHERE PLUGIN_NAME=&apos;plg-name&apos;; 半同步复制实现 前提： master和slave时间同步 [root@master~]#ntpdate 172.18.0.1 [root@master~]#vim /etc/chrony.conf [root@master~]#systemctl start chronyd.service slave步骤同上 确保关闭了iptables和selinux功能 配置主从复制master 配置： 修改配置文件 [root@master~]#vim /etc/my.cnf.d/server.cnf 授权用户 MariaDB [(none)]&gt; GRANT REPLICATION SLAVE,REPLICATION CLIENT ON . TO ‘joah’@’192.168.4.%’ IDENTIFIED BY ‘123456’; MariaDB [(none)]&gt; FLUSH PRIVILEGES; 查看二进制日志 MariaDB [(none)]&gt; SHOW MASTER STATUS; MariaDB [(none)]&gt; SHOW BINLOG EVENTS IN ‘log-bin.000001’; slave配置 修改配置文件[root@slave1~]#vim /etc/my.cnf.d/server.cnf slave1和slave2配置相同，不过需要修改下server_id 修改主节点 MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_USER=’joah’,MASTER_HOST=’192.168.4.61’,MASTER_PASSWORD=’123456’,MASTER_LOG_FILE=’log-bin.000001’,MASTER_LOG_POS=245; MariaDB [(none)]&gt; START SLAVE; MariaDB [(none)]&gt; SHOW SLAVE STATUS\G; 实现半同步复制master节点配置 安装semisync插件 MariaDB [(none)]&gt; INSTALL PLUGIN rpl_semi_sync_master SONAME ‘semisync_master’; 查看变量 MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES LIKE ‘rpl_semi%’;+————————————+——-+| Variable_name | Value |+————————————+——-+| rpl_semi_sync_master_enabled | OFF || rpl_semi_sync_master_timeout | 10000 || rpl_semi_sync_master_trace_level | 32 || rpl_semi_sync_master_wait_no_slave | ON |+————————————+——-+ 启动此插件功能 MariaDB [(none)]&gt; SET GLOBAL rpl_semi_sync_master_enabled=ON; 显示状态 MariaDB [(none)]&gt; SHOW GLOBAL STATUS LIKE ‘%rpl%’; Slave1 配置 安装插件 MariaDB [(none)]&gt; INSTALL PLUGIN rpl_semi_sync_slave SONAME ‘semisync_slave’; 查看semi变量 MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES LIKE ‘%rpl_semi%’;+———————————+——-+| Variable_name | Value |+———————————+——-+| rpl_semi_sync_slave_enabled | OFF || rpl_semi_sync_slave_trace_level | 32 |+———————————+——-+ 启动semi功能 MariaDB [(none)]&gt; SET @@global.rpl_semi_sync_slave_enabled=ON;重启IO线程，如果不重启当执行时会超时MariaDB [(none)]&gt; STOP SLAVE IO_THREAD; MariaDB [(none)]&gt; START SLAVE IO_THREAD; 查看master上的状态 选项介绍rpl_semi_sync_master_enabled 是否开启半同步 rpl_semi_sync_master_timeout 超时时长 rpl_semi_sync_slave_enable slave是否开启半同步 rpl_semi_sync_master_clients 查看有多少个slave开启半同步 rpl_semi_sync_master_status 查看master是否正在运行 rpl_semi_sync_master_no_tx 查看有多少事物没有用半同步复制的机制进行复制 rpl_semi_sync_master_yes_tx 查看有多少事物是通过半同步复制机制成功复制 rpl_semi_sync_slave_status 查看slave是否正常运行]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL半同步复制</category>
      </categories>
      <tags>
        <tag>半同步复制，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基于SSL实现主从复制]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E5%9F%BA%E4%BA%8ESSL%E5%AE%9E%E7%8E%B0%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[mysql数据库基于SSL实现主从复制实验环境： node1:192.168.4.61 node2:192.168.4.62 CA：192.168.4.63 node1和node2时间同步[root@node1~]#ntpdate 172.18.0.1 [root@node2~]#ntpdate 172.18.0.1 [root@node1~]#vim /etc/chrony.conf #node1和node2操作一样 [root@node1~]#systemctl start chronyd.service #启动服务 node1和node2基于key连接[root@node1~]#ssh-keygen [root@node1~]#ssh-copy-id -i /root/.ssh/id_rsa.pub 192.168.4.62 #将公钥复制到node2上 node2操作和node1操作相同。 修改hosts文件node1和node2配置相同 [root@node1~]#vim /etc/hosts 3 192.168.4.61 node1 4 192.168.4.62 node2 确保关闭iptables和selinuxnode1和node2安装mariadb数据库[root@node1~]#yum install -y mariadb-server [root@node2~]#yum install -y mariadb-server 配置node1为主服务器[root@node1~]#vim /etc/my.cnf.d/server.cnf [root@node1~]#systemctl start mariadb #启动mariadb服务 MariaDB [(none)]&gt; GRANT REPLICATION CLIENT,REPLICATION SLAVE ON *.* TO &apos;joah&apos;@&apos;192.168.4.62&apos; IDENTIFIED BY &apos;123456&apos;; #对用户授权 查看是否开启二进制日志MariaDB [(none)]&gt; SHOW VARIABLES LIKE &apos;%log%bin%&apos;; 在node1上二进制日志状态信息MariaDB [(none)]&gt; SHOW MASTER STATUS; 配置node2从服务器[root@node2~]#vim /etc/my.cnf.d/server.cnf [root@node2~]#systemctl start mariadb #启动mariadb服务 MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_HOST=&apos;192.168.4.61&apos;,MASTER_USER=&apos;joah&apos;,MASTER_PASSWORD=&apos;123456&apos;,MASTER_LOG_FILE=&apos;master-log.000003&apos;,MASTER_LOG_POS=417; #设置连接主服务器 启动从服务器MariaDB [(none)]&gt; START SLAVE; 启动IO线程和SQL线程MariaDB [(none)]&gt; START SLAVE IO_THREAD,SQL_THREAD; 查看从服务器状态MariaDB [(none)]&gt; START SLAVE IO_THREAD,SQL_THREAD; ######如果出现图中红框中的信息说明已经启动成功。 #####测试是否已经实现主从复制 实现SSL功能搭建CA服务器[root@CA/etc/pki/CA]#touch index.txt [root@CA/etc/pki/CA]#echo 01 &gt; serial 生成key文件[root@CA/etc/pki/CA]#(umask 077;openssl genrsa -out private/cakey.pem 2048) 生成自签证书[root@CA/etc/pki/CA]#openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days 3650 node1生成证书[root@node1~]#mkdir /etc/mysql/ssl -pv [root@node1~]#chown mysql.mysql /etc/mysql/ssl/ -R [root@node1/etc/mysql/ssl]#(umask 077;openssl genrsa -out master.key 2048)[root@node1/etc/mysql/ssl]#openssl req -new -key master.key -out master.csr [root@node1/etc/mysql/ssl]#scp master.csr 192.168.4.63:/etc/pki/CA/newcerts/ [root@CA/etc/pki/CA/newcerts]#openssl ca -in master.csr -out master.crt -days 365 [root@CA/etc/pki/CA/newcerts]#scp master.crt ../cacert.pem 192.168.4.61:/etc/mysql/ssl [root@node1~]#vim /etc/my.cnf.d/server.cnf [root@node1~]#systemctl restart mariadb 查看是否开启SSL功能 node2生成证书[root@node2~]#mkdir /etc/mysql/ssl -pv [root@node2~]#chown mysql.mysql /etc/mysql/ssl/ -R [root@node2/etc/mysql/ssl]#(umask 077;openssl genrsa -out slave.key 2048) [root@node2/etc/mysql/ssl]#openssl req -new -key slave.key -out slave.csr [root@node2/etc/mysql/ssl]#scp slave.csr 192.168.4.63:/etc/pki/CA/newcerts [root@CA/etc/pki/CA/newcerts]#openssl ca -in slave.csr -out slave.crt -days 365 [root@CA/etc/pki/CA/newcerts]#scp slave.crt ../cacert.pem 192.168.4.62:/etc/mysql/ssl [root@node2/etc/mysql/ssl]#vim /etc/my.cnf.d/server.cnf 重启服务[root@node2/etc/mysql/ssl]#systemctl restart mariadb 基于SSL连接node1授权MariaDB [(none)]&gt; GRANT REPLICATION CLIENT,REPLICATION SLAVE ON *.* TO &apos;joah&apos;@&apos;192.168.4.62&apos; IDENTIFIED BY &apos;123456&apos; REQUIRE SSL; 测试[root@node2~]#mysql -ujoah -p123456 -h192.168.4.61 --ssl node2连接主服务器以ssl复制MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_HOST=&apos;192.168.4.61&apos;,MASTER_USER=&apos;joah&apos;,MASTER_PASSWORD=&apos;123456&apos;,MASTER_LOG_FILE=&apos;master-log.000008&apos;,MASTER_LOG_POS=429,MASTER_SSL=1,MASTER_SSL_CA=&apos;/etc/mysql/ssl/cacert.pem&apos;,MASTER_SSL_CERT=&apos;/etc/mysql/ssl/slave.crt&apos;,MASTER_SSL_KEY=&apos;/etc/mysql/ssl/slave.key&apos;; MariaDB [(none)]&gt; START SLAVE; #启动从服务器 MariaDB [(none)]&gt; SHOW SLAVE STATUS\G; 小结（1）如果你已经正确的添加了证书，但是启动以后还是没有启动SSL功能，有可能没有权限 [root@node2~]#chown mysql.mysql -R /etc/mysql/ssl （2）如果出现图片中的问题，停止slave即可 （3）每一个过程中都需要验证是否成功然后进行下面的操作。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL基于SSL实现主从复制</category>
      </categories>
      <tags>
        <tag>Xtrabackup，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL双主模式]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E5%8F%8C%E4%B8%BB%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[双主模式互为主从：两个节点各自都要开启binlog和relay log （1）数据不一致 （2）自动增长ID 定义一个节点使用奇数ID auto_increment_offset=1 auto_increment_increment=2 另外一个节点使用偶数ID auto_increment_offset=2 auto_increment_increment=2 前提： （1）server_id必须要使用不同值 （2）均启用binlog和relay log （3）存在自动增长ID的表，为了使得ID不相冲突，需要定义其自动增长方式 （4）都授权复制权限的用户账号 （5）各把对方指定为主节点 复制时应该注意的问题： 1、从服务器设定为“只读” 在从服务器启动read_only，但仅对非SUPER权限用户有效 组织所有用户： FLUSH TABLES WITH READ LOCK; 2、尽量确保复制时的事物安全 在master节点启用参数 sync_binlog = ON 如果用到的是InnoDB存储引擎： innodb_flush_logs_at_trx_commit=ON innodb_support_xa=ON 3、从服务器意外终止时尽量避免自动复制线程 4、从节点：设置参数 sync_master_info = ON sync_relay_log_info = ON 实战： 在node1进行如下配置 [root@node1~]#vim /etc/my.cnf.d/server.cnf 在node2节点进行如下配置 [root@node2~]#vim /etc/my.cnf.d/server.cnf [root@node1~]#systemctl start mariadb [root@node2~]#systemctl start mariadb 在node1和node2相互授权 GRANT REPLICATION CLIENT,REPLICATION SLAVE ON *.* TO &apos;joah&apos;@&apos;192.168.4.62&apos; IDENTIFIED BY &apos;123456&apos;; GRANT REPLICATION CLIENT,REPLICATION SLAVE ON *.* TO &apos;joah&apos;@&apos;192.168.4.61&apos; IDENTIFIED BY &apos;123456&apos;; 在node1和node2指定master MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_HOST=&apos;192.168.4.62&apos;,MASTER_USER=&apos;joah&apos;,MASTER_PASSWORD=&apos;123456&apos;,MASTER_LOG_FILE=&apos;master-log.000003&apos;,MASTER_LOG_POS=422; MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_HOST=&apos;192.168.4.61&apos;,MASTER_USER=&apos;joah&apos;,MASTER_PASSWORD=&apos;123456&apos;,MASTER_LOG_FILE=&apos;master-log.000003&apos;,MASTER_LOG_POS=245; 在node1和node2启动从服务器 MariaDB [(none)]&gt; SHOW SLAVE STATUS\G; MariaDB [(none)]&gt; START SLAVE IO_THREAD,SQL_THREAD; 测试 MariaDB [(none)]&gt; SHOW SLAVE STATUS\G; 如果出现上述红框中yes字样就成功]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL双主模式</category>
      </categories>
      <tags>
        <tag>Xtrabackup，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基于证书连接]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E5%9F%BA%E4%BA%8E%E8%AF%81%E4%B9%A6%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[基于证书连接 搭建私有CA [root@CA/etc/pki/CA]#echo 01 &gt; serial [root@CA/etc/pki/CA]#touch index.txt [root@CA/etc/pki/CA]#(umask 077;openssl genrsa -out private/cakey.pem 2048) #创建key文件 [root@CA/etc/pki/CA]#openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days 3650 #创建自签证书 mysql创建证书文件 [root@mysql~]#yum insatll -y mariadb-server 查看是否支持ssl MariaDB [(none)]&gt; SHOW VARIABLES LIKE &apos;%ssl%&apos;; +---------------+----------+ | Variable_name | Value | +---------------+----------+ | have_openssl | DISABLED | #这里是支持ssl的没有启动而已 | have_ssl | DISABLED | | ssl_ca | | | ssl_capath | | | ssl_cert | | | ssl_cipher | | | ssl_key | | +---------------+----------+ [root@mysql/etc/my.cnf.d]#mkdir ssl [root@mysql/etc/my.cnf.d/ssl]#(umask 077;openssl genrsa -out mysqlsrv.key 2048) #生成key文件 [root@mysql/etc/my.cnf.d/ssl]#openssl req -new -key mysqlsrv.key -out mysqlsrv.csr #生成证书请求文件 You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter &apos;.&apos;, the field will be left blank. ----- Country Name (2 letter code) [XX]:CN State or Province Name (full name) []:zhengzhou Locality Name (eg, city) [Default City]:henan Organization Name (eg, company) [Default Company Ltd]:test Organizational Unit Name (eg, section) []:ops Common Name (eg, your name or your server&apos;s hostname) []:www.test.com Email Address []: Please enter the following &apos;extra&apos; attributes to be sent with your certificate request A challenge password []: An optional company name []: 注意：这里填写的内容需和CA认证中心对应 [root@mysql/etc/my.cnf.d/ssl]#scp mysqlsrv.csr 192.168.4.63:/etc/pki/CA/newcerts/ #将请求认证证书发送给认证中心 认证中心对请求证书签署 [root@CA/etc/pki/CA]#openssl ca -in newcerts/mysqlsrv.csr -out newcerts/mysqlsrv.crt -days 365 将ca证书和认证证书发送到myql客户端 [root@CA/etc/pki/CA/newcerts]#scp mysqlsrv.crt ../cacert.pem 192.168.4.62:/etc/my.cnf.d/ssl 修改刚刚生成文件的权限（因为mysql是以mysql用户运行的，如果您是别的用户修改别的用户即可） [root@mysql/etc/my.cnf.d/ssl]#chown mysql.mysql * 修改my.cnf配置文件 [root@mysql~]#vim /etc/my.cnf 重启服务测试 [root@mysql~]#systemctl restart mariadb MariaDB [(none)]&gt; SHOW VARIABLES LIKE &apos;%ssl%&apos;; +---------------+--------------------------------+ | Variable_name | Value | +---------------+--------------------------------+ | have_openssl | YES | #此时支持ssl功能了 | have_ssl | YES | | ssl_ca | /etc/my.cnf.d/ssl/cacert.pem | | ssl_capath | | | ssl_cert | /etc/my.cnf.d/ssl/mysqlsrv.crt | | ssl_cipher | | | ssl_key | /etc/my.cnf.d/ssl/mysqlsrv.key | +---------------+--------------------------------+ 7 rows in set (0.00 sec) 客户端配置 [root@client~]#mkdir .mysql/ssl -pv #基于安全考虑使用隐藏目录 [root@client~/.mysql/ssl]#(umask 077;openssl genrsa -out mysqlcli.key 2048) [root@client~/.mysql/ssl]#openssl req -new -key mysqlcli.key -out mysqlcli.csr 将请求认证文件发送到CA认证中心 [root@client~/.mysql/ssl]#scp mysqlcli.csr 192.168.4.63:/etc/pki/CA/newcerts/ 认证中心对此请求证书签署 [root@CA/etc/pki/CA/newcerts]#openssl ca -in mysqlcli.csr -out mysqlcli.crt -days 365 [root@CA/etc/pki/CA/newcerts]#scp mysqlcli.crt ../cacert.pem 192.168.4.61:/root/.mysql/ssl #将签署证书和ca证书发送给客户端 修改配置文件 [root@client~]#vim /etc/my.cnf 11 ssl-ca=/data/ssl/cacert.pem 12 ssl-key=/data/ssl/s.key 13 ssl-cert=/data/ssl/s.crt 测试 MariaDB [(none)]&gt; GRANT ALL ON *.* to &apos;joah&apos;@&apos;192.168.4.61&apos; IDENTIFIED BY &apos;123456&apos; REQUIRE ssl; #授权某个用户 [root@client~]#mysql -ujoah -p -h192.168.4.62 --ssl]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL基于证书连接</category>
      </categories>
      <tags>
        <tag>证书，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础一]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E5%9F%BA%E7%A1%80%E4%B8%80%2F</url>
    <content type="text"><![CDATA[mysql1、概念MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。 2、mariadbMariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。在存储引擎方面，使用XtraDB（英语：XtraDB）来代替MySQL的InnoDB。 MariaDB由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入Oracle的手中。MariaDB名称来自Michael Widenius的女儿Maria的名字。 3、如何使用二进制安装mariadb呢？之前我们讲过使用源码编译安装DNS，其实编译安装的过程都是大同小异的，但是源码编译安装会耗费我们很多的时间，是不是如果有人把源码编译好我们直接使用该如何呢？但是这种方式有一个缺点不能自己定制自己的需求，如果你想只针对自己的需求安装那就只能使用源码编译安装了。下面我们就来看看二进制如何安装mariadb 先从官网下载二进制包 https://downloads.mariadb.org/mariadb/10.2.8/ 创建mysql用户 [root@localhost mysql]# useradd -r -m -d /app/testdata -s /sbin/nologin mysql 解压指定目录并创建软连接 [root@localhost ~]# tar xvf mariadb-10.2.8-linux-x86_64.tar.gz -C /usr/local [root@localhost local]# ln -sv mariadb-10.2.8-linux-x86_64/ mysql #创建软连接 准备配置文件 [root@localhost mysql]# mkdir /etc/mysql #创建目录 [root@localhost mysql]# cp support-files/my-large.cnf /etc/mysql/my.cnf #复制模板文件 [root@localhost mysql]# cd /etc/mysql/ [root@localhost mysql]# vim my.cnf #修改配置文件 [mysqld] datadir = /app/testdata innodb_file_per_table = on skip-name_resolve = on port = 3306 socket = /tmp/mysql.sock skip-external-locking key_buffer_size = 256M max_allowed_packet = 1M table_open_cache = 256 sort_buffer_size = 1M read_buffer_size = 1M read_rnd_buffer_size = 4M myisam_sort_buffer_size = 64M thread_cache_size = 8 query_cache_size= 16M 现在我们已经把主配置文件创建好了，但是如果现在启动的话，会出现下面情况 [root@localhost~]#service mysqld start Redirecting to /bin/systemctl start mysqld.service Failed to start mysqld.service: Unit not found. 我们还没有创建启动脚本呢！！！ [root@localhost mysql]# cp support-files/mysql.server /etc/rc.d/init.d/mysqld #将启动脚本复制到启动脚本目录下 [root@localhost mysql]# chkconfig --add mysqld #添加服务 创建数据库文件 [root@localhost/usr/local/mysql]#./scripts/mysql_install_db --datadir=/app/testdata --user=mysql #初始化数据库，但是这里需要注意的是这个执行文件必须在文件父目录上执行。 这是我们尝试去启动mysqld，看看是否可以启动 [root@localhost/usr/local/mysql]#service mysqld start 出错啦，出错啦，是什么原因呢？使我们的日志文件没有创建导致，现在我们去解决这个问题。 [root@localhost/usr/local/mysql]#journalctl -xe #查看日志 Sep 25 15:07:28 localhost.localdomain mysqld[3756]: Starting MySQL.170925 15:07:28 mysqld_safe Logging to &apos;/var/log/mariadb/mariadb.log&apos;. 如何解决这个问题呢？ [root@localhost/usr/local/mysql]#mkdir /var/log/mariadb [root@localhost/usr/local/mysql]#touch /var/log/mariadb/mariadb.log #创建日志文件 [root@localhost/usr/local/mysql]#setfacl -R -m u:mysql:rwx /var/log/mariadb/ #设置权限 现在我们来再尝试启动，看看能不能成功呢？ [root@localhost/usr/local/mysql]#service mysqld start Starting mysqld (via systemctl): [ OK ] 高兴，终于启动了，那让我们来尽情的享用吧？ 初始化数据库 [root@localhost/usr/local/mysql]#/usr/local/mysql/bin/mysql_secure_installation NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY! In order to log into MariaDB to secure it, we&apos;ll need the current password for the root user. If you&apos;ve just installed MariaDB, and you haven&apos;t set the root password yet, the password will be blank, so you should just press enter here. Enter current password for root (enter for none): #输入现在的密码，新创建的密码为空，直接回车 OK, successfully used password, moving on... Setting the root password ensures that nobody can log into the MariaDB root user without the proper authorisation. Set root password? [Y/n] Y #询问是否为root创建密码 New password: #输入密码 Re-enter new password: Password updated successfully! Reloading privilege tables.. ... Success! By default, a MariaDB installation has an anonymous user, allowing anyone to log into MariaDB without having to have a user account created for them. This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment. Remove anonymous users? [Y/n] Y #是否移除匿名用户 ... Success! Normally, root should only be allowed to connect from &apos;localhost&apos;. This ensures that someone cannot guess at the root password from the network. Disallow root login remotely? [Y/n] Y #是否远程root 登录 ... Success! By default, MariaDB comes with a database named &apos;test&apos; that anyone can access. This is also intended only for testing, and should be removed before moving into a production environment. Remove test database and access to it? [Y/n] N #是否移除test数据库 ... skipping. Reloading the privilege tables will ensure that all changes made so far will take effect immediately. Reload privilege tables now? [Y/n] Y #是否立即生效 ... Success! Cleaning up... All done! If you&apos;ve completed all of the above steps, your MariaDB installation should now be secure. Thanks for using MariaDB! 咦，有出错了，先哭会，再解决；这个原因是我们没有设置mysql路径，那么我们来设置下喽。 [root@localhost/usr/local/mysql]#vim /etc/profile.d/mysql.sh #写路径 export PATH=/usr/local/mysql/bin:$PATH [root@localhost/usr/local/mysql]#source /etc/profile.d/mysql.sh #使其生效。 如果您出现上图所示内容，说明你已经成功，来给自己鼓个掌。 安装过程中有没有注意到，为什么我们要创建/etc/mysql/目录来创建配置文件呢？ 在mysql中配置文件查找次序：后面的会覆盖前面的配置文件 /etc/my.cnf–&gt;/etc/mysql/my.cnf–&gt;–default-extra-file=/PATH/TO/CONF_FILE–&gt;/.my.cnf 示例创建两张表一个学生基本信息如ID、姓名、性别、年龄。另一张表为学生的成绩ID、姓名、成绩 MariaDB [student]&gt; CREATE TABLE information(ID TINYINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,name VARCHAR(20) NOT NULL,age TINYINT UNSIGNED) MariaDB [student]&gt; CREATE TABLE score (ID TINYINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,name VARCHAR(20) NOT NULL , scores INT NOT NULL); 授权用户MariaDB [mysql]&gt; SELECT user,host,password FROM user; 如何给创建用户并添加密码呢？ MariaDB [(none)]&gt; CREATE USER &#39;li&#39;@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;123456&#39;; MariaDB [(none)]&gt; CREATE USER &#39;wang&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;; 如何更改口令呢？ MariaDB [(none)]&gt; UPDATE mysql.user SET PASSWORD = PASSWORD(&#39;123456&#39;) WHERE USER = &#39;li&#39;; MariaDB [(none)]&gt; SET PASSWORD FOR &#39;li&#39;@&#39;192.168.4.%&#39; = PASSWORD(&#39;123456&#39;); 在一台主机上远程登录，可以登了，但是看不到数据库 那么如何才可以使其使用呢？那必须授权此用户操作。 MariaDB [(none)]&gt; GRANT SELECT,DELETE ON student.* TO &#39;li&#39;@&#39;192.168.4.%&#39;; MariaDB [(none)]&gt; REVOKE ALL ON student.* FROM &#39;li&#39;@&#39;192.168.4.%&#39;; #当有一天这个人离职了，需要收回特权。 **注意：mariadb服务进程启动时会读取mysql库中的所有授权表至内存中。 (1)GRANT或REVOKE等执行权限操作会保存于系统表汇总，mariadb的服务进程通常自动重读授权表，使其生效。（2）对于不能够或不能及时重读授权表的命令，可手动让mariadb的服务进行重复授权表。FLUSH PRIVILEGES]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL基础一</category>
      </categories>
      <tags>
        <tag>数据库，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL备份与恢复]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[mysql备份和恢复（数据）：备份存储的数据副本；原始数据：持续改变。 备份原因：灾难恢复：硬件故障（冗余）、软件故障（bug）、自然灾害、黑客攻击、误操作等等。 备份时应注意事项 能容忍最多丢失多少数据 恢复数据需要在多长时间内完成 需要恢复哪些数据 备份类型 备份的数据集的范围： 完全备份：整个数据集 部分备份：数据集的一部分，比如部分表等 全量备份、增量备份、差异备份： 完成备份：整个数据集、文件等 增量备份：仅备份自上一次完全备份或增量备份以来变量的那部分数据 差异备份：仅备份自上一次完成备份以来的那部分数据 物理备份、逻辑备份： 物理备份：复制数据文件进行的备份 逻辑备份：从数据库导出数据另存在一个或多个文件 根据数据服务是否在线： 热备：读写操作均可进行的状态下所做的备份 温备：可读但不可写状态下进行的备份 冷备：读写操作不可进行的状态下所做的备份 备份需要考虑因素：锁定资源多长时间？ 备份过程的时长？ 备份时的服务器负载？ 恢复过程的时长？ 备份策略： 全量+差异+binlogs 全量+增量+binlogs 备份内容： 数据 二进制日志、InnoDB的事物日志 代码（存储过程、存储函数、触发器、时间调度器） 服务器的配置文件 备份工具： mysqldump mysql服务自带的备份工具；逻辑备份工具 InnoDB:支持热备、温备、冷备 MyISAM：支持温备、冷备；备份时要锁定表 mysqldump命令使用格式： mysqldump [OPTIONS] database [tables] 备份单库，可以只备份其中一部分表（部分备份） OR mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...] 备份多库 OR mysqldump [OPTIONS] --all-databases [OPTIONS] 备份所有库 选项： -x，--lock-all-tables：锁定所有库的所有表，读锁 -l，--lock-talbes：锁定指定库所有表 --single-transaction：创建一个事物，基于快照执行备份 -R，--routines：备份指定库的存储过程和存储函数 --triggers：备份指定库的触发器 -E，--events：备份事务 --master-data[=#] 1 ：记录为CHANGE MASTER TO语句，此语句不被注释 2：记录为CHANGE MASTER TO 语句，此语句被注释 --flush-logs：锁定表完成后，即进行日志刷新操作 示例： 只备份某个库某张表 [root@client~]#mysqldump -uroot -h 192.168.4.62 -p --databases hellodb --tables classes 只备份某个库的多张表 [root@client~]#mysqldump -uroot -h 192.168.4.62 -p --databases hellodb --tables classes coc 备份多个库 [root@client~]#mysqldump -uroot -h 192.168.4.62 -p --databases hellodb mysql 备份所有库 [root@client~]#mysqldump -uroot -p -h192.168.4.62 --all-databases 备份时锁定指定库的所有表 [root@client~]#mysqldump -uroot -p -h192.168.4.62 --databases hellodb -l 备份创建一个事物并锁定指定库所有表 [root@client~]#mysqldump -uroot -p -h192.168.4.62 --databases hellodb -l --single-transaction 如果锁定某个时间点如何做？ [root@client~]#mysqldump -uroot -p -h192.168.4.62 --databases hellodb --tables classes -l --single-transaction --master-data=2 --triggers -E &gt;test.sqll 这样我们就可以支持从哪个binlog日志中回复并从那个点回复 实战： 将一个数据库复制然后恢复，如何操作？ （1）在远程主机上dump [root@client~]#mysqldump -uroot -p -h192.168.4.62 --all-databases --master-data=2 --triggers -E --single-transaction -R --flush-logs &gt;test.sql 如果有远程存储服务器可以存储到此服务器上。 （2）模拟数据库奔溃 [root@mysql~]#systemctl stop mariadb [root@mysql~]#rm -rf /var/lib/mysql/ （3）恢复数据库 [root@client~]#scp test.sql 192.168.4.62:root #将备份文件拷贝到mysql服务器上 创建数据库存放位置 [root@mysql~]#mkdir /var/lib/mysql [root@mysql~]#chown mysql.mysql /var/lib/mysql #修改所有者所属组 先关闭此会话binlog日志功能 MariaDB [(none)]&gt; SET @@session.sql_log_bin=OFF； MariaDB [(none)]&gt; SELECT @@session.sql_log_bin #查询是否关闭 导入文件 [root@mysql~]#mysql &lt; test.sql 查看此时时从哪个时间点记录的 使用binlog日志恢复此后的内容 [root@mysql/app/data/binlog]#mysqlbinlog master-log.000001 -j 245 &gt; /tmp/testbin.sql 这里防止到tmp目录下，对所用用户都可以访问，如果您想放到别的目录下，如果使用下面操作需对mysql用户授权 MariaDB [(none)]&gt; \. /tmp/testbin.sql 导入数据库 MariaDB [hellodb]&gt; SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | hellodb | | mysql | | performance_schema | | test | +--------------------+ 5 rows in set (0.01 sec) 至此已经完成恢复 开启binlog日志功能 MariaDB [hellodb]&gt; SET @@session.sql_log_bin=ON; cp/tar 基于lvm，快照（请求一个全局锁），之后立即释放锁，达到几乎热备的效果，物理备份 注意：不能仅备份数据；同时备份事物日志；并且要求数据文件和事物日志位于同一个逻辑卷。 实战： 创建逻辑卷 [root@localhost~]#fdisk /dev/sdb 同步磁盘 [root@localhost~]#partprobe /dev/sdb 创建物理卷 [root@localhost~]#pvcreate /dev/sdb{1,2} [root@localhost~]#pvdisplay 创建卷组 [root@localhost~]#vgcreate mysqldisk /dev/sdb{1,2} [root@localhost~]#vgdisplay 创建逻辑卷 [root@localhost~]#lvcreate -L 15 -n mysqlv mysqldisk /dev/sdb{1,2} [root@localhost~]#lvdisplay 格式化 [root@localhost~]#mke2fs -t ext4 /dev/mysqldisk/mysqlv 挂载 [root@localhost~]#mkdir /data/mysql [root@localhost~]#mount /dev/mysqldisk/mysqlv /data/mysql/ 修改mysql数据和日志存放位置 [root@localhost~]#chown mysql.mysql /data/mysql/ [root@localhost~]#vim /etc/my.cnf [root@localhost~]#vim /etc/my.cnf.d/server.cnf 请求锁定所有表 MariaDB [hellodb]&gt; FLUSH TABLES WITH READ LOCK; 查看二进制日志 MariaDB [hellodb]&gt; FLUSH LOGS; MariaDB [hellodb]&gt; SHOW MASTER STATUS; 创建快照卷 [root@localhost~]#lvcreate -L 2G -s -p r -n mysql /dev/mysqldisk/mysqlv 释放锁 MariaDB [hellodb]&gt; UNLOCK TABLES; 挂载快照，并执行备份，备份完后删除快照卷 创建临时挂载点并挂载快照 [root@localhost~]#mkdir /test [root@localhost~]#mount /dev/mysqldisk/mysnap /test/ 如果有远程存储可以将内容存储到远程服务器上 [root@localhost~]#mkdir /backup/mysql -pv #创建一个备份目录 [root@localhost~]#cp -a /test/* /backup/mysql 卸载挂载点并删除快照 [root@localhost~]#umount /test/ [root@localhost~]#lvremove /dev/mysqldisk/mysnap 周期性备份二进制日志并将文件放置到远程存储服务器上 [root@localhost/data/mysql]#mysqlbinlog master-log.000003 &gt; test.sql 如果库被删除如何恢复？ [root@localhost~]#rm -rf /data/mysql/* [root@localhost~]#cp /backup/mysql/* /data/mysql/ -a [root@localhost~]#mysql &lt; test.sql 至此数据库就恢复完成了。 如果需要将文件压缩打包传送到远程服务器，可以使用如下命令： [root@localhost~]#tar cvf mysql.tar /backup/mysql/*]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL备份与恢复</category>
      </categories>
      <tags>
        <tag>备份与恢复，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL工作方式]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[##1、mysql读取配置文件次序 ###my_print_defaultsdisplay options from option files 使用方法： my_print_defaults [options] option_group ... 选项： --defaults-file=file_name #修改默认读取的配置文件 --defaults-extra-file=path #在读取的默认配置文件之外再加载一个文件 [root@localhost~]#my_print_defaults --version #打印出信息 Default options are read from the following files in the given order 读取多出的多个配置文件，而且以指定的次序进行: /etc/mysql/my.cnf /etc/my.cnf ~/.my.cnf 不同的配置文件中出现同一个参数且拥有不同值时，后读取配置文件中的参数将为最终生效值。- ##2、mysqld服务器程序工作特性 ###服务器变量类型 全局（global）：对所有会话生效；所有的会话在建立时都从全局继承，但继承完成后每个会话独立维护自己会话级变量；修改时需要管理权限。 会话（session）：仅对当前会话有效；修改此变量即可生效并且不需要有管理权限。 ####修改变量的方法： 动态修改：会话级别，并且立即生效；全局级别，新建立的会话有效，对此前已经连接的会话无效。 静态修改：修改配置文件，或修改传递给mysqld的选项的值，重启后生效。 #####上述的修改访问不能永久保存，如果需要永久保存需要写入配置文件中；并且重启服务才能生效。 注意：并非所有的变量都支持动态修改。- ####查看服务器变量的方法 （1）方法一 mysql&gt; SHOW [GLOBAL | SESSION] VARIABLES [LIKE &apos;pattern&apos; | WHERE expr] （2）方法二 mysql&gt; SELECT@@{GLOBAL|SESSION}.VARIABLE_NAME 示例： MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES\G; #显示所有全局变量 MariaDB [(none)]&gt; SHOW SESSION VARIABLES\G; #显示所有会话变量 MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES LIKE &apos;innodb_file_per_table&apos;; #显示某个全局变量的信息 +-----------------------+-------+ | Variable_name | Value | +-----------------------+-------+ | innodb_file_per_table | OFF | +-----------------------+-------+ MariaDB [(none)]&gt; SHOW SESSION VARIABLES LIKE &apos;wait_timeout&apos;; #查看某个会话变量信息 +---------------+-------+ | Variable_name | Value | +---------------+-------+ | wait_timeout | 28800 | +---------------+-------+ MariaDB [(none)]&gt; SELECT @@SESSION.tx_isolation; #查看会话隔离级别 +------------------------+ | @@SESSION.tx_isolation | +------------------------+ | REPEATABLE-READ | +------------------------+ MariaDB [(none)]&gt; SELECT @@GLOBAL.tx_isolation; #查看全局隔离级别 +-----------------------+ | @@GLOBAL.tx_isolation | +-----------------------+ | REPEATABLE-READ | +-----------------------+ ###运行时修改变量值操作方法 使用格式： SET variable_assignment [, variable_assignment] ... variable_assignment: user_var_name = expr | [GLOBAL | SESSION] system_var_name = expr | [@@global. | @@session. | @@]system_var_name = expr 示例： MariaDB [(none)]&gt; SET @@SESSION.autocommit=0; #设置会话变量 MariaDB [(none)]&gt; SET SESSION autocommit=0 ; MariaDB [(none)]&gt; SELECT @@SESSION.autocommit; +----------------------+ | @@SESSION.autocommit | +----------------------+ | 0 | +----------------------+ 注意：GOLBAL值的修改要求用户拥有管理权限。- ####参看数据库服务器状态信息 mysql&gt; SHOW GLOBA|[SESSION] STATUS [LIKE clause]; 示例： MariaDB [(none)]&gt; SHOW GLOBAL STATUS; #显示全局状态信息 MariaDB [(none)]&gt; SHOW SESSION STATUS; #显示当前会话状态信息 MariaDB [(none)]&gt; SHOW SESSION STATUS LIKE &apos;Uptime&apos;; #显示当前会话某个状态信息 数据库实现并发控制- ####类类型：读锁：共享锁，可被多个读操作共享 写锁：排他锁，独占锁 ####锁粒度：表锁：在表级别施加的锁，并发性降低 行锁：在行级别施加锁，并发性较高；维持所状态的成本较大 ####锁类别： 显示锁：用户手动请求的锁 隐式锁：存储引擎自行根据需要施加的锁 示例：显示所使用 如图所示，如果设置为read，不能进行写操作 撤销所以后写进入了 将表设置为write测试 小结： 如果将表设置为read状态，可以在另外一个终端读，但是写不进去；如果将表设置为write状态，在另外一个终端读不行，写也不行。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL工作方式</category>
      </categories>
      <tags>
        <tag>mysql工作方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL引擎]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[ACID测试 A：AUTOMICITY ，原子性；整个事物中的所有操作要么全部成功执行，要么全部失败后回滚 C：CONSISTENY,一致性；数据库总是应该从一个一致性状态转为另一个一致性状态 I：ISOLATION：隔离性；一个数据所作出的操作在提交之前，是否能为其它事物可见；出于保证并发操作之目的，隔离有多种级别 D：DURABILITY 持久性；事物一旦提交，其所作出的修改会永久保存 事物隔离级别 READ-UNCOMMITTED：读未提交–&gt;脏读 READ-COMMITTED：读提交–&gt;不可重复读 REPEATABLE-READ：可重复读–&gt;幻读 SERIALIZABLE：串行化 手动控制事物启动：START TRANSACTION 提交：COMMIT 回滚：ROLLBACK 事物支持savepoints： SAVEPOINT identifier ROLLBACK [work] TO [SAVEPOINT] identifier RELEASE SAVEPOINT identifier 查看InnoDB存储引擎的状态信息 MariaDB [class]&gt; SHOW ENGINE innodb STATUS\G; mysql服务器引擎- 存储引擎：也称为“表类型”，表级别概念，不建议咋同一个库中的表上使用不同的ENGINE。 查看数据库服务器支持的引擎 MariaDB [(none)]&gt; SHOW ENGINES\G; MariaDB [(none)]&gt; SHOW ENGINE INNODB STATUS\G; #显示INNODB引擎状态 常见的引擎 MyISAM, Aria, InnoDB, MRG_MYISAM, CSV, BLACKHOLE, MEMORY, PERFORMANCE_SCHEMA, ARCHIVE, FEDERATED InnoDB和MyISAM引擎的区别- InnoDB Percon-XtraDB，支持事物，支持级别锁，支持外键 数据存储在“表空间（tables space）”中： （1）所有数据库中所有类型为InnoDB的表的数据和索引存储于同一个表空间中； 表空间文件：datadir定义的目录中 文件：ibdata1，ibdata2... （2）innodb_file_per_table=ON这个选项添加到配置文件中意味着每张表使用单独的表空间文件；每张表的数据文件（数据和索引，存储于数据库目录）存储在自己专用的表空间文件中，并存储于数据库目录下：tb1_name.ibd 表结构定义：在数据库目录，tb1——name.frm [root@localhost~]#vim /etc/my.cnf [root@localhost~]#systemctl start mariadb.service #重启服务 MariaDB [students]&gt; CREATE TABLE student (ID INT,NAME VARCHAR(30)); #创建一张表 [root@localhost/var/lib/mysql/students]#ls db.opt student.frm student.ibd 事务性存储引擎，适合对事物要求较高的场景中；但较适用于处理大量短期事物 基于MVCC（Mutli Version Concurrency Control） 支持高并发； 支持四个隔离级别，默认级别为REPEATALBE-READ;间隙锁以防止幻读 MariaDB [students]&gt; SHOW SESSION VARIABLES LIKE ‘tx_isolation’; +—————+—————–+ | Variable_name | Value | +—————+—————–+ | tx_isolation | REPEATABLE-READ | +—————+—————–+ MariaDB [students]&gt; SELECT @@GLOBAL.tx_isolation; +———————–+ | @@GLOBAL.tx_isolation | +———————–+ | REPEATABLE-READ | +———————–+ 使用聚集所以（主键索引） 支持“自适应Hash索引” 锁粒度：行级锁，间隙锁 小结： 数据存储：表空间 并发：MVCC，间隙锁，行级锁 索引：聚集索引、辅助索引 性能：预读操作、内存数据缓冲、自适应Hash索引、插入操作缓存区 备份：支持热备 MyISAM 支持全文索引、压缩、空间函数（GIS） 不支持事物 锁粒度：表级锁 崩溃无法保证表安全恢复 使用场景：只读或读多写少的场景、较小的表（以保证崩溃后恢复的时间较短） 文件：每个表有三个文件，存储于数据库目录中 tb1_name.frm：表格式定义 tb1_name.MYD：数据文件 tb1_name.MYI：索引文件 示例： MariaDB [students]&gt; CREATE DATABASE class; MariaDB [class]&gt; CREATE TABLE classes (ID INT ,number INT) ENGINE MyISAM; #创建表并指定引擎 [root@localhost/var/lib/mysql/class]#ls classes.frm classes.MYD classes.MYI class.frm class.ibd db.opt 特性： 加锁和并发：表级锁 修复：手动或自动修复、但可能会丢失数据 索引：非聚集索引 延迟索引更新 表压缩 其他的存储引擎CSV：将CSV文件（以逗号分隔字段的文本文件）作为mysql表文件 MRG_MYISAM：将多个MyISAM表合并成虚拟表 BLANCKHOLE：类似于/dev/null，不真正存储数据 MEMORY：内存存储引擎，支持hash索引，表级锁，常用于临时表 FEDERATED：用于访问其他远程mysql服务器上表的存储引擎接口 mariadb额外支持很多中引擎：OQGraph、SphinxSE、TokuDB、Cassandra、CONNECT、SQUENCE、..]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL引擎</category>
      </categories>
      <tags>
        <tag>引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL日志]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[##mysql日志 mysql日志分类 查询日志：general_log 慢查询日志：log_slow_queries 错误日志：log_error，log_warnings 二进制日志：binlog 中继日志：relay_log 事物日志：innodb_log 查询日志记录查询语句日志存储位置： 文件：file 表：table（mysql.general_log） 选项： general_log={ON|OFF}：是否开启日志查询功能 general_log_file=HOSTNAME.log：如果日志以文件存储，此时指定存放日志的文件；并且日志文件名称以主机名.log命名 log_output={FILE|TABLE|NONE}：指定日志输出的格式 注意：查询日志一般不建议开启。 示例： 基于file存储 查看mysql是否开启日志存储功能MariaDB [(none)]&gt; SHOW VARIABLES LIKE &apos;general_log%&apos;; 开启日志存储功能并以file存储MariaDB [(none)]&gt; SHOW VARIABLES LIKE &apos;log_output&apos;; #查看以日志存储以什么形式存储 如果没有以file格式存储则通过如下方式开启即可 MariaDB [hellodb]&gt; SET @@global.log_output=FILE; MariaDB [(none)]&gt; SET @@global.general_log=ON; #开启查询日志存储功能 测试是否我们执行操作时记录日志中 MariaDB [hellodb]&gt; INSERT INTO students (StuID,Name,Age,Gender,ClassID,TeacherID) VALUES (26,&quot;xiao li&quot;,25,&quot;F&quot;,5,24); 基于table存储查询日志 设置为以table存储MariaDB [hellodb]&gt; SET @@global.log_output=&quot;TABLE&quot;; MariaDB [hellodb]&gt; SHOW VARIABLES LIKE &apos;log_output&apos;; #查询是否设置成功 +---------------+-------+ | Variable_name | Value | +---------------+-------+ | log_output | TABLE | +---------------+-------+ 测试是否已经启动table记录查询日志 event_time：时间发生时间 user_host：用户和主机 thread_id：线程ID server_id：服务ID command_type：命令类型 argument：参数 慢查询日志慢查询：运行时间超出指定时长的查询 选项： long_query_time：慢查询等待时长 log_slow_queries={ON|OFF}：日志是否开启慢查询功能 slow_query_log={ON|OFF}：是否开启慢查询功能 slow_query_log_file：慢查询文件 log_output={FILE|TABLE|NONE}：慢查询类型 log_slow_filter=admin,filesort,filesort_on_disk,full_join,full_scan,query_cache,query_cache_miss,tmp_table,tmp_table_on_disk 慢查询过滤 log_slow_rate_limit：慢查询速率限制 log_slow_verbosity 查看默认值 MariaDB [mysql]&gt; SHOW VARIABLES LIKE &apos;long_query_time&apos;; +-----------------+-----------+ | Variable_name | Value | +-----------------+-----------+ | long_query_time | 10.000000 | +-----------------+-----------+ 存储位置 文件：FILE 表：TABLE,mysql.slog_log 错误日志错误日志记录如下几类信息： （1）mysqld启动和关闭过程中输出的信息 （2）mysqld运行中产生的错误信息 （3）event scheduler运行时产生的信息，相当于周期性计划 （4）主从复制架构中，从服务器复制线程启动时产生的日志 选项： log_error=/var/log/mariadb/mariadb.log|log #是否开启错误日志 log_warnings={ON|OFF}：是否开启警告日志 示例： 建议：开启错误日志功能，方便以后排错 二进制日志用于记录引起数据改变或存在引起数据改变的潜在可能性的语句（STATEMENT）或改变后的结果（ROW）,也可能是二者混合。 作用：实现重放，恢复到某个时间点。 选项： binlog_format={STATEMENT|ROW|MIXED} #二进制日志格式 log_bin=/PATH/TO/BIN_LOG_FILE 定义二进制日志存放位置 session.sql_log_bin={ON|OFF}：控制某回话中的”写“操作语句是否会被记录于日志文件中 max_binlog_size 二进制文件最大容量 sync_binlog={1|0}：是否同步到磁盘中，binlogs先缓冲在内存中，不会立即写入磁盘中，开启此选项是否直接写入磁盘中。 查看二进制日志文件中的事件语法： SHOW BINLOG EVENTS [IN &apos;log_name&apos;] [FROM pos] [LIMIT [offset,] row_count] 示例： 创建二进制日志存放位置 [root@mysql~]#mkdir /app/data/binlog -pv [root@mysql~]#chown -R mysql.mysql /app/data/binlog/ #对mysql用户赋予权限 修改服务端配置文件启动二进制日志功能 [root@mysql~]#vim /etc/my.cnf.d/server.cnf 注意：二进制文件自动会加后缀 重启mysql服务 [root@mysql~]#systemctl restart mariadb 查看是否启动二进制功能 测试是否已经可以使用二进制日志功能 执行一些语句 MariaDB [hellodb]&gt; SELECT * FROM courses; 查看是否生成二进制文件 [root@mysql/app/data/binlog]#ls master-log.000001 master-log.index 查看二进制内容方法 [root@mysql/app/data/binlog]#mysqlbinlog master-log.000001 事件的起始位置：# at NUMBER 事件发生的日期时间：#171110 21:07:44 事件发生的服务器ID：server id 1 事件的结束位置： end_log_pos 427 事件的类型：Query 事件发生时所在服务器执行此时间的线程ID：thread_id=2 语句的时间戳与将其写入二进制日志文件中的时间差：exec_time=0 错误代码：error_code=0 设定时间发生的时间戳：SET TIMESTAMP=1510320590/*!*/; 事件内容 中继日志：从服务器上记录下来从主服务器的二进制日志文件同步过来的事件 事物日志：事物型存储引擎innodb用于保证事物特性的日志文件 注意：如果我们使用二进制日志回放，建议关闭此时会话记录二进制日志。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL日志</category>
      </categories>
      <tags>
        <tag>日志，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL用户管理]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[用户管理1、新建普通用户（1）使用CREATE USER语句创建新用户 使用格式： CREATE USER &apos;user&apos;@&apos;host&apos; [IDENTIFIED BY [PASSWORD] &apos;password&apos;] [,&apos;user&apos;@&apos;host&apos; [IDENTIFIED BY [PASSWORD] &apos;password&apos;]...] user：新建用户 host：主机名 IDENTIFIED BY 设置用户密码 示例： MariaDB [(none)]&gt; CREATE USER test@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;; 在mysql.user表中会插入一行记录 MariaDB [(none)]&gt; SELECT user,host,password FROM mysql.user; +------+-----------------------+-------------------------------------------+ | user | host | password | +------+-----------------------+-------------------------------------------+ | root | localhost | | | root | localhost.localdomain | | | root | 127.0.0.1 | | | root | ::1 | | | | localhost | | | | localhost.localdomain | | | test | localhost | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 | +------+-----------------------+-------------------------------------------+ （2）在musql.user表中INSERT用户 MariaDB [(none)]&gt; INSERT INTO mysql.user (user,host,password) VALUES (&quot;testA&quot;,&quot;192.168.4.60&quot;,PASSWORD(&apos;123456&apos;)); 执行完INSERT之后，要使用如下命令生效。 MariaDB [(none)]&gt; FLUSH PRIVILEGES; （3）使用GRANT创建用户 使用格式： GRANT priv_type ON database.table TO user[IDENTIFIED BY [PASSWORD] &apos;password&apos;] [,user [IDENTIFIED BY [PASSWORD] &apos;password&apos;]...] priv_type：授予的权限 database.table：权限的范围 user：新建用户 IDENTIFIED BY 设置密码 示例： MariaDB [(none)]&gt; GRANT SELECT ON *.* TO testB@&apos;192.168.4.60&apos; IDENTIFIED BY &apos;123456&apos;; 2、重命名使用格式： RENAME USER old_user TO new_user[, old_user TO new_user] ... 示例： MariaDB [(none)]&gt; RENAME USER testA@&apos;192.168.4.60&apos; TO testC@&apos;192.168.4.60&apos;; 3、删除用户使用格式： DROP USER &apos;user&apos;@&apos;host&apos; [, &apos;user&apos;@&apos;host&apos;] ... 示例： MariaDB [class]&gt; DROP USER testC@&apos;192.168.4.60&apos;; 4、修改用户密码（1）使用mysqladmin命令修改密码 使用格式： mysqladmin -uUSERNAME -hHOST -p password &apos;NEW_PASS&apos; 示例： [root@localhost~]#mysqladmin -uroot -p password Enter password: New password: Confirm new password: [root@localhost~]#mysqladmin -utest -p password &#39;testabd&#39; Enter password: mysqladmin: Can&apos;t turn off logging; error: &apos;Access denied; you need (at least one of) the SUPER privilege(s) for this operation&apos; 修改普通用户需要超级管理权限 （2）修改mysql.user表 使用格式： UPDATE mysql.user SET Password=PASSWORD(&apos;cleartext password&apos;) WHERE User=&apos;USERNAME&apos; AND Host=&apos;HOST&apos;; 示例： MariaDB [(none)]&gt; UPDATE mysql.user SET PASSWORD=PASSWORD(&apos;testabcd&apos;) WHERE User=&apos;test&apos;; （3）使用SET语句修改密码 使用格式： SET PASSWORD [FOR &apos;user&apos;@&apos;host&apos;] = PASSWORD(&apos;cleartext password&apos;); 示例： MariaDB [(none)]&gt; SET PASSWORD FOR test@&apos;localhost&apos;=PASSWORD(&apos;testabcd&apos;); （4）GRANT语句修改普通用户密码 示例： MariaDB [(none)]&gt; GRANT SELECT ON *.* TO &apos;test&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;; 5、忘记管理员密码如何解决？（1）先确保mysql服务停止 [root@localhost~]#systemctl stop mariadb.service （2）确保其他用户连接不到mysql服务 （3）修改启动配置文件 [root@localhost~]#vim /usr/lib/systemd/system/mariadb.service （4）启动服务并修改密码 [root@localhost~]#systemctl restart mariadb.service MariaDB [(none)]&gt; UPDATE mysql.user SET PASSWORD=PASSWORD(&apos;123456&apos;) WHERE user=&apos;root&apos;; （5）修改更改文件 [root@localhost~]#systemctl stop mariadb.service [root@localhost~]#vim /usr/lib/systemd/system/mariadb.service 删除刚添加的参数 （6）重启服务测试 [root@localhost~]#systemctl restart mariadb.service [root@localhost~]#mysql -uroot -p Enter password: Welcome to the MariaDB monitor. Commands end with ; or \g. Your MariaDB connection id is 3 Server version: 5.5.56-MariaDB MariaDB Server 授权使用格式： GRANT priv_type [(column_list)] [, priv_type [(column_list)]] ... ON [object_type] priv_level TO user_specification [, user_specification] ... [REQUIRE {NONE | ssl_option [[AND] ssl_option] ...}] [WITH with_option ...] priv_type：表示权限类型 column_list：设置列 user：设置用户 password：用户密码 WITH关键字后面带有一个或多个with_option参数 GRANT OPTION：被授权用户可以使用的参数 MAX_QUERIES_PER_HOUR count：设置每小时允许执行的count查询 MAX_UPDATES_PER_HOUR count：设置每小时count更新 MAX_CONNECTIONS_PER_HOUR count：设置每小时可以建立count连接 MAX_USER_CONNECTIONS count：设置单个用户可以同时具有count连接数 示例： MariaDB [class]&gt; GRANT SELECT(number) ON class.class TO &apos;test&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;; 查看授权使用格式： SHOW GRANTS [FOR &apos;user&apos;@&apos;host&apos;] 示例： MariaDB [class]&gt; SHOW GRANTS FOR test@&apos;localhost&apos;\G; *************************** 1. row *************************** Grants for test@localhost: GRANT SELECT ON *.* TO &apos;test&apos;@&apos;localhost&apos; IDENTIFIED BY PASSWORD &apos;*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9&apos; *************************** 2. row *************************** Grants for test@localhost: GRANT SELECT (number) ON `class`.`class` TO &apos;test&apos;@&apos;localhost&apos; MariaDB [class]&gt; SHOW GRANTS ; #默认查询root的权限 取消授权使用格式 REVOKE priv_type [(column_list)][, priv_type [(column_list)]] ... ON [object_type] priv_level FROM &apos;user&apos;@&apos;host&apos; [, &apos;user&apos;@&apos;host&apos;] ... 示例： MariaDB [class]&gt; REVOKE SELECT(number) ON class.class FROM test@&apos;localhost&apos;;]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL用户管理</category>
      </categories>
      <tags>
        <tag>用户管理，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL索引]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[mysql索引提取索引的创建在的表上字段中的数据，构建出一个独特的数据结构。 索引的作用加速查询操作；副作用：降低些操作性能 表中数据子集：把表中某个或某些字段的数据提取出来另存为一个特定数据结构组织的数据。 某个字段或某些字段：WHERE子句中用到的字段 索引类型B+ TREE顺序存储，每一个叶子节点到根节点的距离相同；左前缀索引，适用于范围类型的数据查询 使用域B+ TREE索引查询类型：全键值、键值范围或键前缀全值匹配：精确匹配某个值 WHERE COLUMN = &apos;VALUE&apos;; 匹配左前缀：只精确匹配开头的部分 WHERE COLUMN LIKE &apos;PREFIX%&apos; 匹配范围值： 精确匹配某一列，范围匹配另一列 只用访问索引的查询：覆盖索引 index（NAME） SELECT NAME FROM students WHERE NAME LIKE &apos;L%&apos;; 不使用B+ TREE索引如果查询条件不是从最左侧开始，索引无效 index（age，fname） WHERE fname=‘jerry’; WHERE age &gt;30 AND fname=’smith&apos;; 不能跳过索引中的某列 index（name，age，gender） WHERE name=&apos;block&apos; and age &gt;30; WHERE name=&apos;block&apos; and gender=&apos;F&apos;; 如果查询中的某个列时为范围查询，那么其右侧的列都无法再使用索引优化查询。 WHERE age&gt;30 AND fname=&apos;smith&apos;; hash索引基于哈希表实现，特别适用于值的精确匹配查询。 使用场景：只支持等值比较实现，例如=、IN(),&lt;=&gt; 不使用场景所有非精确值查询，mysql仅对memory存储引擎支持显示的hash索引 索引优点降低需要扫描的数据量，减少IO次数； 可以帮助避免排序操作，避免使用临时表 帮助将随机IO转为顺序IO 高性能索引策略： 在WHERE中独立使用列，尽量避免其参与运算 WHERE age+2 &gt; 23 左前缀索引：索引构建于字段的最左侧的多少个字符，要通过索引选择性来评估 索引选择性：不重复的索引值和数据表的记录总数的比值 多列索引 AND连接的多个查询条件更适合使用多列索引，而非多个单间索引 选择合适的索引列次序：选择性更高的放左侧 示例： MariaDB [student]&gt; CREATE INDEX age ON students(age); #创建索引 MariaDB [student]&gt; SHOW INDEX FROM students; #查看索引 MariaDB [student]&gt; CREATE INDEX age_and_name ON students(age,name); #创建组合索引 MariaDB [student]&gt; EXPLAIN SELECT name,age FROM students WHERE age &gt; (SELECT avg(age) FROM students); +------+-------------+----------+-------+------------------+--------------+---------+------+------+--------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +------+-------------+----------+-------+------------------+--------------+---------+------+------+--------------------------+ | 1 | PRIMARY | students | index | age,age_and_name | age_and_name | 38 | NULL | 2897 | Using where; Using index | | 2 | SUBQUERY | students | index | NULL | age | 5 | NULL | 2897 | Using index | +------+-------------+----------+-------+------------------+--------------+---------+------+------+--------------------------+ 从上述可以看出通过使用index查询 EXPLAIN来分析索引有效性使用格式： EXPLAIN [explain_type] SELECT select_options 输出格式信息分析： id：当前查询语句中，第个SELECT 语句的编号 注意：联合查询的分析结果会出现一个额外的匿名临时表 select_type：查询类型 简单查询：SIMPLE 复杂查询： 简单子查询：SUBQUERY 用于FROM中的子查询：DERIVED 联合查询中的第一个查询：PRIMARY 联合查询中的第一个查询之后的其他查询：UNION 联合查询生成的临时表：UNION RESULT table：查询针对的表 type：关联类型，或称为访问类型，即mysql如何取查询表中的行 ALL ：全表扫描 index：根据索引的顺序进行的全表扫描；但同时如果EXTRA列出现了“Using index”表示使用了覆盖索引 range：有范围限制地根据索引实现范围扫描；扫描位置始于索引中的某一项，结束语另一项 ref：根据索引返回的表中匹配到某单个值的所有行（匹配给定值的行不止一个） eq_ref：根据索引返回的表中匹配到某单个值的单一行，仅返回一个行，但需要与某个额外的参考值比较，而不是常熟 const，systemc：与某个常数比较，且只返回一行 possible_keys：查询中可能会用到的索引 key：查询中使用的索引 key_len：查询中用到的索引长度 ref：在利用key字段所显示的索引完成查询操作时所引用的列或常量值 rows：mysql估计出的为找到所有的目标而需要读取的行数 Extra：额外信息 Using index：使用了覆盖索引进行的查询 Using where：拿到数据后还要再次进行过滤 Using temporary：使用了临时表以完成查询 Using filesort：对结果使用了一个外部索引排序]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL索引</category>
      </categories>
      <tags>
        <tag>索引，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL表分区]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E8%A1%A8%E5%88%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[MySQL表分区MySQL表分区有两种切分方法： 垂直切分：切库，把一个库中的多个表分组后放置于不同的物理服务器上。 水平切分：切表，分散其行至多个表中存放（table partitions）。 partition_options:PARTITION BY { [LINEAR] HASH(expr) | [LINEAR] KEY(column_list) | RANGE{(expr) | COLUMNS(column_list)} | LIST{(expr) | COLUMNS(column_list)} } [PARTITIONS num] [SUBPARTITION BY { [LINEAR] HASH(expr) | [LINEAR] KEY(column_list) } [SUBPARTITIONS num] ] [(partition_definition [, partition_definition] ...)] partition_definition:PARTITION partition_name [VALUES {LESS THAN {(expr | value_list) | MAXVALUE} | IN (value_list)}] [[STORAGE] ENGINE [=] engine_name] [COMMENT [=] &apos;comment_text&apos; ] [DATA DIRECTORY [=] &apos;data_dir&apos;] [INDEX DIRECTORY [=] &apos;index_dir&apos;] [MAX_ROWS [=] max_number_of_rows] [MIN_ROWS [=] min_number_of_rows] [TABLESPACE [=] tablespace_name] [NODEGROUP [=] node_group_id] [(subpartition_definition [, subpartition_definition] ...)] 分区类型： range：通过将数据划分为不同的范围 hash ：通过对表的一个或多个列hash key 计算，最后通过这个hash码不同的数值对应的数据区域进行分区 列:根据列进行划分]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL表分区</category>
      </categories>
      <tags>
        <tag>分表，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NFS]]></title>
    <url>%2F2017%2F11%2F28%2FNFS%2F</url>
    <content type="text"><![CDATA[一、NFS介绍1、NFS简介NFS （Network File System，网络文件系统），通过网络让不同的机器、不同的操作系统能够彼此分享个别的数据，让应用程序在客户端通过网络访问位于服务器磁盘中的数据，是在类Unix系统间实现磁盘文件共享的一种方法。NFS 的基本原则是“容许不同的客户端及服务端通过一组RPC分享相同的文件系统”，它是独立于操作系统，允许不同硬件及操作系统的系统共同进行文件的分享。 NFS在文件传送或信息传送过程中依赖于RPC协议。RPC， (Remote Procedure Call，远程过程调用）是能使客户端执行其他系统中程序的一种机制，RPC采用C/S模式。NFS本身是没有提供信息传输的协议和功能的，但NFS却能让我们通过网络进行资料的分享，这是因为NFS使用了一些其它的传输协议。而这些传输协议用到这个RPC功能的。可以说NFS本身就是使用RPC的一个程序；或者说NFS也是一个RPC SERVER，所以只要用到NFS的地方都要启动RPC服务，不论是NFS SERVER或者NFS CLIENT。这样SERVER和CLIENT才能通过RPC来实现PROGRAM PORT的对应。可以这么理解RPC和NFS的关系：NFS是一个文件系统，而RPC是负责负责信息的传输。 注意：RPC服务启动之后才能启动nfs服务，因为nfs服务要到RPC注册端口号。 2、NFS工作机理 （1）客户端向NFS服务器发送资源请求时，客户端RPC服务通过网络向NFS服务器的RPC（111端口）服务发出资源请求。 （2）NFS服务器的RPC端口获取到服务器端nfs服务注册端口，通知客户端RPC服务器 （3）客户端收取到正确的端口之后，直接与服务端的nfs服务建立通信。 （4）服务器nfs服务接受到请求资源之后本地响应读取本地磁盘中的内容，然后返回至客户端这样就完成一次存取操作。 3、NFS优势（1）节省本地存储空间 （2）用户不需要再网络中的每个机器上都建有home目录 4、NFS版本对比||NFS v2|NFS v3|NFS v4|只支持32位文件传输，最大文件数为4G |支持64位传输|CentOS 7 默认使用NFS v4，实现伪根挂载，辅助服务不需要，完全支持kerberos|文件传输尺寸限制在8K |没有文件尺寸限制|||无|v3增加和完善了许多错误和成功信息的返回，对于服务器的设置和管理能带来很大好处|改进了INTERENT上的存取和执行效能在协议中增强了安全方面的特性|只提供了对UDP协议的支持，在一些高要求的网络环境中又很大限制|增加了对TCP传输协议的支持，有更好的I/O性能|只支持TCP传输，通过一个安全的带内系统，协商在服务器和客户端之间使用的安全性类型使用字符串而不是整数俩表示用户和组标识符 5、NFS服务主要进程rpm.nfsd 最主要的NFS进程，管理客户端是否可登陆，登入者ID的判断。监听在2049端口 rpc.mount 主要功能管理NFS的文件系统。当客户端通过rpc.nfsd登入主机后，使用NFS服务器提供的文件之前，还会经过文件使用权限的认证程序。读取/etc/exports配置文件来对比客户端的权限；如果权限认证通过，客户端就可以使用NFS提供的文件了。 rpc.lockd 管理文件锁，避免同时写错 rpc.statd 检查文件一致性，可修复文件 6、NFS配置文件软件包名：nfs-utils 配置文件 /etc/exports.d和/etc/exports 配置NFS使用固定端口 RQUOTAD_PORT LOCKD_TCPPORT LOCKD_UDPPORT MOUNTD_PORT STATD_PORT rpc.statd监听端口 STATD_OUTGONING_PORT outgoing设置端口 锁配置文件 /etc/modprobe.d/lockd.conf nfs服务启动配置文件 /etc/sysconfig/nfs 命令配置文件 /sbin/mount.nfs /sbin/mount.nfs4 /sbin/osd_login /sbin/rpc.statd /sbin/umount.nfs /sbin/umount.nfs4 7、/etc/exports配置文件格式 /DIR(共享的文件或目录) 主机1（opts） 主机2（opts） 主机格式： 单个主机：IPv4 IPv6 FQDN IP network：两种掩码格式均支持 0.0.0.0/24 0.0.0.0/255.0.0.0 wildcards:主机名通配，例如*.localhost.com netgroups:NIS域主机组，@group_name anonymous：表示使用*通配所有客户端 ops： secure：使用了1024以下的TCP/IP端口实现NFS的连接。 insecure：允许客户端从大于1024的TCP/IP端口实现NFS连接。 rw：允许NFS客户机进行读写访问 ro：允许NFS客户机进行只读访问 async：异步，数据变化后不立即写磁盘，可以改进性能 no_wdelay：关闭写延时；如果设置了async，NFS会忽略这个选项 nohide：如果将一个目录挂载到另外一个目录上，那么原来的目录通常就被隐藏起来，这个选项禁用这种行为。 hide：隐藏原来目录中的内容 no_stbtree_check：关闭子树检查；子树检查会执行一些不想忽略的安全性检查。默认启用子树检查 mp（mountpoint=path）：NFS要求挂载所导出的目录 no_auth_nlm：NFS守护进程不要对加锁请求进行认证。默认为auth_nlm或secure_locks fsid=num|root|uuid：NFS需要识别每个文件系统。 crossmnt：这个选项类似于nohide，使得客户端能访问挂载目录下的文件。例如如果B目录挂载A目录上，设置crossmnt在A目录上不被隐藏。 用户映射通过NFS中的用户映射，可以将伪或实际用户和组的表示赋给一个正在对NFS卷进行操作的用户，这个NFS用户具有映射所允许的用户和组的许可权限。对NFS卷使用一个通过的用户/组可以提供一定的安全性和灵活性。 在使用NFS挂载的文件系统上的文件时，用于的访问通常都会受到限制，都是以匿名用户的身份对文件进行访问的，这些用户缺省的情况下对这些文件只有只读权限。NFS允许指定访问远程文件用户通过用户标识号和组标识号，可以禁用正常的squash行为 用户映射选项 root_squash：将root用户及所属组映射为匿名用户或用户组，默认选项 no_root_squash：允许root用户访问挂载NFS卷 all_squash：对于公共访问的NFS卷时非常有用的，它会限制所有的UID和GID，只使用匿名用户（nfsnobody）访问NFS卷 anonuid：将远程访问的所有用户都映射为匿名用户，并制定该用户为本地用户（UID=NUM） anongid：将远程用户的所有用户组都映射为匿名用户组账户，并指定该匿名用户组账户为本地用户组账户（GID=NUM） 客户端NFS挂载选项fg：前台挂载 bg：后台挂载 hard：持续请求 soft：非持续请求 rsize：从服务器中读取的字节数 wsize：写入服务器的字节数，默认为1024，如果使用比较高的值，可以提高传输速度 _netdev：网络设备挂载，如果检测到网络自动挂载 8、管理命令（1）exportfs 管理当前NFS共享文件系统列表 -a 打开或取消所有目录共享 -o 指定一列共享选项 -i 忽略`/etc/exports`文件，从而只是用默认的和命令行指定的选项 -r 重新读共享所有目录。它是/etc/exportfs和/var/lib/nfs/xtab同步。 -u 取消一个或多个目录共享 -v 输出详细信息 （2）showmount 查询mountd守护进程，以显示NFS服务器加载的信息 -d 仅显示以被NFS客户端加载的目录 -e 显示NFS服务器上的所有共享目录 （3）rpcinfo 显示portmap的有关信息 -p 列出所有host用portmap注册的RPC程序，如果没有指定host，就查找本机上RPC程序 -u RPC调用host程序program的version版本，并报告是否接受到相应 -t TCP RPC调用host程序program的version版本，并报告是否接收到响应 -n 根据-t或者-u，使用编号为port的端口，而不是portmap指定的端口 -d 将程序program的version版本从本机的RPC注册表中删除。注意只用root权限的用户才可以使用此选项。 -s 查看RPC注册程序 （4）mount.nfs 挂载NFS -r 只读挂载 -w 读写挂载 -f 假挂载，不实际调用mount -n 不更新/etc/mtab 三、示例1、基本挂载并分享（1）CentOS 7 共享目录/app/testnfs [root@localhost/app]#vim /etc/exports 1 /app/testnfs 192.168.4.132 （2）使用命令exportfs重读 [root@localhost/app]#exportfs -r （3）CentOS 6使用showmount命令查看 [root@localhost/app]#showmount -e 192.168.4.60 （4）挂载 [root@localhost ~]# mount -t nfs 192.168.4.60:/app/testnfs /mnt/nfs/ 如果不NFS服务器中挂载不添加任何选项，默认为 ro,sync,wdelay,hide,no_subtree_check,sec=sys,secure,root_squash,no_all_squash 如果客户对文件有写权限，但是此目录NFS设为只要只读权限，所以对NFS写不进去文件或创建目录等等操作。如果需要这种操作需要确保文件对此目录是否有写权限，并且NFS共享时是否设置了读写权限；只有两者同时具备才可以写操作。 这时我们开启NFS共享文件的权限 [root@localhost/app]#chmod 777 /app/testnfs 再次写去测试即可创建 2、实现NFS伪根（1）创建一个目录并在目录下在创建目录 [root@localhost/app/testnfs]#mkdir nfs1[root@localhost/app/testnfs]#mkdir nfs2 （2）配置共享文件 [root@localhost/app/testnfs]#vim /etc/exports 1 /app/testnfs 192.168.4.132(rw,fsid=0,crossmnt) 2 /app/testnfs/nfs1 192.168.4.132(rw,root_squash) 3 /app/testnfs/nfs2 192.168.4.132(ro) [root@localhost/app/testnfs]#exportfs -v /app/testnfs 192.168.4.132(rw,sync,wdelay,hide,crossmnt,no_subtree_check,fsid=0,sec=sys,secure,root_squash,no_all_squash) /app/testnfs/nfs1 192.168.4.132(rw,sync,wdelay,hide,no_subtree_check,sec=sys,secure,root_squash,no_all_squash) /app/testnfs/nfs2 192.168.4.132(ro,sync,wdelay,hide,no_subtree_check,sec=sys,secure,root_squash,no_all_squash) 我们也可以通过 /var/lib/nfs/etab [root@localhost/app/testnfs]#cat /var/lib/nfs/etab /app/testnfs/nfs2 192.168.4.132(ro,sync,wdelay,hide,nocrossmnt,secure,root_squash,no_all_squash,no_subtree_check,secure_locks,acl,no_pnfs,anonuid=65534,anongid=65534,sec=sys,secure,root_squash,no_all_squash) /app/testnfs/nfs1 192.168.4.132(rw,sync,wdelay,hide,nocrossmnt,secure,root_squash,no_all_squash,no_subtree_check,secure_locks,acl,no_pnfs,anonuid=65534,anongid=65534,sec=sys,secure,root_squash,no_all_squash) /app/testnfs 192.168.4.132(rw,sync,wdelay,hide,crossmnt,secure,root_squash,no_all_squash,no_subtree_check,secure_locks,acl,no_pnfs,fsid=0,anonuid=65534,anongid=65534,sec=sys,secure,root_squash,no_all_squash) （3）测试 [root@localhost ~]# showmount -e 192.168.4.60 [root@localhost ~]# mount -t nfs 192.168.4.60:/ /mnt/nfs/ [root@localhost nfs1]# touch nfs.txt [root@localhost nfs1]# ll -rw-r--r--. 1 nfsnobody nfsnobody 0 Oct 15 2017 nfs.txt 此时我们看创建文件的所有者及所属组都为nfsnobody，这里就验证了我们刚刚前面提到的root用户映射为匿名用户nfsnobody。 [joah@localhost nfs1]$ ll -rw-rw-r--. 1 joah joah 0 Oct 15 2017 nfs2.txt -rw-r--r--. 1 nfsnobody nfsnobody 0 Oct 15 2017 nfs.txt 通过上述查看非系统账号创建的文件的所有者及所属组为自己本身。 此时我们在NFS服务器上查看文件 [root@localhost/app/testnfs/nfs1]#ll -rw-rw-r--. 1 500 500 0 Oct 15 23:45 nfs2.txt -rw-r--r--. 1 nfsnobody nfsnobody 0 Oct 15 23:42 nfs.txt 在客户端创建的文件在NFS服务器上的所有者和所属组都为500。而客户端joah的所有者和所属组的id也为500，这也验证了上述说明的用户映射。如果服务器500这个id号被占用如何处理？ [root@localhost/app/testnfs/nfs1]#ll -rw-rw-r--. 1 li 500 0 Oct 15 23:45 nfs2.txt 此时所有者不一样了。这样有时就会出现问题。 关于权限 （1）客户端连接时候，对普通用户检查 a、如果明确设定了普通用户被压榨，那么此时客户端用户的身份转换为指定用户 b、如果没有明确指定，那么此时用户身份被压榨成nfsnobody （2）客户端连接时，对root的检查 a、如果设置no_root_squash，此时root用户身份被压榨成NFS服务器上的root b、如果设置了all_squash、anonuid、anongid，此时root的身份被压榨为指定用户 c、如果没有明确指定，root被压榨为nfsnobody d、如果同时指定no_root_squash和all_squash用户将被压榨为nfsnobody；如果设置了anonuid、anongid将被压榨为指定用户与组 四、自动挂载1、auto简介Autofs与Mount/Umount的不同之处在于，它是一种看守程序。如果它检测到用户正试图访问一个尚未挂接的文件系统，它就会自动检测该文件系统，如果存在，那么Autofs会自动将其挂接。另一方面，如果它检测到某个已挂接的文件系统在一段时间内没有被使用，那么Autofs会自动将其卸载。因此一旦运行了Autofs后，用户就不再需要手动完成文件系统的挂接和卸载。 2、配置文件主配置文件 /etc/autos.conf 配置挂载文件 /etc/auto.master 3、autofs挂载方式（1）相对路径法 /etc/auto.master配置格式 DIRNAME 子配置文件 子配置文件格式 BASENAME 需要挂载的文件等 示例 ： [root@localhost ~]# vim /etc/auto.master /mnt /etc/auto.nfs [root@localhost ~]# vim /etc/auto.nfs nfs -fstype=nfs 192.168.4.60:/ 重启服务测试即可 [root@localhost ~]# cd /mnt/nfs/[root@localhost nfs]# ls fstab nfs1 nfs2 （2）绝对路径法 /etc/auto.master配置格式 /- 子配置文件 子配置文件格式 挂载点路径 被挂载文件等 示例： [root@localhost ~]# vim /etc/auto.master /- /etc/auto.nfs [root@localhost ~]# vim /etc/auto.nfs /mnt/nfs -fstype=nfs 192.168.4.60:/ 重启服务测试即可 [root@localhost ~]# cd /mnt/nfs/[root@localhost nfs]# ls fstab nfs1 nfs2 注意：如果父目录不存在时，会自动创建。使用绝对路径不会隐藏原来目录下目录中的内容。]]></content>
      <categories>
        <category>文件管理</category>
        <category>NFS</category>
      </categories>
      <tags>
        <tag>nfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx指令]]></title>
    <url>%2F2017%2F11%2F28%2FNginx%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Nginx配置指令参考： https://nginx.org/en/docs/- 事前注意：配置Nginx和配置Apache不一定，Nginx必须要在指定的部分添加指令，否则会报错。 正常运行必备指令- （1）user 指定worker进程的运行身份，如果组不指定，默认和用户名同名。 Syntax: user user [group]; Default: user nobody nobody; 这里需要注意下如果系统中默认有nginx账户，不会使用nobody账户运行。 Context: main 规定只能在main定义此指令 （2）pid /PATH/TO/PID_FILE 指定存储nginx主进程PID的文件路径 Syntax: pid file; Default: pid nginx.pid; Context: main （3）include file |mask 指明包含进来的其他配置文件片段 Syntax: include file | mask; Default: — Context: any （4）load_module file 指明加载模块的路径 模块加载配置文件：/usr/share/nginx/modules/*.conf 指明要装载的动态模块路径：/usr/lib64/nginx/modules Syntax: load_module file; Default: — Context: main This directive appeared in version 1.9.11. 此指令在1.9.11版本中才有 性能优化相关指令- （1）worker_process number|auto worker进程的数量，通常应该设置为小于或等于当前主机CPU的物理核心数 Syntax: worker_processes number | auto; Default: worker_processes 1; Context: main （2）worker_cpu_affinity auto [cpumask] 指定运行在哪些CPU上 Syntax: worker_cpu_affinity cpumask ...; worker_cpu_affinity auto [cpumask]; Default: — Context: main 示例： worker_processes 4; worker_cpu_affinity 0001 0010 0100 1000; 查看工作在哪颗CPU的命令 ps axo pid,cmd,psr,ni |grep nginx （3）worker_priority number 指定worker进程nice值，设置worker进程优先级[-20,20]，不过正常的话nice值为[-20，19] Syntax: worker_priority number; Default: worker_priority 0; Context: main （4）worker_rlimit_nofile number worker进程所能够打开的文件数量上限 Syntax: worker_rlimit_nofile number; Default: — Context: main 事件驱动相关指令：- （1）worker_connections number 每个worker进程所能够打开的最大并发连接数量 Syntax: worker_connections number; Default: worker_connections 512; Context: events （2）use method 指明并发连接请求的处理方法，默认自动选择最优方法，默认使用epoll Syntax: use method; Default: — Context: events （3）accept_mutex on|off 互斥处理新的连接请求方法 on：指由各个worker轮流处理新的请求 off：指每个新请求的到达都会通知所有的worker进程，但只有一个进程可获得连接，造成“惊群”，影响性能，默认为on Syntax: accept_mutex on | off; Default: accept_mutex on; Context: events 调试和定位问题- （1）daemon on|off 是否以守护进程方式运行nginx，默认为守护进程方式 Syntax: daemon on | off; Default: daemon on; Context: main （2）master_process on|off 是否以master/worker模型运行nginx；默认为on Syntax: master_process on | off; Default: master_process on; Context: main （3）error_log file [level] 错误日志文件及其级别；出于调试需要可设置为debug；如果要是用debug，需要在编译使用“–with-debug”选项 Syntax: error_log file [level]; Default: error_log logs/error.log error; Context: main, http, mail, stream, server, location stderr：发送到标准错误 syslog：server-address[,parameter=values]：发送到syslog memory： size内存 level:debug|info|notice|warn|error|crit|alter|emerg （4）time_resolution 计时器解析度；降低此值，可减少gettimeofday（）系统调用的次数 Syntax: resolver_timeout time; Default: resolver_timeout 30s; Context: mail, server http协议的相关指令- （1）server{…} 配置一个虚拟主机 （2）listen PORT|address[:port]|unix:/PATH/TO/SOCKET_FILE listen address[:port] [default_server] [ssl] [http2 | spdy] [backlog=number] [rcvbuf=size] [sndbuf=size] Default: listen *:80 | *:8000; Context: server default_server：设置为默认虚拟主机 ssl ：限制仅能够通过ssl连接提供服务 backlog=number：超过并发连接数后，新请求进入后院队列的长度 rcvbuf=size：接受缓冲区大小sndbuf=size发送缓冲区大小 示例： listen 127.0.0.1:8000; listen 127.0.0.1; listen 8000; listen localhost:8000; 注意： （1）基于port listen PORT；指令监听在不同的端口 （2）基于IP的虚拟主机 listen IP:PORT；IP地址不同 （3）基于hostname server_name FQDN:指令指向不同的主机名 listen只能放在server端中 （3）server_name name …; 指定虚拟主机的主机名称，可跟多个由空白字符分隔的字符串 Syntax: server_name name ...; Default: server_name &quot;&quot;; Context: server server_name支持“*”通配任意长度的任意字符 示例： server_name *.test.com server_name支持“~”起始的字符做正则表达式匹配；此方法会消耗性能 server_name ~^www\d+.test\.com$ \d表示[0-9] 匹配优先级 （1）首先是字符串精确匹配,www.test.com （2）左侧通配符 \.test.com （3）右侧通配符 www.test.\ （4）正则表达式 ~^www\d+.test.com$ （5）default_server （4）tcp_nodelay on|off 在keepalived模式下的连接是否启用tcp_nodelay Syntax: tcp_nodelay on | off; Default: tcp_nodelay on; Context: http, server, location off：延迟发送，合并多个请求后再发送 on：不延迟发送 （5）sendfile on|off 是否启用sendfile功能，在内核封装报文直接发送 Syntax: sendfile on | off; Default: sendfile off; Context: http, server, location, if in location （6）server_tokens on|off|build|string 是否在响应报文的server首部显示nginx版本 Syntax: server_tokens on | off | build | string; Default: server_tokens on; Context: http, server, location 定义路径相关指令（1）root 设置web资源的路径映射；用于指明请求的URL所对应的文档的目录路径 Syntax: root path; Default: root html; Context: http, server, location, if in location 示例： location /i/ { root /data/w3; } （2）location [ = | ~ | ~* | ^~ ] uri { … } 在一个server中location配置段可存在多个，用于实现从URI到文件系统的路径映射；nginx会根据用户请求的URI来检查定义的所有location，并找出一个最佳匹配，而后应用其配置 Syntax: location [ = | ~ | ~* | ^~ ] uri { ... } location @name { ... } Default: — Context: server, location ^~：对URI的最左边部分做匹配检查，不区分字符大小写 ~：对URI做正则表达式做模式匹配，区分字符大小写 ~*：对URI做正则表达式模式匹配，不区分字符大小写 不带符号：匹配起始于URI的所有URI 匹配优先级从左到右降低= ^~ ~ ~* 不带符号 示例： location = / { [ configuration A ] } location / { [ configuration B ] } location /documents/ { [ configuration C ] } location ^~ /images/ { [ configuration D ] } location ~* \.(gif|jpg|jpeg)$ { [ configuration E ] } （2）alias path 路径别名，文档映射的另一种机制；仅能用于location上下文 Syntax: alias path; Default: — Context: location alias和root指令的区别（a）root指令给定的路径对应于localtion中的URI左侧的 （b）alias指令给定的路径对应于localtion中的URI右侧 示例： http://www.test.com/bbs/index.html location /bbs/ { alias /web/forum/; } --&gt; /web/forum/index.html location /bbs/ { root /web/forum/; } --&gt; /web/forum/bbs/index.html （3）index file 指定默认网页资源；ngx_http_index_module模块提供 Syntax: index file ...; Default: index index.html; Context: http, server, location （4）error_page code …[=[response]] URI 定义错误页，以指定的响应码状态进行响应 Syntax: error_page code ... [=[response]] uri; Default: — Context: http, server, location, if in location 示例： error_page 404 /404.html error_page 404 =200 /404.html （5）try_files files … URI 按顺序检查文件是否存在，返回对一个找到的文件或文件夹（结尾加斜线表示文件夹）；如果所有的文件或文件夹都找不到，会进行一个内部重定向到最后一个参数，只有最后一个参数可以引起一个内部重定向，之前的参数只设置内部URI的指向；最后一个参数是回退URI且必须存在，否则会出现内部500错误 Syntax: try_files file ... uri; try_files file ... =code; Default: — Context: server, location 示例： location /images/ { try_files $uri /images/default.gif; } location / { try_files $uri $uri/index.html $uri.html =404; } 定义客户端请求的指令（1）keepalive_timeout timeout [header_timeout] 设置保持连接时长超时时长，0表示禁止长连接，默认为75秒 Syntax: keepalive_timeout timeout [header_timeout]; Default: keepalive_timeout 75s; Context: http, server, location （2）keepalive——request number 在一次长连接上所允许请求的资源最大数量 Syntax: keepalive_requests number; Default: keepalive_requests 100; Context: http, server, location （3）keepalive——disable none|browser 对哪种浏览器禁用长连接 Syntax: keepalive_disable none | browser ...; Default: keepalive_disable msie6; Context: http, server, location （4）send_timeout time 向客户端发送响应报文的超时时长，此处是指两次写操作之间的间隔时长，而非整个过程的传输时长 Syntax: send_timeout time; Default: send_timeout 60s; Context: http, server, location （5）client_body_buffer_size size 用于接受每个客户端请求报文的body部分的缓冲区大小；默认为16k，超出此大小时，将其暂存到磁盘上由client_body_temp_path指令所定义的位置，仅能应用于上传 Syntax: client_body_buffer_size size; Default: client_body_buffer_size 8k|16k; Context: http, server, location （6）client_body_temp_path path [level 1 [level2 [level3]]] 设定用于存储客户端请求报文的body部分的临时存储路径及子目录结构和数量 目录名为16进制的数字 client_body_temp_path /var/tmp/client_body 1 2 2 1 :1级目录占1位16进制即2^4=16个目录 0-f 2:2级目录占2位16进制，即2^8=256个目录 00-ff 2:3级目录占2位16进制，即2^8=256个目录 00-ff 对客户端进行限制的相关指令（1）limit_rate rate 限制响应给客户端的传输速率，单位为bytes/second，默认为0表示无限制 Syntax: limit_rate rate; Default: limit_rate 0; Context: http, server, location, if in location （2）limit_except method …{…}， 限制客户端使用除了制定的请求方法之外的其他方法 Syntax: limit_except method ... { ... } Default: — Context: location method： GET, HEAD, POST, PUT, DELETE, MKCOL, COPY, MOVE, OPTIONS, PROPFIND, PROPPATCH, LOCK, UNLOCK, or PATCH. 示例： limit_expect GET { allow 192.168.4.0./24; deny all; } 文件操作优化指令（1）aio on|off|threads[=pool] 是否开启aio功能 Syntax: aio on | off | threads[=pool]; Default: aio off; Context: http, server, location This directive appeared in version 0.8.11.0.8.11版本以后才可以支持 （2）directio size|off 是否同步写磁盘，而非写缓存，在linux 主机启用O_DIRECT标记，则文件大于等于给定大小时使用 Syntax: directio size | off; Default: directio off; Context: http, server, location This directive appeared in version 0.7.7. 示例： directio 4m 当文件大于或者等于4m开始同步磁盘 （3）open_file_cache off open_file_cache max=N[inactive=time] Syntax: open_file_cache off; open_file_cache max=N [inactive=time]; Default: open_file_cache off; Context: http, server, location nginx可以缓存以下三种信息： a、文件元数据：文件FD、文件大小和最近一次的修改时间 b、打开的目录结构 c、没有找到的或者没有权限访问的文件的相关信息 max=N：可缓存的缓存项上限；达到上限后会使用LRU算法实现管理； inactive=time：缓存项的非活动时长，在此处指令的时长内未被命中的或者命中次数少于open_file_cache_min_uses指令指定的次数的缓存项；即非活动项将被删除 （4）open_file_cache_errors on|off 是否缓存查找时文件发生错误的文件一类的信息 Syntax: open_file_cache_errors on | off; Default: open_file_cache_errors off; Context: http, server, location （5）open_file_cache_min_uses number open_file_cache指令的inactive参数指定的时长内，至少被命中此处指令的次数方可被归类为活动项 Syntax: open_file_cache_min_uses number; Default: open_file_cache_min_uses 1; Context: http, server, location （6）open_file_cache_valid time 缓存项有效检查频率 Syntax: open_file_cache_valid time; Default: open_file_cache_valid 60s; Context: http, server, location ngx_http_access_module 实现基于IP访问控制功能（1）allow address|CIDR|unix：|all 指定允许访问的IP （2）deny address | CIDR | unix: | all; 指定不能访问的IP Syntax: allow/deny address | CIDR | unix: | all;Default: —Context: http, server, location, limit_except 注意：检查规则为自上而下检查，一旦匹配，将生效；建议条件严格的放置前面。 示例： location / { deny 192.168.1.1; allow 192.168.1.0/24; allow 10.1.1.0/16; allow 2001:0db8::/32; deny all; } ngx_http_auth_basic_module实现基于用户的访问控制，使用basic机制进行用户认证（1）auth_basic string|off 是否可以认证功能或string Syntax: auth_basic string | off; Default: auth_basic off; Context: http, server, location, limit_except （2）auth_basic_user_file filename 认证文件的位置 Syntax: auth_basic_user_file file; Default: — Context: http, server, location, limit_except 用户口令方式： a、明文文本 格式： name:password:comment b、加密文本：需要htpasswd工具实现，由httpd_tools安装包提供 格式： USERNAME PASSWORD ngx_http_stub_stastus_module 用于输出nginx基本状态信息stub_status Syntax: stub_status; Default: — Context: server, location 示例： location /status { stub_status; allow 192.168.4.0/24; deny all; } 显示信息解释： active connection ：当前状态，活动状态的连接数 accepts：统计总值，已经接受的客户端请求的总数 handled：统计总值，已经处理完成的客户端请求的总数 requests：统计总值，客户端发来的总的请求数 reading：当前状态，正在读取客户端的请求报文的链接数 writing：当前状态，正在向客户端响应报文过程中的连接数 waiting：当前状态，正在等待客户端发出请求的空闲连接数 ngx_http_log_module指定日志格式记录请求（1）log_format name string … nginx核心模块及其他模块内嵌的变量 Syntax: log_format name [escape=default|json] string ...; Default: log_format combined &quot;...&quot;; Context: http （2） access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]] access_log off; 是否开启日志功能 访问日志文件路径，格式及相关的配置 buffer=size 定义缓存区大小 gzip 定义日志压缩级别 flush 定义刷新时间 示例： log_format compression &apos;$remote_addr - $remote_user [$time_local] &apos; &apos;&quot;$request&quot; $status $bytes_sent &apos; &apos;&quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$gzip_ratio&quot;&apos;; access_log /spool/logs/nginx-access.log compression buffer=32k; 注意：为了使用压缩工作，必须安装zlib 库 （3）open_log_file_cache max=N[inactive=time][valid=time] open_log_file_cache off；是否开启日志缓存 max：缓存的最大文件描述符数量 min_uses：在inactive指定的时长内访问大于等于此值认为活动项 inactive：非活动时长 valid：验证缓存中各缓存是否为活动项的时间间隔 Syntax: open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time]; open_log_file_cache off; Default: open_log_file_cache off; Context: http, server, location ngx_http_gzip_module使用gzip方法压缩响应数据，可以节约带宽（1）gzip on|off 是否启用gizp压缩 Syntax: gzip on | off; Default: gzip off; Context: http, server, location, if in location （2）gzip_comp_level level 指定压缩比 范围1-9 Syntax: gzip_comp_level level; Default: gzip_comp_level 1; Context: http, server, location （3）gzip_disable regex … 匹配到客户端浏览器不执行压缩 Syntax: gzip_disable regex ...; Default: — Context: http, server, location （4）gzip_min_length length 启用压缩功能的响应报文大小阈值 Syntax: gzip_min_length length; Default: gzip_min_length 20; Context: http, server, location （5）gzip_http_version 1.0|1.1 设定启用压缩功能时，协议的最小版本 Syntax: gzip_http_version 1.0 | 1.1; Default: gzip_http_version 1.1; Context: http, server, location （6）gzip_buffers number size 支持实现压缩功能时缓冲区数量及每个缓存区的大小 Syntax: gzip_buffers number size; Default: gzip_buffers 32 4k|16 8k; Context: http, server, location （7）gzip_type mime_type 指明仅对哪些类型的资源执行压缩操作；默认为test/html,不用再次指定，否则会报错。 Syntax: gzip_types mime-type ...; Default: gzip_types text/html; Context: http, server, location （8）gzip_vary on|off 如果启用压缩，是否在响应报文首部添加“vary:Accept_Encoding” Syntax: gzip_vary on | off; Default: gzip_vary off; Context: http, server, location （9） gzip_proxied off | expired | no-cache | no-store | private | no_last_modified | no_etag | auth | any … Syntax: gzip_proxied off | expired | no-cache | no-store | private | no_last_modified | no_etag | auth | any ...; Default: gzip_proxied off; Context: http, server, location nginx对于代理服务器请求的响应报文，在何种情况下启用压缩功能 ||off|对于被代理的请求不启用压缩|expired，no-cache,no-store，private|对代理服务器请求的响应报文首部Cache-Control值任何一个，启用压缩功能 示例： gzip on; gzip_min_length 1000; gzip_proxied expired no-cache no-store private auth; gzip_types text/plain application/xml; ngx_http_ssl_module（1）ssl on|off 是否启用https protocol，建议用listen指令代替 listen 443 ssl Syntax: ssl on | off; Default: ssl off; Context: http, server （2）ssl_certificate file 当前虚拟机使用证书文件路径 Syntax: ssl_certificate file; Default: — Context: http, server （3）ssl_certificate_key file 当前虚拟机使用证书的私钥文件 Syntax: ssl_certificate_key file; Default: — Context: http, server （4）ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3 支持ssl协议版本 Syntax: ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3]; Default: ssl_protocols TLSv1 TLSv1.1 TLSv1.2; Context: http, server （5）ssl_session_cache off|none|[builtin[:sieze]][shared:name:size] 是否开启ssl会话缓存 none：相当于干跑 builtin[:size]：使用openssl内建缓存，为每个worker进程私有； [shared:name:size]：在各worker之间使用一个共享缓存 Syntax: ssl_session_cache off | none | [builtin[:size]] [shared:name:size]; Default: ssl_session_cache none; Context: http, server （6）ssl_session_timeout time 客户端连接可以服用ssl session cache中缓存的ssl参数有效市场 Syntax: ssl_session_timeout time; Default: ssl_session_timeout 5m; Context: http, server 示例： server { listen 443 ssl; server_name www.test.com; root /vhosts/ssl/htdocs; ssl_certificate /etc/nginx/ssl/nginx.crt; ssl_certificate_key /etc/nginx/ssl/nginx.key; ssl_session_cache shared:sslcache:20m; ssl_session_timeout 10m; } 查看证书 openssl s_client -connect www.test.com/443 注意：可以为每个FQDN提供不同的证书，这是在apache中不能实现的 server { listen 443 ssl; server_name www.test.com; root /vhosts/ssl/htdocs; ssl_certificate /etc/nginx/ssl/nginx.crt; ssl_certificate_key /etc/nginx/ssl/nginx.key; ssl_session_cache shared:sslcache:20m; ssl_session_timeout 10m; } server { listen 443 ssl; server_name www.test2.com; root /vhosts/ssl/htdocs; ssl_certificate /etc/nginx/ssl/nginx2.crt; ssl_certificate_key /etc/nginx/ssl/ngin2x.key; ssl_session_cache shared:sslcache:20m; ssl_session_timeout 10m; } server { listen 443 ssl; server_name www.test2.com; root /vhosts/ssl/htdocs; ssl_certificate /etc/nginx/ssl/nginx3.crt; ssl_certificate_key /etc/nginx/ssl/nginx3.key; ssl_session_cache shared:sslcache:20m; ssl_session_timeout 10m; } ##ngx_http_rewrite_module将用户请求URI基于PCRE regex所描述的模式进行检查，而完成重定向替换 （1）rewrite regex replacement[flag] 将用户的请求的URI基于regex所描述的模式进行检查，匹配到时将其替换为replacement指定新的URI Syntax: rewrite regex replacement [flag]; Default: — Context: server, location, if [flag]所表示的标志位用于控制此循环机制 last：重写完成后停止对当前URI在当前location中后续的其他重写操作，而后对新的URI启动新一轮重写检查；提前重启新一轮循环 break：重写完成后停止对当前URI在当前location中后续的其他重写操作，而直接跳转至重写规则之后的其他配置；结束循环，建议在location中使用 redirect：临时重定向，重写完成之后以临时重定向后生成新的URI给客户端，由客户端重新发起新的；不能以http://huo https://开头，使用相对路径，状态码为302 permanent：重写完成之后以永久重定向方式直接返回重写后生成新的URI给客户端，由客户端重新发起新请求：状态码为301 上述中last和break是在服务器内部做跳转；redirect和permanent是客户端做跳转 （2）return Syntax: return code [text]; return code URL; return URL; Default: — Context: server, location, if 停止处理，并返回客户端指定的响应码 （3）rewrite_log on|log 是否开启重写日志，发送至error_log Syntax: rewrite_log on | off; Default: rewrite_log off; Context: http, server, location, if （4）set $variable value 用户自定义变量 注意：变量定义和调用都要以$开头 Syntax: set $variable value; Default: — Context: server, location, if （5）if(condition){…} 引入新的上下文，条件满足时，执行配置块中的配置指令 ||==|相同|！=|不相同|~|模式匹配，区分字符大小写|~|模式匹配，不区分大小写|！~和!~|上述两种的否定 文件及目录存在性判断 ||-e，！-e|存在，不存在|-f，！-f|是否为文件|-d，！-d|是否为目录|-x，！-x|是否可执行 ####注意：如果在同一级配置块中存在多个rewrite规则，那么会自上而下逐个检查，被某条件规则替换完成后，会重新一轮的替换检查。隐含有循环机制，但不超过10次，如果超过10此，提示500响应码 示例： location /admin { return 403 “Not Found”; } location /admin { return 403 http://www.baidu.com; } location /admin { return http://www.baidu.com; } ngx_http_referer_module（1）valid_referers none|blocked|server_names|string … 定义referer首部的合法可用值，不能匹配的将是非法值 Syntax: valid_referers none | blocked | server_names | string ...; Default: — Context: server, location #||none|请求报文首部没有referer首部|blocked|请求报文有referer首部，但无有效值，前段可能被代理服务器删除|server_names|参数，其可以有值作为主机名或主机名模式|arbitrary_string|任意字符串，但可使用*做通配符|regular experssion|被指定的正则表达式模式匹配的字符串，要使用~开头 示例： valid_referers none blocked server_names *.example.com example.* www.example.org/galleries/ ~\.google\.; ngx_http_headers_module由代理服务器响应给客户端的响应报文添加自定义首部，或修改指定首部的值 （1）add_header name value [always] 添加自定义首部 Syntax: add_header name value [always]; Default: — Context: http, server, location, if in location （2）add_tralier name value [always] 添加自定义响应信息的尾部 Syntax: add_trailer name value [always]; Default: — Context: http, server, location, if in location 示例： add_header X-Via $server_addr; add_header X-Cache $upstream_cache_status; add_header X-Accel $server_name;]]></content>
      <categories>
        <category>服务</category>
        <category>Nginx</category>
        <category>Nginx指令</category>
      </categories>
      <tags>
        <tag>nginx，指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx介绍]]></title>
    <url>%2F2017%2F11%2F28%2FNginx%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强。 一、Nginx介绍 1、Nginx程序架构Nginx程序架构：master/worker结构 （1）一个master主进程：负载加载和分析配置文件、管理worker进程、平滑升级；一个或多个worker进程处理并响应用户请求。 （2）事件驱动机制 （3）支持sendfile （4）支持AIO（异步非阻塞） （5）支持mmap 2、Nginx功能 基本功能： 静态资源的web服务器；能缓存打开文件描述符（fd） http、smtp、pop3协议的反向代理服务器 缓存加速、负载均衡功能 支持FastCGI，uWSGI 模块化（非DSO机制）、过滤器zip、SSI及图像大小的调整 扩展功能 基于名称和IP的虚拟主机 支持keeplive 支持平滑升级 定制范文日志、支持日志缓冲区提供日志存储性能 支持url和rewrite 支持路径别名 支持基于IP及用户的访问控制 支持速率限制；支持并发数限制 3、Nginx特性模块化设计，较好的扩展性 高可靠性 支持热部署：不停机更新配置文件，升级版本；更新日志文件 低内存消耗：10000个keep-alive连接模式下的非活动连接，仅需要2.5M内存 4、Nginx工作模式非阻塞、事件驱动、由一个master进程生成多个worker进程，每个worker进程响应多个请求。 二、Nginx配置文件详解/etc/nginx/nginx.conf和/etc/nginx/*.conf- #1、配置文件的组成部分 全局配置段：main .block 对全局生效 http{}段：定义http协议相关的配置 格式： http{ 各server的公共配置server用于定义一个虚拟主机 server{ location [OPERATOR] URL { 指定URL的特性 if CONDITION { } } } } event{}段：定义event模型工作特性 mail{}段：定义mail协议相关配置段 stream{}端：定义stream服务器相关配置段 2、配置文件格式directive value1 value2 ... 注意： 1、配置指令都要以“；”结尾。 2、支持使用配置变量：内置变量，模块提供的内建变量；自定义变量，set var_name value]]></content>
      <categories>
        <category>服务</category>
        <category>Nginx</category>
        <category>Nginx介绍</category>
      </categories>
      <tags>
        <tag>nginx，文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx源码编译安装]]></title>
    <url>%2F2017%2F11%2F28%2FNginx%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[nginx源码编译安装https://nginx.org/en/download.html 源码包下载地址- 1、源码编译nginx选项介绍 选项 说明 –prefix=/path/ 指定nginx安装路径 –sbin-path=/path 指明nginx程序文件安装路径 –conf-path=/path 主配置文件安装路径 –error-log-path=/path 错误日志文件安装位置 –http-log-path=/path 访问日志文件安装路径 –pid-path=/path 指明pid文件安装位置 –lock-path=/path 锁文件安装路径 –http-client-body-temp-path=/path 客户端body部分的临时文件存放路径，如果服务器允许客户端使用put方法提交大数据时，临时存放的磁盘路径 –http-proxy-temp-path=/path 作为代理服务器，服务器响应报文临时文件存放路径 –http-fastcgi-temp-path=/path 作为fastcgi代理服务器，服务器响应报文的临时文件存放路径 –http-uwsgi-temp-path=/path 作为uwsgi代理服务器，服务器响应报文临时文件存放的路径 –http-scgi-temp-path=/path 作为scgi反代理服务器，服务器响应报文的临时文件存放的路径 –user=USERNAME 指明以哪个身份运行worker进程，主控进程一般由root运行 –group=GROUPNAME 指明组 –with-http_ssl_module 是否编译ssl模块 2、nginx编译过程（1）源码下载并加压缩 [root@localhost/usr/local/src]#tar xf nginx-1.12.2.tar.gz [root@localhost/usr/local/src]#cd nginx-1.12.2/ （2）安装编译环境 [root@localhost/usr/local/src/nginx-1.12.2]#yum groupinstall -y &quot;development tools&quot; [root@localhost/usr/local/src/nginx-1.12.2]#yum install -y pcre-devel openssl-devel zlib-devel （3）源码编译安装 [root@localhost/usr/local/src/nginx-1.12.2]#./configure --prefix=/usr/local/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx/nginx.lock --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_dav_module --with-http_stub_status_module --with-threads --with-file-aio #根据自己所需的要求添加模块 [root@localhost/usr/local/src/nginx-1.12.2]#make &amp;&amp; make install 如果想自定义版本名，设置如下行 nginx服务运行时显示 [root@localhost/usr/local/src/nginx-1.12.2/src/core]#vim nginx.h nginx服务停止时显示 [root@localhost/usr/local/src/nginx-1.12.2/src/http]#vim ngx_http_header_filter_module.c （4）修改环境变量 [root@localhost~]#vim /etc/profile.d/nginx.sh 1 PATH=/usr/local/nginx/sbin:$PATH [root@localhost~]#source /etc/profile.d/nginx.sh （5）测试是否可以启动 [root@localhost~]#nginx [root@localhost~]#ss -tnlp LISTEN 0 128 *:80 *:* users:((&quot;nginx&quot;,pid=57986,fd=6),(&quot;nginx&quot;,pid=57985,fd=6)) 至此源码编译nginx安装成功。]]></content>
      <categories>
        <category>服务</category>
        <category>Nginx</category>
        <category>Nginx源码编译安装</category>
      </categories>
      <tags>
        <tag>nginx，源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAM]]></title>
    <url>%2F2017%2F11%2F28%2FPAM%2F</url>
    <content type="text"><![CDATA[PAM认证1、概念 PAM （Pluggable Authentication Modules）可插入认证模块是一套共享库,使本地系统管理员可以随意选择程序的认证方式.。提供了对所有服务进行认证的中央机制，适用于login，远程登录（telnet，rlogin,fsh,ftp，点对点协议（ppp）），su等应用程序中。系统管理员通过PAM配置文件来指定不同应用程序的不同认证策略；应用程序开发者通过在服务程序中使用PAM API来实现对认证方法的调用；而PAM服务模块的开发者则利用PAM SPI来编写模块，主要调用一些函数，将不同的认证机制加入到系统中；PAM接口库则读取配置文件，将应用和相应PAM服务模块联系起来。 2、配置文件模块存放位置/lib64/security/ 环境相关的配置/etc/security/ 模块通过读取配置文件完成用户对系统资源的使用控制 主配置文件/etc/pam.conf 默认不存在 文档 /usr/share/doc/pam-*;man -k pam_ 查看所有pam的说明 注意：如果/etc/pam.d/和/etc/pam.conf两个文件同时存在，则只有/etc/pam.d/*下的文件起效。 3、认证原理PAM一般遵循的顺序：server–&gt;PAM（配置文件）–&gt;pam.*so；PAM认证首先要确定哪一项服务，然后加载相应PAM的配置文件（/etc/pam.d）,最后调用认证文件（/lib64/security/）进行认证。 4、passwd程序PAM认证机制过程（1）用户执行/usr/bin/passwd程序，并输入密码； （2）passwd开始呼叫PAM模块，PAM模块会搜寻passwd程序的PAM相关设定文件，这个设定文件在/etc/pam.d/目录下与之程序同名的文件。即PAM会搜寻/etc/pam.d/passwd （3）经由/etc/pam.d/passwd设定的文件数据取用PAM所提供的相关模块来进行验证； （4）将验证结果回传给passwd程序，而passwd这个程序会根据PAM回传的结果决定下一个动作。 5、/etc/pam.d/目录下文件格式||type|control|module-path|argument| （1）type类型 type 解释 Auth 账号的认证和授权 Account 与账号管理相关的非认证类的功能 Password 用户修改密码复杂度检查机制等功能 Session 用户获取之前或使用服务完成之后需要进行的一些附加操作，如打开或关闭数据的信息，监视目录等 -type 表示因为缺失而不能加载的模块将不记录在系统日志，对于不总是安装在系统上的模块有用 （2）control PAM库如何处理与该服务相关的PAM模块成功或失败情况 control 解释 required 一票否决，表示本模块必须返回成功才能通过认证，但是如果该模块返回失败，失败结果也不会立即通知用户，而是要等到同一type类型全部执行完毕再将放回给应用程序。即为必要条件 requisite 一票否决，该模块必须返回成功才能通过认证，但是一旦该模块返回失败，将不再执行同一type内的任何模块，而是直接将控制权返回给应用程序。即一个必要条件 sufficient 一票通过权，表明本模块返回成功则通过身份认证的要求，不必再执行同一type内的其他模块，但是如果本模块返回失败可忽略，即充分条件 optional 表明本模块为可选的，它的成功与否不会对身份认证起关键作用，其返回值一般被忽略 include 调用其他的配置文件中定义的配置信息 还有另外一种方式：使用一个或多个“status=action” status：检查结果的返回值 action：采取行为ok，done，die，bad，ignore，reset action 解释 ok 模块通过，继续检查 done 模块通过，返回最后检查给应用 bad 结果失败，继续检查 die 结果失败，返回失败结果给应用 ingore 结果忽略，不影响最后结果 reset 忽略已经得到的结果 （3）modules-path 相对路径:/lib64/security目录下的模块可使用的相对路径；如pam_shells.so绝对路径：如果编译安装以后模块存放的位置 建议：将来修改PAM文件时，备用一个ssh连接窗口，以免我们误操作。 （4）argument 用来给该模块传递参数 6、常用pam模块1、pam_shells：检查有效shell 会调用文件/etc/shells 示例 （a）先创建用户指定其bash为/bin/csh [root@centos6~]#useradd -s /bin/bash wang （b）在CentOS6上修改/etc/shells和/etc/pam.d/su文件 在认证前添加 auth required pam_shells.so （c）在CnetOS6使用wang账户登录 [root@localhostsecurity]#su - wang Password: su: incorrect password 但是此时使用ssh还可以连接 [root@localhostpam.d]#ssh wang@192.168.4.131 wang@192.168.4.131&apos;s password: Last login: Thu Sep 14 13:42:35 2017 from 192.168.4.131 如果我们想彻底禁止wang登录把/etc/pam.d/su 和/etc/pam.d/sshd两个文件在auth前天添加如下一行： auth required pam_shells.so （d）如果让wang登录删除上述设置即可。 2、pam_securetty.so：只允许root用户在/etc/securetty列出的安全终端上登录 示例 允许telnet使用root登录 方法一： 修改配置文件/etc/pam.d/remote配置文件 #auth required pam_securetty.so 方法二： 直接修改/etc/securetty添加所需要登录的终端；如果连接的终端使用完毕后，后续的连接将不会执行。 3、pam_nologin.so：如果/etc/nologin文件存在，将导致非root用户不能登录 作用机理：如果用户shell是/etc/nologin时，当该用户登录时，会显示/etc/nologin.txt文件内容，并拒绝登录。 file=/PATH/TO/SOMEFILE 示例 修改配置文件login文件添加入下面一行： auth required pam_nologin.so 在CentOS7使用wang登录 [root@centos7~]#ssh wang@192.168.4.131 wang@192.168.4.131&apos;s password: Connection closed by 192.168.4.131 如果想给非root用户提示信息可以编辑文件/etc/pam.d/nologin account required pam_nologin.so file=/etc/nologin.txt 4、pam_limits.so：在用户级别对其可使用的资源的限制 （1）配置文件 /etc/security/limits.conf /etc/security/limits.d/*.conf （2）格式 ||domain|type|item|value| （a）domain 应用于哪些对象 username 单个用户 @group 组内所有用户 （b）type类型 soft软限制，普通用户可以自己修改；如果出现会有警告信息 hard硬限制，只有root能设定，且通过kernel强制生效 -：两者同时设定 （c）item 限制资源 选项 说明 core limits the core file size (KB) data max data size (KB) fsize maximum filesize (KB) memlock max locked-in-memory address space (KB) nofile max number of open file descriptors rss max resident set size (KB) stack max stack size (KB) cpu max CPU time (MIN) nproc max number of processes as address space limit (KB) maxlogins max number of logins for this user maxsyslogins max number of logins on the system priority the priority to run user process with locks max number of file locks the user can hold sigpending max number of pending signals msgqueue max memory used by POSIX message queues (bytes) nice max nice priority allowed to raise to values: [-20, 19] rtprio max realtime priority （4）value 指定具体值 ulimit命令的使用 选项 解释 -a 列出所有设定值 -n 最多打开的文件描述符个数 -u 最大用户进程数 -S 使用’SOFT’资源限制 -H 使用‘HARD’资源限制 5、pam_time.so （1）格式： services; ttys ；users； times （2）services 服务程序名称 （3）ttys 登录的终端 可是使用* （4）users 用户 （5）times 格式：day/time-range Mo Tu We Th Fr Sa Su Wk Wd Al MoMo = no day MoWk = all weekdays bar Monday 所有的工作日但是除了星期一 AllFr 所有添但是除了星期五 time-range： 格式：HHMM 如果开始时间小于结束时间，系统假设到了第二天。 可是使用模式 “&amp;” “ |”“ ！” 示例 禁止用户上班时间使用ssh服务 编辑/etc/security/time.conf添加如下一行： sshd;*;centos;Wk 编辑/etc/pam.d/sshd添加如下一行： auth required pam_time_so 了解pam_group.so模块]]></content>
      <categories>
        <category>安全</category>
        <category>PAM</category>
      </categories>
      <tags>
        <tag>PAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PXE]]></title>
    <url>%2F2017%2F11%2F28%2FPXE%2F</url>
    <content type="text"><![CDATA[一、PXE1、pxe概念PXE(preboot execute environment，预启动执行环境)是由Intel公司开发的最新技术，工作于Client/Server的网络模式，支持工作站通过网络从远端服务器下载映像，并由此支持通过网络启动操作系统，在启动过程中，终端要求服务器分配IP地址，再用TFTP（trivial file transfer protocol）或MTFTP(multicast trivial file transfer protocol)协议下载一个启动软件包到本机内存中执行，由这个启动软件包完成终端（客户端）基本软件设置，从而引导预先安装在服务器中的终端操作系统。PXE可以引导多种操作系统，如：Windows95/98/2000/windows2003/windows2008/winXP/win7/win8,linux系列系统等。 2、pxe的工作原理（1）Client向PXE Server上的DHCP发送IP地址请求消息， （2）DHCP检测Client是否合法（主要是检测Client的网卡MAC地址），如果合法则返回Client的IP地址，同时将启动文件pxelinux.0的位置信息一并传送给Client （3）Client向PXE Server上的TFTP发送获取pxelinux.0请求消息，TFTP接收到消息之后再向Client发送pxelinux.0大小信息，试探Client是否满意，当TFTP收到Client发回的同意大小信息之后，正式向Client发送pxelinux.0 （4）Client执行接收到的pxelinux.0文件 （5）Client向TFTP Server发送针对本机的配置信息文件（在 TFTP 服务的pxelinux.cfg目录下），TFTP将配置文件发回Client，继而Client根据配置文件执行后续操作。 （6）Client向TFTP发送Linux内核请求信息，TFTP接收到消息之后将内核文件发送给Client （7）Client向TFTP发送根文件请求信息，TFTP接收到消息之后返回Linux根文件系统 （8）Client启动Linux内核 （9）Client下载安装源文件，读取自动化安装脚本 3、PXE依赖的服务、软件包及文件（1）dhcp服务如果不理解dhcp请查看http://merit.blog.51cto.com/10757694/1966078 （2）tftp服务（a）tftp的安装包 tftp 客户端，tftp-server服务端 （b）端口号为69/UDP （c）配置为文件 /etc/xinetd.d/tftp service tftp { socket_type = dgram protocol = udp wait = yes user = root server = /usr/sbin/in.tftpd server_args = -s /var/lib/tftpboot disable = yes #此选项是否开启tftp服务 per_source = 11 cps = 100 2 flags = IPv4 } （d）如何 CentOS 7如何启动此服务？[root@localhost ~]# yum install -y tftp-server 方法一：直接修改配置文件[root@localhost ~]# systemctl start tftp #启动服务[root@localhost ~]# ss -unl #查看端口是否启动 方法二：直接启动服务并设置开机自动启动[root@localhost ~]# systemctl start tftp[root@localhost ~]# systemctl enable tftp （3）syslinux包（a）概念 syslinux是一个功能强大的引导加载程序，而且兼容各种介质。它的目的是简化首次安装Linux的时间，并建立修护或其它特殊用途的启动盘。它的安装很简单，一旦安装syslinux好之后，sysLinux启动盘就可以引导各种基于DOS的工具，以及MS-DOS/Windows或者任何其它操作系统。不仅支持采用BIOS结构的主板，而且从6.0版也开始支持采用EFI结构的新型主板。（b）文件介绍 ||后缀名|解释||none or other|Linux内核映像||.0|PXE 启动引导程序(NBP)|.bin|“光盘引导扇区”|.bs|“磁盘引导扇区”|.bss|“磁盘引导扇区”，|.c32|COM32映像文件|.cbt|COMBOOT映像文件|.com|COMBOOT映像文件|.img|磁盘映像文件|.ima|软盘映像文件 制作PXE常使用的文件menu.c32、pxelinux.0。 （4）kickstart文件如果不理解怎么配置kickstart文件，请查看http://merit.blog.51cto.com/10757694/1966072 ##二、PXE自动化安装CentOS 7在进行操作之前确保iptables服务时关闭的，selinux是禁用的。 （a）配置yum源和ks文件[root@localhost ~]# yum install -y vsftpd #安装vsftpd服务[root@localhost ~]# systemctl enable vsftpd #设置为开机启动[root@localhost ~]# systemctl start vsftpd 启动服务[root@localhost ~]# cd /var/ftp/pub/[root@localhost ~]# mkdir centos/7 -pv #创建目录[root@localhost ~]# mount /dev/sr0 centos/7 #挂载光盘[root@localhost pub]# rz 将ks文件上传至当前目录具体的可以参考http://merit.blog.51cto.com/10757694/1966072 （b）安装syslinux包[root@localhost ~]# yum install -y syslinux（c）按装tftp服务，并将配置文件复制[root@localhost ~]# yum install -y tftp-server #安装tftp服务包[root@localhost ~]# cd /var/lib/tftpboot/[root@localhost tftpboot]# cp /usr/share/syslinux/{pxelinux.0,menu.c32} . #将pxelinux.0和menu.c32复制到当前目录下[root@localhost tftpboot]# cp /media/cdrom/isolinux/{vmlinuz,initrd.img} . #将内核文件和虚拟文件系统复制到当前目录下[root@localhost tftpboot]# mkdir pxelinux.cfg[root@localhost tftpboot]# cp /media/cdrom/isolinux/isolinux.cfg pxelinux.cfg/default #将isolinux.cfg文件复制到pxelinux.cfg目录下并改名为default[root@localhost tftpboot]# tree #目录结构 . ├── initrd.img ├── menu.c32 ├── pxelinux.0 ├── pxelinux.cfg │ └── default └── vmlinuz 1 directory, 5 files [root@localhost tftpboot]# vim pxelinux.cfg/default编辑default配置文件 default menu.c32 timeout 600 menu title CentOS 7 PXE Install label desktop menu label ^desktop kernel vmlinuz append initrd=initrd.img ks=ftp://192.168.4.51/pub/ks7.cfg menu end （d）新建一台虚拟机，测试 三、PXE自动化CentOS 6（1）准备yum源和ks6.cfg`[root@centos6~]#yum install -y httpd #安装httpd服务[root@centos6/var/www/html]#mkdir centos/6 -pv[root@centos6/var/www/html]#mkdir ksdir/[root@centos6/var/www/html]#mount /dev/sr0 centos/6/ #挂载光盘[root@centos6/var/www/html]#cp ks6.cfg ksdir/ #复制ks文件并修改 #version=DEVEL # System authorization information auth --enableshadow --passalgo=sha512 # Use ftp/http installation media url --url=ftp://192.168.4.137/centos/6 # Use graphical install graphical # Run the Setup Agent on first boot firstboot --enable ignoredisk --only-use=sda # Keyboard layouts keyboard --vckeymap=us --xlayouts=&apos;us&apos; # System language lang en_US.UTF-8 # Network information network --bootproto=dhcp --device=ens33 --onboot=on --ipv6=auto network --hostname=localhost.localdomain # Root password # System services services --disabled=&quot;chronyd&quot; # System timezone timezone Asia/Shanghai # X Window System configuration information xconfig --startxonboot # System bootloader configuration bootloader --append=&quot; crashkernel=auto&quot; --location=mbr --boot-drive=sda zerombr # Partition clearing information clearpart --all part /boot --fstype=&quot;xfs&quot; --ondisk=sda --size=1024 part swap --fstype=&quot;swap&quot; --ondisk=sda --size=2048 part / --fstype=&quot;xfs&quot; --ondisk=sda --size=50000 part /app --fstype=&quot;xfs&quot; --ondisk=sda --size=50000 %packages @^gnome-desktop-environment @base @core @desktop-debugging @dial-up @directory-client @fonts @gnome-desktop @guest-agents @guest-desktop-agents @input-methods @internet-browser @java-platform @multimedia @network-file-system-client @networkmanager-submodules @print-client @x11 kexec-tools autofs lftp dhcp vsftpd %end %post #Create repo mkdir /media/cdrom mkdir /etc/yum.repos.d/bak mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak cat &gt; /etc/yum.repos.d/base &lt;&lt;EOF [base] name=centos 6 baseurl=file:///media/cdrom gpgcheck=0 enabled=1 EOF cat &gt;&gt; /etc/fstab &lt;&lt; EOF /dev/sr0 /media/cdrom iso9660 defaults 0 0 cat &gt;&gt; /root/.bashrc &lt;&lt; EOF alias cdnet=&quot;cd /etc/sysconfig/network-scripts/&quot; EOF cat &gt;&gt; /etc/profile.d/env.sh export PS1=&apos;\[\e[31m\][\u@\h\w]\$\[\e[0m\]&apos; EOF %end [root@centos6/var/www/html]#service httpd start #启动http服务（2）安装syslinux-nonlinux包[root@centos6/var/www/html]#yum install -y syslinux-nonlinux（3）安装tfpt服务并复制文件[root@centos6/var/www/html]#cd /var/lib/tftpboot/[root@centos6/var/lib/tftpboot]#cp /usr/share/syslinux/{pxelinux.0,menu.c32} . #将菜单需要的文件复制到当前目录[root@centos6/var/lib/tftpboot]#cp /media/cdrom/isolinux/{vmlinuz,initrd.img} . #复制内核文件和虚拟文件系统到当前目录下[root@centos6/var/lib/tftpboot]#mkdir pxelinux.cfg[root@centos6/var/lib/tftpboot]#cp /media/cdrom/isolinux/isolinux.cfg pxelinux.cfg/default #复制菜单显示内容文件[root@centos6/var/lib/tftpboot]#vim pxelinux.cfg/default #修改default文件 default menu.c32 #prompt 1 timeout 600 menu title PXE Install CentOS 6 label desktop menu label ^desktop menu default kernel vmlinuz append initrd=initrd.img ks=http://192.168.4.137/ksdir/ks6.cfg menu end （4）安装dhcp服务并配置[root@centos6~]#yum install -y dhcpd[root@centos6~]#cp /usr/share/doc/dhcp-4.1.1/dhcpd.conf.sample /etc/dhcp/dhcpd.con[root@centos6~]#vim /etc/dhcp/dhcpd.conf[root@centos6~]#service dhcpd start #启动http服务（5）新建一台虚拟机，查看是否可以成功 四、如何使用PXE能支持CentOS 6和CentOS 7的安装（a）前几步骤都和上述安装过程类似（b）修改配置文件`[root@centos6~]#vim /var/lib/tftpboot/pxelinux.cfg/default default menu.c32 timeout 600 menu title CentOS Linux PXE Install label centos7 menu label Auto Install CentOS Linux ^7 kernel centos7/vmlinuz append initrd=centos7/initrd.img ks=http://192.168.4.135/ksdir/ks7-1.cfg label centos6 menu label Auto Install CentOS Linux ^6 kernel centos6/vmlinuz append initrd=centos6/initrd.img ks=http://192.168.4.135/ksdir/ks6-1.cfg label manual7 menu label ^Manual Install CentOS Linux 7 kernel centos7/vmlinuz append initrd=centos7/initrd.img inst.repo=http://192.168.4.135/centos/7 label manual6 menu label Manual ^Install CentOS Linux 6 kernel centos6/vmlinuz append initrd=centos6/initrd.img inst.repo=http://192.168.4.135/centos/6 menu end （c）新建虚拟机测试]]></content>
      <categories>
        <category>自动化运维</category>
        <category>PXE</category>
      </categories>
      <tags>
        <tag>cobbler，自动化安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BIND编译安装]]></title>
    <url>%2F2017%2F11%2F28%2FBIND%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[编译安装bind （1）下载源码包 https://www.isc.org/downloads/ （2）解压缩源码包 [root@localhost~]#mv bind-9.10.6.tar.gz /usr/src/ [root@localhost~]#cd /usr/src/ [root@localhost/usr/src]#tar xvf bind-9.10.6.tar.gz （3）来我们先看看bind包原来有没有安装脚本呢？ [root@localhost ~]# rpm -q --scripts bind 从图中我们可以看出，安装前需要自己创建用户，那么我们来创建一个用户吧 [root@localhost/usr/src/bind-9.10.6]#useradd -r -d /var/named -s /sbin/nologin -m named #这里由于是系统用户，如果不加“-m”的话，是不能创建家目录的，切记！！！ （4）我们接下来看看如何安装bind [root@localhost/usr/src/bind-9.10.6]#cat README 如果直接向定制bind程序，显然这样做是不能满足我们的需求的，我们可以使用如下操作定制我们bind程序 [root@localhost/usr/src/bind-9.10.6]#./configure --help 如上图所示，这里只是截取部分图，这里可以选择我们要安装的包位置，启用或关闭某些功能，实现定制bind，相信很多第一次编译的像我这样的人来说认真研究一种程序源码安装过程，基本可以掌握别的源码包的安装。 [root@localhost/usr/src/bind-9.10.6]#./configure --prefix=/app/bind10 --sysconfdir=/etc/bind10 来来看看，我说什么了，当出现这是不是不知道如何操作，没有人家说的很清楚了，没有gcc，那该如何解决呢？那么我们来安装一个开发包来解决这个问题 [root@localhost/usr/src/bind-9.10.6]#yum groupinstall -y &quot;development tools&quot; 那我们再来尝试一次，看看这次会出现什么幺蛾子。 [root@localhost/usr/src/bind-9.10.6]#./configure --prefix=/app/bind10 --sysconfdir=/etc/bind10 看看我说什么来着，这次又出错啦，为什么呢？它提示我们说没有openssl程序，如果想依赖这个程序，可以安装openssl-devel；一般源码包遇到的情况，都安装相对的开发包即可。 那我们再来测试一次，看看还会出现什么情况呢？ 当当当，哈哈，竟然成功啦 ；不过这只是成功了一部分，如果想继续成功那就实行下面步骤吧 （5）进行编译安装 [root@localhost/usr/src/bind-9.10.6]#make ;make install make 的作用是开始进行源代码编译，以及一些功能的提供，这些功能由他的 Makefile 设置文件提供相关的功能； make install 一般表示进行安装，相当于创建软连接，创建目录等等一些操作。 （6）这样安装的话是没有命令PATH和man帮助的，那如何实现呢？ [root@localhost~]#vim /etc/profile.d/env.sh [root@localhost~]#source !$ source /etc/profile.d/env.sh export PATH=/app/bind10/bin:/app/bind10/sbin:$PATH [root@localhost~]#vim /etc/man_db.conf （7）刚刚在（2）比步骤是不是看看还有安装后脚本呀，对的你没有看错，那么我们来进行安装后脚本需要的操作。安装后脚本需要我们使用命令rndc-confgen创建相当于”暗号“，创建了暗号才能访问，那么我们就看看如何创建暗号呢？ [root@localhost~]#rndc-confgen -r /dev/urandom &gt; /etc/bind10/rndc.conf #如果不重定向只能在终端上显示，写不到文件中 不过我们现在还没有主配置文件named.conf文件，怎么办呢？那就手动创建一个喽 [root@localhost~]#vim /etc/bind10/named.conf 不过刚刚我们了解到bind程序运行者是named用户，但是我们来看看这个文件所有者和所属组是who [root@localhost~]#ll /etc/bind10/named.conf -rw-r--r--. 1 root root 200 Sep 22 10:19 /etc/bind10/named.conf [root@localhost~]#chgrp named /etc/bind10/named.conf #修改所属组 [root@localhost/etc/bind10]#chgrp named bind10/ -R #修改文件都为named所属组 （8）不过DNS中解析当然需要根啦那么我们就创建一个喽 [root@localhost named]# scp named.ca 192.168.4.152:/var/named/ #从远程主机上拷贝一个 [root@localhost/var]#chgrp named named/ -R #修改权限 [root@localhost~]#vim /etc/bind10/named.conf [root@localhost/var/named]#vim test.com.zone #编辑测试域 [root@localhost/var/named]#chgrp named test.com.zone #修改权限 （9）那我们接下来尝试着看看能不能起来服务 [root@localhost~]#named -u named -g -f -d 3 [root@localhost~]#ss -tnul 端口53/tcp 53/udp 953/tcp 已经处于监听状态，说明启动已经成功 （10）我们尝试看看可以解析么？ 那么接下来测测我们dns的性能如何喽 对压力测试工具编译安装 [root@localhost ~]# cd /usr/src/bind-9.10.6/contrib/queryperf #切换至源码包位置 [root@localhost/usr/src/bind-9.10.6/contrib/queryperf]#./configure #进行编译 [root@localhost/usr/src/bind-9.10.6/contrib/queryperf]#make [root@localhost/usr/src/bind-9.10.6/contrib/queryperf]#cp queryperf /app/bind10/bin/ #将程序复制到bind执行程序的目录下 创建一个测试文本 [root@localhost~]#vim test 测试 [root@localhost~]#queryperf -d test -s 127.0.0.1]]></content>
      <categories>
        <category>服务</category>
        <category>DNS</category>
        <category>BIND编译安装</category>
      </categories>
      <tags>
        <tag>BIND编译安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis主从复制]]></title>
    <url>%2F2017%2F11%2F28%2FRedis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[redis主从复制一个master可以有多个slave主机，支持链式复制；master以非阻塞方式同步数据值slave主机。 修改方式： redis-cli&gt; SLAVEOF &lt;MASTER_IP&gt; &lt;MASTER_PORT&gt; redis-cli&gt; CONFIG SET masterauth &lt;PASSWORD&gt; 节点 IP 角色 node1 192.168.4.61 master node2 192.168.4.62 slave node3 192.168.4.63 slave 同步时间基于主机名访问确保firewalld和selinux是否关闭三个节点上都安装redis[root@node1~]#yum install -y redis[root@node1~]#systemctl start redis.service node1进行配置[root@node1~]#vim /etc/redis.conf bind 0.0.0.0 requirepass centos node2和node3配置node2以第一种方式配置-[root@node2~]#vim /etc/redis.conf bind 0.0.0.0 requirepass centos slaveof 192.168.4.61 6379 masterauth centos slave-priority 90 [root@node2~]#systemctl start redis node3以第二种方式配置- 127.0.0.1:6379&gt; CONFIG GET slaveof #查看salveof的值 1) &quot;slaveof&quot; 2) &quot;&quot; 127.0.0.1:6379&gt; SLAVEOF 192.168.4.61 6379 #设定slaveof的值 OK 127.0.0.1:6379&gt; CONFIG GET slaveof 1) &quot;slaveof&quot; 2) &quot;192.168.4.61 6379&quot; 127.0.0.1:6379&gt; CONFIG SET masterauth centos OK 127.0.0.1:6379&gt; CONFIG SET requirepass centos OK 127.0.0.1:6379&gt; CONFIG GET slave-read-only (error) NOAUTH Authentication required. 127.0.0.1:6379&gt; AUTH centos OK 127.0.0.1:6379&gt; CONFIG GET slave-read-only 1) &quot;slave-read-only&quot; 2) &quot;yes&quot; 127.0.0.1:6379&gt; CONFIG REWRITE OK 在node1上查看 测试 sentinel主要完成三个功能：监控、通知、自动故障转移 配置项port 指定端口 sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; 设定监控 &lt;quorum&gt; 表示sentinel集群的quorum机制，即至少quorum个sentinel节点同时判定主节点故障，才认为其真的故障 s_down：subjectively down o_down：objectively down sentinel auth-pass &lt;master-name&gt; &lt;password&gt; 连接主节点的密码 sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; 指定failover过程中，能够被sentinel并行配置的从节点的数量 sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt; sentinel必须在此指定的时长内完成故障转移操作，否则，将视为故障转移操作失败 sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; 通知脚本，此脚本被自动传递多个参数 命令： redis-cli -h SENTINEL_HOST -p SENTINEL_PORT redis-cli &gt; SENTINEL masters SENTINEL slaves &lt;MASTER_NAME&gt; SENTINEL failover &lt;MASTER_NAME&gt; SENTINEL get-master-addr-by-name &lt;MASTER_NAME&gt; 注意：在集群中每个节点都要配置并启动sentinel服务。 ### 在刚刚三个集群中配置 [root@node1~]#vim /etc/redis-sentinel.conf bind 0.0.0.0 sentinel monitor mymaster 192.168.4.61 6379 2 sentinel auth-pass mymaster centos systemctl start redis-sentinel.service 查看此时的主节点 [root@node1~]#systemctl stop redis.service down掉主节点 如果故障点修改成功需要上线，进行如下操作： [root@node1~]#vim /etc/redis.conf slaveof 192.168.4.62 6379 masterauth centos slave-priority 70 [root@node1~]#systemctl start redis.service]]></content>
      <categories>
        <category>缓存服务</category>
        <category>Redis</category>
        <category>Redis主从复制</category>
      </categories>
      <tags>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis简单介绍]]></title>
    <url>%2F2017%2F11%2F28%2FRedis%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、Redis1、Redis简介Redis是一个开源的内存数据结构存储，用作数据库，缓存和消息代理。支持数据结构：字符串、列表（数组）、hahses（关联数据）、集合、有序集合、位图、hyperloglogs、空间索引。支持内建的复制，Lua 脚本，LRU算法、事物、持久存储、高可用。基于内存的高性能key-value数据库。 2、Redis优势 性能极高 丰富的数据类型 原子性 丰富的特性 3、Redis安装[root@node1~]#yum install -y redis 安装时会安装jemalloc（支持并存存储） （1）程序文件配置文件：/etc/redis.conf 主程序：/usr/bin/redis-server Unit File ：/usr/lib/systemd/system/redis.service 数据目录：/var/lib/redis 监控配置文件：/etc/redis-sentinel.conf （2）/etc/redis.conf文件详解[root@node1~]#grep &#39;###&#39; /etc/redis.conf INCLUDES 包括其他文件配置 NETWORK 网络配置项 bind IP 监听地址，一般为本地对外通信的地址，多个地址使用空格分隔。0.0.0.0表示监听所有地址 port PORT 监听的端口 protected-mode 是否启用受保护模式 如果bind和port其中一个没有设定就启用保护模式 tcp-backlog tcp级的后援队列长度 unixsocket unix套接字 tcp-keepalived 保持连接时长 timeout 连接的超时时长 GENERAL 基本配置项 daemonize 是否启用守护进程 supervised loglevel 日志级别 pidfile pid文件 logfile 日志文件 databases 设定数据库数量，默认为16个，每个数据库的名字均为正数，从0开始标号，默认操作的数据库为0 SNAPSHOTTING 快照配置项 按事先定制的策略，周期性地将数据从内存同步至磁盘；数据文件默认为dump.rdb 客户端显示使用SAVE或BGSAVE命令手动自动快照保存机制 SAVE：同步，即在主线程中保存快照，此时会阻塞所有客户端请求 BGSAVE：异步，backgroud（后台）进行 save 定义保存策略 表示三个策略满足其中任意一个均会触发SNAPSHOTTING操作；900s内至少有一个key变化，300s内至少有10个key变化；60s内至少有1w个key变化 stop-writes-on-bgsave-error dump操作出现错误时，是否禁止新的写入操作请求 rdbcompression 是否启用压缩功能 rdbchecksum 是否检验 dbfilename 文件名称 dir 定义保存文件的路径，通常不再默认位置下存放 REPLICATION 复制相关的配置项 slave-serve-stale-data 是否使用过期数据响应用户 slave-read-only 设置从为只读 repl-diskless-sync 复制是否无磁盘的复制 新的从节点或某较长时间未能与主节点进行同步的从节点重新与主节点通信，需要做“full synchronization”，此时其同步方式： （1）Disk-backend：主节点新创建快照文件与磁盘中，而后将其发送给从节点 （2）Diskless：主节点新创建快照后直接通过网络套接字文件发送给从节点；为了实现并行复制，通常需要在复制启动前延迟一个时间段。 repl-diskless-sync-delay 启用无磁盘延迟时间 repl-ping-slave-eriod 探测冲节点是否存活 repl-timeout 超时时长 repl-disable-tcp-nodelay 延迟tcp连接，通常关闭此功能 repl-backlog-size 队列的长度 slave-priority 从的优先级 复制集群中，主节点故障时，sentinel应用场景中的主节点选举时使用的优先；数字越小优先级越高，但0表示不参与选举 min-slaves-to-rewrite 主节点仅允许其能够通信的从节点数量大于等于此处的值时接受些操作 min-slaves-max-log 从节点延迟时长超出此处指定的时长时，主节点会拒绝写入操作。 SECURITY 安全相关的配置项 requirepass 设定密码 rename-command 主从复制不建议修改；在AOD或Replication环境中，不推荐使用 LIMITS limit相关的配置项 maxclients 最大并发连接数 maxmemory 最大的内存空间 maxmemory-policy noeviction 定义淘汰机制 volatile-lru 对设定过期期限的key淘汰 allkey-lru 有无过期都在淘汰序列中 volatile-random 对设定过期期限自由淘汰 allkeys-random 对有无过期期限的都自由淘汰 volatile-ttl 移除最接近淘汰期限的key noevication 不过期任何key，只返回错误 maxmemory-samples 淘汰算法运行时的采样本书 APPEND ONLY MODE 记录每次写操作至指定的文件尾部实现的持久化；当redis重启时，可通过重新执行文件中的命令在内存中重建出数据库 BGREWRITEAOD：AOF文件重写 不会读取正在使用AOF文件，而是通过将内存中的数据以命令的方式保存至临时文件中，完成之后替换原来的AOF文件 appendonly 是否开启追加文件 appendfilename 定义名称 appendfsync 定义同步时间 no redis不执行主动同步操作，而是OS内核进行 always 只要发生写就同步 everysec 每秒同步 no-appendfsync-on-rewrite 是否在后台执行aof重写期间不调用fsync，默认为no，表示调用 auto-aof-rewrite-percentage 自动重写的百分比 auto-aof-rewrite-min-size 自动重写的最小大小 上述两个条件同时满足时，方会触发重写AOF，与上次AOF文件大小相比，其增长量超过100%，且大小不少于64MB auto-load-truncated 自动加载截断 注意： RDB与AOF同时启用： （1）BGSAVE和BGREWRITEAOF不会同时进行 （2）Redis服务器启动时用持久化的数据文件恢复数据，会优先使用AOF LUA SCRIPTING Lua脚本 REDIS CLUSTER 集群相关的配置项 cluster-enabled 是否开启集群功能 cluster-config-file 集群节点集群信息配置文件，每个节点都有一个，由redis生成和更新，配置时避免名称冲突 cluster-node-timeout 集群节点互联超时的预支，单位毫秒 cluster-slave-validity-factor 进行故障转移时，slave会申请成为master，有时slave会和master失联很久数据较旧，这样的slave不应该成为master。这个配置用来判断slave是否和master失联时间过后长。 SLOW LOG SlowLog相关的配置项 slowlog-log-slower-than slowlog-max-len slowlog记录的日志最大条目 LATENCY MONITOR EVENT NOTIFICATION ADVANCED CONFIG 高级配置项 hash-max-ziplist-entries hash-max-ziplist-value 设置ziplist的键数量最大值，每个值的最大空间 client-output-buffer-limit normal client-output-buffer-limit slave client-output-buffer-limit pubsub &lt;hard-limit&gt; &lt;soft-limit&gt; &lt;soft-limit seconds&gt; ##注意：持久机制本身不能取代备份；应该制定备份策略，对redis库定期备份。##]]></content>
      <categories>
        <category>缓存服务</category>
        <category>Redis</category>
        <category>Redis简单介绍</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis集群]]></title>
    <url>%2F2017%2F11%2F28%2FRedis%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[redis集群同步时间主机名互相解析确保firewalld和iptables关闭1、配置三个节点[root@node3~]#yum install -y redis 2、修改配置文件 node1配置： [root@node1~]#vim /etc/redis.conf bind 192.168.4.61 requirepass centos cluster-enabled yes cluster-config node1.conf #集群节点信息配置文件，存放在/var/lib/redis目录下 cluster-node-timeout 15000 clusert-migration-barrier 1 #这个选项设置如果master宕机，是否从节点全部迁移到新的master上 [root@node1~]#systemctl start redis.service node2配置： [root@node2~]#vim /etc/redis.conf bind 192.168.4.62 requirepass centos cluster-enabled yes cluster-config node2.conf #集群节点信息配置文件，存放在/var/lib/redis目录下 cluster-node-timeout 15000 clusert-migration-barrier 1 #这个选项设置如果master宕机，是否从节点全部迁移到新的master上 [root@node1~]#systemctl start redis.service node3配置： [root@node3~]#vim /etc/redis.conf bind 192.168.4.63 requirepass centos cluster-enabled yes cluster-config node3.conf #集群节点信息配置文件，存放在/var/lib/redis目录下 cluster-node-timeout 15000 clusert-migration-barrier 1 #这个选项设置如果master宕机，是否从节点全部迁移到新的master上 [root@node1~]#systemctl start redis.service [root@node1~]#redis-cli -h 192.168.4.61 -a centos -p 6379 CLUSTER INFO 查看集群信息 此时看集群状态为fail，因为还没有进行分slot和建立集群关系。3、为每个redis建立slot[root@node1~]#redis-cli -h 192.168.4.61 -a centos -p 6379 CLUSTER ADDSLOTS {0..5461} [root@node1~]#redis-cli -h 192.168.4.62 -a centos -p 6379 CLUSTER ADDSLOTS {5462..10923} [root@node1~]#redis-cli -h 192.168.4.63 -a centos -p 6379 CLUSTER ADDSLOTS {10924..16383} 注意：如果有4个节点，需要自动计算除每个节点有多少个slots，然后进行分配。slot总共有16384个 4、设置集群关系[root@node1~]#redis-cli -h 192.168.4.61 -a centos -p 6379 CLUSTER MEET 192.168.4.62 6379 [root@node1~]#redis-cli -h 192.168.4.61 -a centos -p 6379 CLUSTER MEET 192.168.4.63 6379 #####查看集群信息时集群的状态已经为”ok“。 5、测试，查看效果[root@node1~]#redis-cli -h 192.168.4.61 -a centos -p 6379 #####通过从图中可以看出，在192.168.4.61这台主机不能创建testkeys hi 这个值，需要移到到192.168.4.62:6379主机上创建。 [root@node2~]#redis-cli -h 192.168.4.62 -a centos -p 6379 小结： 客户单向redis发送任何key指令，须先对key计算一个词hash作为其槽位编号，将指令发送给对应槽位的持有节点。就像我们刚刚操作的，如果发送到了错误的节点，会报错；而是返回表示MOVE的错误信息。]]></content>
      <categories>
        <category>缓存服务</category>
        <category>Redis</category>
        <category>Redis集群</category>
      </categories>
      <tags>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL语法]]></title>
    <url>%2F2017%2F11%2F28%2FSQL%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[SQL1、概念结构化查询语言(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。 2、RDBMS术语 数据库：数据库是一些关联表的集合。 数据表：表示数据的矩阵。在一个数据库中的表开起来像一个简单的电子表格。 列（column）：一列包含了相同的数据，又称为属性，字段。 行（row）：是一组相关的数据，又称为一条记录record。 域（domain）：属性的取值范围。 主键（Primary Key）：一个或多个字段的组合，填入的数据必须能在本表中唯一表示本行；必须提供数据，即NOT NULL。一个表中有且只有一个主键。 唯一键：一个或多个字段的组合，填入的数据必须能在本表中唯一表示本行；允许为NULL。一个表中可以存在多个。 外键（foreign key）：一个表中的某字段可填入的数据取决于另一个表中的主键或唯一键已有的数据。即用于关联两个表。 检查（check）：字段在一定范围内。 索引：将表中的一个或多个字段中的数据复制一份另存，并且这些需要按特定次序排序存储。相当于我们一个书前面的目录作用。 复合件：两个或多个字段组成，相当于主键的作用。 SQL处理过程 3数据表类型数值型 类型 大小(字节) 范围（有符号） 范围（UNSIGNED） 用途 TINYINT 1 -128,127 0,255 小整数值 SMALLINT 2 -32768,32767 大整数值 MEDINUMINT 3 -8388608,8388607 0,16777215 大整数值 INT或INTEGER 4 -2^4,2^4-1 0,2^4*2 大整数值 BIGINT 8 -2^8,2^8-1 0,2^8*2 极大整数值 FLOAT（m,d） 4 单精度，浮点数值 DOUBLE(m,d) 8 多精度浮点数值 DECIMAL 小数值 DECIMAL的解释：Decimal(n,m)表示数值中共有n位数，其中整数n-m位，小数m位。例：decimal(10,6)，数值中共有10位数，其中整数占4位，小数占6位。 日期和时间类型 类型 大小（字节） 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 -838:59:59/838:59:59 HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份 DATETIME 8 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2037年某时 YYYYMMDDHHMMSS 时间戳 若一个字段定义为timestamp，这个字段的时间数据随其他字段修改的时候自动更新，这个数据的字段可以存放这条记录最后被修改的时间。 字符串类型 类型 大小(字节) 用途 CHAR 0-255 定长字符串 VARCHAR 0-65535 变长字符串 TINYBLOB 0-255 不超过255个字符的二进制字符串 TINYTEXT 0-255 短文本字符串，可变长度 BLOB(binary large object 0-65535 二进制形式的长文本数据，可变长度 TEXT 0-65535 场文本数据可变长度 MEDIUMBLOB 0,2^24-1 二进制中等长度文本数据，可变长度 BINARY（M） 0，M 固定长度，可存二进制或字符， VARBINARY(M) 0，M 可变长度，可存二进制或字符 char和varchar区别 char(n)若存入字符数小于n，则以空格补充其后，查询之时再将空格去掉。所以char类型存储的字符末尾不能有空格。 char（n）固定长度，不管存入几个字符，都将占用n个字节；varchar（n）是存入的实际字符数+1个字节。真正存入的数据位实际字节-1。会使用1-2个字节来存储值长度。-char类型的字符串检索速度比varchar速度快 varchar和text区别 varchar可指定n，text不能指定n；内部存储varchar是存入的实际字节数+1个字节，text是实际字节数+2的字节。 text类型不能有默认值 varchar可直接创建索引；text创建索引要指定前多少个字符。varchar查询速度比text快。 BOLB与TEXT区别 TEXT以文本方式存储，英文存储区分大小写；而BLOB是以二进制方式存储，不分大小写。 BLOB存储的数据只能整体读出。 TEXT可以指定字符集;BLOB不用指定字符集。 如何正确的数据类型？ ①尽量使用可正确存储数据的最小数据类型 ②简单数据类型的操作通常需要更少的CPU周期 ③尽量避免NULL，包含NULL的列对MySQL更难优化 修饰符类型 类型 解释 NULL 空 NOT NULL 确保不能有NULL值 DEFAULT 提供未指定时为列的默认值 PRIMARY KEY 唯一表示数据库表中的每一行 FOREIGN KEY 唯一表示热河其他数据库表中的行 UNIQUE KEY 确保在一列中所有的值是唯一的 CHARACTER SET name 指定一个字符集 ATUO_INCREMENT 自动递增，适用于整数类型 UNSIGNED 无符号 CHECK 确保列中的所有值满足一定的条件 删除约束的方法ALTER TABLE column_name DROP CONSTRAINT PK; ###4 SQL通配符 通配符 描述 % 替代一个或多个字符 _ 仅替代一个字符 [] 中括号中任意单一字符 [^]或[!] 除中括号中任意单一字符 注意：SQL通配符必须跟LIKE运算符一起使用 ###5、 SQL算数运算符 运算符 描述 + 加法 - 减法 * 乘法 / 除法 % 取模，相当于取余数 ###6、SQL比较运算符 =、!=、 &lt;&gt;、 &gt;、 &lt;、 &gt;=、 &lt;=、 !&lt;、 !&gt; ###7、SQL逻辑运算符 操作符 描述 ALL 用来在另一个值设定比较值的所有值 AND 运行多个条件在SQL语句中，存在WHERE子句中 ANY 用于根据条件在列表中的值进行标胶的任何应用值 BETWEEN…AND 用于搜索是在一组的那个值，给定最小值和最大值 EXISTS 用于搜索中指定的表，以满足某些标准的存在 IN 用于一个值进行比较，以已被指定的文字值的列表 LIKE 用来标胶使用通配符运算符相似的值 NOT 取反 OR 用来多个条件子句结合起来的SQL语句 IS NULL 用来比较一个NULL的值 UNIQUE 搜索指定表的每一行的唯一性 ###8、SQL Alias格式：SELECT column_names FROM table_name AS alias_name ###9、SQL表达式 SQL 布尔表达式 语法：SELECT column_name1 column_name2 column_name3 FROM table_name WHERER SINGLE VALUE MATCHTING EXPRESSION; SQL 数字表达式 语法：SELECT numerical_expression as OPERATION_NAME [FROM table_name WHERE CONDITION]; SQL 日期表达式 SELECT CURRENT_TIMESTAMP; #显示当前系统的时间值 SELECT GETDATE(); #显示时间 ###10、SQL 索引索引是数据库的搜索引擎使用，以加快数据检索特定的查找表，是一个指向表中的数据。相当于一本书的目录，便于快速查找，对数据没有影响。缺点：如果UPDATE和INSERT会减慢数据的输入。 注意：索引是唯一的，索引防止在列或者有一个索引重复条目。 语法：CREATE INDEX index_name ON table_name; 单列索引：是一个基于只有创建表列。 语法：CREATE INDEX index_name ON table_name （colum_name）; 唯一索引:不仅用于性能，而且要求数据的完整性。 语法：CREATE UNIQUE INDEX index_name ON table_name （column_name）; 组合索引：两个或多个索引 语法：CREATE INDEX index_name ON table_name （column_name1，column_name2..）; ###11、SQL视图SQL视图（View）是SQL语句结果集的可视化表。视图中的字段是来自一个或多个数据库中真实表中的字段。 注意：数据库的设计不会受到视图中的函数、where或join语句的影响。 语法：CREATE VIEW view_name AS SELECT column_name（s） FROM table_name WHERE [CONDITION]; WHIT CHECK OPTION 是CREATE VIEW 语句选项。目的是为了确保所有更新和插入满足视图定义的条件。 示例：CREATE VIEW testView AS SELECT name，age FROM testtable WHERE age IS NOT NULL WITH CHECK OPTION; #WITH CHECK OPTION 拒绝任何age为NULL值的行。 那么是不是这样我们就可以随便更新视图了呢？那可不一定哦，更新视图是有一定条件的： SELECT子句不包含关键字DISTINCT. SELECT子句不包含汇总函数。 SELECT子句不包含集合函数。 SELECT子句不能包含集合运算符 SELECT子句不能包含一个ORDER BY 子句。 FROM子句中不能包含多个表。 WHERE子句中不能包含子查询。 查询不包含GROUP BY 或HAVING. 计算列无法更新 从基表中的所有NOT NULL 列必须包含在视图。 看看是不是不是随便能更新视图能。好忧伤。。。 示例：UPDATE testView SET age = 20 WHERE name ‘xiaomian’ ; ###12、SQL排序语法：SELECT column-list FROM table_name [WHERE CONDITION] [ORDER BY column1,column2..][ASC|DESC]; ###13SQL约束事物就是对数据库执行的工作单元。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！ 事物的特性事务是必须满足4个条件（ACID）： Atomicity（原子性）、Consistency（稳定性）、Isolation（隔离性）、Durability（可靠性） 事务的原子性：确保工作单元中的所有操作都成功完成。否则，该事物被终止的故障点，操作回滚到操作之前的状态。 一致性：确保数据库正确后成功提交事物更改状态。 隔离性：事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。 可靠性：软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候把事务保存到日志里。 控制事物使用的命令： COMMIT :保存修改 ROLLBACK:回滚更改 SAVEPOINT:回滚事物组创建点 SET TRANSACTION:用来设置事物的隔离级别 ##14、 SQL命令分类DDL（Data Define Language） 命令 描述 CREATE 创建一个表、数据库、表的视图 ALTER 修改现有数据库对象 DROP 删除整个表、数据库中的表或其他对象或视图 DML（Data Manager Language） 命令 描述 INSERT 插入记录 UPDATE 修改记录 DELETE 删除记录 DCL（Date Control Language） 命令 描述 GRANT 授予用户权限 REVOKE 撤销授予用户的权限 DQL（Date Query Language） 命令 描述 SELECT 从一张表或多张表中检索特定的记录 ###、15、SQL语言规范 在数据库系统中，SQL语句不区分大小写（建议使用大写），但在字符串中常量区分大小写。 SQL语句中可以单行书写，并以“；”结尾。 在SQL中关键词不能跨多行或简写。 子句通常独立运行，便于管理，提高可读性。 SQL注释标准：/需要注释的内容/ 或 –需要注释的内容]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL语法</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH基于密钥认证]]></title>
    <url>%2F2017%2F11%2F28%2FSSH%E5%9F%BA%E4%BA%8E%E5%AF%86%E9%92%A5%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[基于密钥认证1、工作机制（a）客户端在本机生成一对密钥 （b）客户端通过密令将本机的公钥拷贝到服务器端，服务端会将客户端的公钥存在至`~/.ssh/authorized.keys`目录下 （c）客户端再次发送请求时，包括IP、用户名； （d）服务端在通过上述目录查找是否有与之对应的公钥，如果查找成功响应IP和用户名，会随机生成一个字符串 （e）服务端将使用客户端的公钥进行加密，然后发送给客户端 （f）客户端得到服务端发来的消息后，客户端使用私钥进行解密，将解密的字符串发送给服务端 （g）服务端接受客户端发来的字符串后，跟之前对比，如果一致，允许登录，反之亦然。 2、生成密钥对命令的介绍ssh-keygen:authentication key generation, management and conversion 格式： ssh-keygen [-q] [-b bits] -t type [-N new_passphrase] [-C comment] [-f output_keyfile] 选项： -t 加密的类型 -P 是否对生成的私钥加密 -f 指定的文件名 ssh-copy-id :install your public key in a remote machine’s authorized_keys 格式： ssh-copy-id [-i [identity_file]] [user@]machine 选项： -i 指定公钥存放的位置 3、基于key的过程（a）在客户端生CentOS 7在一对密钥 [root@localhost~]#ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): #密钥存放的位置 Enter passphrase (empty for no passphrase): #是否对密钥加密，建议加密，这里相当于选项-P Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: f5:f9:21:08:dd:2a:8d:f7:9f:88:4e:88:53:3e:45:a3 root@localhost.localdomain The key&apos;s randomart image is: +--[ RSA 2048]----+ | | | . . | | . = . | | B = . | | E * + . | | + = . o . | | o + . . . | | . o . o . | | .o . o | +-----------------+ （b）使用命令将公钥拷贝到服务端CentOS 6主机上 [root@localhost~]#ssh-copy-id -i .ssh/id_rsa.pub root@192.168.10.100 [root@centos6~]#ls .ssh/authorized_keys 查看是否在服务端生成目录`authorized.keys` .ssh/authorized_keys （c）测试 [root@localhost~]#ssh 192.168.10.100 Last login: Thu Sep 7 18:39:01 2017 from 192.168.159.1 #登录成功 如果我们私钥加密需要验证多台，如果我们一台一台的验证，这样显然不是我们想要的方法，下面就很好的解决了我们这个问题 ssh-agent命令介绍ssh-agent是个长时间持续运行的守护进程（daemon），设计它的唯一目的就是对解密的专用密钥进行高速缓存，这是一个一次性的过程，如果终端退出即消失。 工作机制 如果执行这条命令，会启动后台一个子进程。代理一开始并没有私钥文件，私钥文件是通过命令`ssh-add`添加。并且把文件~/.ssh/id_rsa, ~/.ssh/id_dsa, ~/.ssh/id_ecdsa, ~/.ssh/id_ed25519 and ~/.ssh/identity添加到代理中。通过使用环境变量能定位和验证。SSH_AUTH_SOCK和SSH_AGENT_PID环境变量。 实现代理的方法（a）ssh-agent xterm &amp; 利用内含的export命令执行环境使环境变量可用 （b）eval `ssh-agent -s` -s sh ksh -c csh 步骤（a）对上述生成的密钥加密 [root@localhost~]#ssh-keygen -p #-p 修改密码 Enter file in which the key is (/root/.ssh/id_rsa): Key has comment &apos;/root/.ssh/id_rsa&apos; Enter new passphrase (empty for no passphrase): Enter same passphrase again: Pass phrases do not match. Try again. （b）启动代理 [root@localhost~]#ssh-agent bash #启动一个bash子进程 （c）将私钥文件添加至代理中 [root@localhost~]#ssh-add Identity added: /root/.ssh/id_rsa (/root/.ssh/id_rsa) （d）测试 [root@localhost~]#ssh 192.168.10.102 Last login: Sun Sep 10 17:46:13 2017 from 192.168.10.101登录成功，这样提高了我们的工作效率。 4、利用xshell基于key连接在xshell中工具--&gt;新建用户密钥生成向导--&gt;选择密钥类型和密钥长度--&gt;给密钥名称命名并给密钥加密--&gt;选择公钥格式--&gt;保存公钥文件至指定目录下--&gt;将公钥复制到需要远程连接的主机上~/.ssh/authorized.keys目录下，如果没有文件需要创建此目录，并修改权限。 在生成密钥是选择不合适的公钥格式，可以使用密令修改：[root@centos6~]#ssh-keygen -i -f PUBLIK.key &gt;&gt;~/.ssh/authorized.keys -i 读取不加密的私钥和公钥非OpenSSH兼容输出]]></content>
      <categories>
        <category>服务</category>
        <category>SSH</category>
        <category>SSH基于密钥认证</category>
      </categories>
      <tags>
        <tag>ssh，密钥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH端口转发]]></title>
    <url>%2F2017%2F11%2F28%2FSSH%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[端口转发在日常生产中，我们常常会遇到这样的问题，在公司运行一个服务或者一些程序，想要查看其运行状态及其结果等；公司的机器只能从内部访问外网，而内部外的并不能访问内部的机器；或者公司有一台ssh服务器，不能使用telnet服务去访问内部的主机，这样我们如何解决呢？由于ssh服务加密传输数据，我们可通过ssh服务解决上述问题。通过ssh连接首先构建一个”隧道“，然后可以通过这个隧道，远程连接到主机。 1、ssh本地端口转发格式：ssh -L localPort:remateIp1（需要远程连接的IP）:rematePort IP2(跳板机的IP) 选项 含义 -f 后台启用 -N 不打开远程shell，处于等待状态 -g 启用网关功能 示例 假设这里有三台机器，CnetOS6.9-1 IP为192.168.159.138；CnetOS6.7-1 IP为192.168.159.139；CnetOS7.3-2 IP为192.168.159.161。CentOS7.3-2和CentOS7.3-1在公司的局域网中，CentOS6.9-1想连接CentOS7.3-2与之通信，该如何实现？ （1）模拟一个环境，先禁止CentOS6.9-1远程连接CentOS7.3-2 [root@localhost~]#iptables -A INPUT -s 192.168.159.138 -j REJECT （2）首先确认要使用本地端口是否被别的服务占用[root@centos7~]#ss -tn （3）CentOS6.9-1利用ssh本地端口转发连接[root@centos6~]#ssh -L 10001:192.168.159.161:23 -fN 192.168.159.139root@192.168.159.139&#39;s password:Last failed login: Tue Sep 12 05:04:50 CST 2017 from ``192.168.159.138 on ssh:nottyThere were 4 failed login attempts since the last successful login.Last login: Tue Sep 12 04:58:25 2017 from 192.168.159.1 （4）查看隧道是否建立成功 [root@centos6~]#ss -tnState Recv-Q Send-Q Local Address:Port Peer Address:PortESTAB 0 0 192.168.159.138:22 192.168.159.1:4708ESTAB 0 0 192.168.159.138:35506 192.168.159.139:22 #已经建立连接[root@localhost~]#ss -tn #在CetnOS 7.3-2无连接State Recv-Q Send-Q Local Address:Port Peer Address:PortESTAB 0 0 192.168.159.161:22 192.168.159.1:474 （5）在CentOS6.9-1ftp服务连接操作了 [root@centos7~]#ssh -p 10000 127.0.0.1 （6）如果我们连接完成想删除“隧道”该怎么解决呢？此时只能同过kill命令删除 [root@centos7~]#kill -9pidof ssh`` 2、ssh远程端口转发与上述示例相反，内网中只有一台主机可以访问外网，而另外一台主机不能访问外网，但是另外一台主机要想与外部的主机连接时，只能让一台主机作为跳板机，连接至外部机器，下面是实现方法： （1）先模拟出来一个环境，同上述环境一样 （2）在CentOS7.3-2主机上创建隧道 [root@centos7~]#ssh -R 9999:192.168.159.138:22 -fN 192.168.159.164 （3）查看端口是否创建成功 [root@centos7~]#ss -tnState Recv-Q Send-Q Local Address:Port Peer Address:Port ESTAB 0 0 192.168.159.139:51608 192.168.159.164:22 （4）在CentOS7.3-2连接CentOS6.9-1 [root@localhost~]#telnet 127.0.0.1 9999 （5）此处删除的方法更ssh本地端口转发一样。 3、ssh动态端口转发上述的两种，只是点对点的转发，如果我们有许多的端口，显然这样操作是不理想的，所有ssh支持ssh动态端口转发功能。如果某一台机器不能受限制不能访问某些网站，而另一台主机可以访问，ssh动态转发就解决了这个问题。工作原理是本地机器上分配一个socket侦听port端口，一旦这个端口上有了连接，该连接就经过安全通道转发出去，根据应用程序的协议可以判断远程主机和哪里连接。 注意：只有root才能转发特权端口。 格式：ssh -D （1）建立通道 [root@centos7~]#ssh -D 1080 -fN 192.168.159.165 （2）测试是否成功 [root@centos7~]#curl --socks5 127.0.0.1 http://192.168.159.166test 上述过程中与sshd_config中的几个选项有关，AllowTcpForwarding、GatewayPorts 4、X协议转发格式：ssh -X user@remotehost gedit X协议转发与sshd_config配置文件中的选项X11Forwarding有关。]]></content>
      <categories>
        <category>服务</category>
        <category>SSH</category>
        <category>SSH端口转发</category>
      </categories>
      <tags>
        <tag>nginx，proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH简单介绍]]></title>
    <url>%2F2017%2F11%2F28%2FSSH%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、SSH基本介绍1、含义： SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH&lt;摘自：百度&gt;。 2、实现SSH的方法 （1）OpenSSH 工具 （2）dropbear 工具 3、SSH协议版本 SSHv1：基于CRC-32做MAC（Massage Autherization Code）；不安全。 SSHv2：双方主机协议选择安全的MAC方式，基于DH算法做秘钥交换，基于RSA或DSA实现身份认证。 4、SSH认证方式 - 基于passwd认证方式 - 基于秘钥认证 二、实现SSH的管理方法1、基于OpenSSH（1）概念OpenSSH 是 SSH （Secure SHell） 协议的免费开源实现。SSH协议族可以用来进行远程控制， 或在计算机之间传送文件。而实现此功能的传统方式，如telnet(终端仿真协议)、 rcp ftp、 rlogin、rsh都是极为不安全的，并且会使用明文传送密码。OpenSSH提供了服务端后台程序和客户端工具，用来加密远程控件和文件传输过程中的数据，并由此来代替原来的类似服务。 （2）openssh工具（a）ssh工具相关的安装包 openssh-VERSION.rpm 通用包 openssh-server-VERSION.rpm 服务端安装包 openssh-client-VERSION.rpm 客户端安装包 （b）配置文件 /etc/sshd/ssh_config客户端配置文件 选项 含义 Host * 表示所有主机 StrictHostKeyChecking ask 首次登陆是否检查提示 ForwardX11Trusted yes 是否开启信任x11转发 /etc/sshd/sshd_config 服务器端配置文件 选项 Port 22 默认端口号为22 AddressFamily any 地址家族 ListenAddress :: 监听的地址 HostKey 密钥存放的位置 AuthorizedKeysFile 认证文件存放位置 PermitRootLogin 是否允许管理员登录，建议改为no UseDNS 是否支持dns反向解析 此选项和GSSAPIAuthentication 同时使用； ClientAliveInterval和ClientAliveCountMax 同时使用，两者相乘，就是连接的存活时间。 MaxAuthTries 最多认证次数 Banner /path/file 登录的提示信息 MaxSessions 最多会话 AllowUsers 允许用户 AllowGroups 允许组> DenyUsers 禁止用户 DenyGroups 禁止组 （3）ssh工具使用格式 ssh [user@]host [COMMAND] ssh [-l user] host [COMMAND] 选项： 选项 说明 -c 压缩方式 -b 绑定IP连接 -p PORT 指定对方的端口号 -X 支持x11转发 -y 支持信任x11转发，与配置文件ForwardX11Trusted有关 -t 强制伪tty分配 ssh -t remoteserver1 ssh remoteserver2：当远程主机remoteserver2无法直接到达时，可以使用-t参数，然后由remoteserver1跳转到remoteserver2。在此过程中要先输入remoteserver1的密码，然后再输入remoteserver2的密码，然后就可以操作remoteserver2了。 示例： 假设这里有三台机器，CnetOS6.9-1 IP为192.168.159.138；CnetOS6.7-1 IP为192.168.159.139；CnetOS7.3-2 IP为192.168.159.161。CentOS6.9-1 可以与CentOS7.3-1通信，不能与CentOS7.3-2通信；而CentOS7.3-1可以与CentOS7.3-2通信。如何实现CentOS6.9-1与CentOS7.3-2通信呢？ （1）在CentOS7.3-2禁止CentOS6.9-1的IP 连接[root@localhost~]#iptables -A INPUT -s 192.168.159.138 -j REJECT （2）在CentOS6.9-1测试是否能ping通[root@centos6~]#ping 192.168.159.161PING 192.168.159.161 (192.168.159.161) 56(84) bytes of data.From 192.168.159.161 icmp_seq=1 Destination Port Unreachable （3）然后通过CentOS7-1为跳板机连接到CentOS7.3-2主机上 （a）先测试CentOS6.9-1是否能连接到主机CentOS7.3-2 [root@centos6~]#ssh 192.168.159.161ssh: connect to host 192.168.159.161 port 22: Connection refused （b）利用CentOS7.3-1作为跳板机连接到CentOS7.3-2主机上[root@centos6~]#ssh -t 192.168.159.139 ssh 192.168.159.161root@192.168.159.139&#39;s password:root@192.168.159.161&#39;s password:Last login: Tue Sep 12 19:21:37 2017 from 192.168.159.161 顺利的解决了我们遇到的问题。 （4）工作机制 当客户端连接SSH服务器时，会复制ssh服务器 `/etc/ssh/ssh_host*.key.pub ` （CentOS7是/etc/ssh/ssh_host_ecdsa_key.pub）文件中的公钥到客户机的` ~./ssh/know_hosts`中。下次连接时，会自动匹配响应的私钥，如果匹配成功，则连接，反之亦然。 （a）客户端向服务器端发出请求 （b）服务器端接受到请求，发送公钥给客户端 （c）客户端输入账户和密码通过服务器端的公钥加密回传给服务端 （d）服务端通过自己的私钥解密，得到用户名和密码与本地作对比验证，验证成功则允许登录，反之亦然。 示例: 前提：CentOS 6 IP 为192.168.10.100；CentOS 7 IP 为192.168.10.101 （1）使用ssh命令使两台主机通信 [root@centos6~]#ssh root@192.168.10.100 The authenticity of host ‘192.168.10.100(192.168.10.100)’ can’t be established. RSA key fingerprint is a1:18:36:cc:e4:a1:de:c5:ad:6f:e4:ec:91:1d:d7:c4. Are you sure you want to continue connecting (yes/no)? yes #第一次连接会询问是否信任此台主机 Warning: Permanently added ‘192.168.10.100’ (RSA) to the list of known hosts. root@192.168.159.1’s password: #输入密码 Last login: Sat Sep 9 23:30:57 2017 from 192.168.159.1# #登录成功上面询问/etc/ssh/ssh_config文件下的选项StrictHostKeyChecking 有关，如果该为no，则不会显示检查 [root@localhost~]#l. #查看是否生成.ssh目录 上述过程中CentOS 6系统会自动创建~/.ssh/known_hosts且会复制CentOS 7中的公钥到自己主机上。 （2）上述的验证机制与公钥有关还是私钥有关呢？ 下面我们再启动 一台虚拟主机 CentOS 7.2 IP 为 192.168.10.102现在我们让CentOS 7.2 冒充CnetOS 6 情况一：修改CentOS 7.2的IP地址为192.168.10.100，尝试连接CentOS 7 （a）修改IP地址为192.168.10.100 （b）把CentOS6服务端IP禁用 [root@localhost~]#ifconfig eth0 down （c）使用客户机CentOS 7 连接 [root@localhost~]#ssh 192.168.10.100会发出WARNING警告远程主机认证已经改变。 情况二：如果我们把公钥复制到CentOS 7.2中连接呢？ （a）将/etc/ssh/ssh_host_rsa_key.pub拷贝到冒充主机上[root@localhost~]#scp /etc/ssh/ssh_host_rsa_key.pub 192.168.10.102:/etc/ssh（b）连接CentOS 7.2 [root@localhost~]#ssh 192.168.10.100会发出警告。 情况三：如果我们发私钥复制到CentOS7.2中，连接会发生什么情况？ [root@localhost~]#ssh 192.168.10.100 认证成功，所以我们在日常生产中保管好自己的私钥文件。 （5）ssh服务的最佳实践 建议 选项 不要使用默认端口 Port 禁止使用version 1 protocol Protocol 限制可登录用户 MaxAuthTries 设定空闲会话时长 ClientAliveInterval和ClientAliveCountMax 利用防火墙设置ssh访问策略 仅监听特定的IP地址 ListenAddress 基于口令认证时，使用强密码策略 基于密钥的认证 PubkeyAuthentication 禁止使用空密码 PasswordAuthentication 禁止root用户直接登录 PermitRootLogin 限制ssh的访问频度和并发在线数 MaxAuthTries和MaxSessions 做好日志分析 SyslogFacility]]></content>
      <categories>
        <category>服务</category>
        <category>SSH</category>
        <category>SSH简单介绍</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Samba]]></title>
    <url>%2F2017%2F11%2F28%2FSamba%2F</url>
    <content type="text"><![CDATA[Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，基于C/S架构。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。SMB协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。通过设置“NetBIOS over TCP/IP”使得Samba不但能与局域网络主机分享资源，还能与全世界的电脑分享资源。 一、SAMAB基本概念1、SMB的基本功能 共享文件和打印，实现在线编辑 实现登录SMB用户的身份认证 可以进行NetBIOS名称解析 外围设备共享 2、SAMAB服务基于协议（1）、NetBIOS协议NETBIOS（Network Basic Input/Output System）协议是由IBM公司开发，主要用于数十台计算机的小型局域网。该协议是一种在局域网上的程序可以使用的应用程序编程接口（API），为程序提供了请求低级服务的统一的命令集，作用是为了给局域网提供网络以及其他特殊功能。系统可以利用WINS服务、广播及Lmhost文件等多种模式将NetBIOS名-——特指基于NETBIOS协议获得计算机名称——解析为相应IP地址，实现信息通讯，所以在局域网内部使用NetBIOS协议可以方便地实现消息通信及资源的共享。 NetBIOS特点 占用系统资源少 传输效率高 （2）CIFS协议CIFS 是一个新提出的协议，它使程序可以访问远程Internet计算机上的文件并要求此计算机提供服务。CIFS 使用客户/服务器模式。客户程序请求远在服务器上的服务器程序为它提供服务。服务器获得请求并返回响应。CIFS是公共的或开放的SMB协议版本，并由Microsoft使用。SMB协议在局域网上用于服务器文件访问和打印的协议。像SMB协议一样，CIFS在高层运行，而不像TCP/IP协议那样运行在底层。CIFS可以看做是应用程序协议如文件传输协议和超文本传输协议的一个实现。 CIFS协议功能 访问服务器本地文件并读写这些文件 与其他用户一起共享一些文件 在短线时自动回复与网络的连接 使用统一码文件名 （3）smb协议SMB(全称是Server Message Block)是一个协议名，它能被用于Web连接和客户端与服务器之间的信息沟通。SMB最初是IBM的贝瑞·费根鲍姆（Barry Feigenbaum）研制的，其目的是将DOS操作系统中的本地文件接口“中断13”改造为网络文件系统。 3、SAMBA服务文件介绍（1）samba相关包介绍 包名 说明 samba 提供smb服务 samba-client 提供客户端工具 samba-common 通用软件 cifs-utils smb客户端工具 samba-winbind 和AD相关的包 （2）主配置文件/etc/samba/smb.confsbm.conf继承了.ini（initialization）文件格式，用[]分成不同的部分。 配置文件分为类 [global]：服务器通过或全局设置的部分 [homes]：用户的家目录共享 [printers]：定义打印机资源和服务 [SHARENAME]：自定义共享目录配置 配置文件宏定义 选项 说明 %m 客户端主机的NetBIOS名 %M 客户端的FQDN %H 当前用户家目录路径 %U 当前用户用户名 %g 当前用户所属组 %h samba服务器的主机名 %L samba服务器的NetBIOS %I 客户端主机的IP %T 当前日期和时间 %S 可登录的用户名 配置文件选项 选项 说明 workgroup 指定工作组名称 server string 主机注释信息 netbios name 指定NetBIOS名 interface 指定服务监听的接口和IP host allow 指定允许指定主机访问，如多个主机可以网段，离散可以使用“，”、空格或tab分离；或使用主机名；默允许所有主机访问。示例192.168.4. config file=/PAHT/TO/SOMEFIEL/%U 用户独立的配置文件 log file=/var/log/samba/log.%m 不同主机采用不同日志 max log size 日志文件大小，单位为KB log level 设置日志级别 comment 注释信息 path 所共享的目录路径 public = {yes或no} 能否被guest访问的共享，默认为no guest ok = {yes或no} 是否允许来宾账号访问 writable = {yes或no} 是否可读写 read only = {yes或no} 是否只读，如果与writeable设置冲突，放在后面的设置生效 write list 指定多个用户是否可写，格式：@GROUP_NAME、+GROUP_NAME或使用“，”分隔，如设置writable = no 列表中的用户或组可读写，不在列表中的用户只读 vaild users 特定用户才能访问此共享，如果设置为空，将允许所有用户；用户名之间使用空格分隔 browsable = {yes或no} 是否允许所有用户列浏览此共享，默认为yes create mask 修改上传权限 注意：如果是某个用户对目录有权限，此用户必须有目录权限和共享权限的交集。 服务脚本： /etc/rc.d/init.d/nmb /etc/rc.d/init.d/smb 4、管理命令（1）testparm：检查smb.conf文件是否正确格式： testparm [-s] {config filename} [hostname hostIP] （2）smbclient 连接SMB/CIFS资源的命令 选项 说明 -I 指定服务器的IP地址； -L 显示服务器端所分享出来的所有资源； -n 指定用户端所要使用的NetBIOS名称； -N 不用询问密码； -p 指定服务器端TCP连接端口编号； -T 备份服务器端分享的全部文件，并打包成tar格式的文件； -U&lt;用户名称&gt; 指定用户名称； -w&lt;工作群组&gt; 指定工作群组名称。 （3）mount.cifs依赖于 cifs-utils包；挂载工具（4）smbpasswd 设置smb用户密码 选项 说明 -a 向smbpasswd文件中添加用户； -c 指定samba的配置文件； -x 从smbpasswd文件中删除用户； -d 在smbpasswd文件中禁用指定的用户； -e 在smbpasswd文件中激活指定的用户； -n 将指定的用户的密码置空。 密码文件存在在/var/lib/samba/private/passdb.tdb （5）pdbedit 选项 说明 -a username 新建Samba账户。 -x username 删除Samba账户。 -L 列出Samba用户列表，读取`/var/lib/samba/private/passdb.tdb数据库文件。 -Lv 列出Samba用户列表的详细信息。 -c “[D]” –u username 暂停该Samba用户的账号。 -c “[]” –u username 恢复该Samba用户的账号。 （6）cifscreds 管理NTLM在内核密钥环中add：把指定用户的用户名和密码加入内核密钥环 二、实现共享（1）实现linux为客户端，windows为服务器端共享在windows系统上创建一个共享目录 选中目录–&gt;右击点属性–&gt;共享 点击图中的用户可以设置权限 在linux客户端查看 [root@localhost ~]# smbclient -L 192.168.4.1 -U joah%PASSWORD [root@localhost ~]# smbclient //192.168.4.1/linuxclient -U joah 挂载此目录 [root@localhost ~]# mount //192.168.4.1/linuxclient -o username=joah,password=PASSWORD /mnt/samba/ （2）实现linux作服务器端，windows作客户端共享文件创建smb账号 [root@localhost ~]# useradd -r smb1[root@localhost ~]# useradd -r smb2[root@localhost ~]# useradd -r smb2 设置smb账号密码 [root@localhost ~]# smbpasswd -a smb1[root@localhost ~]# smbpasswd -a smb2[root@localhost ~]# smbpasswd -a smb3 使用命令查看 [root@localhost ~]# pdbedit -L smb1:496: smb3:494: smb2:495: 创建共享目录 [root@localhost ~]# vim /etc/samba/smb.conf [sharewin] comment = linux share path = /app/smbshare 弹出对话框输入上述账户和密码即可登录 （3）linux中实现不同用户权限访问共享目录###创建共享目录 [root@localhost ~]# mkdir /app/share{1,2,3}[root@localhost ~]# chmod 777 /app/share{1,2,3} 并设置目录权限 编辑配置文件[root@localhost ~]# vim /etc/samba/smb.conf在全部设置下添加如下一行内容 config file = /etc/samba/conf.d/%U 创建每个用户的配置文件[root@localhost ~]# mkdir /etc/samba/conf.d #创建指定配置文件存放位置 [root@localhost conf.d]# vim smb1 [share] comment = share1 path = /app/share1 writeable = yes [root@localhost conf.d]# vim smb2 [share] comment = share2 path = /app/share2 [root@localhost conf.d]# vim smb3 [share] comment = share3 path = /app/share3 重启服务测试[root@localhost conf.d]# service nmb restart ;service smb restart 在另一外linux主机上测试 [root@localhost ~]# smbclient -L //192.168.4.55 -U smb1%123456 [root@localhost ~]# smbclient //192.168.4.55/share -U smb1%magedu 挂载共享目录在本地[root@localhost smb]# mount //192.168.4.55/share /mnt/smb/ -o username=smb1,password=123456 实现开机自动挂载[root@localhost smb]# vim /etc/fstab //192.168.4.55/share /mnt/smb cifs username=smb1,password=magedu 0 0 如果我们这样挂载的话，密码直接暴露出来，显然不安装，我们可以将用户和密码写到一个配置文件中 [root@localhost smb]# vim /etc/samba/userpasswd username=smb1 password=123456 [root@localhost ~]# chmod 600 /etc/samba/userpasswd #修改文件权限 [root@localhost ~]# vim /etc/fstab //192.168.4.55/share /mnt/smb cifs credentials=/etc/samba/userpasswd 0 0 [root@localhost ~]# mount -a #使挂载生效 [root@localhost ~]# df Filesystem 1K-blocks Used Available Use% Mounted on /dev/sda2 50264772 1632864 46071908 4% / tmpfs 502056 0 502056 0% /dev/shm /dev/sda3 50264772 89224 47615548 1% /app /dev/sda1 487652 35604 426448 8% /boot /dev/sr0 3878870 3878870 0 100% /media/cdrom //192.168.4.55/share 50264772 53092 47651680 1% /mnt/smb #挂载成功 （4）实现多用户挂载（CentOS 7中可以启用这种方法）修改配置文件[root@localhost ~]# vim /etc/samba/smb.conf [share] comment = sharedirectory path = /app/sharedir write list = smb1 #设置只有smb1用户具有写权限 创建共享目录并赋予权限[root@localhost ~]# mkdir /app/sharedir[root@localhost ~]# chmod 777 /app/sharedir 在客户端创建与服务器端相同的账号注意：客户端与服务器端必须有相同的用户。 [root@localhost ~]# useradd smb1 [root@localhost ~]# useradd smb2 [root@localhost ~]# useradd smb3 使用smb3用户挂载目录[root@localhost ~]# vim /etc/samba/userpasswd username=smb3 password=123456 修改/etc/fstab文件[root@localhost ~]# vim /etc/fstab //192.168.4.55/share /mnt/smb cifs multiuser,credentials=/etc/samba/userpasswd 0 0 //192.168.4.55/share /mnt/smb cifs credentials=/etc/samba/userpasswd,multiuser 0 0 credentials：用于指定包含挂载用户信息文件 multiuser：用于指定使用多用户挂载 [root@localhost ~]# mount -a #使挂载生效 测试是否可以切换到smb1有写权限[root@localhost/mnt/smb]#su - smb1[smb1@localhost~]$cifscreds add 192.168.4.55 Password: [smb1@localhost~]$ls /mnt/smb/ anaconda-ks.cfg xx]]></content>
      <categories>
        <category>文件管理</category>
        <category>Samba</category>
      </categories>
      <tags>
        <tag>samba</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP_wrappers]]></title>
    <url>%2F2017%2F11%2F28%2FTCP_wrappers%2F</url>
    <content type="text"><![CDATA[tcp_wrappers1、概念Transmission Control Protocol (TCP) Wrappers 为由 inetd 生成的服务提供了增强的安全性。TCP Wrappers 是一种对使用 /etc/inetd.sec 的替换方法。TCP Wrappers 提供防止主机名和主机地址欺骗的保护。欺骗是一种伪装成有效用户或主机以获得对系统进行未经授权的访问的方法。 2、工作机制（1）工作在第四层的TCP协议（2）对有状态的特定服务进行安全检测并实现访问控制（3）以库文件形式实现（4）其进程是否接受libwrap的控制取决于发起此进程的程序在编译时是否针对libwrap进行编译的。 3、如何查看服务程序是否支持libwrap访问控制（1）先使用命令查看执行程序文件是哪个 which COMMAND （2）使用命令ldd 对上述文件查找 lddwhich COMMAND|grep libwrap 4、配置文件1、配置文件 /etc/hosts.allow和/etc/hosts.deny 2、检查顺序 在tcp_wrappers中检查顺序并不像前面的服务一样，前面的成功后面的就不再执行。而tcp_wrappers的检查顺序为/etc/hosts.allow–&gt;/etc/hosts.deny 前面的规则一旦匹配成功，直接生效，将不再继续后面的执行；如果前面的没有成功，则继续向后执行。 3、基本语法damon_list@host：client_list [:option:option…] damon_list格式： （1）单个应用程序的二进制文件名，而非服务名 （2）以逗号或空格分隔的应用程序文件名列表 （3）ALL 表示所有接受tcp_wrappers控制的服务程序 （4）主机有多个IP ，可用@hostIP来实现 如：in.telnetd@192.168.159.131 client_host格式： （1）以逗号或空格分隔的客户端列表 （2）基于IP地址 （3）基于主机名 （4）基于网络/掩码 192.168.159.0/255.255.255.0 （5）基于CIDR格式 192.168.159.0/24 （6）基于网络组 @munetwork （7）内置ACL：ALL,LOCAL,KNOWN,UNKNOWN,PARANOID EXPECT用法 示例： sshd:192.168.159.0/24 EXPECT 192.168.159.151 [:OPTIONS]选项 (1)deny 主要用在/etc/host.allow文件中，定义“拒绝”规则。如：vsftpd:192.168.159.159:deny 先定义了这个IP可以访问但是又否定。 (2)allow 主要用在/etc/hosts.deny 定义“允许”规则如：vsftpd:192.168.159.159:allow 先定义192.168.159.159不允许然后否定允许使用 (3)spawn 启动一个外部进程完成执行的操作 选项： %c：客户端信息 %s：服务器端信息 %d：服务名 %p：守护进程的PID注意：如果在配置文件中想使用“%”需要使用两个“%”；如果使用“：”则需要使用“\”进行转义。 示例：在CentOS6主机上编辑/etc/hosts.allow文件[root@localhost~]#vim /etc/hosts.allowsshd:192.168.4.135:spaw echo &quot;date%c to %s %d %p &quot; &gt;&gt; /var/log/sshd.log 在CentOS7主机上连接[root@centos7/var/log]#ssh 192.168.4.131 在CentOS6上查看是否生成sshd.log文件并且有内容[root@localhost~]#cat /var/log/sshd.logThu Sep 14 09:33:18 CST 2017 192.168.4.135 to sshd@192.168.4.131 sshd 29705 (4)twist 实际动作是拒绝访问，使用指定的操作替换当前服务，标准I/O和ERROR发送到客户端，默认输出至/dev/null 示例：在CentOS6上配置/etc/hosts.allow文件[root@localhost~]#vim /etc/hosts.allow vsftpd:192.168.4.135:twist /bin/echo &quot;Do not login&quot; 在CentOS7上连接[root@centos7~]#ftp 192.168.4.131 Connected to 192.168.4.131 (192.168.4.131). Do not login ftp&gt; 测试工具： tcpdmatch [-d] daemon[@host] client -d 测试当前目录下的host.allow和hosts.deny文件 [root@localhost~]#tcpdmatch -d /etc/hosts.deny 192.168.4.135 client: address 192.168.4.135 server: process hosts.deny access: granted [root@localhost~]#tcpdmatch -d /etc/hosts.allow 192.168.4.135 client: address 192.168.4.135 server: process hosts.allow access: granted]]></content>
      <categories>
        <category>安全</category>
        <category>TCP_wrappers</category>
      </categories>
      <tags>
        <tag>tcp_wrappers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP三次握手]]></title>
    <url>%2F2017%2F11%2F28%2FTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%2F</url>
    <content type="text"><![CDATA[一、Socket1、概念 socket是“孔”和“插座”之意。在linux中显然是插座的意思，相当于我们家中插头和插座之意，它们连接才能通电。在Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。实现进程间通信，允许位于不同主机（或同一主机）上不同进程之间进行通信和数据交换。Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。 2、Socket的类型（1）Socket DomainAF_INET：Address Family IPv4 AF_INET6：Address Family IPv6 AF_UNIX：同一台主机不同进程之间通信使用。 （2）Socket TypeSOCK_STREAM：流套接字，TCP套接字；可靠传输，面向对象传输。 SOCK_DGRAM：数据报，UDP套接字；不可靠传输，无直接连接。 SOCK_RAW：裸套接字，无须TCP或UDP，应用程序直接通过IP 包通信。 （3）Socket Protocol指定实际使用的传输协议。常见IPPROTO_TCP、IPPROTO_UDP等。 3、Socket函数 socket（） 为通讯创建一个端点，为套接字返回一个文件描述符。 注意：当调用socket（）创建一个socket时，只赋予其所使用的协议，没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind（），否则就当调用connect（）、listen（）时系统会自动随机分配一个端口。 bind() 为一个套接字分配地址。对应的Socket protocol把一个IPv4 或IPv6地址和端口组合赋给socket。 通常服务器在启动时会绑定IP地址和端口，用于提供服务；而客户端就不用指定，系统自动分配一个端口和自身的IP 地址。这就是为什么通常服务器端在listen之前要bind（），而客户端不会调用，而是在connect（）时由系统自动生成一个。 listen（） 当socket和一个地址（IP和端口）绑定之后，listen（）函数就开始监听可能的链接请求。socket（）函数创建的socket默认是一个主动类型，listen函数将socket变为被动类型，等待客户的连接请求。一旦连接被接受，返回0表示成功，-1表示错误。 accept（） 当应用程序监听来自其他主机的面对数据流的连接时，通过时间通知它。必须用accept（）函数初始化连接，TCP服务器监听到这个请求之后，就会调用accept（）函数接受请求。这样就连接就建立好了。之后就可以进行I/O操作了。 accept默认会阻塞进程，直到有一个客户连接建立后返回，返回一个新可用的套接字，这个套接字是连接套接字。 监听套接字：在调用函数listen函数之后，是服务器开始调用socket（）生成的；存在于服务器整个生命周期。 连接套接字：一个套接字会从主动连接变为一个监听套接字；accept函数返回值是已经连接socket描述符，它代表着一个网络已经存在的点点连接；利用I/O可以实现不同进程间的通信。 connect() 系统调用为一个套接字设置连接，参数有文件描述符和主机地址。 某些类型的套接字是无连接的，如DUP协议，连接时默认发送和接受数据的主机由给定的地址确定，可以使用send（）和recv（）。 read()、write() 服务器与客户已经建立连接。就可以使用不同进程之间的通信了。 close（） 在服务器与客户建立连接之后，会进行一些读写操作，完成之后就要关闭响应的socket描述子。 注意：close只是在相应的socket描述字的引用计数-1，只有当计数为0时，才会触发TCP客户端向服务器发送终止请求。 4、Socket工作 二、TCP三次握手和TCP四次挥手我们先来举一个示例想必大家就懂了它的工作流程了。 小明：您好，请问您是小红么？ 小红：是的，您是谁？ 小明：我是小明。 小红：有什么事情呢？ 然后他们就开始友好的聊天了 。这个过程和我们TCP三次握手一样，TCP三次握手也是分为三步，然后建立连接实现通信。 第一步 Client主动向和Server发送请求；发送SYN=1，seq=x(Synchronize Sequence Numbers)，此时Client由状态CLOSED进入SYS_SENT状态。 第二步 Server接受到Client请求时，此时状态由LISTEN进入SYN_RECV状态。并向Client发送自己的SYN=1，ACK=1，seq=y，并确定Client同步序列号seq+1并返回，即ack=x+1。 第三步 Client接受到Server请求时,并向Server发送ACK=1，seq=x+1代表要进行通信的序列号，发送希望Server下次通信的数据包的ack=y+1。这里需要注意只有Server接受到ack=y+1时才代表通讯成功。此时就可以愉快的通信了；此时状态进入ESTABLISHED。 TCP和Socket怎么结合工作呢？如下表。 Server Server服务器端调用socket()，生成socket 调用bind()绑定，为socket分配一个地址（IP和端口） 调用listen()进行监听；默认socket为主动连接状态，变为被动监听状态 调用accept()阻塞，等待客户端连接。 Clinet Client调用socket()生成socket 调用connect()阻塞，等待服务端的回应 接下来就是TCP三次握手的过程： 第一步 Client主动向和Server发送请求；发送SYN=1，seq=x(Synchronize Sequence Numbers)，此时Client由状态CLOSED进入SYS_SENT状态。 第二步 Server接受到Client请求时，此时状态由LISTEN进入SYN_RECV状态。并向Client发送自己的SYN=1，ACK=1，seq=y，并确定Client同步序列号seq+1并返回，即ack=x+1。 第三步 Client接受到Server请求时,并向Server发送ACK=1，seq=x+1代表要进行通信的序列号，发送希望Server下次通信的数据包的ack=y+1。这里需要注意只有Server接受到ack=y+1时才代表通讯成功。此时就可以愉快的通信了；此时状态进入ESTABLISHED。 那么Client想和Server分手怎么办呢？ 假如小明和小红在一起久了，觉得双方在一起不合适，这是就会发生如下事情 小明：我发现我们在这么久了，不太适合，我们分手吧！ 假如这时候小明和小红有一些经济的往来，借了一些钱 小红：为什么呢？我还没有还你那些钱呢，等我换一阵子我们了清了就分手！！！ 过了一段时间小红把小明的钱还了之后，并和小明说 小红：我们分手吧 小明：这时小明收到小红的分手信，好的，那就分手吧，从此一段姻缘就这样结束了。]]></content>
      <categories>
        <category>服务</category>
        <category>TCP</category>
        <category>三次握手</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP四次挥手]]></title>
    <url>%2F2017%2F11%2F28%2FTCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[TCP四次挥手的过程 第一步 Client和Server相互传送完包以后，Client主动向Server发送关闭连接的信息：FIN=1，seq=u；此时进入FIN_WAIT状态 第二步 Server接收到Client请求之后，假如他们过程中还有一些包传输没有完成，这就Server向Client发送：ACK=1，seq=y（自己的序列号），ack=u+1（确认Client发送过程的请求号），此时进入CLOSE_WAIT。 第三步 当数据包全部传送完成之后，Server主动向Client发送回应：FIN=1，ACK=1，seq=w（此时完成传送的序列号），ack=u+1（这是这个确认好还是确认那序列号），此时进入LASET_ACK状态 第四步 Client接受到Server指令，并向Server发送：ACK=1，seq=u+1，ack=w+1，此时进入`TIME_WAIT状态，而不是直接关闭，原因是如果网络不通畅，重新发送包，相当于防止zombie状态。 Client调用close()主动关闭连接，TCP发送一个FIN 1,seq=u Server接收到FIN 1,seq=u之后，执行被动关闭，对这个seq=u进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；这是并不能立即关闭连接，如果有数据传送ACK=1，seq=y,ack=u+1，但没有发送FIN信号。 一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。ServerTCP也发送一个FIN 1，ACK=1，seq=w,ack=u+1 Client接收到这个FIN它进行确认,并向Server发送ACK=1，seq=u+1，ack=w+1。此时进入TIME_WAIT 1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？ 因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 2．为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？ 因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态但是网络并不能保证通畅，无法确保发送的ACK报文会Server能接受到；因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。]]></content>
      <categories>
        <category>服务</category>
        <category>TCP</category>
        <category>四次挥手</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat会话保持]]></title>
    <url>%2F2017%2F11%2F28%2FTomcat%E4%BC%9A%E8%AF%9D%E4%BF%9D%E6%8C%81%2F</url>
    <content type="text"><![CDATA[会话保持保证同一个用户相关的访问请求被分配到同一台服务器上。 1、会话保持的类型（1）session sticky 与调度器有关 不同调度器实现方式nginx：ip_hash haproxy：source lvs：sh （2）session cluster：delta session manager 如上图所示，就是session cluster工作原理：基于IP组播来完成session复制 Tomcat会话复制分类：全局会话复制：利用Delta Manager复制会话中的变更信息到集群中的所有其他节点 非全局复制：使用backup Manager进行复制，它会把session复制给一个指定的备份节点 此中session保持一般不超过6个节点，如果小型可以使用。 （3）session server：redis（store），memcached（cache） 如图所示为此中会话保持的工作原理，基于共享会话实现 上述两种与server端有关 2、Tomcat Cluster（Session）（1）httpd+tomcat cluster前提： httpd：mod_proxy,mod_proxy_http,mod_proxy_balancer tomcat cluster :http connector 实战 同步时间 [root@tomcatA~]#ntpdate 172.18.0.1 [root@tomcatA~]#vim /etc/chrony.conf 修改hosts文件 [root@tomcatA~]#vim /etc/hosts 3 192.168.4.62 tomcatA 4 192.168.4.63 tomcatB 基于密钥连接 [root@tomcatA~]#ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: SHA256:z+CBC0/eQP/sW9O+TqUXn6DCxR1j6Wt/XAyvuHMMW9E root@tomcatA The key&apos;s randomart image is: +---[RSA 2048]----+ | | | . | | . = . | | . o . + = E| | . + S o + *.| | = =.B. o.+oB| | + oo=.oO+++| | ...=+=.o| | o..=+o.| +----[SHA256]-----+ [root@tomcatA~]#ssh-copy-id -i /root/.ssh/id_rsa.pub tomcatB tomcatB： [root@tomcatB~]#ssh-keygen [root@tomcatB~]#ssh-copy-id -i /root/.ssh/id_rsa.pub tomcatA tomcatB中的其他配置都和tomcatA配置相同这里就不累述 安装jdk环境 [root@tomcatB~]#yum install -y java-1.8.0-openjdk tomcat安装及配置 [root@tomcatA~]#yum install -y tomcat-docs-webapp tomcat-lib tomcat-webapps tomcat [root@tomcatA~]#systemctl enable tomcat [root@tomcatA~]#systemctl start tomcat 配置一个示例程序 [root@tomcatA/usr/share/tomcat/webapps]#mkdir test/{WEB-INF,classes,lib} -pv [root@tomcatA/usr/share/tomcat/webapps/test]#vi index.jsp &lt;%@ page language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;TomcatA&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;font color=&quot;red&quot;&gt;TomcatA.magedu.com&lt;/font&gt;&lt;/h1&gt; &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;Session ID&lt;/td&gt; &lt;% session.setAttribute(&quot;magedu.com&quot;,&quot;magedu.com&quot;); %&gt; &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Created on&lt;/td&gt; &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; [root@tomcatB/usr/share/tomcat/webapps]#mkdir test/{WEB-INF,classes,lib} -pv [root@tomcatB/usr/share/tomcat/webapps/test]#vi index.jsp &lt;%@ page language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;TomcatB&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;font color=&quot;blue&quot;&gt;TomcatB.magedu.com&lt;/font&gt;&lt;/h1&gt; &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;Session ID&lt;/td&gt; &lt;% session.setAttribute(&quot;magedu.com&quot;,&quot;magedu.com&quot;); %&gt; &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Created on&lt;/td&gt; &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; [root@tomcatA/usr/share/tomcat/webapps]#vim /etc/tomcat/server.xml #在host中添加如下内容 [root@tomcatA/usr/share/tomcat/webapps]#systemctl restart tomcat.service #重启测试 至此tomcatA和tomcatB配置完成 http安装及配置 查看是否已经加载所需要的模块 [root@httpd/etc/httpd/conf.d]#httpd -M |grep proxy 安装及配置成开启启动并启动服务 [root@httpd~]#yum install -y httpd [root@httpd~]#systemctl enable httpd.service [root@httpd~]#systemctl start httpd.service 修改配置文件并实现http调度功能 [root@httpd/etc/httpd/conf]#vim httpd.conf 354 Include conf.d/tomcat-host.conf [root@httpd/etc/httpd/conf.d]#vim tomcat-host.conf &lt;proxy balancer://tcsrvs&gt; BalancerMember http://192.168.4.62:8080 BalancerMember http://192.168.4.63:8080 ProxySet lbmethod=byrequests &lt;/Proxy&gt; &lt;VirtualHost *:80&gt; ServerName www.test.com ProxyVia on ProxyRequests off ProxyPreserveHost on &lt;Proxy *&gt; Require all granted &lt;/Proxy&gt; ProxyPass / balancer://tcsrvs/ ProxyPassReverse / balancer://tcsrvs/ &lt;Location /&gt; Require all granted &lt;/Location&gt; &lt;/VirtualHost&gt; 选项说明： ProxyPreserveHost {on|off}：如果启用此功能，代理会将用户请求报文中的Host行发送给后端服务器，而不再使用PorxyPress指定的服务器地址。如果在反向代理中支持虚拟主机，则需开启此项。 ProxyVia：{on|off|full|block}：用于控制在http首部是否使用Via，主要用于在多级代理中控制代理请求的流向。 off：不开启此功能 on：表示每个请求和响应报文均添加Via full：表示每个Via都会添加当前apache服务器的版本信息 block：表示每个代理请求报文中的Via都会被移除 ProxyRequests {on|off}：是否开启apache正向代理的功能；启用此项时为了代理http协议需启用mod_proxy_http模块 ProxyPass [path] !|URL [key=value ...]：将后端服务器某URL与当前服务器的某虚拟路径关联起来作为提供服务的路径。 path：当前服务器上的某虚拟路径 URL：后端服务器上某URL路径 注意：如果path以“/”结尾，则对应的URL也必须&quot;/&quot;结尾。 key类型 min：连接池的最小容量 max：连接池最大容量 loadfactor：用于负载均衡集群配置中，定义对应后端服务器的权重 retry：当apache将请求发送至后端服务器得到错误响应时等待多长时间以后重试 **lbmethod类型** byrequests：基于权重将统计请求个数进行调度 bytraffic：基于权重的流量计数调度 bybusyness：通过考量每个后端服务器的当前负载进行调度 maxattempts：放弃请求之前实现故障转义的次数，默认为1，其最大值不应该大于总的节点数 nofailover {on|off} on：表示后端服务器故障时，用户的session将损坏 stickysession：调度器的sticky ProxyPassReverse：用于让apache调整HTTP重定向响应报文中的Location、Content-Location及URI标签所对应的URL，在反向代理环境中必须使用此指令避免重定向报文绕过proxy服务器。 BalancerMember [balancerurl] url [key=value [key=value...]] status: D:设置不可用disabled S：设置为stopped I：忽略错误，请求还会往此主机上调 H：如果别的主机不可用时启用相当于backup E：设置为error状态 N：仅仅接受seesion sticky请求 实现会话粘性 [root@httpd/etc/httpd/conf.d]#vim tomcat-host.conf 1 Header add Set-Cookie &quot;ROUTEID=.%{BALANCER_WORKER_ROUTE}e;path=/&quot; env=BALANCER_ROUTE_CHANGED 2 &lt;proxy balancer://tcsrvs&gt; 3 BalancerMember http://192.168.4.62:8080 route=tomcatA loadfactor=1 4 BalancerMember http://192.168.4.63:8080 route=tomcatB loadfactor=2 5 ProxySet lbmethod=byrequests 6 ProxySet stickysession=ROUTEID 7 &lt;/Proxy&gt; 8 9 &lt;VirtualHost *:80&gt; 10 ServerName www.test.com 11 ProxyVia on 12 ProxyRequests off 13 ProxyPreserveHost on 14 &lt;Proxy *&gt; 15 Require all granted 16 &lt;/Proxy&gt; 17 ProxyPass / balancer://tcsrvs/ 18 ProxyPassReverse / balancer://tcsrvs/ 19 &lt;Location /&gt; 20 Require all granted 21 &lt;/Location&gt; 22 &lt;/VirtualHost&gt; 至此我们就实现的session sticky 实现管理功能 24 25 SetHandler balancer-manager 26 ProxyPass ! 27 Require all granted 28 这里为了测试方便我们设置成了所有用户都可以访问，在实际生产中需要指定特定IP访问。 显示状态信息 [root@httpd/etc/httpd/conf.d]#vim tomcat-host.conf 29 &lt;Location /status&gt; 30 ProxyPass ! 31 SetHandler server-status 32 Require all granted 33 &lt;/Location&gt; 重启服务器测试 （2）httpd+tomcat cluster前提： httpd:mod_proxy,mod_proxy_ajp,mod_proxy_balancer tomcat cluster:ajp connecotr 实战 前面的步骤都和上述配置相同 编辑tomcat-host.conf配置文件 [root@httpd/etc/httpd/conf.d]#vim tomcat-host.conf 1 Header add Set-Cookie &quot;ROUTEID=.%{BALANCER_WORKER_ROUTE}e;path=/&quot; env=BALANCER_ROUTE_CHANGED 2 &lt;proxy balancer://tcsrvs&gt; 3 BalancerMember ajp://192.168.4.62:8009 route=tomcatA loadfactor=1 4 BalancerMember ajp://192.168.4.63:8009 route=tomcatB loadfactor=2 5 ProxySet lbmethod=byrequests 6 ProxySet stickysession=ROUTEID 7 &lt;/Proxy&gt; 8 9 &lt;VirtualHost *:80&gt; 10 ServerName www.test.com 11 ProxyVia on 12 ProxyRequests off 13 ProxyPreserveHost on 14 &lt;Proxy *&gt; 15 Require all granted 16 &lt;/Proxy&gt; 17 ProxyPass / balancer://tcsrvs/ 18 ProxyPassReverse / balancer://tcsrvs/ 19 &lt;Location /&gt; 20 Require all granted 21 &lt;/Location&gt; 22 &lt;/VirtualHost&gt; 23 24 &lt;Location /bm&gt; 25 SetHandler balancer-manager 26 ProxyPass ! 27 Require all granted 28 &lt;/Location&gt; 29 &lt;Location /status&gt; 30 ProxyPass ! 31 SetHandler server-status 32 Require all granted 33 &lt;/Location&gt; （3）httpd+tomcat cluster前提： httpd:mod_jk tomcat cluster:ajp connector 此种方法现在不常用就不介绍了… （ 4）nginx+tomcat cluster#####实战 nginx安装并设置为开机启动 [root@httpd~]#yum install -y nginx [root@httpd~]#systemctl enable nginx [root@httpd~]#systemctl start nginx 修改配置文件实现调度功能 [root@httpd/etc/nginx/conf.d]#vim tomcat-nginx.conf 1 upstream tomsrvs { 2 server 192.168.4.62:8080 ; 3 server 192.168.4.63:8080 ; 4 } 5 6 server { 7 listen 80; 8 server_name www.test.com; 9 location /{ 10 proxy_pass http://tomsrvs; 11 } 12 } 基于ip_hash实现会话粘性 [root@httpd/etc/nginx/conf.d]#vim tomcat-nginx.conf 1 upstream tomsrvs { 2 server 192.168.4.62:8080 ; 3 server 192.168.4.63:8080 ; 4 ip_hash; 5 } 6 7 server { 8 listen 80; 9 server_name www.test.com; 10 location /{ 11 proxy_pass http://tomsrvs; 12 } 13 } 基于hash key 实现 基于指定的key的hash表来实现对请求的调度 1 upstream tomsrvs { 2 server 192.168.4.62:8080 ; 3 server 192.168.4.63:8080 ; 4 hash $remote_addr consistent; 5 } 6 7 8 9 server { 10 listen 80; 11 server_name www.test.com cookie; 12 location /{ 13 proxy_pass http://tomsrvs; 14 } 15 } ###3、tomcat session replication cluster 在tomcat服务器上进行配置 [root@tomcatB/etc/tomcat]#vi server.xml &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;tomcatA&quot;&gt; #添加jvmRoute 下面的配置可以放在Host、Engine、Context中其作用效果不同 &lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot; channelSendOptions=&quot;8&quot;&gt; &lt;Manager className=&quot;org.apache.catalina.ha.session.DeltaManager&quot; expireSessionsOnShutdown=&quot;false&quot; notifyListenersOnReplication=&quot;true&quot;/&gt; &lt;Channel className=&quot;org.apache.catalina.tribes.group.GroupChannel&quot;&gt; &lt;Membership className=&quot;org.apache.catalina.tribes.membership.McastService&quot; address=&quot;228.100.100.4&quot; port=&quot;45564&quot; frequency=&quot;500&quot; dropTime=&quot;3000&quot;/&gt; &lt;Receiver className=&quot;org.apache.catalina.tribes.transport.nio.NioReceiver&quot; address=&quot;auto&quot; #这里设定为tomcat真实IP port=&quot;4000&quot; autoBind=&quot;100&quot; selectorTimeout=&quot;5000&quot; maxThreads=&quot;6&quot;/&gt; &lt;Sender className=&quot;org.apache.catalina.tribes.transport.ReplicationTransmitter&quot;&gt; &lt;Transport className=&quot;org.apache.catalina.tribes.transport.nio.PooledParallelSender&quot;/&gt; &lt;/Sender&gt; &lt;Interceptor className=&quot;org.apache.catalina.tribes.group.interceptors.TcpFailureDetector&quot;/&gt; &lt;Interceptor className=&quot;org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor&quot;/&gt; &lt;/Channel&gt; &lt;Valve className=&quot;org.apache.catalina.ha.tcp.ReplicationValve&quot; filter=&quot;&quot;/&gt; &lt;Valve className=&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot;/&gt; &lt;Deployer className=&quot;org.apache.catalina.ha.deploy.FarmWarDeployer&quot; tempDir=&quot;/tmp/war-temp/&quot; deployDir=&quot;/tmp/war-deploy/&quot; watchDir=&quot;/tmp/war-listen/&quot; watchEnabled=&quot;false&quot;/&gt; &lt;ClusterListener className=&quot;org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener&quot;&gt; &lt;ClusterListener className=&quot;org.apache.catalina.ha.session.ClusterSessionListener&quot;&gt; &lt;/Cluster&gt; [root@tomcatA/etc/tomcat]#cp /etc/tomcat/web.xml /usr/share/tomcat/webapps/test/WEB-INF/ [root@tomcatA/etc/tomcat]#vim /usr/share/tomcat/webapps/test/WEB-INF/web.xml 23 &lt;distributable/&gt; #添加此内容 重启服务测试 tomcatA和tomcatB的配置相似就不累述。 如果修改/etc/tomcat/web.xml文件时全局配置。 注意的问题：- （1）官方文档上面的配置文件中： &lt;ClusterListener className=&quot;org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener&quot;/&gt; &lt;ClusterListener className=&quot;org.apache.catalina.ha.session.ClusterSessionListener&quot;/&gt; 上述少了“/”结尾，记得加上 （2）绑定地址为auto时，会自动解析本地主机名，并解析得出的IP地址作为使用的地址；建议指定IP地址。 4、session servertomcatA和tomcatB配置相似，这里以tomcatA为例 （1）安装tomcat和memcache并进行配置 [root@tomcatA/etc/tomcat]#yum install -y memcached [root@tomcatA/etc/tomcat]#systemctl enable memcached [root@tomcatA/etc/tomcat]#systemctl start memcached （2）配置tomcat 下载所需要的jar文件 https://github.com/magro/memcached-session-manager/wiki/SetupAndConfiguration http://owatlfstl.bkt.clouddn.com/2017-11-07_171315.jpg [root@tomcatA~]#cp *.jar /usr/share/tomcat/lib/ [root@tomcatA/etc/tomcat]#vim server.xml #编辑配置文件 131 &lt;Context&gt; 132 &lt;Manager className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot; 133 memcachedNodes=&quot;n1:192.168.4.62:11211,n2:192.168.4.63:11211&quot; 134 failoverNodes=&quot;n1&quot; 135 requestUriIgnorePattern=&quot;.*\.(ico|png|gif|jpg|css|js)$&quot; 136 transcoderFactoryClass=&quot;de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory&quot; 137 /&gt; 138 &lt;/Context&gt; [root@tomcatA/etc/tomcat]#scp server.xml tomcatB:/etc/tomcat/server.xml [root@tomcatB/usr/share/tomcat/webapps/test]#vim index.jsp 编辑index.jsp文件 1 &lt;%@ page language=&quot;java&quot; %&gt; 2 &lt;html&gt; 3 &lt;head&gt;&lt;title&gt;TomcatB&lt;/title&gt;&lt;/head&gt; 4 &lt;body&gt; 5 &lt;h1&gt;&lt;font color=&quot;blue&quot;&gt;TomcatB.magedu.com&lt;/font&gt;&lt;/h1&gt; 6 &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt; 7 &lt;tr&gt; 8 &lt;td&gt;Session ID&lt;/td&gt; 9 &lt;% session.setAttribute(&quot;magedu.com&quot;,&quot;magedu.com&quot;); %&gt; 10 &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt; 11 &lt;/tr&gt; 12 &lt;tr&gt; 13 &lt;td&gt;Created on&lt;/td&gt; 14 &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt; 15 &lt;/tr&gt; 16 &lt;/table&gt; 17 &lt;/body&gt; 18 &lt;/html&gt; tomcatB同理 [root@tomcatA~]#systemctl restart tomcat 配置http服务器 [root@httpd/etc/httpd/conf.d]#vim tomcat-host.conf 1 &lt;proxy balancer://tcsrvs&gt; 2 BalancerMember ajp://192.168.4.62:8009 loadfactor=1 3 BalancerMember ajp://192.168.4.63:8009 loadfactor=2 4 ProxySet lbmethod=byrequests 5 &lt;/Proxy&gt; 6 7 &lt;VirtualHost *:80&gt; 8 ServerName www.test.com 9 ProxyVia on 10 ProxyRequests off 11 ProxyPreserveHost on 12 &lt;Proxy *&gt; 13 Require all granted 14 &lt;/Proxy&gt; 15 ProxyPass / balancer://tcsrvs/ 16 ProxyPassReverse / balancer://tcsrvs/ 17 &lt;Location /&gt; 18 Require all granted 19 &lt;/Location&gt; 20 &lt;/VirtualHost&gt; 21 22 &lt;Location /bm&gt; 23 SetHandler balancer-manager 24 ProxyPass ! 25 Require all granted 26 &lt;/Location&gt; 27 &lt;Location /status&gt; 28 ProxyPass ! 29 SetHandler server-status 30 Require all granted 31 &lt;/Location&gt; 重启http服务 [root@httpd/etc/httpd/conf.d]#systemctl restart httpd 测试 查看是否已有缓存到本地 [root@tomcatA~]#memcached-tool 127.0.0.1:11211 dump 接下来停止tomcatA服务测试 重启启动tomcatA 测试 至此已经实现了session server 序列化工具lavolution实现-memcached-session-manager-tc7-2.1.1.jar memcached-session-manager-2.1.1.jar spymemcached-2.12.3.jar msm-javolution-serializer-2.1.1.jar javolution-5.4.3.1.jar [root@memcache~]#scp /etc/tomcat/server.xml tomcatB:/etc/tomcat/server.xml [root@memcache~]#systemctl restarst tomcat 上述创建站点及测试也相同就不累述 测试- [root@memcache/usr/share/tomcat/lib]#memcached-tool 127.0.0.1:11211 dump 在测试过程中，存在版本不兼容的情况，更换版本即可。]]></content>
      <categories>
        <category>服务</category>
        <category>Tomcat</category>
        <category>Tomcat会话保持</category>
      </categories>
      <tags>
        <tag>tomcat，cluster，memcached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat基于Redis缓存session共享]]></title>
    <url>%2F2017%2F11%2F28%2FTomcat%E5%9F%BA%E4%BA%8EMemcached%E7%BC%93%E5%AD%98session%E5%85%B1%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[基于Memcached缓存session共享使用memcached服务存取session信息，应用服务器接受心情求将session信息保存于memcached中。 缺点 Memcached支持的数据结构比较单一 Memcached内存必须足够大，否则会出现session从Cache中清除 需要定期刷新缓存 如果服务器发生故障时，存储于内存的数据消失 基于Redis缓存session共享基于Redis缓存session共享不会重启后数据消失。 实验架构图 实验前提每天服务器同步时间确保firewalld和selinux关闭（如果启用，自行设置即可）可以基于主机名解析基于密钥认证（非必须）node4中tomcat设置[root@node4~]#yum install -y java-1.8.0-openjdk [root@node4~]#yum install -y tomcat-admin-webapps tomcat-webapps tomcat [root@node4/var/lib/tomcat/webapps]#mkdir test/{WEB-INF,lib,classes} -pv [root@node4/var/lib/tomcat/webapps/test]#vi index.jsp &lt;%@ page language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;TomcatA&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;font color=&quot;red&quot;&gt;TomcatA.magedu.com&lt;/font&gt;&lt;/h1&gt; &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;Session ID&lt;/td&gt; &lt;% session.setAttribute(&quot;magedu.com&quot;,&quot;magedu.com&quot;); %&gt; &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Created on&lt;/td&gt; &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; [root@node4/etc/tomcat]#vim server.xml #在host内填入如下一行 &lt;Context path=&quot;&quot; docBase=&quot;test&quot; reloadable=&quot;&quot; /&gt; [root@node4/etc/tomcat]#systemctl start tomcat.service node5中tomcat配置[root@node5/var/lib/tomcat/webapps]#mkdir test/{WEB-INF,lib,classes} -pv[root@node5/var/lib/tomcat/webapps/test]#vi index.jsp &lt;%@ page language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;TomcatB&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;font color=&quot;blue&quot;&gt;TomcatB.magedu.com&lt;/font&gt;&lt;/h1&gt; &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;Session ID&lt;/td&gt; &lt;% session.setAttribute(&quot;magedu.com&quot;,&quot;magedu.com&quot;); %&gt; &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Created on&lt;/td&gt; &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; [root@node5/etc/tomcat]#vim server.xml &lt;Context path=&quot;&quot; docBase=&quot;test&quot; reloadable=&quot;&quot; /&gt; [root@node5/etc/tomcat]#systemctl start tomcat.service node4和node5安装redis[root@node4~]#yum install -y redis [root@node4~]#vim /etc/redis.conf bind 192.168.4.64 requirepass centos [root@node5~]#vim /etc/redis.conf bind 192.168.4.65 requirepass centos [root@node5~]#systemctl start redis.service node4和node5上传所需要的jar文件tomcat-redis-session-manager-VERSION.jar 下载地址：https://github.com/jcoleman/tomcat-redis-session-manager jedis-VERSION.jar 下载地址：https://github.com/xetorthio/jedis/releases commons-poolVERSION.jar 下载地址：http://commons.apache.org/proper/commons-pool/download_pool.cgi [root@node4~]#ls *.jarcommons-pool2-2.2.jar jedis-2.5.2.jar tomcat-redis-session-manager-1.2-tomcat-7.jar [root@node4~]#cp *.jar /usr/share/tomcat/lib/ 注意：可能有强依赖的版本。 node4和node5修改配置[root@node4/etc/tomcat]#vim context.xml #在配置文件中填入以下几行 37 &lt;Valve className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot; /&gt; 38 &lt;Manager className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot; 39 host=&quot;192.168.4.65&quot; 主机IP，默认为localhost 40 port=&quot;6379&quot; 端口 password=&quot;&quot; 如果redis设置密码需要设置，否则连不上 41 database=&quot;0&quot; 数据库 42 maxInactiveInterval=&quot;60&quot; 最大非活动间隔 /&gt; [root@node5/etc/tomcat]#vim context.xml 36 &lt;Valve className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot; /&gt; 37 &lt;Manager className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot; 38 host=&quot;192.168.4.65 39 port=&quot;6379&quot; 40 database=&quot;0&quot; 41 maxInactiveInterval=&quot;60&quot; /&gt; 42 &lt;Context/&gt; 重启服务[root@node4~]#systemctl start tomcat.service Apache服务器配置[root@node3/etc/httpd/conf.d]#vim tomcat-http.conf 1 &lt;proxy balancer://tcsrvs&gt; #相当于定义一组后端服务器 2 BalancerMember ajp://192.168.4.62:8009 loadfactor=1 3 BalancerMember ajp://192.168.4.63:8009 loadfactor=2 4 ProxySet lbmethod=byrequests 5 &lt;/Proxy&gt; 6 7 &lt;VirtualHost *:80&gt; 8 ServerName www.test.com 9 ProxyVia on 10 ProxyRequests off 11 ProxyPreserveHost on 12 &lt;Proxy *&gt; 13 Require all granted 14 &lt;/Proxy&gt; 15 ProxyPass / balancer://tcsrvs/ 16 ProxyPassReverse / balancer://tcsrvs/ 17 &lt;Location /&gt; 18 Require all granted 19 &lt;/Location&gt; 20 &lt;/VirtualHost&gt; 21 22 &lt;Location /bm&gt; #定义管理主机 23 SetHandler balancer-manager 24 ProxyPass ! 25 Require all granted #建议这里使用本机主机访问 26 &lt;/Location&gt; 27 &lt;Location /status&gt; #定义状态页 28 ProxyPass ! 29 SetHandler server-status 30 Require all granted 31 &lt;/Location&gt; 查看redis服务器[root@node5~]#redis-cli -p 6379 -h 192.168.4.65 redis 192.168.4.65:6379&gt; keys * 1) &quot;AAB3EB7FC0F829F0DEB07BFADC1B21A2&quot; 注意这里默认存储在0数据库中，这时我们在context.xml文件database中设置的。 测试 小结1、在构建过程中，jar文件包耽搁了很长时间，由于版本的依赖性较强。如果可以修改jar包最好修改下，即可。 2、在构建过程中需要验证每一步都是正确再进行如下步骤。]]></content>
      <categories>
        <category>服务</category>
        <category>Tomcat</category>
        <category>Tomcat基于Redis缓存session共享</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat简单介绍]]></title>
    <url>%2F2017%2F11%2F28%2FTomcat%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阈等。但是不能将Tomcat和Apache HTTP服务器混淆，Apache HTTP服务器时一个用C语言实现的HTTP web服务器，而Tomcat则是由Java编写。 #一、javaJava是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。Java的特点之一面向对象，是程序设计方法的一种。 #####程序是由指令和数据组成。 过程式编程：以指令为中心，数据服务于代码 对象式编程：以数据位中，指令服务于数据 ###1、Java代码编译过程 用java语言编译源代码，通过JAVAC （Java complie）它编译成java .class(bytes code)文件，然后在Java VM中运行.class文件；当编写程序时，通过调用类（API class）中的方法来访问系统资源，而当程序运行时，它通过调用class文件中实现Java API的方法来满足程序的Java API调用。Java VM 和Java API一起组成一个平台，被称为JDK（Java Development Kit），所有的Java程序都在其上编译和运行。 Java VM主要任务时装载class文件并且执行其中的字节码，加载程序的类文件即程序的类文件依赖到的其他的类文件而后运行，整个运行表现为一个jvm进程。它包含一个类装载器（class loader）可以从程序和API装载class文件；但是Java API的类只在程序执行中需要时才会装载。 ###2、Java API Java SE包含了Java二进制程序（如JVM和Java字码编译器）和Java的核心代码库；而Java EE标准则包含了一组适用于创建企业级Web应用程序API。Java EE是建立在Java SE基础之上；它包含了多个独立的API，如Servlet和JSP等 ###3、Java VM 内部体系结构 方法区线程共享，用于存储被JVM加载的class信息、常量、静态变量、方法等 堆JVM所管理的内存中占用空间最大的一部分；也是GC管理的主要区域；存储对象 栈线程私有，存储线程自己的局部变量 PC寄存器线程私有的内存空间，程序的指令指针 本地方法栈执行引擎调用本地方法是的运行时聂村去 JVM的功能模块主要包括类加载器、执行引擎和垃圾回收系统。 – JVM组成 JRE（JVM+java SE API）：是用于实现java程序运行的最小环境 JDK（Java+API+JVM）：是用于实现Java程序开发的最小环境 ###3、JSP代码运行过程 index.jsp–&gt;jasper–&gt;servert Source Code(.java)–&gt;Java Compiler (.class)–&gt;在JVM虚拟机上运行 注意：基于jasper将静态输出的数据转为java代码进行输出，结果为servlet规范的代码。- #二、TomcatTomcat不是一个完整意义上的Java EE服务器，甚至没有提供对一个主要java EE API。由于遵守apache开源协议，tomcat为众多java应用程序服务器嵌入自己的产品中构建商业的java应用程序服务器，如JBoss等 ###1、JSP和Servlet区别 Servlet通常需要实现编译好，而JSP则并非必须事先编译。这意味着Servlet通常放置于私有资源区域，而JSP则通常以嵌入代码的方式包含于HTML页面文件中，这些HTML文件通常放置在公开资源区域。 ###2、MVC架构MVC架构由Contoller、Model和View构成，实现Apache Structs框架。 a、Servlet用于实现应用逻辑 b、JSP用于内容展示 c、标签库和JSP扩展语言用于替换JSP内部嵌入Java代码，进而降低了HTML维护的复杂度 d、MVC框架用于实现展示和应用逻辑分离 ###3、Servlet目录结构对于一个web应用程序而言，其通常由Servlet、JSP和其他文件等共同组成。这些文件通常被打包成WAR（Web Application Archive）格式，并以.war作为打包后的文件扩展名。而Servlet规范则定义了在WAR内部组织这些文件的标准目录结构。 / ：web应用程序的根目录，所有可被公开访问的文件均放置于此处，如HTML、JSP和图片文件等 /WEB-INF :此目录为私有资源目录，其内部的所有文件和子目录不能被公开访问；包含此web应用程序的配置文件web.xml，通常放置于此目录 /WEB-INF/classes：当前web应用程序的类文件存在目录 /WEB-INF/lib：可被打包为JAR格式的类文件通常放置于此目录 ###4、Tomcat目录 bin：脚本，即启动时用到的类 conf：配置文件目录 lib：库文件，Java类库，jar logs：日志文件目录 temp：临时文件目录 webapps：webapp的默认目录 work：工作目录，存放编译后的字节码文件 ###5、Tomcat文件 server.xml tomcat主配置文件，包含service、connector、engine、realm、valve、host相关配置信息 web.xml 每个webapp只有“部署”后才能被访问，它的部署方式通常有web.xml进行定义，其存放的位置为WEB-INF/目录下，次文件为所有的webapps提供默认部署相关的配置 context.xml 每个文本app都可以使用的配置文件，它通常有专用的配置文件contest.xml来定义，其存放位置为WEB-INF/目录下 tomcat-user.xml realm认证时用到的相关角色、用户和密码等信息；tomcat自带的manager默认情况下会用到此文件。此文件在tomcat启动时被装入内存 catalina.policy 当使用-security选项启动tomcat时，用于为tomcat设置安全策略 catalina.properties Java属性的定义文件，用于设定类加载器路径，以及一些与JVM调优相关参数 logging.properties 日志系统相关的配置 ####server.xml组件 Tomcat组件 顶级组件：位于配置层次的顶级，并且彼此间有着严格的对应关系（server、service） 连接器：连接客户端请求至servlet（connector） 容器：包含一组其他组件（engine、host、context） 被嵌套的组件：位于一个容器当中，但不能包含其他组件（valve、logger、realm） &lt;Server&gt; &lt;Service&gt; &lt;connector/&gt; &lt;connector/&gt; ... &lt;Engine&gt; &lt;Host&gt; &lt;Context/&gt; &lt;Context/&gt; ... &lt;/Host&gt; &lt;Host&gt; ... &lt;/Host&gt; ... &lt;/Engine&gt; &lt;/Service&gt; &lt;/Server&gt; #####tomcat常用组件配置 server：代表tomcat instance，即表现出一个java进程；监听在8005端口，只能接受“SHUTDOWN”指令。各server监听的端口不能相同，因此在同一物理主机启动多个示例时，需要修改其监听端口为不同的端口。这个端口的定义为管理员提供一个关闭此示例的便捷途径，管理员可以直接使用telnet命令连接此端口SHUTDOWN关闭此示例。基于安全角度考虑，通常不允许远程进行 service：用于实现将一个或多个connector组件关联至一个engine组件 className：用于实现service的类名 name：此服务的名称，默认为catalina connector：负责接收请求，常见的有三类http、https、ajp address：指定连接器监听的地址，默认为所有地址 maxThreads：支持的最大并发连接数，默认为200 port：监听的端口，默认为0 protocol：连接器使用的协议，默认为HTTP/1.1，定义AJP协议时通常为AJP/1.3 redirectPort：如果某连接器支持的协议时HTTP，当接收客户端发来的HTTPS请求时则转发至此属性的定义端口 connectionTimeout：等待客户端发送请求的超时时间，单位为毫秒，默认为6000 enableLookups：是否通过request.getRemoteHost（）即是否启用DNS查询功能 acceptCount：设置等待队列的最大长度 engine： servlet示例，即servlet引擎，其内部可以一个或多个host组件来定义站点；通常需要defaultHost属性来为其定义一个接受所有发往非明确定义虚拟主机的请求的host组件 name：engine组件的名称，用于日志和错误信息记录时却别不同的引擎 host：位于engine内部用于接受请求并进行响应处理的主机或虚拟主机 appBase：此host的webapps的默认存放目录，指存放非归档的web应用程序的目录或归档的WAR文件目录路径；可以使用基于$CATALINA_BASE变量所定义的路径的相对路径 autoDepoly：在tomcat处于运动状态时，将某webapp放置于appBase所定义的目录中，是否自动将其部署至tomcat；默认为true unpackWars：在启用此webapss时是否对WAR格式的归档文件先进行展开，默认为true 主机别名定义：如果一个主机有两个或两个以上的主机名，额外的名称均可以以别名的形式进行定义 示例 &lt;Host name=&quot;www.test.com&quot; appBase=&quot;webapps&quot; unpackWARS=&quot;true&quot;&gt; &lt;Alias&gt;test.com&lt;/Alias&gt; &lt;/Host&gt; context：context在某些意义上类似于apache的路径别名，一个context定义用于表示tomcat示例中的一个web应用程序 docBase：相应的web应用程序存放位置；也可以使用相对路径，起始路径为Context所属Host中appBase定义的路径；切记，docBase的路径名不能与相应的Host中的appBase中定义的路径名有包含关系，比如appBase为deploy，而docBase决不能为deploy-bbs类的名字 path：相对于web服务器根目录而言的URI，如果为空，则表示为webapp的根路径；如果context定义了一个单独的xml文件，此属性不需要定义 reloadable：是否允许重新加载此context相关的web应用程序类，默认为false 示例 &lt;Context path=&quot;/path&quot; docBase=&quot;/path/to/somedir&quot; reloadable=&quot;&quot;/&gt; realm：一个realm表示一个安全上下文，授权访问某个给定context的用户列表和某用户所允许切换角色相关定义的列表 valve：类似于过滤器，valve定义的次序决定了他们的生效次序。 RemoteHostValve：基于远程主机名称的访问控制 RemouteAddrValve：基于远程地址的访问控制 控制本身可以通过allow或deny来进行定义，这有点类似于apache的访问控制功能 示例： &lt;Context path=&quot;/test&quot; docBase=&quot;test&quot;&gt; &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;127\.0\.0\.1&quot;/&gt; &lt;/Context&gt; *className*：相关的java实现的类名 *allow*：以逗号分开的允许访问的IP地址列表，支持正则表达式，使用“.”需要转义；仅定义allow选项是，被明确allow的地址均被deny *deny*：以逗号分开的禁止访问IP地址列表，支持正则表达式，使用方式同allow 部署（deploy）webapp相关操作 将webapp的源文件放置于目标目录，配置tomcat服务器能够基于web.xml和context.xml文件中定义的路径来访问webapp；将其特有的类和依赖的类通过class loader装载至JVM中 部署方式： （1）自动部署auto deploy （2）手动部署 冷部署：把webapp复制到指定的位置，而后才能启动tomcat 热部署：在不停止tomcat的前提下进行部署 部署工具：manager、ant脚本、tcd（tomcat client deployer） undeploy：拆除（反部署），停止webapp，并从tomcat示例上卸载webapp start：启动处于停止状态的webapp stop：停止webapp，不再向用户提供服务，其类亦然在jvm上 redeploy：重新部署 ###6、启动manager功能 &lt;role rolename=&quot;manager-gui&quot;/&gt; &lt;role rolename=&quot;manager-script&quot;/&gt; &lt;role rolename=&quot;standard&quot;/&gt; &lt;user username=&quot;tomcat&quot; password=&quot;secret&quot; roles=&quot;admin-gui,manager-script,standard&quot;/&gt; ###7、tomcat请求的分类 （1）standalone：请求来自客户端浏览器 （2）由其他的web server反代，来自前段的反代服务器 nginx--&gt;http connector --&gt;tomcat httpd(proxy_http_module)--&gt;http connector--&gt;tomcat httpd(proxy_ajp_module)--&gt;ajp connector --&gt;tomcat http(mod_jk)--&gt;ajp connector --&gt;tomcat #三、Tomcat安装方式一：- 使用yum源安装即可 （1）安装jdk环境，由于base源提供了三个不同版本的jdk环境，根据我们的需要自行安装所需要的版本 [root@localhost~]#yum install -y java-1.8.0-openjdk-src [root@localhost~]#java -version #查看是否安装成功 如果多 版本并存时，可使用alternatives命令设定默认使用的版本。 （2）安装tomcat [root@localhost~]#yum install -y tomcat tomcat-admin-webapps tomcat-docs-webapp tomcat-webapps tomcat-libs [root@localhost~]#systemctl start tomcat.service #启动服务 方式二：- （1）从官网下载rpm安装jdk# http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html #[root@localhost~]#rpm -ivh jdk-8u144-linux-x64.rpm [root@localhost~]#java -version #测试是否安装成功 （2）二进制安装tomcat https://tomcat.apache.org/download-80.cgi [root@localhost~]#tar xf apache-tomcat-7.0.78.tar.gz -C /usr/local/ #解压缩 [root@localhost~]#cd /usr/local/ [root@localhost/usr/local]#ln -sv apache-tomcat-7.0.78/ tomcat #创建软连接 [root@localhost/usr/local/tomcat]#vim /etc/profile.d/tomcat.sh #修改环境变量 1 export CATALINA_BASE=/usr/local/tomcat 2 export PATH=$CATALINA_BASE/bin:$PATH 修改权限 [root@localhost/usr/local]#useradd -r tomcat #创建用户 [root@localhost/usr/local]#chown -R :tomcat tomcat/ #修改配置文件所属组 [root@localhost/usr/local/tomcat]#chown tomcat ./{logs,temp,work,webapps} [root@localhost/usr/local/tomcat]#source /etc/profile.d/tomcat.sh #使环境变量生效 （3）重启服务测试 [root@localhost/usr/local/tomcat/bin]#catalina.sh --help Usage: catalina.sh ( commands ... ) commands: debug Start Catalina in a debugger debug -security Debug Catalina with a security manager jpda start Start Catalina under JPDA debugger run Start Catalina in the current window run -security Start in the current window with security manager start Start Catalina in a separate window start -security Start in a separate window with security manager stop Stop Catalina, waiting up to 5 seconds for the process to end stop n Stop Catalina, waiting up to n seconds for the process to end stop -force Stop Catalina, wait up to 5 seconds and then use kill -KILL if still running stop n -force Stop Catalina, wait up to n seconds and then use kill -KILL if still running configtest Run a basic syntax check on server.xml - check exit code for result version What version of tomcat are you running? [root@localhost~]#mkdir test/{logs,temp,work,webapps} -pv [root@localhost~]#chown -R tomcat test/{logs,temp,work,webapps} [root@localhost/usr/local/tomcat/bin]#catalina.sh start #启动服务 建议一般以普通用户运行tomcat #四、示例 ###1、冷部署方法 （1）创建所需要的目录 [root@localhost~]#mkdir test/{classes,lib,WEB-INF} -pv （2）创建index.jsp文件 [root@localhost~]#vim test/index.jsp 1 &lt;%@ page language=&quot;java&quot; %&gt; 2 &lt;%@ page import=&quot;java.util.*&quot; %&gt; 3 &lt;html&gt; 4 &lt;head&gt; 5 &lt;title&gt;Test Page&lt;/title&gt; 6 &lt;/head&gt; 7 &lt;body&gt; 8 &lt;% out.println(&quot;hello world&quot;); 9 %&gt; 10 &lt;/body&gt; 11 &lt;/html&gt; （3）将test目录移动到webapps目录下 [root@localhost~]#cp -r test/ /usr/share/tomcat/webapps/ （4）重启服务测试 [root@localhost~]#systemctl start tomcat 如果是程序员将打包好的jar文件发给我们，可以将此包直接防止webapps目录下，可以自行部署 （5）查看部署过程 [root@localhost/usr/share/tomcat/work/Catalina/localhost]#tree test/ test/ └── org └── apache └── jsp ├── index_jsp.class └── index_jsp.java ###2、手动使用SHUTDOWN关闭服务（1）首先先查看下我们的服务是否正常运行 （2）使用telnet连接关闭服务 此时我们再看服务已经没有开启了，为了防止恶意之人，我们需要将命令修改为随机数等等 [root@localhost/etc/tomcat]#openssl rand -hex 20 fb8a9c1a78827dcb81950feca0e18c6d4470997e ###3、创建站点 [root@localhost/etc/tomcat]#vim server.xml [root@localhost/etc/tomcat]#mkdir -pv /app/webapps [root@localhost/etc/tomcat]#mkdir -pv /app/webapps/ROOT/{lib,classes,WEB-INF} [root@localhost/etc/tomcat]#cp /usr/share/tomcat/webapps/test/index.jsp /app/webapps/ROOT/ #创建站点文件 重启服务测试 [root@localhost/etc/tomcat]#systemctl start tomcat [root@localhost/etc/tomcat]#curl www.test.com:8080 &lt;html&gt; &lt;head&gt; &lt;title&gt;Test Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello world &lt;/body&gt; &lt;/html&gt; 出现上述结果正常，使用的是curl命令没有做修改 [root@localhost/etc/tomcat]#links www.test.com:8080 ###4、修改conext组件相当于修改别名 （1）创建目录 [root@localhost~]#cp -r test/ /data/test （2）编辑server.xml文件 [root@localhost~]#vim /etc/tomcat/server.xml （3）编辑index.jsp文件 [root@localhost/data/test]#vim index.jsp 1 &lt;%@ page language=&quot;java&quot; %&gt; 2 &lt;%@ page import=&quot;java.util.*&quot; %&gt; 3 &lt;html&gt; 4 &lt;head&gt; 5 &lt;title&gt;Test Page&lt;/title&gt; 6 &lt;/head&gt; 7 &lt;body&gt; 8 &lt;% out.println(&quot;hello tomcat&quot;); 9 %&gt; 10 &lt;/body&gt; 11 &lt;/html&gt; （4）重启服务测试 [root@localhost/data/test]#links www.test.com:8080/test ###5、启动web-gui管理 （1）如果我们想启用Server Status功能需要认证，如果我们点击cancle则出现指示方法 （2）修改tomcat-user.xml配置文件 [root@localhost/etc/tomcat]#vim tomcat-users.xml （3）重启tomcat服务测试 [root@localhost/etc/tomcat]#systemctl restart tomcat ###5、禁止或允许某个或某些远程IP主机管理 （1）编辑server.xml配置文件 [root@localhost/etc/tomcat]#vim server.xml （2）测试 禁止此IP访问没有显示内容 那么接下来我们允许此IP访问并再次重启服务测试]]></content>
      <categories>
        <category>服务</category>
        <category>Tomcat</category>
        <category>Tomcat简单介绍</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VRRP协议]]></title>
    <url>%2F2017%2F11%2F28%2FVRRP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[一、VRRP协议虚拟路由冗余协议（VRRP，Virtual Router Redundancy Protocol）通过把几台路由设备联合组成一台虚拟的路由设备，使用一定的机制保证当主机的下一跳路由机出现故障时，及时将业务切换到备份路由器，从而保持业务的持续性和可靠性。 基本概念 虚拟路由器（Virutal Router）：又陈VRRP备份组，由一个master设备和多个backup设备组成，被当做一个共享局域网内主机的缺省网关 Master设备（Virtual Router Master）：承担转发报文任务的VRRP设备 Backup设备（Virtual Router Backup）：一组没有承担转发任务的VRRP设备，当Master设备出现故障时，他们将通过优先级成为新的Master设备 VRID：虚拟路由器的表示 虚拟IP地址（Virtual IP Address）：虚拟路由器IP地址，一个虚拟路由器可以有一个或多个IP地址 IP地址拥有者（IP Address Owner）：如果一个VRRP设备将虚拟路由器IP地址作为真实的接口地址，则该设备称为IP地址拥有者，如果IP地址拥有者是可用的，通常称为Master 虚拟MAC地址（Virtual MAC Address）：虚拟路由器根据虚拟路由器ID生成的MAC地址 主IP地址（Primary IP Address）：从接口的真实IP地址中选出来的一个主用IP地址，通常选择配置的第一个IP地址。VRRP广播报文使用主IP地址作为IP报文的源地址。 优先级（Priority）：虚拟路由器中VRRP设备的优先级。虚拟路由器根据优先级选举出Master设备和Backup设备 抢占模式：如果Backup设备的优先级比当前Master设备的优先级高，则主动将自己切换成Master 非抢占模式：只要Master设备没有出现故障，Backup设备即使随后被配置了更高的优先级也不会成为Master设备 VRRP工作原理（1）VRRP备份组中的交换机根据优先级选举出Master。Master交换机通过发送免费ARP报文，将虚拟MAC地址通知给与它连接的设备或主机，从而承担报文转发任务。 （2）Master交换机周期性向备份组内的Backup交换机发送VRRP通告报文，以公布其配置信息和工作状态。 （3）如果Master交换机出现故障，VRRP备份组中的Backup交换机将根据优先级重新选举新的Master。 （4）VRRP备份组状态切换时，Master交换机由一台设备切换为另外一台设备，新的Master交换机立即发送携带虚拟路由器的虚拟MAC地址和虚拟IP地址信息的免费ARP报文，刷新与它连接的主机或者设备中的MAC表项。 （5）如果原来的Master恢复时，若优先级高时，将直接切换为Master状态。 VRRP主备备份示例- VRRP主主示例]]></content>
      <categories>
        <category>服务</category>
        <category>Keepalived</category>
        <category>VRRP协议</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB工作过程]]></title>
    <url>%2F2017%2F11%2F28%2FWEB%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Web服务请求处理过程 此图为经过的OSI模型 （1）Client需要和Server通信，这时需要发出建立连接请求 （2）Client与Server进行传输数据包时，需要经应用层–&gt;传输层–&gt;网络层–&gt;链路层:层层打包然后传输至Server，Server对此包进行 链路层–&gt;网络层–&gt;传输层–&gt;应用层：层层解封装。http协议工作在应用层，TCP/IP协议工作在网络层，这时就要经过三次握手进行连接（具体想看上述过程） （3）Server接受Client发过的请求 （4）Server接受请求之后需要对处理请求，对请求报文进行解析，获取Client请求的资源及请求资源使用的方法等相关信息；Server根据解析到的结果进行处理 （5）Server这时获取报文中需要请求的资源Web服务器，即存放了Web资源的服务器，此服务器存Client请求的静态文静或运行后生成的资源（6）存放Web资源的服务器识别了请求的资源，执行Client要求的动作并将返回响应报文。响应报文中包括：响应状态码、响应头部、如果生成了响应主体并返回响应主体。 （7）构建完报文之后需要就此报文发送给Client，但是这时Server需要面对一个严重的问题：Server到Client有很多连接，有些是空闲的，有些是正向Server发送数据，还有一些在向客户端回送响应数据。在连接中存在非长连接（服务器应该在发送了整条报文之后关闭自己这条连接）和长连接（在传输完成之后可能还扔保持打开状态）。这时Server就需要精确计算除Content-Length首部，目的是为了知道传送什么时候才能结束。（8）当传输完成之后，理应是把这个通道关闭，这时就要出发TCP四次挥手过程（详细过程请查看上述过程），这种情况是对非长连接说的。如果是长连接，此通道会保持此状态。直到KeepAliveTimeout时间到之后触发TCP四次挥手，结束连接。 （9）如果你有一个好习惯的话，做完一件事情之后要对这件事请求有一个总结，不能做完之后什么都得不到把。Server跟这个性质一样。当完成传输之后在日志文件中记录这条信息。方便以后出现什么情况好解决。]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>WEB工作过程</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zabbix+Grafana]]></title>
    <url>%2F2017%2F11%2F28%2FZabbix%2BGrafana%2F</url>
    <content type="text"><![CDATA[Grafana-Grafana是一款开源度量分析和可视化套件。它有良好的展示页面。它最常用与对基础设施和应用分析的时间序列数据进行可视化，如工业传感器、进程控制等等。 Installing Grafana安装Grafana[root@localhost~]#yum install https://s3-us-west-2.amazonaws.com/grafana-releases/release/grafana-4.6.2-1.x86_64.rpm 配置yum仓库安装[grafana] name=grafana baseurl=https://packagecloud.io/grafana/stable/el/6/$basearch repo_gpgcheck=1 enabled=1 gpgcheck=1 gpgkey=https://packagecloud.io/gpg.key https://grafanarel.s3.amazonaws.com/RPM-GPG-KEY-grafana sslverify=1 sslcacert=/etc/pki/tls/certs/ca-bundle.crt [root@node1/etc/grafana]#yum install grafana 启动服务[root@node1~]#systemctl start grafana-server.service[root@node1~]#systemctl status grafana-server.service 地址栏输入：http://192.168.4.61:3000/ 默认的登陆账号和密码均为admin；建议登陆后修改密码。 安装zabbix插件[root@node1~]#grafana-cli plugins install alexanderzobnin-zabbix-app 建议：只给Grafana SELECT权限。因为Grafana不能验证。 添加zabbix 添加数据库为了能在刚刚配置的中直连数据库需要先添加数据库信息 效果图]]></content>
      <categories>
        <category>服务</category>
        <category>Zabbix</category>
        <category>Zabbix+Grafana</category>
      </categories>
      <tags>
        <tag>zabbix，grafana</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xtrabackup]]></title>
    <url>%2F2017%2F11%2F28%2FXtrabackup%2F</url>
    <content type="text"><![CDATA[xtrabackup由percona提供、开源工具，支持对InnoDB做热备，物理备份工具。 特点： 物理备份；速率快、可靠； 备份完成后自动校验备份结果是否可用 还原速度快 使用格式[innobackupex [--defaults-file=#] --backup | innobackupex [--defaults-file=#] --prepare] [OPTIONS] https://www.percona.com/software/mysql-database/percona-server innobackupex命令 使用innobackupex备份时，其会调用xtrabackup备份所有的InnoDB表，复制所有关于表结构定义相关文件（.frm）、以及MyISAM、MERGE、CSV和ARCHIVE表相关文件，同时还会备份触发器和数据库配置信息相关文件。这些文件会被保存至一个以时间命名的目录中。 在备份的同时，innobackupex还会备份目录中创建如下文件： xtrabackup_checkpoints 备份类型（如完全或增量）、备份状态（如是否已经为prepared状态）和LSN（日志序列号）范围信息 每个InnoDB页（通常为16k大小）都会包含一个日志序列号（LSN）。LSN是整个数据库系统的系统版本号，每个页面相关的LSN能够表明此页面时如何发生改变的。 xtrabackup_binlog_info mysql服务器当前正在使用的二进制日志文件及至备份这一刻为止二进制日志事件的位置 xtrabackup_binlog_pos_innodb 二进制日志文件及用于InnoDB或XtraDB表的二进制日志文件的当前position xtrabackup_binary 备份中用到的xtrabackup的可执行文件 backup-my.cnf 备份命令用到的配置选项信息 在使用innobackupes进行备份时，还可以使用–no-timestamp选项来阻止命令自动创建一个以时间命名的目录；如此一来，innobackupex命令将会创建一个BCAKUP-DIR目录来存储备份数据。 准备一个完全备份 一般情况下，在备份完成后，数据尚且不能用于恢复操作，因为备份的数据中可能会包含尚未提交的事务或已经提交单尚未同步至数据文件中的事务。因此，此时数据文件仍处理不一致状态。“准备”的主要作用是通过回滚为提交的事务及同步已经提交的事务至数据文件也使得数据文件处于一致性状态。 --apply-log选项可用于实现上述功能。 使用格式： innobackupex --apply-log /PATH/TO/BACKUP-DIR 在实现“准备”过程中，innobackupex通常还可以使用–use-memory选项来指定其可以使用的内存大小，默认为100M。如果有足够的内存使用，可以多划分一些内存给prepare的过程，以提高其完成速度。 从一个完全备份中恢复数据 注意：恢复时不用启动mysql服务 innobackupex命令的–copy-back选项用于执行恢复操作，其通过复制所有数据相关的文件至mysql服务器的DATADIR目录中来执行恢复过程。innobackupex通过backup-my.cnf来获取DATADIR目录的相关信息。 使用格式： innobackupex --copy-back /PATH/TO/BACKUP-DIR 当数据恢复之DATADIR目录中，需要确保所有数据文件的所属主和所属组均为mysql用户。否则，在启动mysql服务器前事先修改数据文件的所有者和所属组。 使用innobackupex进行增量备份 每个InnoDB的页面都会包含一个LSN信息，每当相关数据发生改变，相关的页面的LSN就会自动增长。这正式InnoDB表可以进行增量备份的基础，即innobackupex通过备份上次完全备份之后发生改变的页面来实现。 使用格式： innobackupex --incremental /BACKUP --incremental-basedir=/BASEDIR 其中BASEDIR指的是完全备份所在的目录，此命令执行结束后，innobackupex命令会在/BACKUP目录中创建一个新的以时间命名的目录以存放所有的增量备份的数据。另外，在执行过增量备份之后再一次进行增量备份时，其–incremental-basedir应该指向上一次的增量备份所在的目录。 增量备份仅能应用于InnoDB或XtraDB表，对弈MyISAM表而言，执行增量备份时其实进行的完全备份。 “准备“增量备份与整理备份不同： （1）需要在每个备份（包括完全和增量备份）上，将已经提交的事物进行“回放”。所有的备份数据将合并到完全备份上 （2）基于所有的备份将未提交的事物进行“回滚” 操作步骤 innobackupex --apply-log --redo-log BASE-DIR innobackupex --apply-log --redo-log BASE-DIR --incremental-dir=INCREMENTAL-DIR-1 innobackupex --apply-log --redo-log BASE-DIR --incremental-dir=INCREMENTAL-DIR-2 其中BASE-DIR指的是完全备份所在的目录，而INCREMENTAL-DIR-1指的是第一次增量备份的目录，INCREMENTAL-DIR-2指的是第二次增量备份目录，其他依次类推，即如果有多次增量备份，每一次都要执行如上操作。 Xtrabackup的“流”及“备份压缩”功能 Xtrabackup对备份的数据文件支持“流”功能，即可以将备份的数据通过STDOUT传输给tar程序进行归档，而不是默认的直接保存至某备份目录中。要使用此功能仅需要使用–stream选项即可。 使用格式： innbackupex --stream=tar /BACKUP |gzip &gt; /BACKUP/`date +F_$H-$M_%M_%S`.tar.gz 也可是使用如下命令将数据备份至某服务器上： innobackupex --stream=tar /BACKUP |ssh user@IP &quot;cat - &gt; /backups/`date +%F_%H-%M-%S`.tar&quot; 在执行本地备份时，还可以使用–parallel选项对多个文件进行并行复制。此选项用于指定在复制时启动的线程数目。在实际进行备份时要利用此功能的便利性，也需要启动inndb_file_per_table选项或共享表空间通过innodb_data_file_path选项存储在多个ibdata文件中。对某一数据库的多个文件的复制无法利用此功能。 使用格式： innobackupex --parallel /path/to/backup 同时innobackupex备份数据文件也可以存储值远程主机，使用–remote-host选项 使用格式： innobackupex --remote-host=user@IP /PATH/IN/REMOTE/HOST/TO/BACKUP 导入或导出单张表 默认情况下，InnoDB表不能通过直接复制文件的方式在mysql服务器之间进行移植，即便使用了innodb_file_per_table选型。而使用Xtreabackup工具可以实现此种功能，不过此时需要“导出”表的mysql服务器启动innodb_file_per_table选项（严格来说，是要“导出”的表在其创建之前，msyql服务器就启用了innodb_file_per_table选项），并且“导入”表的服务器同时启用了innodb_file_per_table和innodb_expand_import选项。 （1）导出表 导出表示在备份的prepare阶段进行的，因此一旦完成备份，就可以在prepare过程中通过–export选项将某表导出了 使用格式： innobackupex --apply-log --export /path/to/bacup 此命令会为每个innodb表的表空间创建一个以.exp结尾的文件，这些以.exp结尾的文件则可以用于导入至其它服务器。 （2）导入表 要在mysql 服务器上导入来自于其他服务器的某个innodb表，需要先在当前服务器上创建一个跟原表结构一致的表，而后才能实现将表导入： CREATE TABLE mytable ENGING=InnoDB; 然后将此表的表空间删除 ALTER TABLE mydatabase.mytable DISCARD TABLESPACE; 接下来，将来自于导出表的服务器的mytable表的mytable.ibd和mysqtalbe.exp文件复制到当前服务器的数据目录： ALTER TABLE mydatabase.mytable IMPORT TABLESPACE; 使用Xtrabackup对数据库进行部分备份 Xtrabackup也可以实现部分备份，即只备份某个或某些指定的数据库或某数据库中的某个或某些表。但要使用此功能，必须启用innodb_file_per_table选项，即每张表保存为一个独立的文件。同时其也不支持–stream选项，即不支持将数据通过管道传输给其他程序进行处理。 此外，还原部分备份跟还原全部数据备份也有所不同，即不能通过简单地将prepared的部分备份使用–copy-back选项直接复制回数据目录，而是要通过导入表的防线来实现还原。当前，有些情况下，部分备份也可以直接通过–copy-back进行还原，但这种范式还原而来的数据多数会产生数据不一致的文件。 （1）创建部分备份 创建部分备份的方式： 正则表达式（–include） 要求为其制定要备份的表的完整名称，即如databasesname.tablename innobackupex --include ‘^student[.]tb1’ /path/to/backup 枚举表文件（–tables-file） 此选项的参数需要一个文件名，此文件中每行包含一个要备份的表的完整名称 echo -e &apos;test.tb1\ntest.tb2&apos; &gt; /tmp/tables.txt innobackupex --tables-file=/tmp/tables.txt /path/to/backup 列出要备份的数据库（–databases） 此选项接受参数参数为数据名，如果要指定多个数据库，彼此间需要以空格隔开；同时，在指定某数据库时，也可以只指定其中的某张表。此外，此选项也可以接受一个文件为参数，文件中每一行为一个要备份的对象。 innobackupex --databases=“test testb” /path/to/backup （2）整理（preparing）部分备份 prepare部分备份的过程类似于导出表的过程，要使用–export选项进行 innobackupex --apply-log --export /PATH/TO/PARTIAL/BACKUP 此命令执行过程中，innobackupex会调用xtrabackup命令从数据字典中移除缺失的表，因此，会显示出许多关于“表不存在”类的警告信息。同时，也会显示出为备份文件中存在的表创建.exp文件的相关信息。 （3）还原部分备份 还原部分备份的过程跟导入表的过程相同。当然，也可以通过直接复制prepared状态的备份直接至数据目录中实现还原，不过此时要求数据目录处于一致状态。 实战： 准备两台虚拟器node1和node2 同步时间 [root@node1~]#ntpdate 172.18.0.1 [root@node2~]#ntpdate 172.18.0.1 [root@node1~]#vim /etc/chrony.conf #node1和node2操作一样 [root@node1~]#systemctl start chronyd.service #启动服务 基于root密钥认证 node1和node2配置一样 [root@node2~]#ssh-keygen [root@node2~]#ssh-copy-id -i /root/.ssh/id_rsa.pub 192.168.4.61 修改hosts文件node1和node2配置相同 [root@node1~]#vim /etc/hosts 3 192.168.4.61 node1 4 192.168.4.62 node2 安装数据库和extabackup [root@node1~]#yum install -y mariadb-server [root@node1~]#yum install -y percona-xtrabackup-24-2.4.7-2.el7.x86_64.rpm 导入一个数据库并备份 [root@node1~]#vim /etc/my.cnf.d/server.cnf 9 [server] 10 log_bin = /data/mysql/master-log [root@node1~]#vim /etc/my.cnf 10 innodb_file_per_table [root@node1~]#systemctl start mariadb.service 创建目录并修改权限 [root@node1~]#mkdir /data/mysql -pv [root@node1~]#chown -R mysql.mysql /data/mysql 查看是否真正开启二进制日志功能 MariaDB [(none)]&gt; SELECT @@global.log_bin; +------------------+ | @@global.log_bin | +------------------+ | 1 | +------------------+ 关闭当前会话二进制功能，并导入数据库 MariaDB [(none)]&gt; SET @@session.sql_log_bin=OFF; [root@node1~]#mysql &lt; hellodb.sql 使用xtrabackup备份数据库 MariaDB [(none)]&gt; GRANT ALL ON *.* TO &apos;root&apos;@&apos;192.168.4.63&apos; IDENTIFIED BY &apos;123456&apos;; #授权远程用户权限 [root@node1~]#innobackupex --user=root --host=localhost /data/mysql/ #使用命令进行备份 [root@node1~]#scp -r /data/mysql/* node2:/data/mysql #将备份数据复制到node2中 在node1中添加一些数据 MariaDB [hellodb]&gt; INSERT INTO scores (ID,StuID,CourseID,Score) VALUES (16,9,3,95); 在node2进行如下操作： [root@node2~]#innobackupex --apply-log /data/mysql/2017-11-11_19-45-11/ #将数据进行回滚 [root@node2~]#innobackupex --copy-back /data/mysql/2017-11-11_19-45-11/ #恢复 [root@node2~]#chown -R mysql.mysql /var/lib/mysql/ #修改权限 此时只是复制了某个时间点的数据，时间点之后的数据没有如何解决？ 查看时间点是的二进制日志在哪个地方 [root@node2/data/mysql/2017-11-11_19-45-11]#cat xtrabackup_binlog_info 在node1节点上查看并导出 [root@node1~]#mysqlbinlog -j 8203 /data/mysql/master-log.000001 &gt; change.sql [root@node1~]#scp change.sql node2:/tmp 在node2节点上导入 MariaDB [hellodb]&gt; SET @@session.sql_log_bin=OFF； 先关闭二进制日志功能 MariaDB [hellodb]&gt; \. /tmp/change.sql #导入 ####如何实现全量和增量？ #####在node1节点操作： [root@node1~]#innobackupex --user=root --host=localhost /data/mysql/ MariaDB [hellodb]&gt; INSERT INTO scores (ID,StuID,CourseID,Score) VALUES (17,10,3,95); #添加一行记录 [root@node1~]#innobackupex --user=root --host=localhost /data/mysql/ --incremental --incremental-basedir=/data/mysql/2017-11-11_20-19-31 #增量备份 MariaDB [hellodb]&gt; INSERT INTO scores (ID,StuID,CourseID,Score) VALUES (18,11,4,95); #再次添加一条记录 [root@node1~]#innobackupex --user=root --host=localhost /data/mysql/ --incremental --incremental-basedir=/data/mysql/2017-11-11_20-22-16 #再次进行增量备份 进行准备操作： [root@node1/data/mysql]#innobackupex --apply-log --redo-only 2017-11-11_20-19-31/ [root@node1/data/mysql]#innobackupex --apply-log --redo-only 2017-11-11_20-19-31/ --incremental-dir=/data/mysql/2017-11-11_20-22-16 #第一次增量准备 [root@node1/data/mysql]#innobackupex --apply-log --redo-only 2017-11-11_20-19-31/ --incremental-dir=/data/mysql/2017-11-11_20-24-32 #第二次增量准备 [root@node1/data/mysql]#innobackupex --apply-log /data/mysql/2017-11-11_20-19-31/ [root@node1/data/mysql]#mysqlbinlog -j 8203 master-log.000002 &gt; /root/mysql.sql [root@node1/data/mysql]#scp -r /root/mysql.sql node2:/tmp 将准备好的备份文件复制到node2节点中 [root@node1/data/mysql]#scp -r /data/mysql/2017-11-11_20-19-31/ node2:/data/mysql 在node2节点上操作[root@node1/data/mysql]#innobackupex --copy-back /data/mysql/2017-11-11_20-19-31/ #恢复数据库 [root@node1/data/mysql]#chown -R mysql.mysql /var/lib/mysql/ #修改权限 MariaDB [hellodb]&gt; \. /tmp/mysql.sql]]></content>
      <categories>
        <category>数据库</category>
        <category>Xtrabackup</category>
      </categories>
      <tags>
        <tag>Xtrabackup，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zabbix介绍]]></title>
    <url>%2F2017%2F11%2F28%2FZabbix%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Zabbix是一款能够监控各种网络参数以及服务器健康性和完整性的软件。Zabbix使用灵活的通知机制，允许用户为几乎任何事件配置基于邮件告警。Zabbix提供了出色的报告和数据可视化功能。Zabbix所有的报告、统计信息和配置参数都可以通过基于Web的前端页面进行访问。 一、Zabbix1、Zabbix特点 数据收集 可用性和性能检查 支持SNMP,IPMI,JMX,VMware监控 自定义检查 按照自定义的间隔收集需要的数据 灵活的阈值定义 高度可配置化的告警 实时图表绘制 Web监控功能 丰富的可视化选项 能够创建自定义的图形，图形中可将多个监控项组合在一个视图展示 网络拓扑图 以仪表盘的样式展现自定义的展现和幻灯片 报告 监控资源的高级视图 历史数据存储 数据存储在数据库中 可配置历史数据 内置数据管理机制 配置简单 将被监控对象添加为主机 主机被创建用于监控，在数据库中唯一存在 应用模板来监控设备 使用模板 在模板中分组检查 模板可以关联其他模板 网络发现 自动发现网络设备 监控代理自动注册 发现文件系统，网络接口和SNMP OID值 简介的Web界面 web前段基于PHP 可以自定义自己的操作方式 审核日志 权限管理系统 安全用户认证 特定用户可以限制访问特定的视图 功能强大并易于扩展监控代理 部署在被监控对象上 可以部署在OS 2、Zabbix结构 zabbix_server：服务端守护进程；负责接收agent发送的报告信息的核心组件，所有配置、统计数据及操作系统均由其组织进行 zabbix_agentd：agent守护进程 zabbix_proxy：代理服务器，可选组件 zabbix_get：命令行工具，手动测试向agent发起数据采集请求 zabbix_sender：命令行工具，运行于agent端，手动向server端发送数据 zabbix_java_gateway：java网关 zabbix_database：MySQL或PGSQL；专用于存储所有配置信息，以及由zabbix收集的数据 zabbix_web：Web-GUI结构，可以运行在任意主机中，连接Zabbix-Server并将数据库的内容在前段展示 3、Zabbix逻辑组件 Host Group（主机组）：主机的逻辑容器，可以包含主机和模板，但同一组内的主机和模板不能互相连接；主机组通常在给用户或用户组指派监控权限时使用 Host（主机）：要监控的网络设备，可由IP或DNS名称指定 item（监控项）：关键时key（实现获取监控的目标上的数据命令或脚本名称）；key+parameter构成。 key分类： （1）Zabbix内建key （2）用户自定义key 存储的值 As is：不对数据做任何处理，保留原值 Delta：（simple change）本次采样减去前一次采样值的结果 Delta：（speed per second）本次采样减去上一次采样的值除以经过的时长 application（应用）：同一类监控项的集合 trigger（触发器）：用于评估某监控对象的特定item内所接受到的数据是否在合理范围内，即阈值；如果不在合理范围内，触发器状态从“ok”转为“problem”- 安全级别： - Not classified - Information - Warning - Average - High - Disaster - trigger条件的设定：使用数据运算符 注意：触发器之间存在依赖关系，如果前段有路由器down，则可以后端主机不发生告警。 event（事件）：即发生的一个值得关注的事情 action（动作）：由条件（condition，多个条件之间存在逻辑关系，如果第一步执行不成功则进行设定的下一步，以此类推。）和操作（operation，条件满足时触发的动作）组件构成 media（媒介）：发送通知的通道；需要用户上定义对各种媒介通道的接收方式 （1）email （2）script：告警脚本 脚本放置路径在zabbix_server.conf配置文件汇总AlertScriptsPath定义，默认路径为/usr/lib/zabbix/alertscripts/目录下 zabbix服务器调用脚本时可以传递三个参数 $1：经由此信道接受信息的目标 $2：subject $3：body （3）remote command执行远程命令 在agent所在的主机上运行用户指定的命令或脚本；如，重启服务、通过IPMI重启服务器、任何用户自定义脚本中定义的操作 注意：在agent执行远程命令时需要进行配置 a、zabbix用户拥有所需要执行命令的权限，编译/etc/sudoers配置文件 Defaults requiretty 关闭使用终端执行命令，这里需要在进程中执行命令 zabbix ALL（ALL） NOPASSWD：ALL 这里需要注意的是，如果要执行某种命令给定即可，越小权限越好；NOPASSWD必须给定，如果不给定的话执行命令需要输入命令，但是我们在进程中运行，显然这不是理想的结果，因此不需要输入密码。 b、agent进程要允许远程执行命令 编辑/etc/zabbix/zabbix_agentd.conf EnableRemoteCommands=1 设定允许远程执行 命令 LogRemoteCommands=1 执行命令记录日志中 notification（通知）：通过选定的媒介发送通知，例如email，wechat等 remote command（远程命令）：预定义的命令，可在被监控主机处于某特定条件下自动执行 告警升级：如果在设定的条件中，没有解决则向上一级发送通知 template（模板）：快速定义被监控主机的各监控项的预设项目集合 graph（图形）：用于展示历史数据或趋势数据的图像 screen（屏幕）：由多个graph组成 注意：zabbix执行过程为Host Group–&gt;Host–&gt;Application–&gt;Item–&gt;trigger–&gt;action，只有前一步发生才会执行下一步操作。 4、zabbix检查方式Zabbix agent可以执行被动和主动两种检方式，Zabbix Server执行的方式取决于Zabbix agent设定的方式 passive 在passive check模式中agent应答数据请求，Zabbix server询问agent数据，如CPU负载情况，然后返回给Zabbix agent结果 active Action check模式中，Zabbix agent首先从Zabbix server索取监控项列表进行独立处理，然后周期性地发送新的值给Zabbix server 宏预设的文本替换模式 级别：全局：Administation--&gt;Genersl--&gt;Macros 模板：编辑模板--&gt;Macros 主机：编辑主机--&gt;Macros 优先级主机 &gt; 模板 &gt; 全局 类型：内建：{MACRO_NAME} 自定义：{$MACRO_NAME} 命名方式：大写字母、数字和下划线 宏名称中允许使用以下字符：A-Z , 0-9 , _ , . Zabbix优先级解析宏（1）主机级别的宏（首先检查） （2）为主机的第一级别模板定义的宏（直接链接到主机的模板），按照模板ID来排序 （3）为主机的第二级别模板定义的宏等 （4）全局宏（最后检查） 用户自定义参数key格式： UserParameter=&lt;key&gt;,&lt;command&gt; 用户自定义key需要在代理端设置，设定完之后必须重启才能生效。 格式2： UserParameter=key[*],command key：唯一的监控项key；[*]定义该key接受括号内的参数 command：执行的命令 注意：可以使用命令中的位置引用监控项key中的相应参数。不管使用双引号还是单引号，都会解析位置引用。要使用位置引用不变，需使用”$$” 二、Zabbix安装使用创建仓库的方式安装。 地址为： 创建仓库[root@node4~]#yum install -y http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-2.el7.noarch.rpm 一台主机上安装 mariadb安装 由于Zabbix数据时存储在database中需要数据存放，这里安装mariadb [root@node4~]#yum install -y mariadb-server [root@node4~]#systemctl start mariadb.service 启动mariadb服务 [root@node4~]#mysql_secure_installation #基于安全考虑执行此命令，取出空密码等操作 MariaDB [(none)]&gt; CREATE DATABASE zabbix; #创建存放表的数据库 MariaDB [(none)]&gt; GRANT ALL ON zabbix.* TO &#39;zbxuser&#39;@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39;; #授权用户 [root@node4~]#yum install -y zabbix-server-mysql zabbix-web zabbix-web-mysql zabbix-agent zabbix-get zabbix-sender #安装所需要的包 包名 说明 zabbix-server-mysql 连接后端mysql包 zabbix-web zabbix的web展示接口 zabbix-server zabbix作为监控端提供服务程序包 zabbix-agent zabbix的agent用于做为客户端交互接口 zabbix-get zabbix的get工具，手动调试使用 zabbix-sender zabbix的sender工具，手动调试使用 zabbix中web是基于LAMP环境构建的，所以在安装时自动安装了所需要的包。如果分开安装需要先搭建LAMP环境。 初始化数据库 [root@node4~]#unzip /usr/share/doc/zabbix-server-mysql-3.4.4/create.sql.gz #解压 [root@node4~]#mysql -uroot -p zabbix &lt; /usr/share/doc/zabbix-server-mysql-3.4.4/create.sql #将表导入创建的数据库中 注意：这里需要制定导入数据库的名称。 zabbix_server.conf文件[root@node4~]#grep &#39;####&#39; /etc/zabbix/zabbix_server.conf ############ GENERAL PARAMETERS ################# 全局参数设置 ############ ADVANCED PARAMETERS ################ 高级参数设置 ####### LOADABLE MODULES ####### 模块设置 ####### TLS-RELATED PARAMETERS ####### 加密设置 [root@node4~]#grep &#39;###&#39; /etc/zabbix/zabbix_server.conf #可以查看每个块中的选项类型 [root@node4~]#vim /etc/zabbix/zabbix_server.conf #修改服务配置文件 ListenPort=10051 设置监听端口 SourceIP=192.168.4.64 绑定地址 LogFile=/var/log/zabbix/zabbix_server.log 日志文件位置 LogFileSize=0 日志文件大小 DebugLevel=3 日志级别 PidFile=/var/run/zabbix/zabbix_server.pid pid文件 SocketDir=/var/run/zabbix socket文件 DBHost=192.168.4.64 数据库主机 DBName=zabbix 数据库名 DBUser=zbxuser 数据库用户 DBPassword=centos 数据库密码 DBSocket=/tmp/mysql.sock 数据库socket文件 DBPort=3306 数据库端口 设置时区 方法一： 在/etc/php.ini配置文件中设置 date.timezone 这种方法设置对php程序都有效。方法二： 在/etc/httpd/conf.d/zabbix/conf配置文件中设置 php_value date.timezone 这种方法设置仅对zabbix程序有效。[root@node4~]#vim /etc/httpd/conf.d/zabbix.conf php_value date.timezone Asia/Shanghai [root@node4~]#systemctl start zabbix-server.service 启动服务 [root@node4~]#systemctl start httpd.service #启动httpd服务 测试http://192.168.4.64/zabbix/setup.php 出现这个界面初步已经搭建成功 如果配置不正确，有的选项会显示false。 这里填写创建数据库的名称，密码等 建议：登陆以后修改密码 分别在三台主机安装- 安装database[root@node3~]#yum install -y mariadb-server [root@node3~]#systemctl start mariadb.service [root@node3~]#mysql_secure_installation MariaDB [(none)]&gt; CREATE DATABASE zabbix; MariaDB [(none)]&gt; GRANT ALL ON zabbix.* TO &#39;zbxuser&#39;@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39;; 安装web GUI[root@node2~]#yum install -y httpd php php-mysql php-mbstring php-gd php-bcmath php-ldap php-xml [root@node2~]#yum install -y zabbix-web zabbix-sender [root@node2~]#vim /etc/httpd/conf.d/zabbix.conf php_value date.timezone Asia/Shanghai [root@node2~]#systemctl start httpd.service 安装server端[root@node1~]#yum install -y zabbix-server-mysql zabbix-get 创建表[root@node1~]#scp /usr/share/doc/zabbix-server-mysql-3.4.4/create.sql.gz 192.168.4.63:/root/test.sql.gz [root@node3~]#gzip -d test.sql.gz [root@node3~]#mysql -uroot -p zabbix &lt;test.sql 编辑zabbix_server.conf配置文件ListenPort=10051 LogFile=/var/log/zabbix/zabbix_server.log LogFileSize=0 DebugLevel=3 PidFile=/var/run/zabbix/zabbix_server.pid SocketDir=/var/run/zabbix DBHost=192.168.4.63 DBName=zabbix DBUser=zbxuser DBPassword=centos DBPort=3306 [root@node1~]#systemctl status zabbix-server.service 在地址栏输入：http://192.168.4.62/zabbix/ 图中信息介绍 Zabbix server is running Yes 192.168.4.61:10051 #显示zabbix是否正常运行以及IP及端口 Number of hosts (enabled/disabled/templates) 76 0 / 1 / 75 0：表示是否已经启用的主机 1：表示不可用的主机 75：表示模板数量 Number of items (enabled/disabled/not supported) 68 0 / 68 / 0 0：表示启用的监控项 68：没有启动的监控项 0：监控项是否不支持 Number of triggers (enabled/disabled [problem/ok]) 46 0 / 46 [0 / 0] 0：表示启动的触发器 46：未启用的触发器 [0/0]：表示状态 Number of users (online) 2 2 2：表示用户 Required server performance, new values per second 0 0：表示每秒的值 示例在node5上安装[root@node5~]#wget http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-2.el7.noarch.rpm[root@node5~]#rpm -ivh zabbix-release-3.4-2.el7.noarch.rpm [root@node5~]#yum install -y zabbix-agent zabbix-sender 编辑/etc/zabbix/zabbix_agent.conf配置文件PidFile=/var/run/zabbix/zabbix_agentd.pid #pid文件 LogFile=/var/log/zabbix/zabbix_agentd.log #日志存放位置 LogFileSize=0 #是否滚动日志 DebugLevel=3 #日志级别 SourceIP=192.168.4.65 #监听地址，如果有多个地址需要指定 EnableRemoteCommands=1 #是否启用远程命令 LogRemoteCommands=1 #是否记录执行的远程命令 Server=192.168.4.61 #Zabbix Server 地址 ListenPort=10050 #监听的端口 ListenIP=192.168.4.65 StartAgents=3 ServerActive=192.168.4.61 #是否主动监听 Hostname=node5 #Zabbix Agent主机名 创建一个主机（host） 定义一个item（监控项） 创建trigger[root@node5~]#vim /etc/nginx/nginx.conf 53 location /status { 54 stub_status on; 55 allow 192.168.4.0/24; 56 deny all; 57 } [root@node5~]#systemctl start nginx.service 定义action 如果在远程执行命令需要对zabbix用户给予权限。[root@node5~]#visudozabbix ALL=(ALL) NOPASSWOD: ALL 需要在agent端开启执行远程命令的选项[root@node5~]#vim /etc/zabbix/zabbix_agentd.conf EnableRemoteCommands=1 LogRemoteCommands=1 创建template #######下面的操作就和创建item、action、traggers等一样。 创建screen 创建slide show web监控web场景包括一个或多个HTTP请求或”步骤”。Zabbix服务器根据预定义的命令周期性的执行这些步骤。 所有web收集的数据：整个场景中所有步骤的下载速度 失败的步骤数量 最后一次错误信息 对于web场景的所有步骤收集的数据平均下载速度 响应时间 HTTP状态码 参考地址：https://www.zabbix.com/documentation/3.4/zh/manual/web_monitoring 网络发现Zabbix提供了有效和非常灵活的网络自动发现功能。包括发现（discovery）和动作（action） 优点：加快Zabbix部署 简化管理 无需过多管理就能快速变化的环境中使用Zabbix 网络发现方式IP范围 可用的外部服务 zabbix agent信息 snmp agetn信息 网络发现模块每次检测到service和host都会生成一个discovey时间||Service Discovered |服务首次被发现或者由’down’变’up’|Service Up |服务持续 ‘up’|Service Lost |服务由 ‘up’ 变 ‘down’|Service Down |服务持续 ‘down’|Host Discovered |在主机的所有服务都 ‘down’ 之后，至少一个服务是’up’。|Host Up |主机至少有一个服务是 ‘up’ 状态|Host Lost| 主机的所有服务在至少一个是 ‘up’ 之后全部是 ‘down’。|Host Down |所有服务都持续 ‘down’ 采取的动作发送通知 添加/删除主机 启用/禁用主机 添加主机到组 从组中删除主机 将主机链接到模板/从模板中取消链接 执行远程脚本命令 JMX监控JMX监控可用于监视java应用程序的JMX计数器。 为java应用程序启用远程JMX监视功能编辑/etc/sysconfig/tomcat配置文件 CATALINA_OPTS=&quot;-Djava.rmi.server.hostname=TOMCAT_SERVER_IP -Djavax.management.builder.initial= -Dcom.sun.management.jmxremote=true -Dcom.sun.management.jmxremote.port=12345 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false&quot; 在Zabbix Web管理段配置JMX接口JavaGateway=192.168.3.14 JavaGatewayPort=10052 StartJavaPollers=5 在Zabbix Web添加监控项jmx[&quot;java.lang:type=Memory&quot;,&quot;HeapMemoryUsage.used&quot;] object name 代表MBean的对象名称 attribute name 一个MBean属性名称，可选的符合数据字段名称以点分隔 示例： [root@node3~]#yum install -y zabbix-agent zabbix-sender [root@node3~]#yum install -y java-1.8.0-openjdk tomcat-admin-webapps tomcat-doc-webapp tomcat-webapps [root@node3~]#vim /etc/sysconfig/tomcat 28 CATALINA_OPTS=&quot;-Djava.rmi.server.hostname=192.168.4.63 -Djavax.management.builder.initial= -Dco m.sun.management.jmxremote=true -Dcom.sun.management.jmxremote.port=12345 -Dcom.sun.manageme nt.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false&quot; [root@node3~]#systemctl start tomcat.service[root@node3~]#systemctl status tomcat.service [root@node3~]#grep &#39;^[^#]&#39; /etc/zabbix/zabbix_agentd.conf PidFile=/var/run/zabbix/zabbix_agentd.pid LogFile=/var/log/zabbix/zabbix_agentd.log LogFileSize=0 DebugLevel=3 SourceIP=192.168.4.63 EnableRemoteCommands=1 LogRemoteCommands=1 Server=192.168.4.61 ListenPort=10050 ServerActive=192.168.4.61 Hostname=node3 [root@node3~]#systemctl start zabbix-agent.service[root@node3~]#systemctl status zabbix-agent.service Zabbix Server配置- [root@node1~]#yum install -y zabbix-java-gateway [root@node1~]#vim /etc/zabbix/zabbix_server.conf JavaGateway=192.168.4.61 JavaGatewayPort=10052 StartJavaPollers=5 [root@node1~]#systemctl start zabbix-java-gateway.service [root@node1~]#systemctl status zabbix-java-gateway.service 进行配置 导入模板即可Zabbix Proxyzabbix proxy可以替代zabbix server收集性能和可用性数据，然后把数据汇报给zabbix server，并且在一定程度上分担了zabbix server的压力。 zabbix proxy使用场景 监控远程区域设备 监控本地网络不稳定区域 当zabbix监控上千设备时，使用它来减轻server的压力 简化分布式监控的维护 注意：使用agent active模式，一定要在agent配置文件参数ServerActive加上proxy的IP地址。 示例： [root@node4~]#yum install -y zabbix-proxy-mysql zabbix-get zabbix-agent zabbix-sender [root@node4~]#yum install -y mariadb-server MariaDB [(none)]&gt; CREATE DATABASE zbxdb CHARACTER &#39;utf8&#39;; MariaDB [(none)]&gt; GRANT ALL ON zbxdb.* TO &#39;zbxuser&#39;@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39;; [root@node4~]#mysql -uroot -p zabbix &lt; test.sql [root@node4~]#grep &#39;^[^#]&#39; /etc/zabbix/zabbix_proxy.conf Server=192.168.4.61 ServerPort=10051 Hostname=node4 LogFile=/var/log/zabbix/zabbix_proxy.log LogFileSize=0 PidFile=/var/run/zabbix/zabbix_proxy.pid SocketDir=/var/run/zabbix DBHost=192.168.4.64 DBName=zbxdb DBUser=zbxuser DBPassword=centos DBPort=3306 ConfigFrequency=10 #根据实际生产中修改 DataSenderFrequency=1 [root@node4~]#systemctl restart zabbix-proxy.service[root@node4~]#systemctl status zabbix-proxy.service [root@node5~]#vim /etc/zabbix/zabbix_agentd.conf Server=192.168.4.61,192.168.4.64 ServerActive=192.168.4.61,192.168.4.64 需要在被代理主机上填入代理主机的地址 [root@node5~]#systemctl restart zabbix-agent.service SNMP示例： [root@node2~]#yum install -y net-snmp net-snmp-utils[root@node2~]#systemctl start snmpd.service[root@node2~]#systemctl status snmpd.service]]></content>
      <categories>
        <category>服务</category>
        <category>Zabbix</category>
        <category>Zabbix介绍</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zabbix基于微信告警]]></title>
    <url>%2F2017%2F11%2F28%2FZabbix%E5%9F%BA%E4%BA%8E%E5%BE%AE%E4%BF%A1%E5%91%8A%E8%AD%A6%2F</url>
    <content type="text"><![CDATA[在zabbix监控中，国内越来越流行使用微信、钉钉、邮件报警，这正式结合了当下的发展趋势。接下来介绍下zabbix如何结合微信发送警报信息。一、企业微信注册企业微信注册地址：https://work.weixin.qq.com/ 注意：我们需要记录以下几个值： Agentld Secret CorpID 部门ID 二、下载脚本[root@node1~]#wget https://www.guoxiangfu.com/wechat [root@node1~]#vim wechat 1 #!/usr/bin/env python #如果是python修改为python3 即可 2 # -*- coding: utf-8 -*- 3 ## File Name: wechat.sh 6 reload(sys) 7 sys.setdefaultencoding( &quot;utf-8&quot; ) 8 9 class WeChat(object): 10 __token_id = &apos;&apos; 11 # init attribute 12 def __init__(self,url): 13 self.__url = url.rstrip(&apos;/&apos;) 14 self.__corpid = &apos;你的Corpid&apos; 15 self.__secret = &apos;你的SecretID&apos; 16 17 # Get TokenID 18 def authID(self): 19 params = {&apos;corpid&apos;:self.__corpid, &apos;corpsecret&apos;:self.__secret} 20 data = urllib.urlencode(params) 21 22 content = self.getToken(data) 23 24 try: 25 self.__token_id = content[&apos;access_token&apos;] 26 # print content[&apos;access_token&apos;] 27 except KeyError: 28 raise KeyError 29 30 # Establish a connection 31 def getToken(self,data,url_prefix=&apos;/&apos;): 32 url = self.__url + url_prefix + &apos;gettoken?&apos; 33 try: 34 response = urllib2.Request(url + data) 35 except KeyError: 36 raise KeyError 37 result = urllib2.urlopen(response) 38 content = json.loads(result.read()) 39 return content 40 41 # Get sendmessage url 42 def postData(self,data,url_prefix=&apos;/&apos;): 44 request = urllib2.Request(url,data) 45 try: 46 result = urllib2.urlopen(request) 47 except urllib2.HTTPError as e: 48 if hasattr(e,&apos;reason&apos;): 49 print &apos;reason&apos;,e.reason 50 elif hasattr(e,&apos;code&apos;): 51 print &apos;code&apos;,e.code 52 return 0 53 else: 54 content = json.loads(result.read()) 55 result.close() 56 return content 57 58 # send message 59 def sendMessage(self,touser,message): 60 61 self.authID() 62 63 data = json.dumps({ 64 &apos;touser&apos;:touser, 65 &apos;toparty&apos;:&quot;2&quot;, #这个相当于刚刚记录的部门ID 66 &apos;msgtype&apos;:&quot;text&quot;, 67 &apos;agentid&apos;:&quot;2&quot;, #修改为刚刚记录的agentid 68 &apos;text&apos;:{ 69 &apos;content&apos;:message 70 }, 71 &apos;safe&apos;:&quot;0&quot; 72 },ensure_ascii=False) 73 74 response = self.postData(data) 75 print response 76 77 78 if __name__ == &apos;__main__&apos;: 79 a = WeChat(&apos;https://qyapi.weixin.qq.com/cgi-bin&apos;) 80 a.sendMessage(sys.argv[1],sys.argv[3]) ##修改权限，所有者、所属组[root@node1~]#chmod +x wechat[root@node1~]#chown zabbix.zabbix wechat ##验证是否可以发送成功[root@node1~]#./wechat zabbix test test {u&apos;invaliduser&apos;: u&apos;zabbix&apos;, u&apos;errcode&apos;: 0, u&apos;errmsg&apos;: u&apos;ok&apos;} 到此我们就配置好了。 Zabbix配置查看存放的脚本[root@node1~]#grep &quot;AlertScriptsPath&quot; /etc/zabbix/zabbix_server.conf ### Option: AlertScriptsPath # AlertScriptsPath=${datadir}/zabbix/alertscripts AlertScriptsPath=/usr/lib/zabbix/alertscripts [root@node1~]#mv wechat /usr/lib/zabbix/alertscripts/ 在地址栏输入：http://192.168.4.61/zabbix/zabbix.php?action=mediatype.edit 发送警报信息内容：故障恢复信息：服务器:{HOST.NAME}: {TRIGGER.NAME}已恢复! { &quot;告警主机&quot;:&quot;{HOST.NAME}&quot;, &quot;告警地址&quot;:&quot;{HOST.IP}&quot;, &quot;告警时间&quot;:&quot;{EVENT.DATE} {EVENT.TIME}&quot;, &quot;恢复时间&quot;:&quot;{EVENT.RECOVERY.DATE} {EVENT.RECOVERY.TIME}&quot;, &quot;告警等级&quot;:&quot;{TRIGGER.SEVERITY}&quot;, &quot;告警信息&quot;:&quot;{TRIGGER.NAME}&quot;, &quot;监控项目&quot;:&quot;{ITEM.NAME}&quot;, &quot;当前状态&quot;:&quot;{TRIGGER.STATUS}&quot;, &quot;持续时间&quot;:&quot;{EVENT.AGE}&quot;, &quot;事件ID&quot;:&quot;{EVENT.ID}&quot;, &quot;监控ID&quot;:&quot;{ITEM.ID}&quot;, &quot;监控取值&quot;:&quot;{ITEM.LASTVALUE}&quot; } 发生故障发送的信息服务器:{HOST.NAME}发生: {TRIGGER.NAME}故障! { &quot;告警主机&quot;:&quot;{HOST.NAME}&quot;, &quot;告警地址&quot;:&quot;{HOST.IP}&quot;, &quot;告警时间&quot;:&quot;{EVENT.DATE} {EVENT.TIME}&quot;, &quot;告警等级&quot;:&quot;{TRIGGER.SEVERITY}&quot;, &quot;告警信息&quot;:&quot;{TRIGGER.NAME}&quot;, &quot;监控项目&quot;:&quot;{ITEM.NAME}&quot;, &quot;当前状态&quot;:&quot;{TRIGGER.STATUS}&quot;, &quot;持续时间&quot;:&quot;{EVENT.AGE}&quot;, &quot;事件ID&quot;:&quot;{EVENT.ID}&quot;, &quot;监控ID&quot;:&quot;{ITEM.ID}&quot;, &quot;监控取值&quot;:&quot;{ITEM.LASTVALUE}&quot; } 测试 小结（1）使用微信告警，必须有CorpID、AgentId和Secret。这是建立与微信通信的措施。 （2）创建过程中，建议每一步都要测试是否成功，再进行下一步。 （3）可以指定多个用户接受信息。]]></content>
      <categories>
        <category>服务</category>
        <category>Zabbix</category>
        <category>Zabbix基于微信告警</category>
      </categories>
      <tags>
        <tag>zabbix，微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible初级认识]]></title>
    <url>%2F2017%2F11%2F28%2Fansible%E5%88%9D%E7%BA%A7%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[一、ansible介绍1、概念ansible是自动化运维工具，基于Python开发，集合了众多的运维工具的优先，实心了批量系统配置、批量程序部署、批量运行命令等功能。 2、特性 模块化：调用特定的模块完成特定的任务 基于Python语言实现，由Paramiko、PyYAML和Jinja2三个关闭模块 部署简单，agentless 支持自定义模块 支持playbook 3、ansible工作原理 由图中我们可以看出ansible的组成结构： Host Inventory ：主机库设置 Playbook：剧本，按照事先设定的顺序完成安排的任务 Core Modules：核心模块 Custom Modules：自定义模块 Connection Plugins：连接插件，一般基于ssh连接，加密传输，相对安全。 后面的Host1、Host2等都是在Host Inventory定义的主机。 用户通过命令执行，Ansible使用ssh等方式连接到Host Inventory定义的主机；执行事先好的Playbook，调用Core Modules或Custom Modules等完成任务。 4、ansible安装[root@localhost~]#yum install -y ansible 由于ansible是由Python开发，所以依赖于有关Python包，需要epel源环境。 配置文件 主配置文件：/etc/ansible/ansible.cfg 设置主机清单：/etc/ansible/hosts 定义格式： 定义单个主机： green.example.com blue.example.com 192.168.100.1 192.168.100.10 定义一组主机 [webservers] alpha.example.org beta.example.org 192.168.1.100 192.168.1.110 如果有一组主机格式相同可以使用如下格式： www[001:006].example.com 如果一个主机属于多个组可以写入不同的组中。 设置角色路径：/etc/ansible/roles 定义每个角色时，均需在此目录创建目录，在新创建的目录下创建目录： files/：存放由copy或script模块等调用的文件 templates/：template模块查找所需要的模板文件的目录，文件均需以“.j2”结尾 tasks/：定义任务的目录；至少应该包含一个名为main.yml的文件，其他的文件需要在此文件中通过include进行包含 handlers/：定义触发条件的目录；至少应该包含一个名为main.yml的文件，其他的文件需要通过include进行包含 vars/：定义变量的目录；至少应该包含一个名为main.yml文件，其他的文件需要在此文件中通过include进行包含 meta/：定义元数据目录；至少应该包含一个名为main.yml的文件，定义当前角色的特殊设定及其依赖关系；其他的文件需要在此文件中通过include进行包含。 default/：设定默认值变量时使用此目录的main.yml文件 命令介绍（1）ansible - run a task on a target host(s) 是一个额外简单的tool/framework/API管理远程主机。允许运行一个简单的任务剧本的adhoc命令。 使用格式: ansible &lt;host-pattern&gt; [-m module_name] [-a args] [options] # 选项 说明 -a ‘ARGUMENTS’, –args=’ARGUMENTS’ 设定参数 -C, –check 在远程不做任何修改，相当于干跑 -c CONNECTION, –connection=CONNECTION 指定使用的连接类型，如ssh、winrm和local，默认为ssh -e EXTRA_VARS, –extra-vars=’EXTRA_VARS 指定额外的变量插入到剧本中，变量需要使用“‘’”引起来，并且命令行的优先级大于剧本中变量的优先级 -f NUM, –forks=NUM 指定并行级别。默认为5 -i PATH, –inventory=PATH 指定主机库，默认为/etc/ansible/hosts –list-hosts 列出指定主机 -m NAME, –module-name=NAME 指定模块名称，默认为command模块 -M DIRECTORY, –module-path=DIRECTORY 指定模块路径，默认为/usr/share/ansible -o, –one-line 输出信息在一行 -u USERNAME, –user=USERNAME 设定连接主机的名称，默认为root （2） ansible-doc - show documentation on Ansible modules显示模块信息 使用格式： ansible-doc [-M module_path] [-l] [-s] [module...] # 选项 说明 -M DIRECTORY, –module-path=DIRECTORY 指定模块路径，默认为/usr/share/ansible -s, –snippet= 列出模块使用方法 -l, –list= 列出所有模块信息 （3）ansible-playbook - run an ansible playbook管理剧本 使用格式： ansible-playbook &lt;filename.yml&gt; ... [options] # 选项 说明 -C, –check 检查脚本是否正确 -c CONNECTION, –connection=CONNECTION 连接使用的方法 -e EXTRA_VARS, –extra-vars=EXTRA_VARS 设定变量 –list-tasks 列出任务 –list-tags 列出标签 –list-hosts 列出主机]]></content>
      <categories>
        <category>自动化运维工具</category>
        <category>ansible</category>
        <category>ansible初级认识</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>playbook</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible中playbook]]></title>
    <url>%2F2017%2F11%2F28%2Fansible%E4%B8%ADplaybook%2F</url>
    <content type="text"><![CDATA[Playbook1、Playbook核心元素 Hosts：运行指定任务的目标主机 remote_user：在远程主机上执行任务的用户 sudo_user：切换用户 Tasks：任务列表 格式： （1）action：module argument （2）module：arguments 注意：shell和command模块后面直接跟命令，而不是key:value的参数列表 Variables：变量 （1）facts：可直接调用的变量 可以使用ansible HOSTS -m setup查看 （2）用户自定义的变量 （a）在命令行中指定使用 -e ARGS或--extra-vars=VARS （b）在playbook中定义变量的方法 vars： - var1：values1 - var2：values2 ... （3）通过roles传递变量 （4）Host Inventory （a）用户自定义变量 向不同主机传递不同的变量： IP/HOSTNAME variable=value var1=vaule1 向组中的主机传递相同的变量可以定义成一个组,可以引用多次 [groupname:vars] variable=value （b）invertory参数 用于定义ansible远程连接目标主机时使用的参数，而非传递给playbook的变量 ansible_ssh_host ansible_ssh_port ansible_ssh_user ansible_ssh_pass ansbile_sudo_pass 变量引用方法： Template：模板文件 注意文件名必须以“j2”结尾。 格式说明： 字符串：使用单引号或双引号 数字：整数、浮点数 列表：[item1,item2..] 元组：（item1，item2...） 字典：{key1:values1,key2:value2...} 布尔型：true/false 算数运算：+ - / *% ** 逻辑运算：and or not Handers：由特定触发的任务 当某个文件参数修改时，这样我们修改了但是并不会立即生效；有没有一个办法当我们修改以后如果某个参数只修改这个文件呢？ notify和tags就是帮我们解决这个问题的。notify通知给相应的handler被触发；tags指定某个服务重启。 条件测试有时我们管理的主机会使不同版本的服务器，每类型服务的执行的命令有些不同，这时就需要条件判断执行。 when语句：在task中使用，jinja2的语法格式 - hosts: websrvs remote_user: root tasks: - name: install conf file to centos7 template: src=/root/nginx.conf.j2 dest=/etc/nginx/nginx.conf when: ansible_distribution_major_version == &quot;7&quot; - name: install conf file to centos6 template: src=/root/nginx.conf2.j2 dest=/etc/nginx/nginx.conf when: ansible_distribution_majoe_version == &quot;6&quot; 循环迭代，需要重复执行的任务 对迭代项的引用，固定变量名为“item”，要在task中使用with_items给定要迭代的元素列表 方式一： name: install some packageyum: name= state=presentwith_items： nginx memcache php-fpm 方式二： name: add some usersuser: name= group= state=presentwith_items: { name: ‘user1’,group: ‘group1’ } { name: ‘user2’,group: ‘group2’ } 在playbook调用角色方法一： - hosts: websrvs remote_user: root roles: - mysql - memcached - nginx 在playbook调用角色方法二： hosts: websrsremote_user: rootroles: { role:nginx, username: nignx } 键role用于指定角色名称，后续的k/v用于传递变量给角色]]></content>
      <categories>
        <category>自动化运维工具</category>
        <category>ansible</category>
        <category>ansible中playbook</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>playbook</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible模块]]></title>
    <url>%2F2017%2F11%2F28%2Fansible%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[常用模块介绍ansible中执行命令时，必须考虑其幂等性；即返回的结果不是错误的。如果一个文件存在则不再创建等等情况。 （1）command模块：在远程节点执行命令，此模块为默认模块 action 说明 chdir 执行命令切换工作目录至指定位置 creates 如果此处给定的文件或目录存在，则不执行命令 remove 如果给定的文件后目录不存在，则不执行命令；即存在才执行此命令 示例： [root@localhost~]#ansible all -m command -a &quot;pwd chdir=/etc/&quot; [root@localhost~]#ansible all -m command -a &quot;pwd chdir=/etc/ansible creates&quot; （2）shell模块：执行命令在节点上。 这个模块解决了echo等情况的问题，如果给一个用户添加密码执行如下指令会报错： [root@localhost~]#ansible all -m command -a &quot;echo test | passwd --stdin test&quot; 因此shell解决了这个问题，支持管道传输命令。 action 说明 chdir 在执行命令前切换目录 creates 如果一个文件已经存在则不执行命令 removes 如果一个给定的文件不存在则不执行命令 excutable 指定运行命令使用的shell解释器 [root@localhost~]#ansible all -m command -a &quot;useradd joah &quot; [root@localhost~]#ansible all -m shell -a &quot;echo centos |passwd --stdin joah&quot; （3）copy模块：复制文件到远程主机 action 说明 dest 指定远程绝对路径 group 设置文件的所属组 mode 设置文件的权限 owner 设置文件的所有者 src 设定本地的文件路径，可以使用相对路径也可以使用绝对路径 content 指定复制的内容 [root@localhost~]#ansible all -m copy -a &quot;src=&#39;/etc/hosts&#39; dest=/root/hosts group=joah owner=joah mode=644 &quot; [root@localhost~]#ansible all -m copy -a &quot;context=&#39;hello ansible&#39; dest=/tmp owner=joah group=joah mode=666&quot; 这种使用方法需要在template中使用 （4）fetch模块：把远程文件复制到本地，此时只能点对点复制 action 说明 dest 目标地址 src 源文件路径或文件 [root@localhost~]#ansible 192.168.4.61 -m fetch -a &quot;src=&#39;/etc/fstab&#39; dest=&#39;/root/&#39;&quot; （5）file模块：设置文件属性 action 说明 group 设置所属组 mode 设置权限 owner 设置所有者 path 要修改文件的路径 src 原文件路径 state 如果为link设置软连接；如果是hard设置硬链接；如果是absent，如果存在则删除；如果为touch，如果要创建的文件不存在则创建一个空文件； 示例： [root@localhost~]#ansible all -m file -a &quot;path=/root/test1 state=directory&quot; 创建目录 [root@localhost~]#ansible all -m file -a &quot;path=/root/test1/hidb state=touch&quot; 创建空文件 [root@localhost~]#ansible all -m file -a &quot;path=/root/host src=/root/test1/hidb state=link&quot; 创建软连接 [root@localhost~]#ansible all -m file -a &quot;path=/root/host src=/root/test1/hidb state=absent&quot; 删除软连接 （6）user模块：管理用户账户 action 说明 name 用户名 password 设置用户的密码 createhome 是否创建家目录 local 设定时区 system 是否设置为系统用户 uid 指定uid shell 设置使用的shell类型 group 设置组 groups 设置附加组 comment 添加注释信息 home 指定家目录位置 注意：如果用户的属性修改可以直接执行命令修改 示例： [root@localhost~]#ansible all -m user -a &quot;name=hello password=centos createhome=yes system=no shell=/sbin/nologin &quot; （7）group模块：管理组 action 说明 gid 设置组ID name 设置组名 state 如果present，如果用户存在则不创建，如果absent，用户删除时需存在组 system 是否创建系统用户 示例： [root@localhost~]#ansible all -m group -a &quot;name=hi gid=1005 state=present&quot; 创建组 [root@localhost~]#ansible all -m group -a &quot;name=hi state=absent&quot; 删除用户 （8）get_url：下载文件从HTTP、HTTPS、或者FTP到节点上 action 说明 checksum 是否检查 dest 目标地址 force no，如果目标路径存在且为空则下载；yes如果目标不是目录则覆盖原来的文件 url 指定url url_password 如果下载链接需要使用密码则给定 url_username 如果下载链接需要使用用户则给定 use_proxy 如果为no则不使用代理 示例： [root@localhost~]#ansible all -m get_url -a &quot;url=https://www.percona.com/downloads/percona-toolkit/3.0.4/binary/redhat/7/x86_64/percona-toolkit-3.0.4-1.el7.x86_64.rpm dest=/root&quot; （9）hostname模块：管理主机名 action 说明 name 主机名称 示例： [root@localhost~]#ansible 192.168.4.61 -m hostname -a &quot;name=node6&quot; （10）pip模块：Manages Python library dependencies.管理Python库依赖关系 action 说明 chdir 切换目录 state forcereinstall是否强制重装 （11）yum模块：管理yum包 action 说明 name 包名 state 是否安装；present、installed和latest表示安装；remove、absent和remove表示卸载 list 列出 示例： [root@localhost~]#ansible all -m yum -a &quot;name=nginx state=latest&quot; （12）service模块：管理服务 action 说明 arguments 添加参数 enabled 是否设置为开启启动 name 服务名 state started启动；stopped停止；restarted重启； runlevel 设定运行级别 示例： [root@localhost~]#ansible all -m service -a &quot;name=nginx state=started enabled=yes&quot; （13）git模块：部署软件从git导出 action 说明 repo 仓库路径 dest 目标路径 version 版本 示例： [root@localhost~]#ansible all -m git -a &quot;repo=https://github.com/mbdavid/FileDB.git dest=/root/test1&quot; （14）haproxy模块：管理代理 action 说明 backend 代理后端池 host 修改后端主机名称 state 后端主机状态 weight 设置权重 （15）cron模块：管理计划任务 action 说明 minute 设定分钟，0-59, , /2, month 设定月份， 1-12, , /2, name 计划任务名称， hour 设定小时 day 设置天 job 设定任务 disabled 是否禁用任务 state 如果为present则创建，如果为absent删除 注意：若果name没有设置并且state=present，如果一个新的任务创建，将覆盖原来的任务 示例： [root@localhost~]#ansible all -m cron -a &quot;name=test job=&#39;ntpdate 172.18.0.1 &amp;&gt; /dev/null&#39; hour=*/2&quot; （16）setup模块：收集远程主机信息]]></content>
      <categories>
        <category>监控工具</category>
        <category>ansible</category>
        <category>ansible模块</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>自动化</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible示例]]></title>
    <url>%2F2017%2F11%2F28%2Fansible%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[完整示例-安装httpd并配置（1）方式一： 创建目录[root@localhost/etc/ansible/roles]#mkdir -pv http/{tasks,templates,files,handlers,vars,meta,default} 创建task文件[root@localhost/etc/ansible/roles/http]#vim tasks/main.yml 1 - name: install package httpd 2 yum: name=nginx state=latest 3 - name: create webdoc 4 file: path={{ http_doc_root }} state=directory 5 - name: service httpd service 6 service: name=nginx state=started 7 - name: configure httpd conf 8 template: src=httpd.conf.j2 dest=/etc/httpd/conf.d/ 9 tags: httpconf 10 notify: reload httpd 创建handler文件[root@localhost/etc/ansible/roles/http]#vim handlers/main.yml 1 - name: relad httpd 2 service: name=httpd state=reloaded 创建vars文件[root@localhost/etc/ansible/roles/http]#vim vars/main.yml 1 http_server_port: 8080 2 http_server_name: www.test.com 3 http_doc_root: /webdate 创建template文件[root@localhost/etc/ansible/roles/http]#vim templates/httpd.conf.j2 1 listen {{ http_server_port }} 2 ServerName {{ http_server_name }} 3 DocumentRoot {{ http_doc_root }} 4 &lt;Directory {{ http_doc_root }}&gt; 5 Require all granted 6 &lt;/Directory&gt; 创建剧本[root@localhost/etc/ansible]#vim http.yml 1 - hosts: websrvs 2 remote_user: root 3 roles: 4 - http 测试[root@localhost~]#ansible-playbook /etc/ansible/http.yml 实战：基于msm的tomcat集群- 实验环境 主机名 IP 安装的包 node1 192.168.4.61 nginx、keepalived node2 192.168.4.62 nginx、keepalived node3 192.168.4.63 tomcat、tomcat-docs-webapp、tomcat-webapps、tomcat-adim-webapps、java-1.8.0-openjdk、memcached-session-manager-2.1.1.jar 、memcached-session-manager-tc7-2.1.1.jar、spymemcached-2.12.3.jar 、msm-javolution-serializer-2.1.1.jar 、javolution-5.4.3.1 node4 192.168.4.64 tomcat、tomcat-docs-webapp、tomcat-webapps、tomcat-adim-webapps、java-1.8.0-openjdk、memcached-session-manager-2.1.1.jar 、memcached-session-manager-tc7-2.1.1.jar、spymemcached-2.12.3.jar 、msm-javolution-serializer-2.1.1.jar 、javolution-5.4.3.1 node5 192.168.4.65 ansible、memcached 基于ssh密钥认证[root@node5~]#vim ssh.sh 1 #!/bin/bash 2 [ ! -f /root/.ssh/id_rsa.pub ] &amp;&amp; ssh-keygen -t rsa -P &apos;&apos; &amp;&gt; /dev/null 3 while read line;do 4 expect &lt;&lt; EOF 5 spawn ssh-copy-id -i /root/.ssh/id_rsa.pub root@$line 6 expect { 7 &quot;yes/no&quot; { send &quot;yes\n&quot;;exp_continue } 8 &quot;password&quot; { send &quot;magedu\n&quot; } 9 } 10 expect eof 11 EOF 12 13 done &lt; /root/ip.txt [root@node5~]#vim ip.txt 1 192.168.4.61 2 192.168.4.62 3 192.168.4.63 4 192.168.4.64 5 192.168.4.65 [root@node5~]#chmod +x ssh.sh ansible中修改主机库文件[root@node5~]#vim /etc/ansible/hosts 25 [nginx-keep] 26 192.168.4.61 27 192.168.4.62 28 [tomcat-cluster] 29 192.168.4.63 30 192.168.4.64 31 [memcached] 32 192.168.4.65 同步时间[root@node5/etc/ansible]#vim ntp.yml 1 - hosts: all 2 remote_user: root 3 tasks: 4 - name: sync time 5 command: ntpdate 172.18.0.1 6 - name: chrony conf 7 file: src=/etc/chrony.conf dest=/etc/chrony.conf 8 tags: chrony 9 notify: restart chronyd.service 10 - name: start chrony 11 service: name=chronyd state=started 12 handlers: 13 - name: restart chronyd.service 14 service: name=chronyd state=restarted [root@node5~]#vim /etc/chrony.conf 7 server 172.18.0.1 iburst [root@node5/etc/ansible]#ansible-playbook --syntax-check ntp.yml #检测语法是否正确 注意：由于yaml格式对于初学者来说有一定的坑，需要严格按照格式写。[root@node5/etc/ansible]#ansible-playbook ntp.yml #语法检测没有问题后，执行剧本 温馨提示：为了以后不必要的错误，建议没此执行完以后，都要确认是否执行正确后再进行下一步基于主机名解析[root@node5/etc/ansible]#ansible all -m copy -a &quot;src=/etc/hosts dest=/etc/hosts&quot; 挂载光盘[root@node5~]#ansible all -m mount -a &quot;name=/media/cdrom src=/dev/sr0 state=mounted fstype=iso9660&quot; 配置nginx角色 创建所需要的目录 [root@node5/etc/ansible/roles]#mkdir haproxy/{tasks,handler,files,templates,vars,default,meta} -pv 创建任务文件 [root@node5/etc/ansible/roles/haproxy]#vim tasks/main.yml 1 - name: install haproxy package 2 yum: name=haproxy state=latest 3 - name: modify haproxy conf 4 template: src=haproxy.cfg.j2 dest=/etc/haproxy/haproxy.cfg 5 tags: haproxy 6 notify: haproxy restart 7 - name: start haproxy service 8 service: name=haproxy state=started 9 handlers: 10 - name: haproxy restart 11 service: name=haproxy state=restarted 创建模板文件 [root@node5/etc/ansible/roles/haproxy]#cp /etc/haproxy/haproxy.cfg templates/haproxy.cfg.j2 42 defaults 43 mode http 44 log global 45 option httplog 46 option dontlognull 47 option http-server-close 48 option forwardfor except 127.0.0.0/8 43 mode http 44 log global 45 option httplog 46 option dontlognull 47 option http-server-close 48 option forwardfor except 127.0.0.0/8 49 option redispatch 50 retries 3 51 timeout http-request 10s 52 timeout queue 1m 53 timeout connect 10s 54 timeout client 1m 55 timeout server 1m 56 timeout http-keep-alive 10s 57 timeout check 10s 58 maxconn 3000 59 60 frontend tomcat #定义前段并指定名称 61 bind 172.18.4.60:{{ tomcat_server_port }} #绑定地址和端口 62 63 backend tomcat-cluster #定义后端服务 64 balance roundrobin 65 server node3 192.168.4.63 check 66 server node4 192.168.4.64 check 67 listen #定义管理界面 68 bind 127.0.0.1:9000 69 stats enable 70 stats uri /stats 71 stats auth joah:centos 72 stats relam &quot;tomcat&quot; 73 stats hide-version 74 stats refresh 10s 75 stats admin if TRUE 注意：模板文件必须以“j2”结尾。 创建变量文件 [root@node5/etc/ansible/roles/haproxy]#vim vars/main.yml 1 tomcat_server_port: 80 创建触发文件 [root@node5/etc/ansible/roles/haproxy]#vim handlers/main.yml 1 - name: haproxy restart 2 service: name=haproxy state=restarted 注意：创建tasks、templates、vars文件时必须以main.yml文件为入口，如果定义别的文件使用include指定即可。 添加IP[root@node5/etc/ansible/roles/haproxy]#ansible tomcat-cluster -m shell -a &quot;ip addr add 192.168.4.60/24 dev eth0 &quot; 创建keepalived角色 创建所需目录 [root@node5/etc/ansible/roles]#mkdir keepalived/{tasks,handler,files,templates,vars,default,meta} -pv 创建任务文件 [root@node5/etc/ansible/roles/keepalived]#vim tasks/main.yml 1 - name: install keepalived package 2 yum: name=keepalived state=latest 3 - name: modify keepalived conf 4 template: src=keepalived.conf.j2 dest=/etc/keepalived/keepalived.conf 5 when: ansible_hostname == &quot;node1&quot; 6 notify: keepalived reloaded 7 tags: keepalived 8 - name: modify keepalived conf 9 template: src=keepalived.conf.j2 dest=/etc/keepalived/keepalived.conf 10 when: ansible_hostname == &quot;node2&quot; 11 notify: keepalived reloaded 12 tags: keepalived 13 - name: start keepalived 14 service: name=keepalived state=started 创建触发文件 [root@node5/etc/ansible/roles/keepalived]#vim handlers/main.yml 1 - name: keepalived reloaded 2 service: name=keepalived state=reloaded 创建模板文件 [root@node5/etc/ansible/roles/keepalived]#vim templates/keepalived.conf.j2 #创建master 1 ! Configuration File for keepalived 2 3 global_defs { 4 notification_email { 5 locahost@qq.com 6 } 7 notification_email_from haproxy@qq.com 8 smtp_server 127.0.0.1 9 smtp_connect_timeout 30 10 router_id node3 11 route_mcast_group4 224.0.100.4 12 vrrp_strict chk_haproxy { 13 script &quot;killall -0 haporxy&quot; 14 interval 3 15 weight -15 16 } 17 } 18 19 vrrp_instance VI_1 { 20 state MASTER 21 interface eth0 22 virtual_router_id 4 23 priority 100 24 advert_int 1 25 authentication { 26 auth_type PASS 27 auth_pass 152369 28 } 29 virtual_ipaddress { 172.18.4.60/16 32 } 33 track_script { 34 chk_haproxy 35 } 36 } [root@node5/etc/ansible/roles/keepalived]#cp templates/keepalived.conf.j2 templates/keepalived.conf2.j2 创建backup 1 ! Configuration File for keepalived 2 3 global_defs { 4 notification_email { 5 locahost@qq.com 6 } 7 notification_email_from haproxy@qq.com 8 smtp_server 127.0.0.1 9 smtp_connect_timeout 30 10 router_id node2 11 route_mcast_group4 224.0.100.4 12 vrrp_strict chk_haproxy { 13 script &quot;killall -0 haporxy&quot; 14 interval 3 15 weight -15 16 } 17 } 18 19 vrrp_instance VI_1 { 20 state BACKUP 21 interface eth0 22 virtual_router_id 4 23 priority 90 24 advert_int 1 25 authentication { 26 auth_type PASS 27 auth_pass 152369 28 } 29 virtual_ipaddress { 172.18.4.60/16 32 } 33 track_script { 34 chk_haproxy 35 } 36 } 注意： （1）master和backup中priority、state需要修改，其他的配置不需要修改。 （2）如果使用auth_type认证，需要双方auth_pass必须相同 （3）如果你想使用脚本检测，vrrp_script可以指定脚本位置/PATH/TO/SCRIPT.sh 创建tomcat角色 创建所需要的目录 [root@node5/etc/ansible/roles]#mkdir tomcat/{tasks,handlers,files,templates,vars,default,meta} -pv 创建tomcat任务 [root@node5/etc/ansible/roles/tomcat]#vim tasks/main.yml 1 - name: install tomcat package 2 yum: name={{ item }} state=latest 3 with_items: 4 - java-1.8.0-openjdk 5 - tomcat 6 - tomcat-docs-webapp 7 - tomcat-admin-webapps 8 - tomcat-webapps 9 - memcached 10 - name: modify tomcat conf 11 template: src=server.xml.j2 dest=/etc/tomcat/server.xml 12 notify: tomcat reload 13 tags: tomcat 14 - name: kryo jar 15 copy: src=/root/{{ item }}.jar dest=/usr/share/tomcat/lib/ 16 with_items: 17 - asm-6.0 18 - kryo-4.0.1 19 - kryo-serializers-0.42 20 - memcached-session-manager-2.1.1 21 - memcached-session-manager-tc7-2.1.1 22 - minlog-1.3.0 23 - msm-kryo-serializer-2.1.1 24 - objenesis-2.6 25 - reflectasm-1.11.3 26 - spymemcached-2.12.3 27 - name: start tomcat 28 service: name=tomcat state=started 29 - name: mkdir directory 30 file: path=/usr/share/tomcat/webapps/test state=directory 31 - name: touch file 32 file: path=/usr/share/tomcat/webapps/test/{{ item }} state=touch 33 with_items: 34 - WEB-INF 35 - classes 36 - lib 37 - name: copy index.jsp 38 copy: src=index.jsp.j2 dest=/usr/share/tomcat/webapps/index.jsp 39 when: ansible_hostname == &quot;node3&quot; 40 notify: tomcat reload 41 tags: tomcat 42 - name: copy index.jsp 43 copy: src=index2.jsp.j2 dest=/usr/share/tomcat/webapps/index.jsp 44 when: ansible_hostname == &quot;node4&quot; 45 notify: tomcat reload 46 tags: tomcat 创建模板文件 [root@node5/etc/ansible/roles/tomcat/templates]#vim server.xml.j2 126 &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; 127 unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt; 128 &lt;Context path=&quot;&quot; docBase=&quot;test&quot; reloadable=&quot;&quot; /&gt; 129 &lt;Context&gt; 130 &lt;Manager className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot; 131 memcachedNodes=&quot;n1:192.168.4.63:11211,n2:192.168.4.64:11211&quot; #指定位置 132 failoverNodes=&quot;n1&quot; 133 requestUriIgnorePattern=&quot;.*\.(ico|png|gif|jpg|css|js)$&quot; 134 transcoderFactoryClass=&quot;de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory&quot; 135 /&gt; 136 &lt;/Context&gt; [root@node5/etc/ansible/roles/tomcat/templates]#vim index.jsp.j2 1 &lt;%@ page language=&quot;java&quot; %&gt; 2 &lt;html&gt; 3 &lt;head&gt;&lt;title&gt;TomcatA&lt;/title&gt;&lt;/head&gt; 4 &lt;body&gt; 5 &lt;h1&gt;&lt;font color=&quot;red&quot;&gt;TomcatA.test.com&lt;/font&gt;&lt;/h1&gt; 6 &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt; 7 &lt;tr&gt; 8 &lt;td&gt;Session ID&lt;/td&gt; 9 &lt;% session.setAttribute(&quot;test.com&quot;,&quot;test.com&quot;); %&gt; 10 &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt; 11 &lt;/tr&gt; 12 &lt;tr&gt; 13 &lt;td&gt;Created on&lt;/td&gt; 14 &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt; 15 &lt;/tr&gt; 16 &lt;/table&gt; 17 &lt;/body&gt; 18 &lt;/html&gt; [root@node5/etc/ansible/roles/tomcat/templates]#vim index2.jsp.j2 1 &lt;%@ page language=&quot;java&quot; %&gt; 2 &lt;html&gt; 3 &lt;head&gt;&lt;title&gt;TomcatB&lt;/title&gt;&lt;/head&gt; 4 &lt;body&gt; 5 &lt;h1&gt;&lt;font color=&quot;blue&quot;&gt;TomcatB.test.com&lt;/font&gt;&lt;/h1&gt; 6 &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt; 7 &lt;tr&gt; 8 &lt;td&gt;Session ID&lt;/td&gt; 9 &lt;% session.setAttribute(&quot;test.com&quot;,&quot;test.com&quot;); %&gt; 10 &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt; 11 &lt;/tr&gt; 12 &lt;tr&gt; 13 &lt;td&gt;Created on&lt;/td&gt; 14 &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt; 15 &lt;/tr&gt; 16 &lt;/table&gt; 17 &lt;/body&gt; 18 &lt;/html&gt; 编辑触发文件 [root@node5/etc/ansible/roles/tomcat]#vim handlers/main.yml 1 - name: tomcat reload 2 service: name=tomcat state=reloaded 编辑剧本 [root@node5/etc/ansible]#vim tomcat.yml 1 - hosts: nginx-keep 2 remote_user: root 3 roles: 4 - keepalived 5 - haproxy 6 - hosts: tomcat-cluster 7 remote_user: root 8 roles: 9 - tomcat]]></content>
      <categories>
        <category>自动化运维工具</category>
        <category>ansible</category>
        <category>ansible示例</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>自动化</tag>
        <tag>示例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dig、nslookup等工具]]></title>
    <url>%2F2017%2F11%2F28%2Fdig%E3%80%81nslookup%E7%AD%89%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[管理命令1、dig命令作用：只能用于测试DNS系统，不会查询hosts文件进行解析。 格式： dig [@server] [-b address] [-c class] [-f filename] [-k filename] [-m] [-p port#] [-q name] [-t type] [-x addr] [-y [hmac:]name:key] [-4] [-6] [name] [type] [class] [queryopt...] simple usage： dig @server name type 选项： -b：绑定源IP -4：仅使用IPv4 -t：指定RR类型，默认为A记录，atfr（反向解析） -x：反向解析 +[no]trace:跟踪解析过程 +[no]recure：递归解析 2、host命令格式： host [-aCdlnrsTwv] [-c class] [-N ndots] [-R number] [-t type] [-W wait] [-m flag] [-4] [-6] {name} [server] 选项： -t：指定RR类型 3、nslookup格式：nslookup [-option] [name | -] [server] nslookup&gt; server IP: 指明使用哪个DNS server进行查询 set q=RR_TYPE: 指明查询的资源记录类型 NAME: 要查询的名称 4、rndc命令(953/tcp)格式： rndc [-b source-address] [-c config-file] [-k key-file] [-s server] [-p port] [-V] [-y key_id] {command} reload：重载主配置文件和区域解析库文件 retranfer：手动启动区域传送，而不管序列号是否增减； notify：重新对区域传送发通知； reconfig：重载主配置文件 querylog：开启或关闭查询日志文件`/var/log/message` trace：递增debug一个级别 trace LEVEL：指定使用的级别 notrace：将调试级别设置为0 flush：清空DNS服务器的所有缓存记录]]></content>
      <categories>
        <category>命令</category>
        <category>dig、nslookup等工具</category>
      </categories>
      <tags>
        <tag>命令使用，dig，nslookup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axel]]></title>
    <url>%2F2017%2F11%2F28%2Faxel%2F</url>
    <content type="text"><![CDATA[axelaxel是 Linux 下一个不错的HTTP/FTP高速下载工具。支持多线程下载、断点续传，且可以从多个地址或者从一个地址的多个连接来下载同一个文件。适合网速不给力时多线程下载提高下载速度 --max-speed=x -s x 最大速度（字节/秒） --num-connections=x -n x 最大连接数 --output=f -o f 指定文件名 --search[=x] -S [x] 从镜像搜索并下载 --header=x -H x 添加头部 --user-agent=x -U x 设置用户代理 --no-proxy -N 不使用任何代理 --quiet -q 静默 --verbose -v 显示更多状态信息 --alternate -a 显示简单进度条 --version -V 显示版本信息 示例： [root@localhost~]#axel -n 3 -o /root ftp://172.18.0.1/pub/ISOs/CentOS-6.9-x86_64-bin-DVD1.iso]]></content>
      <categories>
        <category>命令</category>
        <category>axel</category>
      </categories>
      <tags>
        <tag>命令使用，curl，elinks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bind包安装]]></title>
    <url>%2F2017%2F11%2F28%2FBind%E5%8C%85%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[实现管理DNS1、bind安装包bind-libs.x86_64 #库包 bind-libs-lite.x86_64 # bind-license.noarch #认证包 bind-utils.x86_64 #提供对dns服务器的测试工具程序 bind-chroot #为bind提供一个伪装的根目录以增强安全性 2、Bind配置文件服务脚本 /etc/rc.d/init.d/named和/usr/lib/systemcd/system/named.service 主配置文件/etc/named.conf /etc/named/rfc1912.zones 存放根服务器地址 /var/named/name.ca 解析库文件 /var/named/ZONE_NAME_ZONE 注意： （1）一台物理服务器可同时为多个区域提供解析。 （2）必须要有根文件：name.ca。 （3）应该有两个实现localhost和本地回环的解析库。 主配置文件/etc/namd.conf // named.conf // // Provided by Red Hat bind package to configure the ISC BIND named(8) DNS // server as a caching only nameserver (as a localhost DNS resolver only). // // See /usr/share/doc/bind*/sample/ for example named configuration files. #这个文件是一个参考例子 // // See the BIND Administrator&apos;s Reference Manual (ARM) for details about the // configuration located in /usr/share/doc/bind-{version}/Bv9ARM.html options { #全局设置 listen-on port 53 { 127.0.0.1; }; #IPv4监听的端口和IP地址 listen-on-v6 port 53 { ::1; }; #IPv6监听的端口 directory &quot;/var/named&quot;; #zone配置文件存放目录 dump-file &quot;/var/named/data/cache_dump.db&quot;; #下载缓存数据库 statistics-file &quot;/var/named/data/named_stats.txt&quot;; #静态文件 memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;; allow-query { localhost; }; #允许询问 /* - If you are building an AUTHORITATIVE DNS server, do NOT enable recursion. - If you are building a RECURSIVE (caching) DNS server, you need to enable recursion. control to limit queries to your legitimate users. Failing to do so will cause your server to become part of large scale DNS amplification attacks. Implementing BCP38 within your network would greatly reduce such attack surface */ recursion yes; #是否递归查询 dnssec-enable yes; #是否支持DNSSEC开关 dnssec-validation yes; #是否进行DNSSEC确认开关 /* Path to ISC DLV key */ bindkeys-file &quot;/etc/named.iscdlv.key&quot;; managed-keys-directory &quot;/var/named/dynamic&quot;; pid-file &quot;/run/named/named.pid&quot;; session-keyfile &quot;/run/named/session.key&quot;; }; logging { #日志信息 channel default_debug { file &quot;data/named.run&quot;; #存放的文件位置 severity dynamic; #工作模式 }; }; zone &quot;.&quot; IN { #根域 type hint; #zone类型 file &quot;named.ca&quot;; #文件名称 }; include &quot;/etc/named.rfc1912.zones&quot;; include &quot;/etc/named.root.key&quot;; 建议一般不要在这个文件中配置zone，可以在/etc/named.rfc1912.zones文件下进行配置。 /var/named/named.localhost 文件 $TTL 1D @ IN SOA @ rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS @ A 127.0.0.1 AAAA ::1 一般这个文件作为一个模板文件进行zone的配置。 3、DNS转发服务器 （1）全局转发：对非本机所负责区域的请求，全转发给指定的服务器。 options{ forward first|only； forwarders { IP; }; }； （2）特定区域转发：仅转发对特定区域的请求，比全局转发优先级高。 zone &quot;ZONE_NAME&quot; IN { tyep forward; forward first|only; forwarders { IP; } }; 4、从DNS服务器（1）应该为一台独立的名称服务器 （2）主服务器区域解析文件中必须有一条NS记录指向从DNS服务器 （3）从服务器只需要定义区域，而无须提供解析库；解析库文件应该放置于/var/named/slaves目录下。 （4）主服务器得允许从服务器区域传送 （5）主从服务器的时间应该保持一致 （6）Bind程序版本应该保持一致；如果不一致，建议主服务器低，从服务器高。 （7）修改网卡配置文件/etc/sysconfig/network-scripts-ifcfg-INTERFACE,添加DNS记录。 5、允许动态更新如果想启用此功能，可以在/etc/named.rfc1912.zones文件中定义之。]]></content>
      <categories>
        <category>服务</category>
        <category>DNS</category>
        <category>Bind包安装</category>
      </categories>
      <tags>
        <tag>dns，bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables命令]]></title>
    <url>%2F2017%2F11%2F28%2Fiptables%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[iptables命令格式： iptables [-t table] SUBCOMMAND chain [-m ] matchname [per-match-options]] -j targetname [per-target-options] 链管理||-F flush|清空规则链；|-N new|创建新的自定义规则链|-X drop|删除用户自定义空的规则链|-Z zero|清零，置零规则计数器|-P policy|为指定链设定默认策略，对于filter表，默认策略通常有ACCEPT、DROP、REJECT|-E rEname|重命名自定义链，注意：引用计数不为0自定义链无法改名，也无法删除|-A append|将新规则追加于指定链的尾部|-I insert|将新规则追加于指定链的位置|-D delete|删除指定链上的指定规则，指明规则序号；指明规则本身|-R replace|替换指定链上的指定规则 查看链规则||-L list|列出指定链上的所有规则|-n |以数字格式显示地址和端口号|-v|显示详细信息|–line-number|显示规则编号|-x exactly|显示计数器计数结果的精确值 匹配条件基本匹配[!]-s,–src,–source address[/mask]:检查报文中的源IP地址是否符合此处指定的地址范围 [!]-d,–dst,–destination address[/mask]:检查报文中源IP地址是否符合此处指定的地址范围 -p，–protocol {tcp|udp|icmp} ：检查报文中的的协议，即IP首部中的protocol所表示的协议 -i，–in-interface INFACE：数据报文的流入接口；仅能用于PREROUTING INPUT FORWARD链上 -o，–out-interface INFACE：数据报文的流出接口；仅能用于FORWARD OUTPUT POSTROUTING链上 扩展匹配使用扩展匹配需加载模块 隐式扩展在使用-p选项指明了特定的协议时，无需再使用-m选项指明扩展模块的扩展机制，不需要手动加载扩展模块 tcp协议扩展选项[!] –source-port,–sport port[:port] ：匹配报文源端口 [!] –destination-port ,–dport port[:port]：匹配报文目标端口 [!] –tcp-flags LIST1 LIST2 ：检查LIST1所指明的所有标志位，且LIST2所表示标记位必须为1，而余下的必须为0,；没有LIST1中指明的不做检查 --syn：用于匹配检查第一次三次握手 与--tcp-flags SYN,ACK,FIN,RST SYN作用相同 udp协议扩展选项[!] –source-port,–sport port[:port] ：匹配报文源端口 [!] –destination-port ,–dport port[:port]：匹配报文目标端口 icmp协议扩展选项[!] –icmp-type {type[/mode]|typename} type/code 0/0 echo-replay :icmp应答 8/0 echo-reques :icmp请求 显示扩展显示扩展必须使用选项-m指定，必须显示指明使用的模块 [root@localhost ~]# rpm -ql iptables |grep \.so$ mulitport扩展，以离散方式定义多端口匹配，最多指定15个端口 [!] –source-ports,–sports port[,port|port:port]指明多个源端口 [!] –destination-ports,–dports port[,port|:port] :指明多个目标端口 [!] –ports port[,port|,port:port] :指明多个源或目标端口 示例：[root@localhost ~]# iptables -A INPUT -s 192.168.4.61 -d 192.168.4.55 -p tcp -m multiport --sports 20:23 -j ACCEPT iprange扩展，指明连续ip地址范围使用；但一般是不能扩展整个网络 [!] –src-range from [-to]:指明连续的源ip地址范围[!] –dst-range from [-to]：指明连续的目标ip地址范围 示例：[root@localhost ~]# iptables -A INPUT -m iprange --src-range 192.168.4.61-192.168.4.65 -p tcp -j ACCEPT string 检查报文中出现的字符串 –algo {bm|kmp}：字符串匹配检测算法 –from offset ：开始偏移 –to offset ：结束偏移 [!] –string PATTERN ：要检查的字符串模式 [!] –hex-string PATTERN：要检测字符串模式 示例：[root@localhost html]# iptables -A OUTPUT -s 192.168.4.61 -d 0/0 -p tcp --sport 80 -m string --algo bm --string &quot;www.google.com&quot; -j REJECT time根据报文到达时间与指定的时间范围进行匹配 –datestart YYYY[-MM[-DD[Thh[:mm[:ss]]]]] –datestop YYYY[-MM[-DD[Thh[:mm[:ss]]]]] –timestart hh:mm[:ss] –timestop hh:mm[:ss] [!] –monthdays day[,day…] [!] –weekdays day[,day…] Mon, Tue, Wed, Thu, Fri, Sat, Sun, or values from 1 to 7, respectively. –kerneltz:内核时区，不建议使用；CentOS 7系统默认使用UTC；CentOS 6 不支持kerneltz，–localtz指定本地时区（默认） 示例：[root@localhost html]# iptables -A INPUT -s 192.168.4.61 -d 192.168.4.55 -p tcp --dport 80 -m time --timestart 15:00 --timestop 16:00 --weekdays 5 -j DROP connlimit 根据每客户端IP 做并发数量限制；通常分别于默认的拒绝或允许策略配合使用 –connlimit-upto N ：连接的数量小于等于N时匹配 –connlimit-above N：连接的数量大于N时匹配 示例：[root@localhost html]# iptables -A INPUT -d 192.168.4.61 -p tcp --dport 22 -m connlimit --connlimit-above 2 -j REJECT limit扩展，基于收发报文的速率做匹配 –limit rate[/second|/minute|/hour|/day] 限制速率 –limit-burst number 限制浏览 默认为5 示例：[root@localhost ~]# iptables -A INPUT -d 192.168.4.55 -p icmp --icmp-type 8 -m limit --limit 3/minute --limit-burst 5 -j ACCEPT state扩展，根据“连接追踪机制”去检查连接的状态，此扩展比较消耗资源 state 注释 NEW 新发出的请求，连接追踪模板中不存在此连接相关的信息条目，因此，将其识别为第一次发出的请求。 ESTABLISHED NEW状态之后，连接追踪模板中为建立的条目失效之前期间所进行的通信的状态。这个状态不管这个数据包是发往防火墙还是由防火墙转发的。ICMP的错误和重定向等信息包也被看做是ESTABLISHED，只要他们是我们所发出的信息应答。 RELATED 相关的连接，如ftp协议的命令连接和数据之间的关系。 INVALID 无法识别的连接 [!] –state STATE conntrack机制：追踪本机上的请求和响应之间的关系 文件 说明 /proc/net/nf_conntrack 已经追踪到的并记录下来的连接信息库 /proc/sys/net/nf_conntrack_max 调整连接追踪所能够容纳的最大连接数量 /proc/sys/net/netfilter 不同的协议连接追踪时长 注意：CentOS 7中需要加载模块：modprobe nf_conntrack iptablesde 连接追踪表最大容量为/proc/sys/net/nf_conntrack_max,各种状态超时连接会从表中删除，当模板满载时，后续连接可能会超时；那么我们如何解决此问题呢？ 方法一： 加大nf_conntrack_max的值 [root@localhost ~]# vim /etc/sysctl.conf net.nf_conntrack_max = 393216 net.netfilter.nf_conntrack_max = 393216 方法二 降低nf_conntrack timeout 时间 [root@localhost ~]# vim /etc/sysctl.conf net.netfilter.nf_conntrack_tcp_timeout_established = 300 net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120 net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60 net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120 示例：[root@localhost ~]# iptables -A OUTPUT -s 192.168.4.55 -p tcp -m multiport --dports 22,80 -m state --state ESTABLISHED -j ACCEPT [root@localhost ~]# iptables -A INPUT -d 192.168.4.55 -p tcp -m multiport --dports 22,80 -m state --state NEW -j ACCEPT mac扩展 指明源MAC地址；适用于PREROUTING、FORWARD、INPUT [!] –mac-source MAC 示例：[root@localhost ~]# iptables -A INPUT -s 192.168.4.61 -p icmp --icmp-type 8 -m mac --mac-source 00:0c:29:40:d6:de -j DROP 目标 target-j TARGET：jump值指定的target 选项 说明 ACCEPT 允许数据包通过 DROP 丢弃数据包 REJECT 丢弃数据包，并且将拒绝信息发送给发送方 SNAT 源地址转换 DNAT 目标地址转换 REDIRECT 目标端口转换 MASQUERADE 地址伪装 LOG：非中断target，本身不拒绝和允许，放在拒绝和允许规则之前，并将日志记录在/var/log/messages系统日志中 –log-level LEVEL 指定日志级别 –log-prefix PREFIX：日志前缀，用于区别不同的日志，最多29个字符 示例：[root@localhost ~]# iptables -A INPUT -s 192.168.4.61 -p tcp -m multiport --dports 21:23,80 -m state --state NEW -j LOG --log-level info --log-prefix &quot;new connections:&quot; 小结 任何不允许的访问，应该在请求到达时给予拒绝。规则在表中的次序为其检查时的生效次序 基于上述，规则优化建议： （1）安全放行所有入站和出站的状态为ESTABLISHED状态连接 （2）谨慎放行入站的新请求 （3）有特殊目的的限制访问功能，要在放行规则之前加以拒绝 （4）同类规则，匹配范围小的放在前面，用于特殊处理 （5）不同类规则，匹配范围大的放在前面 （6）应该将那些可由一条规则能够描述的多个规则合并为一条 （7）设置默认策略，建议白名单（只放心特定连接） iptables -P 不建议使用 建议在规则的最后定义规则作为默认策略 iptables -A INPUT -j DROP 规则的保存和恢复service iptables save 将规则覆盖保存至/etc/sysconfig/iptables文件中 iptables-save /PATH/TO/SOMEFILE 保存至指定文件中 iptables -S /PATH/TO/SOMEFILE 保存至指定文件中 service iptables restart 会从/etc/sysconfig/iptables文件中重新载入规则 iptables-restore &lt; /PATH/TO/SOMEFILE 从指定文件中加载规则 -n，--noflush：不清楚原有规则 -t，--test：仅分析生成规则集，但不提交 如果需要开启自动加载自己配置的规则，如何实现？ 方法一： 将iptables命令写至/etc/rc.d/rc.local，让此脚本开机后自动运行 方法二： 将iptables命令写入一个专门放置/PATH/TO/SOMEFILE文件中，然后将此脚本文件放置/etc/rc.d/rc.local文件中 iptables-restore &lt; /PATH/TO/SOMEFILE 方法三： 在CentOS 7 中可以自定义Unit File ，进行iptables-restore 注意：由于CentOS 7 中/etc/rc.d/rc.local文件没有执行权限，需要赋予执行权限才能实现 如果要实现不同场景中实现不同规则，可以将规则集放入到不同的文件中，在不同场景中使用 iptables-restore &lt; /PATH/TO/SOMEFILE即可。但是只能有且只用一个规则集生效。]]></content>
      <categories>
        <category>防火墙</category>
        <category>iptables命令</category>
      </categories>
      <tags>
        <tag>iptables命令，四表五链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keepalived实战]]></title>
    <url>%2F2017%2F11%2F28%2Fkeepalived%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[实战keepalived单实例，高可用性IPVS集群，IPVS集群提供apache；NAT模式topology （1）node1和node2环境前提 时间同步：[root@node1 ~]# ntpdate 172.18.0.1 [root@node1 ~]# vim /etc/ntp.conf [root@node1 ~]# service ntpd start #重启服务 [root@node1 ~]# chkconfig ntpd on #设置为开机启动 另外一个节点也是这样操作 如果是CentOS 7 操作如下[root@node2~]#vim /etc/chrony.conf[root@node2~]#systemctl start chronyd.service [root@node2~]#systemctl enable chronyd （2）关闭iptables和selinux node1： [root@node1 ~]# iptables -F [root@node1 ~]# service iptables stop [root@node1 ~]# chkconfig iptables off [root@node1 ~]# vim /etc/selinux/config SELINUX=disabled [root@node1 ~]# setenforce 0 node2： [root@node2~]#systemctl disable firewalld [root@node2 ~]# vim /etc/selinux/config SELINUX=disabled [root@node1 ~]# setenforce 0 （3）修改/etc/hosts文件 node1 [root@node1 ~]# vim /etc/hosts 192.168.4.61 node2 192.168.4.56 node1 node2 [root@node2 ~]# vim /etc/hosts 192.168.4.56 node1 192.168.4.61 node2 测试ping能否ping通 [root@node1 ~]# ping node2 PING node2 (192.168.4.61) 56(84) bytes of data. 64 bytes from node2 (192.168.4.61): icmp_seq=1 ttl=64 time=0.392 ms [root@node2~]#ping node1 PING node1 (192.168.4.56) 56(84) bytes of data. 64 bytes from node1 (192.168.4.56): icmp_seq=1 ttl=64 time=0.247 ms （4）node1和node2之间root用户可以基于密钥认证ssh服务完成互相通信 node1： [root@node1 ~]# ssh-keygen -t rsa [root@node1 ~]# ssh-copy-id -i /root/.ssh/id_rsa.pub node2 node2： [root@node2 ~]# ssh-keygen -t rsa [root@node2~]#ssh-copy-id -i /root/.ssh/id_rsa.pub node1 （5）node1和node2安装keepalived服务并配置 [root@node1 ~]# yum install -y keepalived ! Configuration File for keepalived global_defs { notification_email { client@mail.com } notification_email_from node1@mail.com smtp_server 192.168.4.132 smtp_connect_timeout 30 router_id node1 #node2为node2 vrrp_mcast_group4 224.100.100.4 } vrrp_instance VI_1 { state MASTER interface eth0 virtual_router_id 4 priority 12 #此处node1和node2优先级不一样 advert_int 1 authentication { auth_type PASS auth_pass e60f4024 } virtual_ipaddress { 172.18.4.60/16 } delay_loop 3 lb_algo wrr lb_kind NAT persistence_timeout 50 protocol TCP sorry_server 172.18.4.60 80 real_server 192.168.4.62 80 { weight 3 HTTP_GET { url { path /app/website status_code 200 } connect_timeout 1 nb_get_retry 3 delay_before_retry 1 } } real_server 192.168.4.63 80 { weight 1 HTTP_GET { url { path /app/website status_code 200 } connect_timeout 1 nb_get_retry 3 delay_before_retry 1 } } } node2和node1配置类似这里不再累述 测试是否VRRP实现 如果关闭node1服务，会出现图中情况。 （6）实现lvs调度 node1：开启路由转发功能 [root@node1 keepalived]# vim /etc/sysctl.conf net.ipv4.ip_forward = 1 [root@node1 keepalived]# sysctl -p node2：开启路由转发功能 [root@node2 keepalived]# vim /etc/sysctl.conf net.ipv4.ip_forward = 1 [root@node1 keepalived]# sysctl -p]]></content>
      <categories>
        <category>服务</category>
        <category>Keepalived</category>
        <category>keepalived实战</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables简单介绍]]></title>
    <url>%2F2017%2F11%2F28%2Fiptables%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、iptables1、iptables历史iptables的前身叫ipfirewall （内核1.x时代）,这是一个作者从freeBSD上移植过来的，能够工作在内核当中的，对数据包进行检测的一款简易访问控制工具。但是ipfirewall工作功能极其有限(它需要将所有的规则都放进内核当中，这样规则才能够运行起来，而放进内核，这个做法一般是极其困难的)。当内核发展到2.x系列的时候，软件更名为ipchains，它可以定义多条规则，将他们串起来，共同发挥作用，而现在，它叫做iptables，可以将规则组成一个列表，实现绝对详细的访问控制功能。 2、iptables概念iptables包含两部分，一部分是netfilter组件，是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤处理的规则集；另一部分是iptables，工作在用户空间中，定义规则的工具，本身并不算是防火墙。它们定义的规则可以让在内核空间当中的netfilter来读取，并且实现让防火墙工作。而放入内核的地方必须要是特定的位置，必须是tcp/ip的协议栈经过的地方；而这个tcp/ip协议栈必须经过的地方，可以实现读取规则的地方就叫做 netfilter.(网络过滤器) 3、防火墙的分类 主机防火墙：服务范围为当前主机网络防火墙，防火墙一侧的局域网 硬件防火墙：专用硬件级别实现部分功能的防火墙 软件防火墙：运行于通用硬件平台上的防火墙的应用软件 网络层防火墙：OSI下面第三层应用层防火墙 （1）网络层防火墙（包过滤防火墙） 工作机理 网络层对数据包进行选择（依据是系统内设置的过滤逻辑，被称为访问控制列表（ACL）），通过检查数据流中每个数据的源地址、目标地址、所用端口和协议状态等因素，或者他们的组合确定是否允许此数据包通过。 优点 对于用户来说是透明的，处理速度快且易于维护 缺点 无法检查应用层数据，如病毒等。 （2）应用层防火墙（代理服务器型防火墙） 工作机理 将所有跨越防火墙的网络通信链路分为两段，内外网用户的访问都是通过代理服务器上的链接来实现的 优点 应用层对数据进行检查，比较安全 缺点 增加防火墙的负载 在现实生产环境中所使用的防火墙一般都是上述两者结合一起发挥功用；即先进行网络数据检查，如果通过之后再送到应用层检查。 4、Netfilter组件netfilter工作在内核空间中，集成于linux内核中，提供一整套hook函数管理机制，使得数据包过滤、网络地址转换和基于协议类型的链接跟中成为了可能。内核中选取五个位置放五个hook function,INPUT、OUTPUNT、PREROUTING、POSTROUTING、FORWARD。由信息过滤表组成，包含控制IP 包处理的规则集，规则被分组放在chain上。 三种报文流向 流入本机：PREROUTING–&gt;INPUT–&gt;用户进程 流出本机：用户进程–&gt;OUTPUT–&gt;POSTROUTING 转发：PREROUTING–&gt;FORWARD–&gt;POSTROUTING 5、iptables组成防火墙的管理工具，工作在用户进程空间中。在用户进程空间中编写好规则之后，被发送给netfilter，告诉内核如何去处理信息包。 iptables由四张表和五个链以及一些规则组成。 四张表 filter ：过滤规则表，根据预先定义的规则过滤符合条件的数据表 nat（network addresss translation）表：地址转换表 mangle表：修改数据标记位规则表 raw表：关闭nat表上启动的链接追踪机制，加快封包速率 四张表的优先级 raw &gt; mangle &gt; nat &gt;filter netfilter表盒链对应关系 防火墙是iptabls和netfilter的组合，可以让规则进行生效，本身不是一种服务。 数据包过滤匹配流程如下 6、内核中数据包传输过程 （1）当一个数据包进入网卡时，数据包首先进入PREROUTING链，内核根据数据包目的IP 判断是否需要转发出去 如果上述判断数据包是进入本机，数据沿着②到达INPUT。数据包进入INPUT链后，任何进程都会接收到它。本机运行的程序可以发送数据包，这些数据包经过OUTPUT链然后到达POSTROUTING链输出 如果数据包要转发出去，且内核开启转发功能，数据包会沿着⑤到达FORWARD链，然后沿着⑥到达POSTROUTING链输出 7、iptables组成根据规则的匹配条件尝试匹配报文，对匹配成功的报文根据规则定义的处理动作做出处理。 规则和链是有计数器： pkgs：由规则和链所匹配到的报文的个数 bytes：由规则或链匹配到的所有报文大小之和 匹配条件 基本匹配：IP 、端口、TCP的标记位 扩展匹配：通过复杂高级功能匹配 处理动作 内置处理动作：ACCEPT DROP REJECT SNAT DNAT MASQUERADE MARK LOG 自定义处理动作：自定义chain，利用分类管理复杂情形 链 内置链：每个内置链对应一个hook函数 自定义链：用于对内置链进行扩展或补充，可以实现更灵活的规则管理机制；只有hook调用自定义链才能生效。 报文不会经过自定义链，只能在内置链上通过规则进行引用后生效。 8、添加规则的考量点（1）实现哪种功能：判断添加在哪张表上合适 （2）报文流经的路径：判断添加在哪个链上 链上的规则次序，即检查次序 同类规则（控制同一种应用访问），匹配范围小的放在上面 不同类规则（访问不同应用），匹配到报文频率较大的放在上面 将那些可有一条规则描述的多个规则合并为一个规则 设置默认策略]]></content>
      <categories>
        <category>防火墙</category>
        <category>iptables简单介绍</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memcached]]></title>
    <url>%2F2017%2F11%2F28%2Fmemcached%2F</url>
    <content type="text"><![CDATA[memcached是是一款开源、高性能、分布式存储内存对象缓存系统。主要目的是通过降低对Database的访问来加速web应用程序。一个基于内存的”键值对”存储用于存储数据库调用、API调用或页面引用结果的直接数据，如字符串、对象等。 一、memcached1、memcached特点（1）简单key/value存储，服务器不关心数据本身的意义及结构，只要是可序列化数据即可。 （2）功能的实现一般依赖于客户端，一般基于服务器端，客户端负责发送存储箱至服务器端，从服务器端获取数据以及无法连接至服务器时采用响应的动作；服务器端负责接收、存储数据，并负责数据项的超时过期 （3）各服务器彼此无视，不再服务器间进行数据同步 （4）o（1）的执行效率 （5）清理超期数据，默认情况下，memcached是一个LRU缓存，它按事先预设的时长清理超期数据，但是，memcached不会删除任何已缓存数据，只是在其过期之后不再为客户所见；也不会真正按期限清理缓存，而仅是当get命令到达时检查其时长 2、yum安装memcached[root@memcache~]#yum install -y memcached 配置文件主程序： /usr/bin/memcached 配置文件： /etc/sysconfig/memcached 1 PORT=&quot;11211&quot; 2 USER=&quot;memcached&quot; 3 MAXCONN=&quot;1024&quot; 4 CACHESIZE=&quot;64&quot; 5 OPTIONS=&quot;&quot; unit file memcached.service 3、命令memcached程序常用选项-l &lt;ip_addr&gt;：指定进程监听的地址 -d：以服务模式运行 -u &lt;username&gt;：以指定的用户身份运行memcached进程 -m &lt;num&gt;：用于缓存数据最大内存空间，单位为MB，默认为64MB -c &lt;num&gt;：最大支持的并发连接数，默认为1024 -p&lt;num&gt;：指定监听的TCP端口，默认为11211 -U&lt;num&gt;：指定监听的UDP端口，默认为11211,0表示关闭UDP端口 -M：内存耗尽时，不执行LRU清理缓存，而是拒绝存入新的缓存项，直到有多余的空间可用时为止 -f &lt;factor&gt;：增长因子，默认是1.25 -t &lt;threads&gt;：启动的用于响应用户请求的线程数 memcached-toolstats and management tool for memcached 使用格式： memcached-tool &lt;host[:port] | /path/to/socket&gt; [mode] display：打印分类信息。默认模式 [root@tomcatB~]#memcached-tool 127.0.0.1:11211 # Item_Size Max_age Pages Count Full? Evicted Evict_Time OOM # Number of the slab class. Item_Size The amount of space each chunk uses. One item uses one chunk of the appropri‐ ate size. Max_age Age of the oldest item in the LRU. Pages Total number of pages allocated to the slab class. Count Number of items presently stored in this class. Expired items are not auto‐ matically excluded. Full? Yes if there are no free chunks at the end of the last allocated page. Evicted Number of times an item had to be evicted from the LRU before it expired. Evict_Time Seconds since the last access for the most recent item evicted from this class. OOM Number of times the underlying slab class was unable to store a new item. stats：显示状态信息 dump：使部分缓存写 远程命令[root@memcache~]#telnet 127.0.0.1 11211 Trying 127.0.0.1... Connected to 127.0.0.1. Escape character is &apos;^]&apos;. 格式： &lt;command name&gt; &lt;key&gt; &lt;flags&gt; &lt;exptime&gt; &lt;bytes&gt; &lt;cas unique&gt; 统计类： stats stats items ,stats slabs ,stats sizes 存储类： set，add，replace，append，prepend 检索类： get ，delete，incr/decr 清空： flush_all]]></content>
      <categories>
        <category>缓存服务</category>
        <category>memcached</category>
      </categories>
      <tags>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keepalived简单介绍]]></title>
    <url>%2F2017%2F11%2F28%2Fkeepalived%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[keepalived介绍keepalived是linux下一个轻量级高可用的解决方案，主要通过VRRP实现高可用功能，作用域网络层、传输层和应用层；主要用作RealServer的健康性检查以及LoadBalance主机和Bcakup主机之间failover的实现。原生设计目的为了高可用的ipvs服务。（常见的前段高可用组合有LVS+Keepalived、Nginx+Keepalvied、HAproxy+Keepalived） 1、keepalived功能 （1）VRRP协议完成地质流动 （2）为VIP地质所在的节点生成ipvs规则 （3）为ipvs集群的各RS做健康状态检测 （4）基于脚本调用接口通过执行脚本完成脚本中定义的功能，进而影响集群事物，以支持nginx、haproxy等服务 2、keepalived组成 keepalived主要有三个模块，分别是core、check和vrrp。 core模块为keepalived的核心，负责主进程启动、维护以及全局配置文件的加载和解析 check模块负责健康检查，包括常见的各种检查方式 vrrp模块来实现VRRP协议 3、Keepalived工作原理 （1）在网络层，运行着四个重要的协议：互联网协议IP、互联网控制报文协议ICMP、地址转换协议以及反向地址转换协议RARP。keepalived在网络层采用的最常见的工作方式通过ICMP协议向服务器集群中的每个节点发送一个ICMP数据包，如果某个及诶单没有返回响应数据包，那么就认为此节点发生了故障，keepalived将报告此节点失效，并从服务器集群中剔除故障节点。 （2）在传输层，提供了主要的协议：传输控制协议TCP和用户数据协议UDP。keepalived在传输层利用TCP协议的端口连接和扫描技术来判断集群点是否工作正常。例如：web服务端口默认为80，如果keepalived在传输层探测到这些端口没有响应数据返回，就认为这些端口发生异常，然后强制将此端口对应的节点从服务器集群中移除。 （3）在应用层，运行着ftp、telnet、smtp、dns等各种不同类型的协议，用户可以编写脚本运行keepalived，keepalived根据用户设定检测各种程序或服务是否运行正常，如果keepalived的检测结果与用户设定不一致时，将对应的服务器从集群中移除。 4、keepalived配置文件安装方式一：- [root@localhost~]#yum install -y keepalived #安装keepalived [root@localhost~]#rpm -ql keepalived /etc/keepalived/keepalived.conf #主配置文件 /etc/sysconfig/keepalived #unit file环境配置文件 /usr/lib/systemd/system/keepalived.service #unit文件 安装方式二：-[root@localhost/usr/local/src]#tar xf keepalived-1.3.9.tar.gz [root@localhost/usr/local/src]#cd keepalived-1.3.9/ [root@localhost/usr/local/src/keepalived-1.3.9]#./configure [root@localhost/usr/local/src/keepalived-1.3.9]#make &amp;&amp; make install /etc/keepalived/keepalived.conf文件详解 Global definitions synopsis global_defs{ #全局定义 notification_email { #指定keepalived在发生切换时需要发送email到的对象，格式：一行一个。 email } notification_email_from email #指定发件人 smtp_server host #smtp服务器地址 smtp_connect_timeout num #smtp服务器连接超时时间 lvs_id string #表示本节点的字符串，通常为hostname } Virtual server definitions synopsis virtual_server (@IP PORT)|(fwmark num) { #设置一个VS ：VIP:PORT delay_loop num #服务轮询的时间间隔 lb_algo rr|wrr|lc|wlc|sh|dh|lblc #LVS调度算法 lb_kind NAT|DR|TUN # LVS集群模式 persistence_timeout num #会话保持时间 persistence_granularity @IP #LVS会话保持粒度，ipvsadm中的-M参数，即每个客户端都做会话保持 virtualhost string #检查web服务器的虚拟主机 protocol TCP|UDP #健康检查使用协议 sorry_server @IP PORT #备用服务器，当后端所有RS节点不可用时，就用此设置，把请求临时请求到这里 real_server @IP PORT { #后端真实节点服务器IP:PORT weight num #权重；0表示失效 TCP_CHECK { connect_ip &lt;IP ADDRESS&gt; #向当前RS的哪个IP地址发起健康状态检测请求 connect_port num #健康检查的端口 connect_timeout num #连接超时时间 bindto &lt;IP ADDRESS&gt; #发出健康状态检测请求时使用的源地址 bind_port &lt;PORT&gt; #发出健康状态检测请求时使用的源端口 } } real_server @IP PORT { weight num MISC_CHECK { misc_path /path_to_script/script.sh (or misc_path &quot;/path_to_script/script.sh &lt;arg_list&gt;&quot;) #外部脚本或程序 misc_timeout num #脚本或程序超时时间 } } real_server @IP PORT { weight num HTTP_GET|SSL_GET { 健康检查方式 url { #要检查的URL path alphanum #具体路径 status_code &lt;INT&gt; #判断上述检测机制为健康状态的响应码 digect alphanum #摘要 } connect_port num #监控检查端口 connect_timeout num #连接超时时长 nb(nat_mask)_get_retry num #重连次数 delay_before_retry num #重连间隔 bindto &lt;IP ADDRESS&gt;：发出健康状态检测请求时使用的源地址 bind_port &lt;PORT&gt; #发出健康状态检测请求时使用的源端口 connect_ip #向当前RS哪个IP地址发起健康状态检测请求 } } } VRRP intance definitions synopsis vrrp_sync_group string { #同步vrrp组 group { string string } notify_master /path_to_script/script_master.sh （or notify_master “/path_to_script/script_master.sh &lt;arg_list&gt;”） notify_backup /path_to_script/script_backup.sh (or notify_backup &quot;/path_to_script/script_backup.sh &lt;arg_list&gt;&quot;) notify_fault /path_to_script/script_backup.sh (or notify_fault &quot;/path_to_script/script_fault.sh &lt;arg_list&gt;&quot;) } vrrp_instance string { #示例名称 state MASTER|BACKUP #当前节点在此虚拟路由器上的初始状态；只能有一个MASTER，其余的为BACKUP interface string #绑定为当前虚拟路由器使用的物理接口 mcast_src_ip @IP #组播IP lvs_sync_daemon_interface string virtual_router_id num #虚拟路由ID，用来区别多个instance的VRRP组播 priority num #优先级 advert_int num #检查间隔 smtp_alert authentication { #认证区域 auth_type PASS（最长8位）|AH #认证类型，默认是PASS认证 auth_pass string #PASS认证密码 } virtual_ipaddress { 不能超过20个 @IP #虚拟VIP地址 @IP } virtual_ipaddress_excluded { @IP @IP } notify_master /path_to_script/script_master.sh （or notify_master “/path_to_script/script_master.sh &lt;arg_list&gt;”） #当前节点成为主节点时触发的脚本 notify_backup /path_to_script/script_backup.sh (or notify_backup &quot;/path_to_script/script_backup.sh &lt;arg_list&gt;&quot;) #当前节点转为备节点时触发的脚本 notify_fault /path_to_script/script_backup.sh (or notify_fault &quot;/path_to_script/script_fault.sh &lt;arg_list&gt;&quot;) #当前节点转为“失败”状态时触发的脚本 notify &lt;STRING&gt;|&lt;QUOTED-STRING&gt; 一个脚本可完成以上上中状态转换时的通知 } vrrp_script chk_http { script &quot;/path_to_script/script.sh&quot; http服务检测脚本 interval num #检查间隔 weight num #权重 fall #如果连接失败次数达到此值，则认为服务器已经down rise #如果连接次数达到此值，则认为服务器已UP，但不修改优先级 weight -NUM #检测失败则优先级-NUM } track_interface { #定义额外的监听网卡，只要其中一个网卡出现故障就会发生准备切换 eth0 eth1 ... } track_script { chk_http #引用VRRP脚本，即在vrrp_script部分指定的名字 } 小结 （1）优先级不会不断的提高或降低 （2）可以编写多个检测脚本为每个检测脚本设置不同的weight （3）不管提高优先级还是降低优先级，范围为1-254 （4）在MASTER节点的vrrp_instance中配置nopreempt，当它异常恢复后，即时它的优先级更高也不会抢占 keepalived调用脚本进行资源监控keepalived调用外部辅助脚本进行资源监控，并根据监控结果状态能实现优先动态太正。 vrrp_script：自定义资源监控脚本，vrrp示例根据脚本返回值，公共定义，可对悲多个示例调用，定义在vrrp示例之外 track_script：调用vrrp_script定义的脚本去监控资源，定义在示例之外，调用事先定义的vrrp_script 定义keepalived日志[root@localhost~]#vim /etc/sysconfig/keepalived 14 KEEPALIVED_OPTIONS=&quot;-D -S 2&quot; [root@localhost~]#vim /etc/rsyslog.conf 74 local2.* /var/log/keepalived.log 重启服务 [root@localhost~]#systemctl restart rsyslog.service [root@localhost~]#systemctl restart keepalived.service]]></content>
      <categories>
        <category>服务</category>
        <category>Keepalived</category>
        <category>keepalived简单介绍</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngx_http_fastcgi_module]]></title>
    <url>%2F2017%2F11%2F28%2Fngx_http_fastcgi_module%2F</url>
    <content type="text"><![CDATA[ngx_http_fastcgi_module转发请求到FastCGI服务器，不支持php模块方式 （1）fastcgi_pass address address 为后端的fastcgi server的地址可用 Syntax: fastcgi_pass address; Default: — Context: location, if in location （2）fastcgi_index name fastcgi默认的主页资源 Syntax: fastcgi_index name; Default: — Context: http, server, location 示例 fastcgi_index index.php （3）fastcgi_param parameter value [if_not_empty] 设置传递给fastcgi服务器的参数值，可以是文本，变量或组合 Syntax: fastcgi_param parameter value [if_not_empty]; Default: — Context: http, server, location 示例： a、在php-fpm服务器上开启以下几行 b、在前段nginx服务器上进行如下配置 location ~*\.php${ fastcgi_pass 192.168.4.60:9000; fastcgi_index index.php; fastcgi_param SRCIPT_FILENAME /app/websit/php$fascgi_script_name; include fastcgi_params; 或者 include fastcgi.conf 或者直接修改fastcgi.conf配置文件不写fastcgi_param指令 } 通过/pm_status和/ping来获取fpm server状态信息 location ~^/(pm_status/ping)${ fastcgi_pass 192.168.4.60:9000 fastcgi_param SCRIPT_FILENAME $fastcgi_script_name; include fascgi.conf } （4）fastcgi_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time] 定义fastcgi缓存 Syntax: fastcgi_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time]; Default: — Context: http max_size：磁盘path路径中用于缓存数据的缓存空间上限 levels=levels：缓存目录的层级数量，以及每以及的目录数量 keys_zone=name：size k/v映射的内存空间的名称及大小 inactive：非活动时长 （5）fastcgi_cache zone|off 调用指定的缓存空间来缓存数据 Syntax: fastcgi_cache zone | off; Default: fastcgi_cache off; Context: http, server, location （6）fastcgi_cache_key string 定义用作缓存向的key的字符串 示例： fastcgi_cache_key $request_uri; （7）fastcgi_cache_methods GET|HEAD|POST 为哪些请求方法使用缓存 Syntax: fastcgi_cache_methods GET | HEAD | POST ...; Default: fastcgi_cache_methods GET HEAD; Context: http, server, location （8）fastcgi_cache_min_uses number 缓存空间中的缓存项在inactive定义的非活动时间至少要被访问到此处所指定的次数方可悲认作为活动项 Syntax: fastcgi_cache_min_uses number; Default: fastcgi_cache_min_uses 1; Context: http, server, location （9）fastcgi_keep_conn on|off 收到后端服务器响应 后，fastcgi服务器是否关闭连接，建议启用长连接 Syntax: fastcgi_keep_conn on | off; Default: fastcgi_keep_conn off; Context: http, server, location （10）fastcgi_cache_valid [code…]time 不同的响应码各自的缓存时长 Syntax: fastcgi_cache_valid [code ...] time; Default: — Context: http, server, location 示例： fastcgi_cache_vaild 200 302 10m http { fastcgi_cache_path /var/cache/nginx fcgi_cache levels=1:2:1 keys_zone=fcgicache:20m inactive=120s; server { location ~* \.php$ { fastcgi_cache fcgicache; fastcgi_cache_key $request_uri; fastcgi_cache_valid 200 302 10m; fastcgi_cache_valid 301 1h; fastcgi_cache_valid any 1m; } } }]]></content>
      <categories>
        <category>服务</category>
        <category>Nginx</category>
        <category>ngx_http_fastcgi_module</category>
      </categories>
      <tags>
        <tag>nginx，fastcgi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngx_http_proxy_module]]></title>
    <url>%2F2017%2F11%2F28%2Fngx_http_proxy_module%2F</url>
    <content type="text"><![CDATA[ngx_http_proxy_module（1）proxy_pass URL Syntax: proxy_pass URL; Default: — Context: location, if in location, limit_except # proxy_pass http://localhost:8000/uri/; ####proxy_pass后面的路径不带URI时，其会将location的URI传递给后端主机 即： server { server_name www.test.com; location /URI/ { proxy_pass http://host[:port]; 最后没有/ } } http://www.test.com/URI--&gt;http://host[:port]/URI 如果http://host[:port]/URI是这样的会会提供location中的URI替换 server { server_name HOSTNAME; location /uri/ { proxy_pass http://host/new_uri/; } } http://HOSTNAME/uri/ –&gt; http://host/new_uri/ ####如果location定义其URI时使用了正则表达式，则proxy_pass之后必须不能使用URI；即http://host/[:port]后面不能带“/”。 （2）proxy_set_header filed value 设定发往后端主机的请求报文的请求首部的值 Syntax: proxy_set_header field value; Default: proxy_set_header Host $proxy_host; proxy_set_header Connection close; Context: http, server, location 示例： proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 如果需要修改日志格式：在nginx.conf配置文件中修改日志格式 logfromat %{X-Real-IP} ...此处为proxy_set_header定义的变量 （3）proxy_cache_path 定义可用于proxy功能的缓存 Syntax: proxy_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time]; Default: — Context: http path 缓存路径 level 级别 示例： proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m; （4）proxy_cache zone|off 指明调用的缓存，或关闭缓存机制 Syntax: proxy_cache zone | off; Default: proxy_cache off; Context: http, server, location （5）proxy_cache_key string 缓存中用于“键”的内容 Syntax: proxy_cache_key string; Default: proxy_cache_key $scheme$proxy_host$request_uri; Context: http, server, location 示例： proxy_cache_key &quot;$host$request_uri $cookie_user&quot;; （6）proxy_cache_valid [code…] time 定义对特定响应码的响应内容的缓存时长 Syntax: proxy_cache_valid [code ...] time; Default: — Context: http, server, location 示例： 首先在nginx.conf配置文件中定义 http{ proxy_cache_path /var/cache/nginx/proxy_cache levels=1:1:1 keys_zone=proxycache:20m inactive=120s max_size=1g; server{ proxy_cache proxycache; proxy_cache_key $request_uri; proxy_cache_valid 200 302 301 1h proxy_cache_vaild any 1m; } } （7）proxy_cache_use_stale 在被代理的后端服务器出现那种情况下，可以直接使用过期缓存响应客户端 Syntax: proxy_cache_use_stale error | timeout | invalid_header | updating | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | off ...; Default: proxy_cache_use_stale off; Context: http, server, location （8）proxy_cache_methods 对哪些客户端请求方法对应的响应进行缓存 Syntax: proxy_cache_methods GET | HEAD | POST ...; Default: proxy_cache_methods GET HEAD; Context: http, server, location （9）proxy_hide_header field 用于隐藏后端服务器特定的响应首部 Syntax: proxy_hide_header field; Default: — Context: http, server, location By default, nginx does not pass the header fields“Date”, “Server”, “X-Pad”, and “X-Accel-…” from theresponse of a proxied server to a client. （10）proxy_connect_timeout time 定义域后端服务器建立连接超时时长，如果超时会出现502错误 Syntax: proxy_connect_timeout time; Default: proxy_connect_timeout 60s; Context: http, server, location （11）proxy_send_timeout time 把请求发送给后端服务器的超时时长 Syntax: proxy_send_timeout time; Default: proxy_send_timeout 60s; Context: http, server, location （12）proxy_read_timeout time 等待祸端服务器发送响应报文的超时时长 Syntax: proxy_read_timeout time; Default: proxy_read_timeout 60s; Context: http, server, location]]></content>
      <categories>
        <category>服务</category>
        <category>Nginx</category>
        <category>ngx_http_proxy_module</category>
      </categories>
      <tags>
        <tag>nginx，proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngx_http_upstream_module]]></title>
    <url>%2F2017%2F11%2F28%2Fngx_http_upstream_module%2F</url>
    <content type="text"><![CDATA[ngx_http_upstream_module用于将多个服务器定义成服务器组，而由proxy_pass，fastcgi_pass等指令进行引用。 （1）upstream name {…} 定义后端服务器组，会引入一个新的上下文，默认调度算法为wrr。 Syntax: upstream name { ... } Default: — Context: stream 示例： upstream websrvs{ server 192.168.4.60:80 weight=2 server 192.168.4.61:81 weight=1 server 192.168.4.62:82 weight=3 } upstream模块的负载均衡算法主要有三种：论调（round-robin）、ip哈希（ip_hash）和最少连接（least_conn） （2）server address [parameters] 在upstream上下文中server成员，以及相关的参数 Syntax: server address [parameters]; Default: — Context: upstream address表示格式 unix：/PATH/TO/SOME_SOCK_FILE IP[:PORT] HOSTNAME[:PORT] parameters weight=number 权重，默认为1 max_conns 连接后端服务器最大并发活动连接数 max_fails=number 失败尝试最大次数；超出此处指定的次数时，server将被标记为不可用，默认为1 backup 将服务器为“备用”，即所有服务器不可用时才启用 down：标记位不可用，配合ip_hash使用，使用灰度发布（部分上线）；可以实现打补丁，维护等 （3）ip_hash 源地址hash调度方法，如果是同一个机器调度到同一个RS上 （4）least_conn 最少连接调度算法，当server拥有不同权重时，其为wlc，当所有后端主机连接数相同时，则使用wrr，适用于长连接。 （5）hash key [consistent] 基于指定的key的hash表来实现对请求的调度，此处key可以直接文本、变量或者二者结合 作用：将请求分类，同一类请求或将发往同一个upstream server，使用consistent参数，将使用kerama一致性hash算法；适用于后端是cache服务器时使用。 hash $request_uri consistent 如果使用相同的uri将发往同一台服务器上 hash $remote_addr 和ip_hash作用类似 （6）keepalive N 为每个worker进程保留的空闲的长连接数量，可节约nginx端口，并减少连接管理的消耗 （7）health_check [parameters] 健康状态检测机制， Syntax: health_check [parameters]; Default: — Context: location 常用参数： interval=time 检测的频率，默认为5秒 fails=number 判断服务器不可用的失败检测次数，默认为1次 passes=number 判断服务器可用的失败检测次数，默认为1次 uri=uri 做健康状态检测测试的目标uri，默认为“/” match=NAME：健康状态检测的结果评估调用此处指定的match配置快 此指令只对nginx plus 有效 （8）match name {…} 对backend server 做健康性检测时，定义其结果判断机制， Syntax: match name { ... } Default: — Context: http 常用参数： status code[code...] 期望的响应状态码 header HEADER[operator value]：期望存在响应首部，也可对期望的响应首部的值基于比较操作符和值进行比较body；期望响应报文的主体部分应该有的内容。 示例： # status is 200, content type is &quot;text/html&quot;, # and body contains &quot;Welcome to nginx!&quot; match welcome { status 200; header Content-Type = text/html; body ~ &quot;Welcome to nginx!&quot;; } # status is not one of 301, 302, 303, or 307, and header does not have &quot;Refresh:&quot; match not_redirect { status ! 301-303 307; header ! Refresh; } # status ok and not in maintenance mode match server_ok { status 200-399; body !~ &quot;maintenance mode&quot;; } ngx_stream_core_module模拟反代基于TCP或UDP的服务连接，即工作于传输层的反代或调度器 （1）stream{…} 定义stream相关的服务 示例： upstream telnetsrvs { server 192.168.4.60:23; server 192.168.4.61:23; least_conn; } server{ listen 192.168.4.55:23; proxy_pass telnetsrvs; } ngx_stream_proxy_module实现代理基于TCP\UDP,UNIX-domain sockets数据流 （1）proxy_pass address 指定后端服务器地址 （2）proxy_timeout timeout 无数据传输时，保持连接状态的超时时长；默认为10m （3）proxy_connect_timeout time 设置nginx与被代理的服务器尝试建立连接的超时时长，默认为60s 示例： stream { upstream telnetsrvs{ server 192.168.4.60:23; server 192.168.4.61:23; hash $remote_addr consistent } server{ listen 192.168.4.55:2323; proxy_pass telnetsrvs; proxy_timeout 60s; proxy_connect_timeout 10s; } }]]></content>
      <categories>
        <category>服务</category>
        <category>Nginx</category>
        <category>ngx_http_upstream_module</category>
      </categories>
      <tags>
        <tag>nginx，upstream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rsyslog]]></title>
    <url>%2F2017%2F11%2F28%2Frsyslog%2F</url>
    <content type="text"><![CDATA[在日常生活中如果您是一个生活有条理的人，一定会记录一下每天发生的事情，方便自己回看。CentOS系统中也是这样工作的，当我们在某时发生了错误时，这时日志就给我们起到了举足轻重的作用；我们可以查看日志并分析错误产生的原因等等。 一、rsyslog基本介绍1、rsyslog基本概念Rsyslog是用于UNIX和类Unix的计算机系统上用于转发IP 网络中的日志消息的开源软件实用程序。它实现了基本的syslog协议，扩展了基于内容的过滤，丰富的过滤功能，灵活的配置选项，并添加了使用TCP进行传输的功能 2、rsyslog构成CentOS 5之前版本：sysklogd CentOS 5之后版本： syslogd：记录系统日志 klogd：记录内核日志 事件记录格式： 日期时间 主机 进程[PID]: 事件内容 示例： Sep 18 11:10:33 localhost rz[3487]: [root] xcache-3.2.0.tar.bz2/ZMODEM: 148392 Bytes, 1037300 BPS 3、rsyslog工作模式基于C/S架构：通过TCP或UDP协议的服务完成日志记录传送，将分布在不同主机的日志实现集中管理。 4、rsyslog特性（1）支持多协议；UDP,TCP,SSL,TLS,RELP等（2）实现日志存储；MySQL，gpsql，oracle等（3）强大的过滤器，可实现过滤日志信息中任何部分（4）自定义输出格式 5、rsyslog配置文件主程序： /usr/sbin/rsyslogd 库文件 /lib64/rsyslog/*.so 主配置文件 /etc/rsyslog.conf和/etc/rsyslog.d/*.conf [root@localhost~]#grep &quot;^###&quot; /etc/rsyslog.conf #### MODULES #### 相关模块配置 #### GLOBAL DIRECTIVES #### 全局配置 #### RULES #### 日志记录相关的规则配置 （1）MODULES格式 $ModLoad ModulesName （2）GLOBAL DIRECTIVES格式 $WorkDirectory /var/lib/rsyslog 定义工作目录 $ActionFileDefaultTemplate 使用时间戳格式 RSYSLOG_TraditionalFileFormat $ActionFileEnableSync on $IncludeConfig /etc/rsyslog.d/*.conf 其他配置文件位置 $OmitLocalLogging on $IMJournalStateFile imjournal.state （3）RULES格式 facility.priority target facility 设施，从功能或程序上对日志进行分类 选项 说明 auth 授权日志信息 authpriv 认证日志信息 cron 任务计划日志信息 daemon 进程日志信息 kern 内核日志信息 lpr 打印机日志信息 mail 邮件日志信息 mark 标签日志信息 news 新闻日志信息 security 安全日志信息 user 用户日志信息 uucp uucp日志信息 syslog 系统日志信息 local0-local7 自定义日志信息 priority 优先级 选项 说明 debug 只要发生就记录下来 info 一些基本的信息说明，无任何严重性 notice 系统进程，但有发生要注意的事项 warn（warning） 系统发生警告信息，但还不至于影响Daemon的正常工作 err（error） 发生重大的错误信息，这些信息通畅可以是说明无法启动的原因 crit（critical） 系统发生比err还严重的错误信息，通畅表示到达系统临界点 emerg（panic） 最严重的等级，通畅表示系统已经瘫痪 如何指定级别？ 选项 说明 * 指定所有级别 none 没有级别 PRIORITY 此级别及更高的级别日志信息 =PRIORITY 只指定此级别 target 文件路径：通常在/var/log目录下定义，文件路径前的“-”表示异步写入，可以提升系统性能 用户：将日志事件通知给指定的用户，*表示登录的所有用户 日志服务器：@HOST,把日志发送至指定的远程服务器中记录；这些可以将日志集中管理。默认监听在TCP/UDP的514端口上。 管道：|COMMAND,转发给其他命令处理 6、其他日志文件/var/log/secure:系统安装日志，文本格式，应周期性分析此日志文件/var/log/btmp：当前系统上，用户的失败尝试登陆相关的日志信息，二进制格式。可以使用lastb命令查看，再日常工作中可以查看是否有人尝试破解密码登录，然后截取除IP地址丢进防火墙中即可。 注意：如果想清楚文件中的内容不能直接把文件删除可以使用&gt;/var/log/wtmp进行清楚。 [root@localhost~]#lastb root :0 :0 Wed Sep 20 11:45 - 11:45 (00:00) btmp begins Wed Sep 20 11:45:14 2017 /var/log/wtmp:当前系统上，用户正常登录系统的相关日志信息，二进制格式，可以使用last命令查看 [root@localhost~]#last root pts/1 192.168.4.1 Thu Oct 12 08:43 still logged in root pts/0 192.168.4.1 Thu Oct 12 08:20 still logged in root :0 :0 Thu Oct 12 08:20 still logged in /var/log/lastlog:每一个用户最近一次的登陆信息，二进格式，可以使用lastlog命令查看。 [root@localhost~]#lastlog Username Port From Latest root pts/1 192.168.4.1 Thu Oct 12 08:43:58 +0800 2017 bin **Never logged in** daemon **Never logged in** /var/log/dmesg:系统引导过程中的日志信息，文本格式，可以使用专用命令dmesg命令查看，如果系统出错可以查看是否启动过程哪里出错 /var/log/anaconda:存放anaconda的日志目录 二、如何启用日志服务器 上面是架构图比较省略，下面我们来实现这个功能。 环境构建：CentOS 6（客户端） 和CentOS 7 (服务器) （1）在服务端配置/etc/rsyslog.conf文件 [root@localhost~]#vim /etc/rsyslog.conf [root@localhost~]#systemctl restart rsyslog.service #重启服务 [root@localhost~]#ss -tnul |grep 514 #查看端口是否开启 udp UNCONN 0 0 *:514 *:* udp UNCONN 0 0 :::514 :::* tcp LISTEN 0 25 *:514 *:* tcp LISTEN 0 25 :::514 :::* （2）客户端进行配置 [root@localhost ~]# vim /etc/rsyslog.conf [root@localhost ~]# service rsyslog restart #重启服务 （3）测试 [root@localhost ~]# logger &quot;test&quot; 在CentOS 6 上测试 看看CentOS 7 上查看是否能收到 [root@localhost~]#tail -f /var/log/messages Oct 2 22:40:48 localhost root: test 三、如何将日志存储到mysql服务器上将日志存储到日志服务器上这样的好处是集中管理日志，但是当我们某天遇到问题时，不可能一个一个的去查询，这样显然增加了我们的工作量，如果可以直接搜索查询多好，mysql就为我们解决了这个问题。 （1）在客户端安装mysql模块相关的程序包 [root@localhost~]#yum install -y rsyslog-mysql[root@localhost~]#rpm -ql rsyslog-mysql #查看文件 /usr/lib64/rsyslog/ommysql.so /usr/share/doc/rsyslog-8.24.0/mysql-createDB.sql 将数据文件拷贝到mysql服务器上 [root@localhost ~]# scp /usr/share/doc/rsyslog-mysql-5.8.10/createDB.sql 192.168.4.60:/root/rsyslogdb （2）安装数据库，原本我CentOS7上已经有数据库就在此不安装了。 [root@localhost~]#mysql -uroot -p &lt; rsyslogdb #为rsyslog创建数据库及表 [root@localhost~]#mysql -uroot -p MariaDB [(none)]&gt; GRANT ALL ON Syslog.* TO &apos;joah&apos;@&apos;192.168.4.170&apos; IDENTIFIED BY &apos;123456&apos;; #对用户进行授权 （3）在客户端进行配置 $ModLoad ommysql *.info;mail.none;authpriv.none;cron.none :ommysql:192.168.4.60,Syslog,joah,123456 [root@localhost ~]# service rsyslog restart #重启服务 （4）测试 在CentOS 6上测试 [root@localhost ~]# logger &quot;test first&quot; [root@localhost~]#mysql -u root -p #登陆mysql日志服务器查看 MariaDB [(none)]&gt; use Syslog MariaDB [Syslog]&gt; SELECT count(*) FROM SystemEvents; +----------+ | count(*) | +----------+ | 3 | +----------+ 1 row in set (0.00 sec) 四、日志图形化管理工具（1）解压缩 [root@localhost/usr/local/src]#tar xf loganalyzer-4.1.5.tar.gz （2）配置环境，由于是编译的httpd所有和yum安装的有所不一样 [root@localhost/usr/local/src/loganalyzer-4.1.5]#cp -r src/ /app/httpd24/htdocs/loganalyzer [root@localhost/app/httpd24]#cp /usr/local/src/loganalyzer-4.1.5/contrib/* htdocs/ [root@localhost/app/httpd24/htdocs/loganalyzer]#chmod +x secure.sh[root@localhost/app/httpd24/htdocs/loganalyzer]#chmod +x configure.sh[root@localhost/app/httpd24/htdocs/loganalyzer]#./configure.sh[root@localhost/app/httpd24/htdocs/loganalyzer]#./secure.sh（3）重启httpd服务 [root@localhost/app/httpd24/htdocs/loganalyzer]#apachectl stop[root@localhost/app/httpd24/htdocs/loganalyzer]#apachectl start （4）测试是否成功 http://192.168.4.60/loganalyzer/install.php?step=8 如果想生成图表可以安装yum install -y php-gd,然后重新启动httpd服务即可。]]></content>
      <categories>
        <category>日志</category>
        <category>rsyslog</category>
      </categories>
      <tags>
        <tag>rsyslog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sudo]]></title>
    <url>%2F2017%2F11%2F28%2Fsudo%2F</url>
    <content type="text"><![CDATA[sudo在生产环境中，一个人的力量总是不够的，我们可以把一些任务分配别的人员协同操作，这样办事效率也提高了。但是我们又不想把所有的权限都分给小伙伴，所以sudo就解决了这样一个问题。sudo能够授权指定用户在指定主机上运行某些命令；如果未授权用户使用sudo尝试登录，会提示管理员。这样方便了我们的管理。 1、含义sudo是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的一个工具，如halt，reboot，su等等。&lt;摘自：百度&gt; 2、sudo的优点（1）提供日志，记录每个用户使用sudo操作 （2）为系统管理员提供配置文件，允许系统管理员集中地管理用户的使用权限和使用的主机。 （3）sudo提供用户一个使用时长，相当于“入场券”，如果超时，重新登录。默认为5分钟（如果想修改，只能自己编译安装时候修改）。 （4）sudo提供专门的修改文件工具visudo，默认是vi界面，如果想使用vim功能，可以自定环境变量“export EDORIT=vim”。 （5）自己创建文件的权限为440，如果你忘记修改权限，visudo命令可以自动修改完成。 （6）修改配置文件是同时打开一个，不能打开多个。并且配置文件不建议直接去修改。 3、配置文件/etc/sudoers/和/etc/sudoers.d/*（1）配置文件支持使用通配符 通配符 说明 ？ 任意单个字符 * 匹配任意长度 [] 匹配单个字符 [!] 除了的任意字符 \ 支持转义 （2）授权规则格式 用户 登入主机=（代表用户） 命令 选项 说明 user 运行命令着的身份 host 通过哪些主机 （runas） 以哪个用户身份运行 command 运行哪些命令 user和runas格式 username #uid %group_name %#group_name User_Alias Runas_Alias host ip或hostname network network/prefix(只有CentOS7支持) Host_Alias command commandName directory sudoedit 可以对文件`/etc/sudoers`修改 CMD_Alias 注意：这里的命令一定要与执行的命令精确匹配，否则不成功。别名定义一定要大写字母开头，构成只能有字母和数字。 （3）别名 格式：Alias_Type NAME1 = item1, item2, item3 : NAME2 = item4, item5注意：不同的别名之间需要使用冒号隔开。%wheel是一个组，权限和root一样，使用时一定要小心。如果在添加NOPASSWD不提供口令直接登录。sudo使用时登录需要认证，但是此时认证时运行者的口令。 时间戳文件/var/db/sudo/日志文件/var/log/secure （4）设定默认值defaults 示例：Defaults：laowang runas_default=tom 4、sudo命令格式：sudo [-u user] COMMAND 选项 解释 -u 指定用户，默认root -l 列出用户在主机上可用的和被禁止的命令 -v 再延长有效期5分钟，更新时间戳 -k 清除时间戳（197–01-01），西祠需要重新输入密码 -K 与-k类似，但还要删除时间戳文件 -b 在后台执行 -p 改变询问密码的提示符号 %p代表用户 -V 显示版本信息等配置信息 注意：在sudoers文件中，如果定义文件后面添加“*”表示所有，即这个文件后面可以添加任意字符 ，言外之意，就是可以看到别的文件。]]></content>
      <categories>
        <category>安全</category>
        <category>sudo</category>
      </categories>
      <tags>
        <tag>sudo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scp、rsync，pssh工具]]></title>
    <url>%2F2017%2F11%2F28%2Fscp%E3%80%81rsync%EF%BC%8Cpssh%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[复制文件命令介绍1、scp命令scp：secure copy (remote file copy program) 格式： scp [options] [user@]host:/sourcefile /destpath scp [options] /sourcefile [user@]host:/destpath ||选项|含义||-c|压缩数据流||-r|递归复制|| -p|保持原文件属性||-q|静默模式|| -P PORT|指明远程主机的端口| 2、rsyncrsync: rsync - a fast, versatile, remote (and local) file-copying tool 格式： Pull: rsync [OPTION…] [USER@]HOST:SRC… [DEST] Push: rsync [OPTION…] SRC… [USER@]HOST:DEST 选项 含义 -n 模拟复制过程 -v 显示详细过程 -r 递归复制 -p 保留权限 -t 保留时间戳 -g 保留组信息 -o 保留所有者信息 -l 将软连接文件本身复制 -L 将软连接文件指向的文件复制 -X 保留SElinux属性 -a 存档，但不保留ACL和SElinux属性 注意：rsync命令只复制原有文件修改的文件或目录。而scp不管是否修改文件属性都复制。 3、sftp命令scp：secure file transfer program，交换式传输工具 格式： sftp [user@]host[:file ...] sftp [user@]host[:dir[/]] 如果我们管理几十台或者更多机器，使用起来并不是特别方便，而且还耗时耗力。下面介绍介个轻量级的工具。 4、psshpssh包是来自于epel源。 /usr/bin/pnuke /usr/bin/prsync /usr/bin/pscp.pssh /usr/bin/pslurp /usr/bin/pssh 以上执行的命令。 pssh命令： parallel ssh program 格式： pssh [-vAiIP] [-h hosts_file] [-H [user@]host[:port]] [-l user] [-p par] [-o outdir] [-e errdir] [-t timeout] [-O options] [-x args] [-X arg] command ... 选项 含义 -h HOST_FILE 包含IP的文件 -H [user@]IP[:port] 连接的主机，如果要接连多个主机用“”引起来，主机之间空格分开 -l USER 用户名 -p 并发数 -t 超时秒数 -o OUTDIR 输出目录，在该目录下创建 -e ERRDIR 错误输出目录 -x ARGS 传递过个命令，多个命令用“”引起来，使用空格分隔 -X 同-x意义一样，但每次只传递一个命令 -i 将输出结果输出当前终端 -I 读取每个输出命令，并传递ssh进程，允许脚本传送到标准输入 -v 显示ssh连接时的错误信息 -P 打印输出 -A 提示输入密码，并把密码传递给ssh服务 示例 pslurp：parallel process kill program 格式： pslurp [-vAr] [-h hosts_file] [-H [user@]host[:port]] [-l user] [-p par] [-o outdir] [-e errdir] [-t timeout] [-O options] [-x args] [-X arg] [-L localdir] remote local 选项 含义 -L localdir 复制远程主机文件或目录到本机指定的目录下 -r 递归复制 其他选项请参考pssh prsync 将文件或文件夹从本地同步到远程主机上 格式： prsync [-vAraz] [-h hosts_file] [-H [user@]host[:port]] [-l user] [-p par] [-o outdir] [-e errdir] [-t timeout] [-O options] [-x args] [-X arg] [-S args] local remote 选项 含义 -a 可以维持文件的属性 -z 压缩传输 pnuke：杀死远程主机上的进程，相当于killall]]></content>
      <categories>
        <category>命令</category>
        <category>scp、rsync，pssh工具</category>
      </categories>
      <tags>
        <tag>scp，rsync，pssh，pslurp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[varnish]]></title>
    <url>%2F2017%2F11%2F28%2Fvarnish%2F</url>
    <content type="text"><![CDATA[Varnish是一款高性能且开源的反向代理服务器和HTTP极速器，其采用全新的软件体系机构和现在的硬件体积紧密配合。 一、Varnish1、varnish系统结构 varnish主要运行两个进程：Manager进程和Cacher 进程 Manager进程功能： 实现应用新的配置 编译VCL（Varnish Configure Language） 监控varnish 初始化varnish 提供一个命令行接口 Manager进程每个几秒会探测cache进程是否正常运行，如果在指定的时间内未得到cache进程响应，Manager进程将重启此Cache进程 Cache进程包含多种类型的线程 Acceptor进程：接受新的链接请求并响应 Worker进程：cache进程会为每个会话启动一个worker线程，因此在高并发场景中可能会出现数百个worker进程或者更多 Expiry进程：从缓存中清理过期内容 varnish日志为了与系统的其他部分进行交互，Cache进程使用了可以通过文件系统接口进行访问的共享内存日志（shared memory log），如果某线程需要记录日志信息，其仅需要持有一个锁，而后向共享内存中的某内存区域写入数据，再释放持有的所即可。 共享内存日志大小一般为90M，其分为两部分，前一部分为计数器，另一部分为客户端请求的数据。varnish提供了多个不同管理日志工具：varnishlog、varnishncsa、varnishstat等来分析共享内存日志中的信息并能够以指定的方式进行显示 2、VCL（Varnish Configuration Language）varnish配置缓存策略工具，是一种基于“域（domain specific）”的简单编程语言。支持有限的算术运算和逻辑运算操作、允许使用正则表达式进行字符串匹配、允许用户使用set自定义变量、支持if判断语句、内置函数和变量等。使用VCL编写的缓存策略通常保存至.VCL文件中，其需要变异成二进制格式后才能由varnish调用。不过整个缓存策略由几个特定的子例程如vcl_recv、vcl_fetch等组成，它们分别在不同的位置执行，如果没有实现为某个位置自定义子例程，varnish将会执行默认定义。 编译过程VCL策略在启用之前，会由manager进程将其转换为C代码，然后再由gcc编译器将C代码编译成二进制程序；编译完成后，manager进程负责将其连接至varnish示例，即Cache进程。 优点： 由于编译工作在Cache进程之外完成，避免了装载错误格式VCL风险。因此varnish修改配置的开销非常小，其可以同时保存尚在引用的旧版本配置，也能够让新的配置即刻生效。编译后的旧版本配置通常在varnish重启时才会被丢弃，如果需要手动请求，则可以使用varnishadm中的vcl.discard命令完成。 3、varnish后端存储varnish支持多种不同类型的后端存储，可以在varnishd启动时使用-s选项指定。 后端存储类型 基于磁盘存储 file：使用特定的文件存储全部的缓存数据，并通过操作系统的mmap()系统调用将整个缓存文件映射至内存区域（如果条件允许） persistent：与file功能相同，但可以持久存储数据（即重启varnish数据时不会被清除），处于测试期基于内存存储 malloc：使用malloc()库调用在varnish启动时向操作系统申请指定大小的内存空间以存储缓存对象；串行存储模式 jemalloc：并行存储模式 选择使用合适的存储方式有助于提升系统性，从经验的角度看，建议在内存空间足以存储所有的缓存对象时使用malloc方法，反之，file存储将有着更好的性能表现。不过varnish实际上使用的空间比使用-s选项指定的缓存空间更大，一般来说，其需要为每个缓存对象多使用差不多1k左右的存储空间。 二、varnish状态引擎（Varnish Finite State Machine） 1、VCL状态引擎在VCL状态引擎中，状态之间具有相关性，但彼此间互相隔离，每个引擎使用return（action）来退出当前状态并指示varnish进入下一个状态。 处理过程varnish开始处理一个请求时，首先需要分析HTTP请求本身，如从首部获取请求方法、验证其是否为一个合法的HTTP请求等；当这些基本分析结束后就需要作出第一个决策，即varnish是否从缓存中查找请求的资源（需要由vcl_recv方法完成；如果没有自定义的vcl_recv函数指定其终止操作，其扔将执行默认的vcl_recv函数。）。 2、VCL语法基本语法： （1）//、#或/comment/用于注释 （2）sub $name 定义函数 （3）不支持循环，有内置变量 （4）使用终止语句，没有返回值 （5）域专用 （6）操作符：=、==、~、！、&amp;&amp;、|| 为什么VCL只有终止语句而没有返回值呢？ VCL函数不接受参数并没有返回值，并非真正意义上的函数，这也限定了VCL内部的数据传递只能隐藏在HTTP首部内部进行。VCL的return语句用于将控制权从VCL状态引擎返回给varnish，而非默认函数。 3、VCL内置函数VCL提供了几个函数来实现字符串修改，添加bans、重启VCL状态引擎以及将控制权转回varnish等 regsub（str，regex，sub）和regsuball（str，regex，sub）：这两个用于基于正则表达式搜索指定的字符串并替换为指定的字符串；只替换第一次匹配到的，而regsuball全部替换 ban（expression）： ban_url（regex）：bans所有其URL能够有regex匹配的缓存对象 purge：从缓存中挑选出某对象以及其相关变种一并删除，这可以通过HTTP协议的PURGE方法完成 hash_data（str）：指明哈希计算的数据；减少差异，以提升命中率 return（restart）：重新运行整个VCL，即重新从vcl_recv开始进行处理；每一次重启都会增加req-restarts变量中的值，而max_restarts参数则用于限定最大重启次数 4、vcl_recv在varnish完成对请求报文的解码为基础数据结构后的第一个要执行的子例程 主要用途（1）修改客户端数据已减少缓存对象差异性，如删除URL中的www.等字符 （2）基于客户端数据选用缓存策略，日入仅缓存特定的URL请求，不缓存POST请求等 （3）位某web应用程序执行URL重写规则 （4）挑选合适的后端web服务器 可以使用下面的终止语句，即通过return（）向varnish返回的指示操作： pass：绕过缓存，即不从缓存中查询内容或不将内容存储至缓存中 pipe：不对客户端进行检查或作出任何操作，而是在客户端与后端服务器之间建立专用“管道”，并直接将数据在二者之间进行传送；此时，keep-alived连接中后续传送的数据也都将通过此管道进行直接传送，并不会出现在任何日志中 lookup：在缓存中查找用户请求的对象，如果缓存中没有其请求的对象，后续操作很可能会将其请求的对象进行缓存 error：由varnish自己合成一个相应报文，一般是响应一个错误类信息、重定向类信息或负载均衡器返回的后端web服务器健康状态检查类信息 可以通过精巧的策略完成一定意义上的安全功能，以将某些特定的攻击扼杀于摇篮中，同时，它也可以检查出一些拼写错误并将其进行修修正 varnish默认的vcl_recv专门设计用来实现安全的缓存策略，主要完成两种功能：（1）仅处理可以识别的HTTP方法，并且只缓存GET和HEAD方法 （2）不缓存任何用户特有的数据 安全起见，一般在自定义的vcl_recv中不要使用return()终止语句，而是再由默认vcl_recv进行处理，并由其作出相应的处理决策。 5、vcl_fetch根据服务器的响应作出缓存决策；在任何VCL状态引擎中返回的pass操作都将由vcl_fetch进行后续处理。vcl_fetch中有许多可用的内置变量，比如最常用的用于定义某对象缓存时长的beresp.ttl变量 通过return()返回给varnish的操作指示有：（1）deliver：缓存此对象，并将其发送给客户端（vcl_deliver） （2）hit_for_pass：不缓存此对象，但可以导致后续对此对象的请求直接送达到vcl_pass进行处理 （3）restart：重启整个VCL，并增加重启计数；超过max_restarts限定的最大重启次数后将会返回错误信息 （4）error code [reason]：返回指定的错误代码给客户端并丢弃此请求 默认的vcl_fetch放弃了缓存任何使用了Set-Cookie首部的响应。 两个特殊引擎- vcl_init：在处理任何请求之前要执行的vcl代码：主要用于初始化VMODs； vcl_fini：所有的请求都已经结束，在vcl配置被丢弃时调用；主要用于倾全力VMODs； 三、修改缓存对象1、缓存内容修剪提高缓存命中率的最有效途径之一时增加缓存对象的生存时间（TTL），但是这也可能会带来副作用，比如缓存的内容再到达为其制定的有效期之间已经失效。因此，手动检验缓存对象的有效性或者刷新时缓存很有可能成为服务器管理员的日常工作之一；varnish完成这类的任务提供了三种途径：HTTP修剪(HTTP purging)、禁用某类缓存对象（banning）和强制缓存未命中（forced cache misses） 2、移除单个缓存对象purge用于清理缓存中的某特定对象及其变种，因此在有着明确要修剪的缓存对象时可以使用此中方式。HTTP协议的PURGE方法可以实现purge功能，不过其仅能用于vcl_hit和vcl_miss中，它会释放内存工作并移除指定缓存对象的所有vary（变种），并等待下一个针对此内容客户端请求到达时刷新此内容。起一般要与return（restart）一起使用。 3、强制缓存未命中在vcl_recv中使用return（pass）能够强制到上游服务器取得请求的内容，但这也会导致无法将其缓存。使用purge会移除就的缓存对象，但如果上游服务器宕机而无法取得新版本的内容时，此内容将无法再响应给客户端。使用req.has_always_miss=true，可以让varnish在缓存中搜寻响应的内容但却总是回应“未命中”，于是vcl_miss将后续地负责启动vcl_fetch从上游服务器取得新内容，并以新内容缓存覆盖就内容；此时，如果上游服务器宕机或未响应，旧的内容将保持原状，并能够继续服务器那些为使用req.has_always_miss=true的客户端，直到其过期失效或者由其他方法移除。 4、banningban（）是一种已缓存对象中过滤出某此特定的对象并将其移除的缓存内容刷新机制，不过它并不足之处新的内容进入缓存或响应于请求。在varnish中，ban的实现是指将一个ban添加至ban列表中，这可以通过命令行接口或VCL实现，他们的使用语法时相同的。ban本身就是一个或多个VCL风格的语句，它会在varnish从缓存哈希（cache hash）中查找某缓存对象时对搜寻的对象进行比较测试，因此，一个ban语句就是类似匹配所有以/downloads开头的URL，或者响应首部中包含nginx的对象。 示例： ban req.http.host == “test。com” &amp;&amp; req.url ~ “\.gif$” 定义好的ban语句会生成一个ban列表（ban-list），新添加的ban语句会被放置在列表中的首部。缓存中的所有对象在响应给客户端之前都会被ban列表检查至少一次，检查完成将会为每个缓存创建一个指向与其匹配的ban语句的指针。varnish在从缓存中获取对象时，总是会检查此缓存对象的指针是否指向了ban列表的首部；如果没有指向ban列表的首部，其将对使用所有的新添加的ban语句对此缓存对象进行测试，如果没有任何ban语句能够匹配则更新ban列表。 四、varnish检测后端主机的健康状态varnish可以检测后端主机的健康状态，在判定后端主机失效时能够给自动将其从可用后端主机列表中移除，而一旦其重新变得可用还可以自动将其设定为可用。为了避免误判，varnish在探测后端主机的健康状态发生转变时，通常需要连续执行几次探测均为新状态才将其标记为转换后的状态。 每个后端服务器当前探测的健康状态探测可以使用.probe进行设定，其结果可有req.backend.healthy变量获取；也可以通过varnishlog中的backend_health查看或varnishadm的debug.health查看 ####### .probe的探测常用的指令： （1）.url：探测后端主机健康状态时请求的URL，默认为”/“ （2）.request：探测后端主机健康状态时请求内容的详细格式，定义后，它会替换.url指定的探测方法 （3）.window：设定在判定后端主机健康状态时基于最近多少次的探测进行，默认为8 （4）.threshold：在.window中指定的次数中，至少有多少次时成功的才能判定后端主机健康运行，默认为3 （5）.initial：varnish启动时对后端主机至少需要多少次的成功探测，默认同.threshold （6）.expected_response：期望后端主机响应的状态码，默认为200 （7）.interval：探测请求的发送周期，默认为5s （8）.timeout：每次探测请求的过期时长，默认为2s 如果varnish在某时刻没有任何可用的后端主机，它将尝试使用缓存对象的“宽容副本（graced copy）”，此时VCL中的各种规则亦然有效。因此更好的办法时在VCL规则中判断req.backend.health变量显示某后端主机不可用时，为此后端主机增大req.grace变量的值以设定使用的宽容期限长度。 五、varnish使用多台后端主机varnish中可以使用的director指令将一个或多个近似的后端主机定义为一个逻辑组，并可以指定的调度方式来轮流将请求发送至这些主机上。不同的director可以使用同一个后端主机，而某director也可以使用“匿名”后端主机（在direcotr中直接进行定义）。每个director都必须有专用名，且在定义后必须在VCL中进行调用，VCL中任何可以指定后端主机的位置均可以按需将其替换为调用已定义的director。 使用前需要导入directors模块 示例： import directors; backend server1 { .host = 192.168.4.60 .port = 80 } backend server2 { .host = 192.168.4.61 .port = 80 } sub vcl_init { new testgrp = direcotrs.round_robin(); testgrp.add_backend(server1); testgrp.add_backend(server2); } sub vcl_recv { set req.backend_hint = testgrp.backend(); } 六、varnish参数varnish有许多参数，但是在某些场合我们需要修改他们提高性能。可以在管理接口中使用param.show命令查看这些参数，而使用param.set则能修改这些参数的值。当时，在命令行接口进行的修改不会保存至任何位置，重启varnish后这些设定会消失。可以通过启动脚本使用-p选项在varnishd启动时为其设定参数的值。 1、线程模型 cache-worker线程：每连接一个用于处理请求， cache-main线程：全局只有一个，用于启动cache 2、线程相关的参数 thread_pools：工作线程池，最好小于或等于CPU核心数量 thread_pool_max：每线程池最大线程数 thread_pool_min：每线程池最小线程数，即最大空闲线程数 thread_pool_timeout：每线程的超时时长 thread_pool_add_delay：添加线程的延迟时间 thread_pool_destory_delay：每线程销毁时长 3、timer相关的参数 send_timeout：客户端连接超时时长 timeout_idle：Idle timeout for client connections. timeout_req：请求超时时长 cli_timeout：Timeout for the childs replies to CLI requests from the mgt_param. 七、varnish命令行工具1、varnishadm命令通过命令行的方式连接至varnishd进行管理操作的工具。 语法： varnishadm [-t timeout] [-S secret_file] [-T address:port] [-n name] [command [...]] 指定要连接的varnish示例的方法：-n name 连接至名称为“name”的示例 -T address:port 连接至指定套接字上的示例 配置文件相关： vcl.list： vcl.load：装载，加载并编译 vcl.use：激活 vcl.discard：删除 vcl.show [-V] &lt;configname&gt;：查看指定的配置文件的详细信息 运行时参数： param.show -1：显示列表 param.show &lt;PARAM&gt; param.set &lt;PARAM&gt; &lt;VALUE&gt; 缓存存储： storage.list 后端服务器： backend.list 2、varnish.param选项 -a address[:port][,address[:port]...]，默认为6081端口 -T address[:port]，默认为6082 -s [name=]type[,options]，定义缓存存储机制 -u user -g group -f config，VCL配置文件 -F 运行在前台 -p param=value：设定运行参数即数值，可重复使用多次 -r param[,param]：设定指定的参数为只读状态 3、varnishstatvarnish缓存统计信息 -l：列出 -f：指定字段名称列表 MAIN.cache_hit MAIN.cache_miss 4、varnishtopvarnish日志全部等级 -l -i taglist，可以同时使用多个-i选项，也可以一个选项跟上多个标签 -I &lt;[targlist:]regex&gt; -x taglist:排除列表 -X &lt;[taglist:]regex&gt; 八、varnish配置文件配置varnish服务进程的工作特性，例如监听的地址和端口，缓存机制 /etc/varnish/varnish.params 配置各Child/cache线程的缓存策略 /etc/varnish/default.vcl 主程序 /usr/sbin/varnishd share memory log交互工具 /usr/bin/varnishhist /usr/bin/varnishlog /usr/bin/varnishncsa /usr/bin/varnishstat /usr/bin/varnishtop 测试工具程序 /usr/bin/varnishtest VCL配置文件重载程序 /usr/sbin/varnish_reload_vcl systemd unit file /usr/lib/systemd/system/varnish.service /usr/lib/systemd/system/varishlog.service /usr/lib/systemd/system/varnishncsa.service]]></content>
      <categories>
        <category>缓存服务</category>
        <category>varnish</category>
      </categories>
      <tags>
        <tag>varnish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于数据库验证vsftpd虚拟用户]]></title>
    <url>%2F2017%2F11%2F28%2F%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AA%8C%E8%AF%81vsftpd%E8%99%9A%E6%8B%9F%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[基于数据库验证vsftpd虚拟用户CentOS7 环境 （1）编译安装pam_mysql,提供pam_mysql.so模块[root@localhost/usr/local/src/pam_mysql-0.7RC1]#yum install -y mariadb-devel pam-devel[root@localhost/usr/local/src/pam_mysql-0.7RC1]#./configure --with-mysql=/usr --with-pam=/usr --with-pam-mods-dir=/lib64/security[root@localhost/usr/local/src/pam_mysql-0.7RC1]#make &amp;&amp; make install （2）准备数据库和相关表 [root@localhost~]#mysql -uroot -p MariaDB [(none)]&gt; CREATE DATABASE ftpdb; MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON ftpdb.* TO ftpuser@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;; MariaDB [(none)]&gt; USE ftpdb; MariaDB [ftpdb]&gt; CREATE TABLE vuser (ID int unsigned auto_increment primary key,username char(40),password char(50)); [root@localhost~]#useradd -d /app/ftproot -s /sbin/nologin ftpuser[root@localhost~]#chmod 555 /app/ftproot/ #修改目录权限，因为CentOS7中默认不允许父目录有写权限 （3）添加虚拟用户 MariaDB [ftpdb]&gt; INSERT INTO vuser(username,password) VALUES(&apos;joah&apos;,password(&apos;123456&apos;)); MariaDB [ftpdb]&gt; INSERT INTO vuser(username,password) VALUES(&apos;li&apos;,password(&apos;123456&apos;)); （4）建立pam认证所需文件 [root@localhost~]#vim /etc/pam.d/vsftpd.mysql 1 auth reuqired pam_mysql.so user=ftpuser passwd=123456 host=localhost db=ftpdb table=vu ser usercolumn=username passwdcolumn=password crypt 2 2 account reuqired pam_mysql.so user=ftpuser passwd=123456 host=localhost db=ftpdb table =vuser usercolumn=username passwdcolumn=password crypt 2 选线说明： auth 表示认证 account 验证账号密码正常使用 reuqired 表示认证通过 user 为登录mysql的用户 passwd 登录mysql的密码 host mysql服务器的主机名或IP地址 db 指定连接mysql的数据库名称 table 指定连接数据库中的表名 usercolumn 当做用户名的字段 passwdcolumn 当做用户名字段的密码 crypt 表示加密方式，0表示不加密；1表示crypt（3）加密；2表示使用mysql password（）函数加密；3表示md5加密；4表示sha1加密 （5）创建虚拟用户配置文件 [root@localhost/etc/vsftpd]#mkdir vdocs[root@localhost/etc/vsftpd]#cd vdocs/[root@localhost/etc/vsftpd/vdocs]#vim joah [root@localhost/etc/vsftpd/vdocs]#vim li （6）修改/etc/vsftpd/vsftpd.conf 在配置文件中添加如下内容 128 guest_enable=YES 129 guest_username=ftpuser 130 pam_service_name=vsftpd.mysql 131 user_config_dir=/etc/vsftpd/vdocs （7）重启服务并测试]]></content>
      <categories>
        <category>文件管理</category>
        <category>FTP</category>
        <category>基于数据库验证vsftpd虚拟用户</category>
      </categories>
      <tags>
        <tag>数据库，vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库类型]]></title>
    <url>%2F2017%2F11%2F28%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、数据库1、数据库的概念数据库(Database)是按照数据结构来组织、存储和管理数据的建立在计算机存储设备上的仓库；它以一定的组织形式存于存储介质上。 2、数据库管理系统(Database Management System)一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS。它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。用户通过DBMS访问数据库中的数据，数据库管理员也通过dbms进行数据库的维护工作。它可使多个应用程序和用户用不同的方法在同时或不同时刻去建立，修改和询问数据库。大部分DBMS提供数据定义语言DDL（Data Definition Language）和数据操作语言DML（Data Manipulation Language），供用户定义数据库的模式结构与权限约束，实现对数据的追加、删除等操作。 &lt;摘自：百度&gt; 3、数据库管理系统与文件管理系统对比||编写应用程序不方便|编写应用程序方便，好管理|数据冗余不可避免|较少的数据冗余|应用程序依赖性|程序与数据相互独立|不支持对文件并发访问|数据可以被并发访问；并保证一致性|数据之间联系弱|相互关联的数据集合|难以按用户要求使用视图表示|可以按用户的需求使用视图表示|无安全控制功能|可以保证数据的安全性、可靠性 4、数据库的种类（1）非关系型数据库（2）关系型数据库（RDBM）创建在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。标准数据查询语言SQL就是一种基于关系数据库的语言。这种语言执行对关系数据中数据的检索和操作。关系模型由关系数据结构、关系操作集合和关系完整性约束三部分组成。 数据结构 包括两类：一类是与数据类型、内容和性质有关的对象，比如关系型中的域、属性和关系等；另一类是与数据之间有关的对象，它从数据组织层表达数据记录于字段的结构。 数据的操作集合 数据提取，在数据集合中提取感兴趣的内容。（SELECT）；数据更新，更改数据库中的数据（INSERT、DELETE和UPDATE）。 数据完整性约束 是一组完整性规则的集合。如实体完整性（Entity Integrity）、域完整性（Doamin Integrity）和参考完整性（Referential Integrity）。 （a）关系实体模型（Entity-Relationship Model，E-R Model） 注： 矩形代表实体 椭圆代表关系 菱形代表关系 实体表示一个离散对象。客观存在并可以相互区分的客观事物或抽象时间被称为实体（Entity）；每个实体必须有一个唯一表示的最小化集合。这个集合叫实体的主键。 关系 描述了两个或多个实体之间是如何关联。如有关两个实体 （b）构建数据库步骤①收集数据，得到字段 ②字段分类，归入表并建立表的关联 ③规范化数据库 （c）关系型数据库正规化设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为范式。各种范式呈递次规范，越高的范式数据库冗余越小。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、Boyce-Codd范式（BCNF）、第四范式（4NF）和第五范式（5NF） 1NF：无重复的列，每一列都是不可分割的基本数据项；同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。除去同类型的字段，简言之：无重复的列。 2NF：要求实体的属性完全依赖于关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。如果存在这个属性和主关键字的这一部分应该分离出来形成一个新的实体。新实体与原来实体之间是一对多关系。为实现区分通常需要为表加上一个列，以存储各个实体的唯一标识（primary key）。简言之，非主属性分非部分依赖于主关键字。 3NF：属性不依赖于其他非主属性。简言之，要求一个数据库不包含已在其他表中已包含的非主关键字信息。非PK（primary key）的字段不能有从属关系。 注意：不过这个不是必要遵守的，有时候在生产中，为了提升效能，刻意而为之。]]></content>
      <categories>
        <category>数据库</category>
        <category>数据库类型</category>
      </categories>
      <tags>
        <tag>数据库类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中五种I/O模型]]></title>
    <url>%2F2017%2F11%2F28%2F%E6%A8%A1%E5%9E%8BIO%2F</url>
    <content type="text"><![CDATA[linux中五种I/O模型- 同步与异步关注的是消息通信机制 同步（synchronous）：调用者自己主动等待被调用者返回消息，才能继续执行下面操作。异步（asynchronous）：被调用者通过状态、通知或回调机制主动通知调用者被调用者运行的状态。阻塞与非阻塞关注调用者在等待结果返回之前所处的状态 阻塞（blocking）：指I/O操作需要彻底完成后才能返回到用户空间，调用结果返回之前，调用者被挂起。非阻塞（nonblocking）：指I/O操作被调用后立即返回给用户一个状态值，无需等到I/O操作彻底完成，最终的调用结果返回之前，调用者不会被挂起。程序空间与内核空间在linux中，对于一次I/O操作数据并不会直接拷贝到程序空间的程序缓冲区；数据首先被拷贝到操作系统内核的缓冲区中，然后丛操作系统内核的缓冲区拷贝到程序空间的缓冲区。 blocking IO（阻塞IO） 工作机理用户进程通过系统调用read发起IO读操作，由用户空间转到内核空间；内核等待数据包到达后，然后将接受的数据拷贝到用户空间，完成read操作。 但是用户需要等待read将数据读取到buffer后才能继续处理接受接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情去，对CPU的资源利用率不够。 nonblocking（非阻塞IO） 工作机理用户进程发起IO请求立即返回，但并未读取到任何数据，用户进程需要不断地发起IO请求，直到数据到达之后，才能真正读取数据，继续执行。即“轮询”机制。 这个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍然需要不断地轮询、重复请求，消耗了大量CPU资源 IO multiplexing（IO 复用） 工作机理用户首先将需要进行IO操作添加到select中，继续执行做其他的工作，同时等待select系统调用返回。当数据到达后，IO被激活，select函数返回。 用户线程正式发起read请求，读取数据并继续执行。从流程上看，使用了select函数进行IO请求和同步阻塞模型没有太大的区别，甚至多了监视IO，以及调用select函数的额外操作，效率更差。而且模型阻塞了两次，第一次阻塞在select上时，select可以监视多个IO上是否已有IO操作准备就绪，即可达到在同一个线程内同时处理多个IO请求的目的。如果用户线程只是注册自己需要的IO请求，然后去做自己的事情去，等待数据到来时再进行处理则可以提高CPU的利用率。 IO费用使用场合：（1）当客户处理多个描述符时（一般是交互式输入和网络套接字），必须使用IO复用。 （2）当一个客户同时处理多个套接字 （3）当一个TCP服务器既要处理多个套接口时，又要处理已经连接套接口 （3）当一个服务器即要处理TCP，又要处理UDP （4）当一个服务器要处理多个服务或多个协议 singal driven IO （信号驱动IO） 工作机理用户进程可以通过sigaction系统调用注册一个信号处理程序，然后主程序可以继续向下执行，当有IO操作准备就绪时，由内核通知触发一个SINGO信号处理程序执行，然后将用户进程所需要的数据从内核空间拷贝到用户空间。 asynchronous IO （异步IO） 工作机理异步IO直接在第二阶段完成后内核直接通知可以进行后续操作。 小结- I/O模型具体实现select- POSIX所规定，本质上是通过设置或者检查存放FD标志位数据结构来处理进行下一步处理 缺点(1)当个进程可监视FD数量被限制，即能监听端口的数量有限 cat /proc/sys/fs/file-max (2)对socket是线性扫描，即采用轮询的方法，效率低 (3)select采取内存拷贝方法来实现内核将FD消息通知给用户空间，这样一个用来存放大量FD的数据结构，会使得用户空间和内核空间在传递该结构时复制开销大 poll- 本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个FD对应的设备状态 （1）没有最大连接数的限制，原因是基于链表来存储的 （2）大量的FD的数组被整体复制与用户态和内核地址空间之间，而不管这样的复制是不是有意义 （3）poll特点是“水平触发”，如果报告了FD后，没有处理那么下次poll时会再次报告该FD （4）边缘触发：只通知一次 epoll- 支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些FD刚刚变为就绪态，并且只会通知一次。使用“事件”的就绪通知方式，通过epoll_ctl注册FD，一旦该FD就绪，内核就会采用类似callback的回调机制来激活该FD，epoll_wait便可以收到通知。 优点：（1）没有最大并发连接的限制：能打开的FD上线远大于1024 （2）效率提升，非轮询方式，不会随着FD数目的增加而效率下降；只有活跃可用的FD才会调用callback函数，即epoll最大的优点在于它只管理“活跃”的链接，而根连接总数无关。 （3）内存拷贝，利用mmap（）文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销]]></content>
      <categories>
        <category>I/O模型</category>
        <category>Linux中五种I/O模型</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统安装]]></title>
    <url>%2F2017%2F11%2F28%2F%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[为什么我们要自动化安装系统呢？管理一些重复性的操作呢，这样可以减轻自己的操作，并且提高了工作效率，假如公司中又有十几台甚至更多的服务器，不可能自己一台一台的安装，这样就需要自动化安装。 一、光盘内容简介1、CentOS系统的启动流程POST–&gt;boot Sequence–&gt;bootloader(MBR)–&gt;kernel(initramdisk)–&gt;rootfs–&gt;/sbin/init/ 2、光盘内容（1）[root@centos7/media/cdrom/isolinux]#ls 内容 解释 boot.cat 相当于启动菜单显示内容 grub.conf 启动系统启动与boot.cat显示内容配置文件 isolinux.bin 相当于系统安装的stage2阶段 memtest 内存检测，这是个独立程序 vmlinuz 内核映像 boot.msg initrd.img 虚拟文件系统 isolinux.cfg isolinux.cat的配置文件 splash.png 背景图片 vesamenu.c32 显示背景界面 （2）isolinux.cfg详解 default vesamenu.c32 #支持菜单功能 timeout 600 #菜单倒计时，十分之算 display boot.msg #显示一条信息 # Clear the screen when exiting the menu, instead of leaving the menu displayed. # For vesamenu, this means the graphical background is still displayed without # the menu itself for as long as the screen remains in graphics mode. menu clear #清除菜单选项 menu background splash.png #显示背景图片 menu title CentOS Linux 7 #显示title menu vshift 8 menu rows 18 menu margin 8 #menu hidden menu helpmsgrow 15 # Border Area menu color border * #00000000 #00000000 none # Selected item menu color sel 0 #ffffffff #00000000 none # Title bar menu color title 0 #ff7ba3d0 #00000000 none # Press [Tab] message menu color tabmsg 0 #ff3a6496 #00000000 none # Unselected menu item menu color unsel 0 #84b8ffff #00000000 none # Unselected hotkey menu color hotkey 0 #ffffffff #00000000 none # Help text menu color help 0 #ffffffff #00000000 none # A scrollbar of some type? Not sure. menu color scrollbar 0 #ffffffff #ff355594 none # Timeout msg menu color timeout 0 #ffffffff #00000000 none menu color timeout_msg 0 #ffffffff #00000000 none # Command prompt text menu tabmsg Press Tab for full configuration options on menu items. #键入TAB进入配置模式 menu separator # insert an empty line menu separator # insert an empty line label linux #相当于标签 menu label ^Install CentOS Linux 7 #安装linux kernel vmlinuz #内核文件 append initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 quiet #向内核传递参数 label check menu label Test this ^media &amp; install CentOS Linux 7 menu default #默认启动项 kernel vmlinuz menu separator # insert an empty line # utilities submenu menu begin ^Troubleshooting menu title Troubleshooting label vesa menu indent count 5 menu label Install CentOS Linux 7 in ^basic graphics mode text help Try this option out if you&apos;re having trouble installing CentOS Linux 7. endtext kernel vmlinuz append initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 xdriver=vesa nomodeset quiet label rescue menu indent count 5 menu label ^Rescue a CentOS Linux system text help If the system will not boot, this lets you access files and edit config files to try to get it booting again. endtext kernel vmlinuz append initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rescue quiet label memtest menu label Run a ^memory test text help If your system is having issues, a problem with your system&apos;s memory may be the cause. Use this utility to see if the memory is working correctly. endtext kernel memtest menu separator # insert an empty line label local menu label Boot from ^local drive localboot 0xffff menu separator # insert an empty line menu separator # insert an empty line label returntomain menu label Return to ^main menu menu exit menu end 配置文件中有“^”相当于快捷键。 3、anaconda程序（1）概念anaconda是系统安装程序。启动系统安装过程。 （2）anaconda安装过程anaconda安装分为三个阶段： （a）安装前配置阶段 安装过程使用的语言 键盘类型 安装目标存储设备 basic storage 本地磁盘 特殊设备 iscsI 设定主机名 配置网络接口 时区设置 管理员密码 设定分区方式及MBR的安装位置 创建一个普通用户 选定要安装的程序包 （b）安装阶段在目标磁盘 创建分区，执行格式化操作等 选定的程序包安装至目标位置 安装BootLoader和initramfs （c）图形模式首次启动 iptables selinux core dump （3）安装程序包的选择（a）本地光盘 （b）本地硬盘 （c）NFS （d）URL ftp server :yum repository http server:yum repository （e）手动指定安装源 在系统启动选项菜单界面进入TAB键，进入boot命令行模式输入`linux askmethod`，如果需要网络后续会跳出来一个对话框填入IP即可。 （4）anaconda配置方式（a）交互式配置 （b）通过读取事先给定的配置文件自动完成配置（kickstart文件） 4、kickstart文件（1）配置文件详解#version=DEVEL #指明版本 # System authorization information auth --enableshadow --passalgo=sha512 # Install OS instead of upgrade install # Use text install text # Firewall configuration firewall --disabled firstboot --disable ignoredisk --only-use=sda # Keyboard layouts keyboard --vckeymap=cn --xlayouts=&apos;cn&apos; # System language lang en_US.UTF-8 # Use network installation #url --url=&quot;http://172.16.0.1/cblr/links/CentOS-7-1511-x86_64&quot; #repo --name=&quot;source-1&quot; --baseurl=http://172.16.0.1/cobbler/ks_mirror/CentOS-7-1511-x86_64 #url --url=&quot;http://172.16.0.1/cobbler/ks_mirror/7/&quot; url --url=$tree # Network information network --bootproto=dhcp --device=ens33 --onboot=yes --ipv6=auto network --hostname=localhost.localdomain # Reboot after installation reboot # SELinux configuration selinux --disabled # Do not configure the X Window System skipx # Root password rootpw --iscrypted $6$dGARWYghrvhD9W7P$4af2uw8A4tHvNLe2F6bDrk0J69dt.uYoV4SneKG4kzIsc/nF3JpfnuHg7D5lVE.jxC3p6.K29FCjwtom9VXWf. # System timezone timezone Asia/Shanghai user --groups=wheel --name=wang --password=$6$S0t9SxXkvSI0Npz5$YDVonz69YGGGkGyZDy/KesO4CI1HUBLNThcHj6PXDntQGS0Cl0SNpN6zGASuzYE.z5veu1XAzMvO4xLWbKE.n0 --iscrypted --gecos=&quot;123456&quot; # System bootloader configuration bootloader --location=mbr --boot-drive=sda # Partition clearing information clearpart --all --initlabel # Disk partitioning information part /boot --fstype=&quot;xfs&quot; --ondisk=sda --size=500 part swap --fstype=&quot;swap&quot; --ondisk=sda --size=2049 part / --fstype=&quot;xfs&quot; --ondisk=sda --size=40960 part /app --fstype=&quot;xfs&quot; --ondisk=sda --size=20480 %post systemctl set-default multi-user.target [ ! -d /root/.ssh ] &amp;&amp; mkdir /root/.ssh &amp;&amp; chmod og=--- /root/.ssh cat &gt;&gt; /root/.ssh/authorized_keys &lt;&lt; EOF ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAlmq1z0G/7wbGuSUewfXlFnwzqCg/myqTi/AwP8LP+JJ49xzIKMzpeWXHD8RWIf5RlDzo+6N7uPK5O22x/QtMosi0egz4shavEJeUkO0EH+KygXXgBIGuMWmAsL+yzbgWXT9H3zdzXi/qWcrBeBv2nYB5mpYSf7o0xqdhCst1MTfcYLD8qxvkwC8RiqBA/1u9N6jeDFbHO+UzZYYCr9zgk9uz4Rrhb9BU7c1GhjUCgRwBDAuo47IHw/OT6KS9lb8lT2R/ujVoDARy/eOhw8cAFXo+QcvzNSW2qKf/Qo21uR/wz2u9SRV0lvUDNSvC2PYtR+iPlDwHY81md430yiNf9w== root@172.16.0.1 EOF ClientName=`ifconfig enoens33 | awk &apos;/inet\&gt;/{print $2}&apos; | awk -F. &apos;{print $NF}&apos;` hostnamectl set-hostname &quot;stu$ClientName.wang.com&quot; #mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak #wget http://172.18.0.1/repos/CentOS-Base.repo -O /etc/yum.repos.d/CentOS-Base.repo %end %packages @base @core @fonts @input-methods @kde-apps @kde-desktop @network-file-system-client @networkmanager-submodules @x11 lftp screen %end %addon com_redhat_kdump --disable --reserve-mb=&apos;auto&apos; %end （2）kickstart文件格式（a）命令端：指明各种安装前配置，如果键盘类型，时区等 必备命令 authconfig：认证方式配置 authconfig –useshadow –passalgo=sha512 bootloader:bootloader的安装位置及相关配置 bootloader –location=mbr –driverorder=sda –append=“crashkernel=auto rhgb quiet” keyboard：设定键盘类型 lang：语言类型 part：创建分区 rootpw：指明root的密码 timezone：时区 可选命令 install OR update text :文本界面安装 network 设定网络 firewall 设置防火墙 selinux 设置selinux halt poweroff reboot repo user：安装完成后为系统创建新用户 url：指明安装源 key -skip：跳过安装号码，适用于rhel版本 （b）程序包段：指明要安装的程序包或程序包组，不安装的包等 %packages #表明开始安装程序包或包组 @group_name #安装包组 package #安装程序包 -package #不安装程序包 %end 指明安装结束 （c）脚本段：指明运行的脚本 %pre #安装前脚本 运行环境：运行于安装介质上的微型linux环境 %post #安装后脚本 运行环境：运行于安装完成后的系统 注意：在每段中一定要有开始有结束%end表明结束安装。 （3）kickstart文件创建方式（a）直接手动编辑，可以依赖模板进行自行修改 （b）可使用创建工具：system-config-kickstart命令，依赖某模板修改并生成新的配置文件注意：在CentOS7中，如果要使用此命令必须把yum仓库光盘的名称修改为development。 检查ks文件的语法错误：ksvalidator 格式：ksvalidator /PATH/TO/SOMEFILE （4）指明kickstart位置DVD drive:ks=cdrom:/PATH/TO/KICKSTART_FILE Hard drive:ks=hd:/PATH/TO/KICKSTART_FILE FTP server:ks=ftp://host:port/PATH/TO/KICKSTART_FILE HTTP server:ks=http://host:port/PATH/TO/KICKSTART_FILE HTTPS server:ks=https://host:port/PATH/TO/KICKSTART_FILE NFS server:ks=nfs:host:/PATH/TO/KICKSTART_FILE 如果想理解更多，请查考详细内容《Installation Guide》。 （5）系统启动的不同方式（a）text：文本安装模式 （b）askmethod：手动指定安装方法 在系统启动界面，键入ESC进入boot命令行模式：输入linux askmethod 与网络相关的引导选项： ip=IPADDR netmask=NETMAKS gateway=GATEWAY dns=DNS_SERVER_IP ifname=NAME:MAC_ADDR（c）与远程功能相关的引导选项 vns vncpassword=“PASSWORD” 实战 手动指定kickstart文件安装系统 方式一： （1）在CentOS7上搭建ftp服务 [root@centos7~]#cd /var/ftp/pub/[root@centos7/var/ftp/pub]#cp /root/ks*.cfg .[root@centos7/var/ftp/pub]#ls ks6.cfg ks7.cfg （2）创建一块虚拟机 （3）手动指定按启动，选定光盘启动 当出现上面图示时，我们手动指定kickstart启动。 方法一：按TAB键，输入ks=ftp://192.168.4.135/pub/ks6.cfg；回车启动方法二：按ESC键进入boot命令行，输入linux ks=ftp://192.168.4.135/pub/ks6.cfg 方式二： 在CentOS7搭建http服务 [root@centos7/var/www/html]#mkdir ks[root@centos7/var/www/html]#mv ks*.cfg ks 其余步骤同上述方法类似。 注意：上述过程必须使ks文件权限为644.上述方法前提为桥接模式。 上述方法是没有办法安装包等后续工作的，我们可以搭建网络yum源进行安装。 方式一：创建网络yum源安装 （1）安装vsftpd服务，并启动服务 （2）将ks7.cfg文件复制到 /var/ftp/pub目录下 （3）在/var/ftp/pub目录下创建centos/7 [root@centos7/var/ftp/pub]#mkdir centos/7 -pv （4）将光盘挂载到centos/7上 [root@centos7/var/ftp/pub]#mount /dev/sr0 /var/ftp/pub/centos/7/（5）测试是否能在网页中打开 输入地址ftp://192.168.4.135/pub （6）新建一台虚拟机测试 按ESC键进入boot命令行，输入linux ks=ftp://192.168.4.135/pub/ks6.cfg ip=192.168.4.138 netmask=255.255.255.0 或按TAB键在行后追加ks=ftp://192.168.4.135/pub/ks6.cfg ip=192.168.4.138 netmask=255.255.255.0 （7）出现下面说明成功 方式二： （1）在CentOS7上搭建http服务 （2）在/var/www/html目录下创建ks目录和centos/7目录 [root@centos7/var/www/html]#mkdir testcentos/7 -pv （3）将光盘挂载至centos/7目录下[root@centos7/var/www/html]#mount /dev/sr0 testcentos/7/ （4）重启服务测试在网站输入http://192.168.4.135/test（5）新建一台虚拟机重新测试，出现下面内容说明成功 按ESC键进入boot命令行，输入linux ks=ftp://192.168.4.135/pub/ks7.cfg ip=192.168.4.138 netmask=255.255.255.0 或 按TAB键在行后追加ks=ftp://192.168.4.135/pub/ks7.cfg ip=192.168.4.138 netmask=255.255.255.0 二、制作光盘或U盘在日常的生产活动中，使用光驱的已经很少了，但是U盘自身的特点得到了大多数人的使用，这样让我掌握如何制作U盘变得特别重要，如果我们公司有的服务器没有光盘咋办，？U盘就很好的帮我们解决了这个问题。 1、如何制作光盘（1）mkisofs命令有关包genisoimage制作光盘需要使用命令才能执行。 ||选项|解释||-o|指定影响文件的名称||-b|指定在制作可开机光盘是所需要的开机映像文件||-c|制作可开机光盘时，会将开机映像文件中的no-eltorito-catalog全部内容做成一个文件||-no-emul-boot|非模拟模式启动||-boot-load-size 4|设置载入部分的数量||-boot-info-table|在启动的图像中显示信息||-R，-rock|使用Rock RidgeExtensions||-J，-joliet|使用Joliet格式的目录与文件名称||-v，-verbose|执行时显示过程||-T，-translation-table|建立文件名的装换表，适用于不支持Rock RidgeExtensions的系统上| （2）制作光盘过程 （a）在CentOS7主机上搭建yum源，并绑定到ftp服务上。 （b）创建光盘引导文件 [root@centos7~]#mkdir /tmp/testiso[root@centos7~]#mkdir /tmp/testiso/isolinux[root@centos7~]#cp /media/cdrom/isolinux/* /tmp/testiso/isolinux[root@centos7/tmp/testiso]#cp /var/ftp/pub/ks7.cfg .[root@centos7/tmp/testiso]#vim ks7.cfg #编辑配置文件[root@centos7/tmp/testiso]#tree . ├── isolinux │ ├── boot.cat │ ├── boot.msg │ ├── grub.conf │ ├── initrd.img │ ├── isolinux.bin │ ├── isolinux.cfg │ ├── memtest │ ├── splash.png │ ├── TRANS.TBL │ ├── vesamenu.c32 │ └── vmlinuz └── ks7.cfg 注意：此处创建使用的是相对路径，而和工作目录无关。必须在isolinux下。 （c）创建光盘[root@centos7/tmp]#mkisofs -R -J -T -v --no-emul-boot --boot-load-size 4 --boot-info-table -V &quot;CentOS 6.9 x86_64 boot&quot; -b isolinux/isolinux.bin -c isolinux/boot.cat -o /root/boot.iso myiso/ （d）将光盘下载至本机，安装到虚拟中尝试启动 说明我们制作的光盘成功 （3）制作U盘 （a）我们这里虚拟一块U盘，添加一块硬盘 （b）将光盘拷贝至硬盘中 [root@centos7~]#dd if=boot.iso of=/dev/sdb （c）新建虚拟机挂载此光盘启动出现上述情况说明我们安装成功。但是这种方法还需要通过网络才能安装，如果我们去到一个地方没有网络，怎么办呢？有没有想过我们把rpm包到拷贝至一个U盘或光盘上呢？这样是不是很方便我们办公呢？ （4）制作完整的光盘和U盘（a）创建一个临时目录并拷贝文件至此目录下[root@localhost ~]#mkdir /tmp/fulliso[root@localhost ~]# cp -a /media/cdrom/* /tmp/fulliso/[root@localhost ~]# cd /tmp/fulliso/[root@localhost fulliso]# cp /media/cdrom/.treeinfo .[root@localhost fulliso]# cp /media/cdrom/.discinfo . （b) 删除repodate目录非comps.xml结尾的文件。`[root@localhost fulliso]# find repodata/ -not -name -comps.xml -delete`[root@localhost fulliso]# find -name TRANS.TBL -delete （c）以上述那个文件制作仓库[root@localhost fulliso]# ls repodata/ d918936f5019be3fb66e9981a28cb2a41477a2963d741d454f79377a22214f43-c7-x86_64-comps.xml （d）编辑kickstart配置文件，并复制fulliso目录下[root@localhost fulliso]# vim ks7.cfg auth --enableshadow --passalgo=sha512 # Use graphical install graphical # Run the Setup Agent on first boot firstboot --enable ignoredisk --only-use=sda # Keyboard layouts keyboard --vckeymap=us --xlayouts=&apos;us&apos; # System language lang en_US.UTF-8 # Network information network --bootproto=dhcp --device=ens33 --onboot=on --ipv6=auto network --hostname=localhost.localdomain # Root password # System services services --disabled=&quot;chronyd&quot; # System timezone timezone Asia/Shanghai # X Window System configuration information xconfig --startxonboot # System bootloader configuration bootloader --append=&quot; crashkernel=auto&quot; --location=mbr --boot-drive=sda zerombr reboot # Partition clearing information clearpart --all part /boot --fstype=&quot;xfs&quot; --ondisk=sda --size=1024 part swap --fstype=&quot;swap&quot; --ondisk=sda --size=2048 part / --fstype=&quot;xfs&quot; --ondisk=sda --size=50000 part /app --fstype=&quot;xfs&quot; --ondisk=sda --size=50000 %packages @^gnome-desktop-environment @base @core @desktop-debugging @dial-up @directory-client @fonts @gnome-desktop @guest-agents @guest-desktop-agents @input-methods @internet-browser @java-platform @multimedia @network-file-system-client @networkmanager-submodules @print-client @x11 kexec-tools autofs lftp dhcp vsftpd %end %post #Create repo mkdir /media/cdrom mkdir /etc/yum.repos.d/bak mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak cat &gt; /etc/yum.repos.d/base &lt;&lt;EOF [base] name=centos 7 baseurl=file:///media/cdrom gpgcheck=0 enabled=1 EOF cat &gt;&gt; /etc/fstab &lt;&lt; EOF /dev/sr0 /media/cdrom iso9660 defaults 0 0 cat &gt;&gt; /root/.bashrc &lt;&lt; EOF alias cdnet=&quot;cd /etc/sysconfig/network-scripts/&quot; EOF cat &gt;&gt; /etc/profile.d/env.sh export PS1=&apos;\[\e[31m\][\u@\h\w]\$\[\e[0m\]&apos; EOF sed -i &apos;s/quiet/&amp; net.ifnames=0/&apos; /etc/default/grub grub2-config -o /boot/grub2/grub.cfg %end （e）编辑isolinux.cfg文件[root@localhost fulliso]# vim isolinux/isolinux.cfg default vesamenu.c32 timeout 600 display boot.msg # Clear the screen when exiting the menu, instead of leaving the menu displayed. # For vesamenu, this means the graphical background is still displayed without # the menu itself for as long as the screen remains in graphics mode. menu clear menu background splash.png menu title CentOS Linux 7 menu vshift 8 menu rows 18 menu margin 8 #menu hidden menu helpmsgrow 15 menu tabmsgrow 13 # Border Area # Selected item menu color sel 0 #ffffffff #00000000 none # Title bar menu color title 0 #ff7ba3d0 #00000000 none # Press [Tab] message menu color tabmsg 0 #ff3a6496 #00000000 none # Unselected menu item menu color unsel 0 #84b8ffff #00000000 none # Selected hotkey menu color hotsel 0 #84b8ffff #00000000 none # Unselected hotkey menu color hotkey 0 #ffffffff #00000000 none # Help text menu color help 0 #ffffffff #00000000 none # A scrollbar of some type? Not sure. menu color scrollbar 0 #ffffffff #ff355594 none # Timeout msg menu color timeout 0 #ffffffff #00000000 none menu color timeout_msg 0 #ffffffff #00000000 none # Command prompt text menu color cmdmark 0 #84b8ffff #00000000 none menu color cmdline 0 #ffffffff #00000000 none # Do not display the actual menu unless the user presses a key. All that is displayed is a timeout message. menu tabmsg Press Tab for full configuration options on menu items. menu separator # insert an empty line menu separator # insert an empty line label desktop menu label desktop Linux 7 kernel vmlinuz append initrd=initrd.img ks=cdrom:/ks7.cfg label mini menu label mini linux 7 menu default kernel vmlinuz append initrd=initrd.img ks=cdrom:/ks7mini.cfg menu end （f）制作光盘[root@localhost ~]# mkisofs -R -T -J -v --no-emul-boot --boot-load-size 4 --boot-info-table -V &quot;CentOS 7 custom&quot; -b isolinux/isolinux.bin -c isolinux/boot.cat -o /root/centos7.iso /tmp/fulliso/ （g）测试是否可成功,新建一台虚拟机，测试出现上述界面，表明制作光盘已经成功。]]></content>
      <categories>
        <category>自动化</category>
        <category>系统安装</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译安装httpd-2.4]]></title>
    <url>%2F2017%2F11%2F28%2F%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85httpd-2.4%2F</url>
    <content type="text"><![CDATA[编译安装httpd-2.4（1）准备安装前环境 [root@localhost ~]# yum groupinstall -y &quot;development tools&quot; （2）编译安装apr [root@localhost src]# tar xf apr-1.6.2.tar.gz[root@localhost apr-1.6.2]# ./configure --prefix=/app/apr[root@localhost apr-1.6.2]# make &amp;&amp; make install （3）编译安装apr-util [root@localhost src]# tar xf apr-util-1.6.0.tar.gz[root@localhost apr-util-1.6.0]# ./configure --prefix=/app/apr-util --with-apr=/app/apr[root@localhost apr-util-1.6.0]# yum install -y expat-devel #编译依赖与这个包（Expat是一个用C语言开发的、用来解析XML文档的开发库）[root@localhost apr-util-1.6.0]# make &amp;&amp; make install （4）编译安装httpd-2.4[root@localhost src]# useradd -r -m -d /app/website -s /sbin/nologin apache [root@localhost src]# tar xf httpd-2.4.27.tar.bz2 [root@localhost httpd-2.4.27]# yum install -y pcre-devel openssl-devel [root@localhost httpd-2.4.27]# ./configure --prefix=/app/httpd24 --enable-so --enable-ssl --enable-cgi --enable-rewrite --with-zlib --with-pcre --with-apr=/app/apr/ --with-apr-util=/app/apr-util/ --enable-modules=most --enable-mpms-shared=all --with-mpm=prefork [root@localhost bin]# make &amp;&amp; make install 修改PATH路径 [root@localhost bin]# vim /etc/profile.d/http24.sh export PATH=/app/httpd24/bin:$PATH [root@localhost bin]# source /etc/profile.d/http24.sh #使其生效[root@localhost bin]# echo $PATH /app/httpd24/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin 修改配置文件 [root@localhost conf]# vim httpd.conf 配置启动脚本 方法一： [root@localhost conf]# scp 192.168.4.132:/etc/init.d/httpd /etc/init.d/httpd24 #如果其他主机上有可以拷贝一份 [root@localhost httpd-2.4.27]# vim /etc/init.d/httpd24 apachectl=/app/httpd24/apachectl httpd=${HTTPD-/app/httpd24/httpd} prog=httpd pidfile=${PIDFILE-/app/httpd24/logs/httpd.pid} lockfile=${LOCKFILE-/var/lock/subsys/httpd} RETVAL=0 STOP_TIMEOUT=${STOP_TIMEOUT-10} [root@localhost conf]# chkconfig --add httpd24 #将此服务加到服务中心[root@localhost conf]# chkconfig httpd24 on设为开机启动 方法二：由于CentOS 6中支持rc.local脚本所有我们可以把命令写到脚本中，设为开机启动 [root@localhost conf]# vim /etc/rc.d/rc.local /app/httpd24/apachectl start [root@localhost conf]# chmod +x /etc/rc.d/rc.local 测试 [root@localhost website]# echo index.html &gt; index.html [root@localhost website]# apachectl start 安装方式二 （1）准备安装前环境 [root@localhost ~]# yum groupinstall -y &quot;development tools&quot; （2）解压apr包 [root@localhost src]# tar xf apr-1.6.2.tar.gz （3）解压apr-util包 [root@localhost src]# tar xf apr-util-1.6.0.tar.gz （4）编译安装httpd-2.4[root@localhost src]# useradd -r -m -d /app/website -s /sbin/nologin apache [root@localhost src]# tar xf httpd-2.4.27.tar.bz2 [root@localhost httpd-2.4.27]# yum install -y pcre-devel openssl-devel 将解压包移动到srclib目录下[root@localhost src]# mv apr-1.6.2 httpd-2.4.27/srclib/apr [root@localhost src]# mv apr-util-1.6.0 httpd-2.4.27/srclib/apr-util [root@localhost httpd-2.4.27]# ./configure --prefix=/app/httpd24 --enable-so --enable-ssl --enable-cgi --enable-rewrite --with-zlib --with-pcre --with-included-apr --enable-modules=most --enable-mpms-shared=all --with-mpm=prefork [root@localhost httpd-2.4.27]# make &amp;&amp; make install 修改配置文件 [root@localhost conf]# vim httpd.conf 配置启动脚本 方法一： [root@localhost conf]# scp 192.168.4.132:/etc/init.d/httpd /etc/init.d/httpd24 #如果其他主机上有可以拷贝一份 [root@localhost httpd-2.4.27]# vim /etc/init.d/httpd24 apachectl=/app/httpd24/apachectl httpd=${HTTPD-/app/httpd24/httpd} prog=httpd pidfile=${PIDFILE-/app/httpd24/logs/httpd.pid} lockfile=${LOCKFILE-/var/lock/subsys/httpd} RETVAL=0 STOP_TIMEOUT=${STOP_TIMEOUT-10} [root@localhost conf]# chkconfig --add httpd24 #将此服务加到服务中心[root@localhost conf]# chkconfig httpd24 on设为开机启动 方法二：由于CentOS 6中支持rc.local脚本所有我们可以把命令写到脚本中，设为开机启动 [root@localhost conf]# vim /etc/rc.d/rc.local /app/httpd24/apachectl start [root@localhost conf]# chmod +x /etc/rc.d/rc.local 方法三：将/app/httpd24/bin/apachectl文件拷贝至/etc/init.d/httpd [root@localhost httpd24]# cp /app/httpd24/bin/apachectl /etc/init.d/httpd24 测试 [root@localhost website]# echo index.html &gt; index.html [root@localhost website]# apachectl start]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>编译安装httpd-2.4</category>
      </categories>
      <tags>
        <tag>源码编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站访问量计算方式]]></title>
    <url>%2F2017%2F11%2F28%2F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E9%87%8F%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[网站访问量计算方式 IP(独立IP)：即Internet Protocol,指独立IP数。一天内来自相同客户机IP地址只计算一次，记录远程客户机IP地址的计算机访问网站的次数，是衡量网站流量的重要指标。 PV(访问量)： 即Page View, 页面浏览量或点击量，用户每次刷新即被计算一次，PV反映的是浏览某网站的页面数，PV与来访者的数量成正比，PV并不是页面的来访者数量，而是网站被访问的页面数量。 UV(独立访客)：即Unique Visitor,访问网站的一台电脑为一个访客。一天内相同的客户端只被计算一次。可以理解成访问某网站的电脑的数量。网站判断来访电脑的身份是通过来访电脑的cookies实现的。如果更换了IP后但不清除cookies，再访问相同网站，该网站的统计中UV数是不变的 http://www.alexa.cn/rank/可以查看全球网站的统计量 示例： 小明在家用ADSL拨号上网，早上8点访问了www.baidu.com下的2个页面，下午2点又拨号访问了www.baidu.com3个页面。那么，对于www.baidu.com来讲，今天的PV、UV、VV、IP各项指标该如何计算呢 ？ IP 2 PV 5 UV 1]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>网站访问量计算</category>
      </categories>
      <tags>
        <tag>访问量计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络防火墙]]></title>
    <url>%2F2017%2F11%2F28%2F%E7%BD%91%E7%BB%9C%E9%98%B2%E7%81%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[网络防火墙网络防火墙可以充当网关；使用filter表中的FORWARD链。如果要启用conntrack机制，建议将双方向的状态为ESTABLISHED的报文直接放行。 如图所示：现在我们的需求是内网可以ping外网但是外网ping不了内网如何实现？ 环境： CentOS 6 192.168.4.55 CentOS 6 172.18.4.61 充当路由器（两块网卡） CentOS 7 172.18.4.56 （1）在CentOS 6 (192.168.4.56)可以路由转发功能并添加规则 [root@localhost ~]# vim /etc/sysctl.conf net.ipv4.ip_forward = 1 [root@localhost ~]# sysctl -p 使其生效 （2）将两台主机的网关指定路由器 [root@localhost ~]# route add default gw 192.168.4.61 [root@localhost ~]# route add default gw 172.18.4.61 （3）测试没有假规则之前是否可以ping通 （4）在路由上添加规则 方式一： [root@localhost~]#iptables -A FORWARD -s 192.168.4.0/24 -d 172.18.4.0/24 -p icmp --icmp-type 8 -j ACCEPT [root@localhost~]#iptables -A FORWARD -s 172.18.4.0/24 -d 192.168.4.0/24 -p icmp --icmp-type 0 -j ACCEPT [root@localhost~]#iptables -A FORWARD -j REJECT 方式二： [root@localhost~]#iptables -A FORWARD -m state --state ESTABLISHED -j ACCEPT [root@localhost~]#iptables -A FORWARD -s 192.168.4.0/24 -d 172.18.4.0/24 -p icmp --icmp-type 8 -j ACCEPT [root@localhost~]#iptables -A FORWARD -j REJECT 方式三： [root@localhost~]#iptables -A FORWARD -m state --state ESTABLISHED -j ACCEPT [root@localhost~]#iptables -A FORWARD -s 192.168.4.0/24 -d 172.18.4.0/24 -m state --state NEW -j ACCEPT [root@localhost~]#iptables -A FORWARD -j REJECT （5）测试是否成功 问题：如何开放被动模式的ftp模式？ （1）需要查看是否已经加载了ftp追踪的模块 跟踪模块路径：/lib/modules/2.6.32-696.el6.x86_64/kernel/net/netfilter/ [root@localhost ~]# lsmod |grep ftp 如果没有记载此模块需要安装模块 [root@localhost ~]# modprobe nf_conntrack_ftp （2）放行请求报文 [root@localhost ~]# iptables -A INPUT -d 192.168.4.55 -p tcp --dport 21 -m state --state NEW -j ACCEPT[root@localhost ~]# iptables -A INPUT -d 192.168.4.55 -p tcp -m state --state RELATED,ESTABLISHED # （3）放行响应报文 [root@localhost ~]# iptables -A OUTPUT -s 192.168.4.55 -p tcp -m state --state ESTABLISHED -j ACCEPT #如果没有别的定义OUTPTU 可以不定义此规则 NAT：Network Address Translation（网络地址转换）NAT工作在PREROUTING、INPUT、OUTPUT、POSTROUTING SNAT :Source Network Address Translation 应用在PREROUTING、INPUT链上，让本地网络中的主机通过某一特定地址访问外部网络，实现地址伪装。 请求报文：修改源IP -J SNAT --to-source [ipaddr[-ipaddr]][:port[-port]] --random 如上图所示，就是SNAT。 实现此功能只需添加一条规则即可 [root@localhost~]#iptables -t nat -A POSTROUTING -s 192.168.4.0/24 -j SNAT --to-source 172.18.4.56 注意：地址转换不需要双方互指网关，只需本地网络指定内网网关即可 ###如果我们不知道外网IP地址或者范围如何实现SNAT呢？ MASQUERADE :伪装，动态IP ，如以前拨号网络 --to-ports[-port] --random [root@localhost~]#iptables -t nat -A POSTROUTING -s 192.168.4.0/24 -j MASQUERADE DNAT ：Destination Network Address Translation 应用在PREROUTING、OUTPUT链上。把本地网络中的主机上的某服务开放给外部网络访问，但可以隐藏真实IP 请求报文：修改目标IP [root@localhost~]#iptables -t nat -A PREROUTING -s 172.18.4.56 -p tcp --dport 80 -j DNAT --to-destination 192.168.4.55 PNAT：Port Network Address Translation 端口号和IP都进行修改。 注意：我们在工作环境中一般把本地网络设置为私网地址，如果设置为公网地址，假设某天您访问的某个网站的IP和你设置的一样可能导致您访问不了。 REDIRECT转发 可用于PREROUTING、 OUTPUT链上。通过改变目标IP和端口，将接受的包转发至不同地址 --to-ports port[-port] [root@localhost~]#iptables -t nat -A PREROUTING -d 192.168.4.55 -p tcp --dport 80 -j REDIRECT --to-ports 8000 实现多端口转发 [root@localhost~]#iptables -t nat -A PREROUTING -d 192.168.4.55 -p tcp -m multiport –dports 1234,9527,8000 -j REDIRECT –to-ports 80]]></content>
      <categories>
        <category>防火墙</category>
        <category>网络防火墙</category>
      </categories>
      <tags>
        <tag>网络防火墙，DNAT</tag>
        <tag>SNAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集群介绍]]></title>
    <url>%2F2017%2F11%2F28%2F%E9%9B%86%E7%BE%A4%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[参考： http://www.linuxvirtualserver.org/zh/lvs1.html 一、服务器集群系统1、对称多处理对称多处理（symmctric multi-processor，SMP）是由多个对称的处理器和通过总线共享的内存和I/O不见所组成的计算机系统。由于SMP的可扩展能力有限，SMP服务器显然不能满足高可伸缩、高可用网络服务器的负载处理能力不断增长需求。 SMP的缺点（1）升级过程繁琐，机器切换会使服务中断并造成原有计算资源的浪费。 （2）高端的服务器所花费的代价大 （3）SMP服务器是单一故障点（Single Point of Failure），一旦该服务器或应用软件失效，会导致整个服务的中断。 2、集群服务器集群，英文名称为Cluster，通俗地说，集群是一种技术：它将多个系统连接到一起，使多台服务器能够像一台机器那样工作或者看起来好像一台机器。采用集群系统通常是为了提高系统的稳定性和网络中心的数据处理能力及服务能力。 3、linux cluster类型1.LB Load Balancing（负载均衡集群），为了提高服务的并发能力 2.HA High Availability（高可用性集群），为了提供7*24小时服务的能力，通过冗余服务器，来防止宕机造成服务器终端 3.HPC High Performance Computing（高性能集群），为了在短期内解决大量复杂的计算 4、Cluster分类LB Cluster实现方法硬件 F5 Big-IP Citrix Netscaler A10 软件 lvs：Linux Virtual Server Nginx：支持四层调度 Haproxy：支持四层调度 ats：apache traffic server，是一个高性能的、模块化的HTTP代理和缓存服务器 Cluster分类基于工作的协议层划分 传输层：DPORT应用层：针对特定协议，自定义的请求模型分类5、会话保持：负载均衡（1）session sticky：同一用户调度固定服务器 （2）session replication ：每台服务器拥有全部内容 （3）session server：专门的session服务器memcached，redis等]]></content>
      <categories>
        <category>集群</category>
        <category>集群介绍</category>
      </categories>
      <tags>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[puppet流程控制语句]]></title>
    <url>%2F2017%2F11%2F28%2Fpuppet%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[puppet流程控制语句（1）if语句格式： if CONDITION { ... } elsif CONDTION { ... } else{ ... } CONDITION类型 变量 比较表达式 有返回值的函数 示例： 1 if $osfamily == &apos;Debian&apos; { 2 $apachename = &apos;apache2&apos; 3 }else{ 4 $apachename = &apos;httpd&apos; 5 } 6 package{&apos;$apachename&apos;: 7 ensure =&gt; latest, 8 } （2）case语句格式： case CONTROL_EXPRESSION { case1：{} case2：{} case3：{} .. default:{} } CONTROL_EXPRESSION 变量 表达式 有返回值的函数 各case给定方式 直接字串 变量 有返回值的函数 正则表达式 default 示例： 1 case $onfamily { 2 &quot;RedHat&quot;: { $webserver = &apos;httpd&apos; } 3 /(?i-mx:debin)}: { $webserver = &apos;apache2&apos; } 4 default: { $webserver = &apos;httpd&apos; } 5 } 6 package{&apos;$webserver&apos;: 7 ensure =&gt; latest, 8 } （4）selector语句格式： 未知变量 = 可知变量 ? { case1 =&gt; value1, case2 =&gt; value2, ... default =&gt; value0, } CONTROL_VARIABLE的给定方法： 变量 有返回值的函数 各case的给定方式： 直接字串； 变量 有返回值的函数 正则表达式模式； default 示例： 1 $pkgname = $osfamily ? { 2 &quot;RedHat&quot; =&gt; &apos;httpd&apos;, 3 /(?i-mx:debian)/ =&gt; &apos;apache2&apos;, 4 default =&gt; &apos;httpd&apos;, 5 }]]></content>
      <categories>
        <category>自动化运维工具</category>
        <category>puppet</category>
        <category>puppet流程控制语句</category>
      </categories>
      <tags>
        <tag>puppet，if，case，selector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[puppet资源]]></title>
    <url>%2F2017%2F11%2F28%2Fpuppet%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[puppet是一种多系统集中配置管理工具，使用自有的puppet描述语言，可管理配置文件、用户、cron、任务等。puppet设计目的是简化对这些资源的管理以及妥善处理资源间的依赖关系。 一、Puppet介绍1、puppet工作模型 单机模型：手动应用清单 puppet apply master/agent：由agent周期性地向Master请求清单并自动应用于本地。 puppet master puppet agent 2、puppet资源（1）puppet从三个维度对资源进行抽象： 相似的资源被抽象成同一个资源“类型”，如程序包资源、用户资源及服务资源等； 将资源属性或状态的描述与其实现方式剥离开来，如仅说明安装一个程序包而不用关心起具体是通过什么方式实现； 仅描述资源的目标状态，即期望其实现的结果，而不是其具体过程。如确定nginx运行起来而不是具体描述为运行nginx命令将其启动。 它们统称为puppet资源抽象派（RAL）；RAL由type和provider组成。 （2）puppet资源定义向资源类型的属性赋值来实现，可称为资源类型实例化。定义了资源示例的文件即清单（manifest）。 type{‘title’ attribute1 =&gt; value1 attribute2 =&gt; value2 …}注意：type必须使用小写字母；title是一个字符串并且在同一类型必须唯一。 （3）资源属性中三个特殊属性 Namevar，可以简称为name，定义title，name可以使用。 ensure，资源的目标状态 Provider，指明资源的管理接口，如果不指定系统选择最优的安装方式。 （4）puppet查询资源puppet describe USAGE: puppet describe [-h|--help] [-s|--short] [-p|--providers] [-l|--list] [-m|--meta] --help 帮助信息 --list 列出所有类型 --meta 列出所有元数据 --short 仅仅列出参数没有详细信息 （5）资源引用如果我们在某个资源中定义需要引用别的资源时，这时就需要想想如何引用资源了。 格式 Type[‘title’] 注意：资源引用时，类型的首字母必须大写。 （6）资源定义依赖关系在定义资源时，某个资源可能依赖另外某几个资源，这时就需要依赖别的资源；就像使用yum安装一样，自动解决了依赖关系；只不过这里是我们手动自定而已。 依赖关系方式 before# type{‘A’attribute1 =&gt; value1 attribute2 =&gt; value2 before =&gt; Type[&apos;B&apos;] } 相当于资源类型A在资源类型B完成。 require# type{‘A’attribute1 =&gt; value1 attribute2 =&gt; value2 require =&gt; Type[&apos;B&apos;] } 相当资源类型A在资源类型B之后完成。 （7）资源通过关系通知相关的其他资源进行“刷新”操作 notify type{‘A’ attribute1 =&gt; value1 attribute2 =&gt; value2 notify =&gt; Type[&apos;B&apos;] } 相当于ansible中的handler触发机制。 subscribe type{‘A’ attribute1 =&gt; value1 attribute2 =&gt; value2 subscribe =&gt; Type[&apos;B&apos;] } 相当于资源B发生改变则资源A就进行”刷新” （8）puppet apply介绍格式： puppet apply [-h|--help] [-V|--version] [-d|--debug] [-v|--verbose] [-e|--execute] [--detailed-exitcodes] [-l|--logdest &lt;file&gt;] [--noop] [--catalog &lt;catalog&gt;] [--write-catalog-summary] &lt;file&gt; 选项 说明 -V 版本信息 -v 详细信息 –noop 相当于干跑 –test 测试 –debug 调试模式 ###2、资源类型 ####（1）group 管理组 参数 说明 name 组名 gid 组ID system 是否为系统用户 true/false ensure 目标状态 present absent members 成员用户 示例： [root@node1~]#vim group.pp 1 group{&apos;test&apos;: 2 ensure =&gt; present, 3 name =&gt; test, 4 gid =&gt; 1234, 5 } [root@node1~]#puppet apply -v --noop --test group.pp Notice: Compiled catalog for node1.magedu.com in environment production in 0.09 seconds Info: Applying configuration version &apos;1511599693&apos; Notice: /Stage[main]/Main/Group[test]/ensure: current_value absent, should be present (noop) Notice: Class[Main]: Would have triggered &apos;refresh&apos; from 1 events Notice: Stage[main]: Would have triggered &apos;refresh&apos; from 1 events Info: Creating state file /var/lib/puppet/state/state.yaml Notice: Finished catalog run in 0.02 seconds ####（2）user 管理用户 参数 说明 name 用户名 uid 用户ID groups 附加组 comment 注释 expiry 过期时间 home 家目录 shell shell的类型 system 是否为系统用户 ensure 目标状态 present/absent password 加密后的字符串 示例： [root@node1~]#vim user.pp 1 group{&apos;test&apos;: 2 ensure =&gt; present, 3 name =&gt; &apos;test&apos;, 4 } 5 user{&apos;tom&apos;: 6 ensure =&gt; present, 7 name =&gt; &apos;tom&apos;, 8 uid =&gt; 2345, 9 system =&gt; false, 10 shell =&gt; &apos;/bin/tcsh&apos;, 11 home =&gt; &apos;/app/tom&apos;, 12 groups =&gt; &apos;test&apos;, 13 require =&gt; Group[&apos;test&apos;], 14 } ####（3）package 管理安装包 参数 说明 ensure 目前状态；installed 、present、latest、absent、any name 包名 source 程序来源，仅对不会自动下载相关程序包的provider有用，如rpm或dpkg 示例： [root@node1~]#vim package.pp 1 package{&apos;nginx&apos;: 2 ensure =&gt; latest, 3 name =&gt; &apos;nginx&apos;, 4 } ####（4）service 管理服务 参数 说明 ensure 目前状态 stopped/false、running/true enable 是否设置为开机启动 hasrestart 判断此服务是否有restart命令，如果没有则先stop然后start start 手动设定命令 restart 手动设定启动命令 [root@node1~]#vim service.pp 1 service{&apos;nginx&apos;: 2 ensure =&gt; running, 3 enable =&gt; true, 4 hasrestart =&gt; true, 5 restart =&gt; &apos;systemctl restart nginx.service&apos;, 6 } ####（5）file 管理文件 参数 说明 ensure 目前状态；file，类型为普通文件，其内容由contest属性生成或复制由source属性指向文件路径创建；link，类型为符号链接，必须由target属性指明其链接的目标文件；directory，类型为目录，可通过source指向的路径复制生成；recurse属性指明是否递归复制 path 文件路径 source 源文件路径 context 文件内容 target 符号链接目标文件 owner 所有者 group 所属组 mode 权限 atime/ctime/mtime 时间戳 示例： [root@node1~]#vim file.pp 1 file{&apos;test&apos;: 2 ensure =&gt; file, 3 path =&gt; &apos;/tmp/fstab&apos;, 4 source =&gt; &apos;/etc/fstab&apos;, 5 owner =&gt; tom, 6 group =&gt; test, 7 } ####（6）exec 执行命令 参数 说明 cwd 切换目录 command 要运行的命令 creates 文件路径，仅此路径表示的文件不存在时，command才执行 user/group 运行命令的用户身份 path 命令路径 onlyif 此属性指定一个命令，此命令正常时运行时，当前commnd才执行 unless 此属性指定一个命令，此命令非正常运行时，当前command才会执行 refresh 重新执行当前command的替代命令 refreshonly 仅接受到订阅的资源的通知时方才执行 示例： [root@node1~]#vim exec.pp 1 exec{&apos;createuser&apos;: 2 command =&gt; &apos;useradd test1&apos;, 3 path =&gt; &apos;/bin:/sbin&apos;, 4 unless =&gt; &apos;id test1&apos;, 5 } ####（7）cron 计划任务 参数 说明 command 执行的任务 ensure 目前的状态，present/absent hour、minute、monthday、month、weekday 定义时间 user 以哪个用户的身份运行命令 target 添加为哪个用户的任务 name 计划任务的名称 示例： [root@node1~]#vim cron.pp 1 cron{&apos;time&apos;: 2 command =&gt; &apos;/usr/sbin/ntpdate 172.18.0.1 &amp;&gt; /dev/null&apos;, 3 ensure =&gt; present, 4 minute =&gt; &apos;*/3&apos;, 5 user =&gt; &apos;root&apos;, 6 } ####（8）notify 参数 说明 message 信息内容 name 信息名称 ·[root@node1~]#vim notify.pp· 1 notify{&apos;hello world&apos;: 2 message =&gt; &apos;hello everyone&apos;, 3 } ###3、数据类型 布尔型：true和false，不能加引号；if语句的测试条件和比较表达式都会返回布尔型值 undef：从为被声明的变量的值，直接使用不加引号的undef字符串 字符型：非结构化的文本字符串，可以使用引号，也可以不使用，单引号中的变量不会替换，而双引号中的能够进行变量替换。字符型值也支持使用转义符 数值型：可以为整数或浮点数。在puppet只有在数值上下文才把数据当数值型对待，其他情况下一律以字符型处理 数组：数组值为中括号‘[]’中以逗号分隔项目列表；数组索引从0开始整数，也可以是用负数索引 hash：外键值数据类型，键和值之间使用“=&gt;”分隔，键值对儿在{}中，彼此间以逗号分隔； 正则表达式：属于puppet的非标准数据类型，不能赋值给变量，仅能用于有限的几个接受正则表达式的地方，即接受使用“=~”及“！~”匹配操作符的位置。 (？:) (? - :) OPTIONs： i：忽略字符大小写 m：把“.”当换行符 x：忽略&lt;PATTERN&gt;中的空白字符 ####4、puppet变量种类 内建变量： - master端变量： $servername $serverip $serverversion - agent变量： $clientcert $clientversion $environment - parser变量 $module_name [root@node1~]#facter -p #查看内建命令 用户自定义变量 $variable_name = value 注意：不管是定义变量还是引用变量都要使用“$“引用。 示例： [root@node1~]#vim package2.pp 1 $pkgname = &apos;redis&apos; 2 package{&apos;installpkg&apos;: 3 ensure =&gt; latest, 4 name =&gt; &apos;$pkgname&apos;, 5 }]]></content>
      <categories>
        <category>自动化运维工具</category>
        <category>puppet</category>
        <category>puppet资源</category>
      </categories>
      <tags>
        <tag>puppet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[puppet类]]></title>
    <url>%2F2017%2F11%2F28%2Fpuppet%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[类Class是用于通用目标或目的的一组资源，因此，它是命名的代码块，在某未知创建之后可在puppet全局使用。类似于其他编程语言中类的功能，puppet的类可以继承，也可以包含子类。 格式： class my_class { ...puppet code ... } 注意：类的名称只能以小写字母开头，可以包含小写字母、或下划线。另外每个类都会引入一个新的变量scope，这意味着在任何时候访问类中的变量时，都得使用期完全限定的名称。不过在本地scope可以重新为top scope 中的变量赋予一个新值。 （1）类声明 方式一 include CLASS_NAME1 ,CLASS_NAME2… 方式二# class {‘CLASS_NAME’: attribute =&gt; value, ... } 示例： 1 class apache2 { 2 $webpkg = $operationsystem ? { 3 /(?i-mx:(centos|redhat|fedora))/ =&gt; &apos;httpd&apos;, 4 /(?i-mx:(ubuntu|debian))/ =&gt; &apos;apache2&apos;, 5 default =&gt; &apos;httpd&apos;, 6 } 7 package{&apos;$webpkg&apos;: 8 ensure =&gt; latest, 9 } 10 } 类继承方式格式： class SUB_CLASS_NAME inherits PARENT_CLASS_NAME { ...puppet code } 示例： 1 class apache2 { 2 $webpkg = $operationsystem ? { 3 /(?i-mx:(centos|redhat|fedora))/ =&gt; &apos;httpd&apos;, 4 /(?i-mx:(ubuntu|debian))/ =&gt; &apos;apache2&apos;, 5 default =&gt; &apos;httpd&apos;, 6 } 7 package{&apos;$webpkg&apos;: 8 ensure =&gt; latest, 9 } 10 } 11 class apache2::web inherits apache2 { 12 file{&apos;file&apos;: 13 path =&gt; &apos;/etc/httpd/conf.d/http-v.conf&apos;, 14 ensure =&gt; file, 15 source =&gt; &apos;root/http-v.conf&apos;, 16 } 17 } 在子类中为父类的资源新增或覆盖指定的属性的值格式： Type[&apos;tile&apos;] { attribute =&gt; value, ... } 在子类中为父类的资源的某属性增加心智Type[&apos;title&apos;] { attribute +&gt; value, ... } 带参数的类在定义在带参数的类时，需要将参数声明在类名后的小括号“（）”，参数可以有默认值，如果使用多个参数，彼此间要使用逗号分隔。在类的内部使用参数的方式同使用本地变量。 格式： class mysql ($user = &apos;mysql&apos;, $port = 3306) { ... } 向类传递参数时，其方式如同定义资源的属性。格式： class http($pkgname=&apos;apache2&apos;) { package{&apos;$pkgname&apos;: ensure =&gt; latest, } } 5、puppet模板puppet模板时erb（embedded ruby）格式的。 文本文件中内嵌变量替换机制：&lt;%= @VARIABLE_NAME %&gt; 格式： file{‘title’: ensure =&gt; file, path =&gt; content =&gt; template(‘/path/to/ERB_FILE’)}]]></content>
      <categories>
        <category>自动化运维工具</category>
        <category>puppet</category>
        <category>puppet类</category>
      </categories>
      <tags>
        <tag>puppet，类，模板</tag>
      </tags>
  </entry>
</search>
