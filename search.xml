<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HAproxy]]></title>
    <url>%2F2017%2F11%2F29%2FHAproxy%2F</url>
    <content type="text"><![CDATA[一、HAProxyHAProxy（High Available Proxy）是基于四层和七层的高可用负载均衡代理服务器，对客户端10000以上的同时连接的高性能的TCP和HTTP负载均衡器。 1、HAProxy功能 TCP/HTTP反向代理服务器，尤其适合于高可用性环境 可以针对HTTP请求添加cookie，进行路由后端服务器 可平衡负载至后端服务器，并支持持久连接 支持基于cookie进行调度 支持所有主服务器故障切换至备用服务器 支持专用端口实现监控服务 支持不影响现有连接情况下停止接受新连接请求 可以在双向添加、修改或删除HTTP报文首部 支持基于PATTERN实现连接请求的访问控制 通过特定的URI为授权用户提供详细的状态信息 2、HAProxy工作原理 HAProxy和lvs的工作类似，只不过是在名称上有所改变。 HAProxy由前段（frontend）和后端（backend）过程，前后端都可以有多个，并且可以实现交叉调度。如果前段和后端是一对一的情况可以使用listen来实现。frontend区域根据Client的请求调度到backend服务器上。不过frontend可以根据HTTP请求的header信息来定义一些规则，将符合规则的请求转发至backend服务器上去。 3、HAProxy安装及配置文件详解[root@localhost~]#yum install -y haproxy HAProxy主配置文件 /etc/haproxy/haproxy.cfg 定义错误页面文件 /usr/share/haproxy/400.http /usr/share/haproxy/403.http /usr/share/haproxy/408.http /usr/share/haproxy/500.http /usr/share/haproxy/502.http /usr/share/haproxy/503.http /usr/share/haproxy/504.http /etc/haproxy/haproxy.cfg配置文件详解配置段- global：全局配置段 定义进程及安全配置相关的参数 性能调整相关参数 debug参数 proxies：代理配置段 default：为frontend、backend、listen提供默认配置 frontend：定义一组接受客户端侦听的套接字连接 backend：定义代理将连接的一组服务器转发连接 listen：同时拥有前后端，适用于一对一环境；通常用于TCP中。 配置指令详解- global配置参数 nbproc ：要启动的haproxy的进程数量，系统默认单进程，要求使用daemon模式 ulimit-n：每个haproxy进程可打开的最大文件数，系统自动会自定，不建议设置 daemon：后端方式运行，建议使用 log：定义全局syslog服务器；最多可以定义两个 格式： log &lt;address&gt; [len &lt;length&gt;] &lt;facility&gt; [max level [min level]] &lt;address&gt;：日志服务器地址 [len &lt;length&gt;]：最大长度，默认1024 &lt;facility&gt;：日志设施 [max level [min level]]：指定日志级别 no log 不启用日志 log global 如果需要使用日志，引用global日志 log-format ：定义日志格式 示例： （1）配置日志服务器 [root@log~]#yum install -y mariadb-server #安装数据库 [root@log~]#systemctl restart mariadb.service [root@log~]#systemctl enable mariadb.service #设置为开机启动 [root@log~]#yum install -y rsyslog-mysql #安装基于mysql的模块 [root@log~]#mysql -uroot -p &lt; /usr/share/doc/rsyslog-8.24.0/mysql-createDB.sql #创建日志数据库 MariaDB [(none)]&gt; GRANT ALL ON Syslog.* TO joah@&apos;192.168.4.65&apos; IDENTIFIED BY &apos;123456&apos;; #授权用户 74 local2.* :ommysql:192.168.4.65,Syslog,joah,123456 将特定信息记录在日志中 capture cookie len ：捕获请求和响应报文中的cookie并记录日志 capture request header len ：捕获请求报文中指定的首部并记录日志 capture response header len ：捕获响应报文中的首部并记录日志 示例：[root@haproxy/etc/haproxy]#vim haproxy.cfg [root@node1~]#vim /etc/httpd/conf/httpd.conf 重启服务测试 [root@client~]#curl http://172.18.4.62 node1 上述的定义均需在httpd.conf选项Log_Format中定义 ：例如{X-Forwarded-For} 如果有多个需要使用“|”分隔。- 性能优化指令 maxconn ：设定每个haproxy进程所能接受的最大并发连接数 maxconnrate ：设置每个进程每秒种所能建立的最大连接数量 maxsessrate：设置每个进程每秒钟所能建立的最大会话数量；一个连接里面可以有多个会话 maxsslconn ：每个进程支持SSL的最大连接数量 spread-checks ：健康监测延迟时长比；建议2-5之间，默认为0 配置段 defaults ：默认配置段 frontend ：指定接受客户端连接侦听套接字设置 backend ：指定将连接请求转发至后端服务器的相关设置 listen ：指定完整前后端设置，只对TCP有效，只有前后端一对一时使用。 bind：指定一个或多个前段侦听地址和端口 格式： bind [&lt;address&gt;]:&lt;port_range&gt; [, ...] [param*] bind /&lt;path&gt; [, ...] [param*] [param*]常用选项 user：设置用户 mode：设置权限 accept-proxy：接受代理 示例： [root@haproxy/etc/haproxy]#vim haproxy.cfg 68 frontend web 69 bind 172.18.4.62:80 70 default_backend websrvs balance配置 balance：后端服务器组内调度算法 格式： balance &lt;algorithm&gt; [ &lt;arguments&gt; ] balance url_param &lt;param&gt; [check_post] \类型 roundrobin：基于权重轮询，动态算法，支持权重的运行时调整，支持慢启动；每个后端backend中最多支持4095个server static-rr：基于权重轮询，静态算法，不支持权重的运行时调整及慢启动；后端主机数量无上限 leastconn：加权最少连接，动态算法，最少连接的后端服务器优先分配接受新连接，相同连接时轮询；推荐在较长会话场景使用，如mysql、LDAP等 first：根据服务器中列表中的位置，自上而下进行调度；前面服务器的连接数达到上限，新请求才会分配给下一台服务器 source：源地址hash，新连接先按权重分配，后续连接按source分配请求 uri：对于URI的左半部分或整个URI做hash计算，并除以服务器总权重取模，以后派发至挑出的服务器，仅适用于后端缓存服务器；只要会话是同一个URI则一直访问同一台服务器 示例： &lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt; 左半部分：/&lt;path&gt;;&lt;params&gt; 整个URI：/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt; url_param：对用于请求的URI听&lt;params&gt;部分中的参数的值做hash计算，并由服务器总权重相除以后派发至某挑选的服务器；通常用于追踪用户，以确保俩字同一个用户的请求始终发往同一个backend server hadr （&lt;name&gt;）：对于每个http请求，此处由&lt;name&gt;指定的http首部将会被取出做hash计算；并由服务器总权重相除以后派发至某跳出的服务器；无有效值的会被轮询调度 rdp-cookie：远程桌面相关 hash-type：哈希算法 格式： hash-type &lt;method&gt; &lt;function&gt; &lt;modifier&gt; \ map-based：除权取余法，哈希数据结构时静态数组 consistent：一致性哈希，哈希数据结构是一棵树 default_backend：无use_backend匹配时，使用默认的backend，用于frontend中 格式： default_backend &lt;backend&gt; default-server ：backend中的各server设定默认选项 格式： default-server [param*] 示例： default_backend websrvs server ：定义后端服务器机器选项 格式： server &lt;name&gt; &lt;address&gt;[:[port]] [param*] &lt;name&gt;：服务器在haproxy上的内部名称；出现在日志及警告信息 &lt;address&gt;：服务器地址，支持使用主机名 [:[port]]：端口映射；省略时表示同bind中绑定的端口 [param*]：定义参数 weight &lt;weight&gt;：权重，默认为1 maxconn&lt;maxconn&gt;：当前server的最大并发连接数 backlog&lt;backlog&gt;：当server的连接数达到上限后的后援队列长度 backup：设定当前server为备用服务器 check：对当前server做健康状态检测，只用于四层检测;注意：httpchk、smtpchk、mysql-check、pgsql-check和ssl-hello-chk用于定义应用层检测方法 addr：针对此IP地址 port：针对此端口进行检测 inter &lt;delay&gt;：连续两次检测之间的时间间隔，默认为2000ms rise &lt;conunt&gt;：连续多少次检测结果为“成功”才标记服务器为可用；默认为2 fall &lt;count&gt;：连续多少次检测结果为“失败”才标记位不可用；默认为3 cookie &lt;value&gt;：为当前server指定cookie值，实现基于cookie的会话粘性 disabled：标记位不可用；用于服务器维护，更换 redir &lt;prefix&gt;：将发往此server的所有GET和HEAD类的请求重定向到指定的URL 示例： [root@haproxy/etc/haproxy]#vim haproxy.cfg 73 backend websrvs 74 balance roundrobin 75 server srv1 192.168.4.63:80 check weight 1 addr 192.168.4.163 port 80 inter 3000 rise 2 fall 3 76 server srv2 192.168.4.64:80 check disabled 重启服务测试 [root@client~]#curl http://172.18.4.62 node1 [root@client~]#curl http://172.18.4.62 node1 通过上述测试出的结果只能调度到node1中。接下来把192.168.4.163 down掉 [root@client~]#curl http://172.18.4.62 &lt;html&gt;&lt;body&gt;&lt;h1&gt;503 Service Unavailable&lt;/h1&gt; No server is available to handle this request. &lt;/body&gt;&lt;/html&gt; [root@client~]#curl http://172.18.4.62 &lt;html&gt;&lt;body&gt;&lt;h1&gt;503 Service Unavailable&lt;/h1&gt; No server is available to handle this request. &lt;/body&gt;&lt;/html&gt; 此时再次测试访问不到页面出现503错误 cookie配置 cookie：基于cookie长连接用于backend 格式： cookie &lt;name&gt; [ rewrite | insert | prefix ] [ indirect ] [ nocache ] [ postonly ] [ preserve ] [ httponly ] [ secure ] [ domain &lt;domain&gt; ]* [ maxidle &lt;idle&gt; ] [ maxlife &lt;life&gt; ] &lt;name&gt;：cookie名称，用于实现持久连接 rewrite：重写 insert：插入 prefix：前缀 示例：基于cookie的session sticky的实现 [root@haproxy/etc/haproxy]#vim haproxy.cfg 73 backend websrvs 74 balance roundrobin 75 cookie SRV insert nocache indirect 76 server srv1 192.168.4.63:80 check weight 2 cookie service1 77 server srv2 192.168.4.64:80 check cookie service2 统计接口启用相关参数- stats enable：启动统计也；基于默认的参数启动stats page 默认设置 stats uri：/ haproxy？stats stats realm：“HAProxy Statistics” stats auth：no authentication stats scope：no restriction stats uri ：自定义stats page URI stats auth :：认证账户和密码，可定义多个 stats realm ：认证时的提示信息 stats hide-version：隐藏版本 stats refresh ：设定自动刷新时间间隔 stats admin {if|unless} ：启用stats page中管理功能，如果stats auth认证成功才可以启用管理功能 示例： [root@haproxy/etc/haproxy]#vim haproxy.cfg 73 listen stats 74 bind 192.168.4.62:9000 75 stats enable 76 stats uri /hastats 77 stats auth ha1:123456 78 stats realm &quot;testhaproxy&quot; 79 stats hide-version 80 stats refresh 2s 81 stats admin if TRUE 重启服务 工作模式 maxconn ：为指定的frontend定义其最大并发连接数，默认为2000 mode {tcp|http|health}：定义haproxy工作模式 tcp：基于L4实现代理，可代理mysql，pgsql，ssh，ssl等协议，https时使用此模式，默认模式 http：仅当代理协议为http时使用，CentOS默认模式 health：工作为健康状态检查的响应模式，当连接请求到达时回应ok后即断开连接，较少使用 示例： 82 listen ssh 83 bind :220 84 balance leastconn 85 mode tcp 86 server sshsrv1 192.168.4.63:22 check 87 server sshsrv2 192.168.4.64:22 check 健康状态检测 对后端服务器做http协议的健康状态检测 option httpchk 默认为：/OPTIONS HTTP/1.0 option httpchk &lt;uri&gt; option httpchk &lt;method&gt; &lt;uri&gt; option httpchk &lt;method&gt; &lt;uri&gt; &lt;version&gt; 定义基于http协议的L7健康状态检测机制 http-check expect [!] &lt;match&gt; &lt;pattern&gt;：http协议健康状态检测响应内容或指定响应码 示例： 89 backend websrvs 90 balance roundrobin 91 server srv1 192.168.4.63:80 check weight 2 92 server srv2 192.168.4.64:80 check 93 option httpchk GET /index.html HTTP/1.1 \r\n host: forwardfor配置 在由haproxy发往后端主机请求报文中添加“X-Forwardde-For”首部，其值为前端客户端的地址，用于向后端主发送真实客户端IP 格式 option forwardfor [ except &lt;network&gt; ] [ header &lt;name&gt; ] [ if-none ] [except &lt;network&gt;]：请求报文来自此处指定的网络是不予添加此首部 [header &lt;name&gt;]：使用自定义首部名称，而非“X-Forwarded-For” [if-none]：如果没有首部才添加首部，如果有使用默认值； 示例： 48 option forwardfor except 127.0.0.0/8 header test 指定MIME类型启用压缩传输功能 compression algo ：启用http协议的压缩机制，指明压缩算法gzip、deflate compression type ：指明压缩的MIME类型 注意：如果添加首部，需要在http服务的日志中定义。 错误页配置 errorfile ：自定义错误页 :HTTP status；支持200、400、403、408、500、502、503、504 ：错误页文件路径 errorloc ：相当于errorloc02 ，利用302重定向指定URL 示例： errorloc 503 http://www.magedu.com/error_pages/503.html 报文首部 reqadd [{if|unless} ]：修改请求报文尾部添加指定首部 rspadd [{if|unless} ]：在响应首部尾部添加指定首部 reqdel [{if|unless} ]：从请求报文中删除匹配正则表达式的首部 reqidel [{if|unless} ]（ignore case）：从请求报文中删除匹配正则表达式的首部（不区分大小写） rspdel [{if|unless} ] rspidel [{if|unless} ]（ignore case）：从响应报文汇总删除正则表达式的首部 连接超时 time client ：客户端最长空闲连接超时时长，默认单位为毫秒 timeout server ：后端服务器最长空闲连接超时时长 timeout http-keep-alive ：持久连接的持久时长 timeout http-request ：一次完整的HTTP请求的最大等待时长 timeout connect ：成功连接后端服务器的最大等待时长 timeout client-fin ：客户端半连接的空闲时长 timeout server-fin ：后端服务器半连接得空闲时长 ACL 访问控制列表的使用提供了一个灵活的解决方案来执行内容交换，并且通常基于从请求中提取的内容、响应或任何环境状态进行决策。 格式： acl &lt;aclname&gt; &lt;criterion&gt; [flags] [operator] &lt;value&gt; ... &lt;value&gt;的类型 boolean integer or integer range IP address /network string hex block &lt;flags&gt; -i ：不区分大小写 -m：使用指定的pattern匹配方法 -n：不做DNS解析 -u：强制每个ACL必须唯一ID，否则多个同名ACL为“或”的关系 -- ：强制flag结束，当字符串和某个flag相似时使用 [operator] 匹配整数值：eq、ge、gt、le、lt 匹配字符串： -exact match （-m str）：字符串必须完全匹配模式 -substring mathc （-m sub）：在提取的字符串查找模式，如果其中任何一个被发现，ACL将匹配 -suffix match （-m end）：将模式与提取字符串的尾部进行比较，如果其中任何一个匹配，则ACL进行匹配 -prefix match （-m beg）：在提取的字符串首部中查找模式，如果其中任何一个被发现，ACL将匹配 -subdir mathc （-m dir）：查看提取出来的用斜线分隔的字符串，如果其中任何一个匹配，则ACL进行匹配 -domain match （-m dom）：查找提取的用“.”分隔字符串，如果其中任何一个匹配，则ACL进行匹配 acl作为条件时的逻辑关系： 与：隐式（默认）使用 或：使用“or”或”||“ 否定：使用“！”使用 &lt;aclname&gt;：ACL名称，可使用字母数字，区分字符大小写 &lt;criterion&gt;：比较的标准和条件 dst：目标IP dst_port：目标port src：源IP src_port：源port base string 返回第一个主机头和请求的路径部分的链接，该请求从第一个斜杠开始，并在问好之前结束，对虚拟主机有用 示例： \:/\:\@*:/\;\&lt; params&gt;*?\#\ base : exact string match base_beg : prefix match base_dir : subdir match base_dom : domain match base_end : suffix match base_len : length match base_reg : regex match base_sub : substring match 同acl类似 path ：string 提取请求的URL路径，该路径从第一个斜杠开始，并在问号之前结束 示例： \:/\:\@\:/\;\&lt; params&gt;?\#\ path : exact string match path_beg : prefix match path_dir : subdir match path_dom : domain match path_end : suffix match path_len : length match path_reg : regex match path_sub : substring match url：string 提取请求中的URL。一个典型的应用是具有预取能力的缓存，以及需要从数据库聚合多个信息并将它们保存在缓存中的网页门户入口 url : exact string match url_beg : prefix match url_dir : subdir match url_dom : domain match url_end : suffix match url_len : length match url_reg : regex match url_sub : substring match req.har（[[.]]）:string 提取在一个HTTP请求报文的首部 hdr([&lt;name&gt;[,&lt;occ&gt;]]) : exact string match hdr_beg([&lt;name&gt;[,&lt;occ&gt;]]) : prefix match hdr_dir([&lt;name&gt;[,&lt;occ&gt;]]) : subdir match hdr_dom([&lt;name&gt;[,&lt;occ&gt;]]) : domain match hdr_end([&lt;name&gt;[,&lt;occ&gt;]]) : suffix match hdr_len([&lt;name&gt;[,&lt;occ&gt;]]) : length match hdr_reg([&lt;name&gt;[,&lt;occ&gt;]]) : regex match hdr_sub([&lt;name&gt;[,&lt;occ&gt;]]) : substring match status：integer 返回在响应报文中的状态码 预定义ACL ACL名称 等价于 说明 TRUE always_true 总是匹配 FALSE always_false 从不匹配 HTTP req_proto_http 匹配HTTP协议 HTTP_1.0 req_ver 1.0 匹配HTTP协议1.0 HTTP_1.1 req_ver 1.1 匹配HTTP协议1.1 HTTP_CONTENT hdr_val(content-length) gt 0 匹配已经存在内容长度 HTTP_URL_ABS url_reg ^[^/:]*:// 匹配URL的绝对路径 HTTP_URL_SLASH url_beg / 匹配URL相对路径 HTTP_URL_STAR url * 匹配URL等于“*” LOCALHOST src 127.0.0.1/8 匹配从localhost来的链接 METH_CONNECT method CONNECT 匹配HTTP CONNECT 方法 METH_GET method GET HEAD 匹配GET和HEAD方法 METH_HEAD method HEAD 匹配head方法 METH_OPTONS method OPTIONS 匹配OPTIONS方法 METH_POST method POST 匹配POST方法 METH_TRACE method TRACE 匹配TRACE方法 RDP_COOKIE req_rdp_cookie_cnt gt 0 match presence of an RDP cookie REQ_CONNTENT req_len gt 0 匹配数据在请求缓存中 WAIT_END wait_end 等待内容分析 use_backend [{if|unless}] 当if|unless一个基于ACL的条件匹配时切换指定 backend {if|unless} 阻止L7请求if|unless一个条件匹配 http-request {allow|deny|add-header |set-header }[{if|unless} ] 对L7层请求的访问控制 tcp-request connection {accept|reject} [{if|unless} ]根据L4条件对传入连接执行操作 示例： 72 frontend mysql 73 bind 172.18.4.62:3306 74 mode tcp 75 default_backend mysqlsrv 76 backend mysqlsrv 77 mode tcp 78 server mysqlsrv1 192.168.4.63:3306 check 79 server mysqlsrv2 192.168.4.64:3306 check 这时我们查看下是谁发起的链接 由此我们可知，真正发起的是代理服务器 支持https协议 （1）支持ssl会话 bind *:443 ssl crt /PATH/TO/SOME_PEM_FILE 注意：crt文件的后缀为PEM格式，且同时包含证书和所有私钥内容 （2）把80端口请求重定向到443 bind *:80 redirect scheme https if!{ssl_fc} （3）向后端传递用户请求的协议和端口 http_request set-header X-Forwarded-Port %[dst_port] http_request add-header X-Forwarded-Proto https if { ssl_fc } 示例： （1）生成证书文件 [root@haproxy/etc/pki/tls/certs]#make httpd.pem [root@haproxy/etc/pki/tls/certs]#cp httpd.pem /root （2）修改haproxy.cfg文件 68 frontend web 69 bind 172.18.4.62:330 ssl crt /root/httpd.pem 70 redirect scheme https if !{ ssl_fc }]]></content>
      <categories>
        <category>服务</category>
        <category>HAproxy</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[firewalld]]></title>
    <url>%2F2017%2F11%2F29%2Ffirewalld%2F</url>
    <content type="text"><![CDATA[firewalldfirewalld是CentOS 7新退出的管理netfilter的工具。firewalld 提供了支持网络 / 防火墙区域 (zone) 定义网络链接以及接口安全等级的动态防火墙管理工具。它支持 IPv4, IPv6 防火墙设置以及以太网桥接，并且拥有运行时配置和永久配置选项。它也支持允许服务或者应用程序直接添加防火墙规则的接口。以前的 iptables 防火墙是静态的，每次修改都要求防火墙完全重启。这个过程包括内核 netfilter 防火墙模块的卸载和新配置所需模块的装载等。而模块的卸载将会破坏状态防火墙和确立的连接。 1、firewalld zone分类 zone名称 默认配置 trusted 允许所有流量 home 拒绝除和传出流量相关的，以及ssh、mdsn、ipp-client、samba-client、dhcpv6-client预定于服务之外其他所有传入流量 internal 允许所有流量 work 拒绝除和传出流量相关的，以及ssh、ipp-client、dhcpv6-client预定于服务之外的其他所有传入流量 public 拒绝除和传出流量相关的，以及ssh、dhcpv6-client预定于服务之外的其他所有传入流量，新家的网卡默认属于public zone external 拒绝除和传出流量相关的，以及ssh预定义服务之外的其他所有传入流量，属于external zone的传出ipv4流量的源地址将被伪装为传出网卡的地址 dmz 拒绝除和传出流量相关的，以及ssh预定义服务之外的其他所有传入流量 block 拒绝除和传出流量相关的所有传入流量 drop 拒绝除和传出流量的所有传入流量 2、预定于服务 服务名称 配置 ssh Local SSH server. Traffic to 22/tcp dhcpv6-client Local DHCPv6 client. Traffic to 546/udp on the fe80::/64 IPv6 network ipp-client Local IPP printing. Traffic to 631/udp. samba-client Local Windows file and print sharing client. Traffic to 137/udp and 138/udp. Multicast DNS (mDNS) local-link name resolution. Traffic to mdns 5353/udp to the 224.0.0.251 (IPv4) or ff02::fb (IPv6) multicast addresse ##3、firewalld-cmd命令选项 选项 说明 –get-zones 列出所有可用区域 –get-default-zone 查询默认区域，只能有一种策略可以使用 –set-default-zone= 设置默认区域 –get-active-zones 列出当前所使用的区域 –add-source=[–zone=] 添加源地址的流量到指定区域，如果无–zone选项，使用默认区域 –remove-source=[–zone=] 从指定区域中删除源地址的流量，如无–zone选项，使用默认区域 –add-interface=[–zone=] 添加来自于指定接口的流量到特定区域，如无–zone选项使用默认区域 –change-interface=[–zone=] 改变指定接口至新的区域，如无–zone选项使用默认区域 –list-all [–zone=] 列出指定区域的所有配置信息，包括接口、源地址、端口、服务等，如无–zone选项使用默认区域 –add-service=[–zone=] 允许指定端口和协议的流量，如无–zone选项使用默认区域 –add-port=[–zone=] 允许指定端口和协议流量如无–zone选项使用默认区域 –remove-port=[–zone=] 从区域中删除指定端口和协议，禁止该端口的流量，如无–zone选项使用默认区域 –reload 删除当前运行时的配置，应用加载永久配置 ##4、其他规则 当基本firewalld语法规则不能满足要求时，可以使用以下更复杂的规则；rich-rules富规则。rich规则比基本的firewalld语法实现更强的功能，不仅实现允许/拒绝，还可以实现日志syslog和auditd，也可以实现端口转发、伪装和限制速率。 ###1、rich语法 [source] [destination] service|port|protocol|icmp-block|masquerade|forward-port [log] [audit] [accept|reject|drop] ###2、规则实施顺序 该区域的端口转发，伪造规则 该区域的日志规则 该区域的允许规则 该区域的拒绝规则 注意：每个区域的规则生效，所有规则都不匹配，该区域默认规则生效。 ###3、rich规则选线 选项 描述 –add-rich-rule=’‘ Add to the specified zone, or the default zone if no zone is specified. –remove-rich-rule=’‘ Remove to the specified zone, or the default zone if no zone is specified. –query-rich-rule=’‘ Query if has been added to the specified zone, or the default zone if no zone is specified. Returns 0 if the rule is present, otherwise 1. –list-rich-rules Outputs all rich rules for the specified zone, or the default zone if no zone is specified. 当选项使用source或destination时，必须用rule [family=”ipv4|ipv6”] 需要制定服务时使用 service name=”service name” Port port port=&quot;port value&quot; protocol=&quot;tcp|udp&quot; Protocol protocol value=&quot;protocol value&quot; ICMP-Block icmp-block name=&quot;icmptype name&quot; Masquerade masquerade firewall-cmd --permanent --zone=&lt;ZONE&gt; --add-rich-rule=&#39;rule family=ipv4 source address=192.168.0.0/24 masquerade&#39; Source-Port source-port port=&quot;port value&quot; protocol=&quot;tcp|udp&quot; Log log [prefix=&quot;prefix text&quot;] [level=&quot;log level&quot;] [limit value=&quot;rate/duration&quot;] Audit audit [limit value=&quot;rate/duration&quot;] Action An action can be one of accept, reject, drop or mark. Limit limit value=&quot;rate/duration&quot; Destination destination [not] address=&quot;address[/mask]&quot; Source source [not] address=&quot;address[/mask]&quot;|mac=&quot;mac-address&quot;|ipset=&quot;ipset&quot; ##端口转发：将发往本机的特定端口的流量转发到本机或不同机器的另一个端口。 格式 firewall-cmd --permanent --zone=&lt;ZONE&gt; --add-forward port=port=&lt;PORTNUMBER&gt;:proto=&lt;PROTOCOL&gt;[:topor t=&lt;PORTNUMBER&gt;][:toaddr=&lt;IPADDR&gt;] 注意：toport和toaddr至少指定一个 示例： firewall-cmd --permanent --zone=public --add-forward-port=port=513:proto=tcp:toport=132:toaddr=192.168.0.25]]></content>
      <categories>
        <category>防火墙</category>
        <category>firewalld</category>
      </categories>
      <tags>
        <tag>firewalld</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVS实战]]></title>
    <url>%2F2017%2F11%2F28%2FLVS%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[实例lvs-nat模型实现http负载集群（VS和RS之间直连）- （1）构建网络拓扑 （2）搭建网络环境 配置路由器 [root@VS~]#vim /etc/sysctl.conf #开启路由转发功能 11 net.ipv4.ip_forward=1 RS1主机上添加路由规则 [root@RS1~]#route add default gw 192.168.4.63 RS2主机上也是如上添加规则即可 配置客户端 [root@RS1~]#route add default gw 172.18.4.63 切记：配置完以后一定要检测网络是否可以相互ping 通。 （3）添加规则 [root@VS~]#ipvsadm -A -t 172.18.4.63:80 -s rr [root@VS~]#ipvsadm -a -t 172.18.4.63:80 -r 192.168.4.64 -m [root@VS~]#ipvsadm -a -t 172.18.4.63:80 -r 192.168.4.65 -m （4）测试 lvs-nat模型实现http负载集群（VS和RS之间使用路由相连）- （1）搭建网络环境 配置VS [root@VS~]#vim /etc/sysconfig/network-scripts/ifcfg-eth0 1 DEVICE=eth0 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=172.18.4.63 5 PREFIX=16 [root@VS~]#vim /etc/sysconfig/network-scripts/ifcfg-eth1 1 DEVICE=eth1 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=192.168.4.63 5 PREFIX=24 6 GATEWAY=192.168.4.64 配置router2 [root@route2~]#vim /etc/sysconfig/network-scripts/ifcfg-eth0 1 DEVICE=eth0 2 BOOTPROTO=static 3 ONBOOT=yes 4 IPADDR=192.168.4.64 5 PREFIX=24 6 GATEWAY=192.168.4.63 [root@route2~]#vim /etc/sysconfig/network-scripts/ifcfg-eth1 1 DEVICE=eth1 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=192.168.100.63 5 PREFIX=24 配置RS1和RS2 [root@RS1~]#vim /etc/sysconfig/network-scripts/ifcfg-eth1 1 DEVICE=eth1 2 BOOTPROTO=none 3 IPADDR=192.168.100.64 4 PREFIX=24 5 GATEWAY=192.168.100.63 [root@RS2~]#vim /etc/sysconfig/network-scripts/ifcfg-eth1 1 DEVICE=eth1 2 BOOTPROTO=none 3 IPADDR=192.168.100.65 4 PREFIX=24 5 GATEWAY=192.168.100.63 务必测试环境是否ping通。 （2）添加规则 [root@VS~]#ipvsadm -A -t 172.18.4.63:80 -s rr[root@VS~]#ipvsadm -a -t 172.18.4.63:80 -r 192.168.100.64 -m[root@VS~]#ipvsadm -a -t 172.18.4.63:80 -r 192.168.100.65 -m [root@VS~]#ipvsadm -ln #查看添加的规则 IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConn TCP 172.18.4.63:80 rr -&gt; 192.168.100.64:80 Masq 1 0 0 -&gt; 192.168.100.65:80 Masq 1 0 0 （3）测试 lvs-nat模型实现https和http负载集群以第二个环境为基础进行 （1）每天RS1上增加证书 [root@RS1~]#cd /etc/pki/tls/certs/ [root@RS1/etc/pki/tls/certs]#make httpd.crt [root@RS1/etc/pki/tls/certs]#mv httpd.* /etc/httpd/conf.d/ #将证书存放在此目录下 由于证书key是加密存在的，每次都要输入密码，为了方便对key文件解密 root@RS1/etc/httpd/conf.d]#openssl rsa -in httpd.key -out httpd.key [root@RS1/etc/httpd/conf.d]#yum install -y mod_ssl #安装模块使其支持加密 修改ssl.conf配置文件 [root@RS1/etc/httpd/conf.d]#vim ssl.conf （2）测试本机是否可以正常访问 [root@RS1/etc/httpd/conf.d]#curl -k https://192.168.100.64 RS1 （3）在VS上添加规则 [root@VS~]#iptables -t mangle -A PREROUTING -d 172.18.4.63 -p tcp -m multiport --dports 80,443 -j MARK --set-mark 10 [root@VS~]#ipvsadm -A -f 10 -s rr [root@VS~]#ipvsadm -a -f 10 -r 192.168.100.64 -m [root@VS~]#ipvsadm -a -f 10 -r 192.168.100.65 -m [root@VS~]#ipvsadm -ln IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConn FWM 10 rr -&gt; 192.168.100.64:0 Masq 1 0 0 -&gt; 192.168.100.65:0 Masq 1 0 0 （4）测试 lvs-nat模型实现https负载集群以第二个环境为基础进行 （1）在RS1和RS2上添加证书 [root@RS1~]#cd /etc/pki/tls/certs/ [root@RS1/etc/pki/tls/certs]#make httpd.crt [root@RS1/etc/pki/tls/certs]#mv httpd.* /etc/httpd/conf.d/ #将证书存放在此目录下 由于证书key是加密存在的，每次都要输入密码，为了方便对key文件解密 root@RS1/etc/httpd/conf.d]#openssl rsa -in httpd.key -out httpd.key [root@RS1/etc/httpd/conf.d]#yum install -y mod_ssl #安装模块使其支持加密 修改ssl.conf配置文件 [root@RS1/etc/httpd/conf.d]#vim ssl.conf （2）测试本机是否可以正常访问 [root@RS1/etc/httpd/conf.d]#curl -k https://192.168.100.64 RS1 （3）VS添加规则 [root@VS~]#ipvsadm -A -t 172.18.4.63:443 -s rr[root@VS~]#ipvsadm -a -t 172.18.4.63:443 -r 192.168.100.64:443 -m[root@VS~]#ipvsadm -a -t 172.18.4.63:443 -r 192.168.100.65:443 -m[root@VS~]#ipvsadm -ln IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConn TCP 172.18.4.63:443 rr -&gt; 192.168.100.64:443 Masq 1 0 0 -&gt; 192.168.100.65:443 Masq 1 0 0 （4）测试是否成功 lvs-dr模型实现http负载集群- （1）搭建网络环境 路由器： [root@router/etc/sysconfig/network-scripts]#vim ifcfg-eth0 1 DEVICE=eth0 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=172.18.4.61 5 PREFIX=24 [root@router/etc/sysconfig/network-scripts]#vim ifcfg-eth1 1 DEVICE=eth1 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=192.168.4.61 5 PREFIX=24 客户端 [root@client/etc/sysconfig/network-scripts]#vim ifcfg-eth0 1 DEVICE=eth0 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=172.18.4.55 5 PREFIX=24 [root@client ~]#route add default gw 172.18.4.61 VS [root@VS/etc/sysconfig/network-scripts]#vim ifcfg-eth0 1 DEVICE=eth0 2 BOOTPROTO=static 3 ONBOOT=yes 4 IPADDR=192.168.4.62 5 PREFIX=24 6 GATEWAY=192.168.4.61 [root@VS/etc/sysconfig/network-scripts]#vim ifcfg-eth0:0 1 DEVICE=eth0:0 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=192.168.4.63 5 PREFIX=24 -RS1和RS2 [root@RS1/etc/sysconfig/network-scripts]#vim ifcfg-eth0 1 DEVICE=eth0 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=192.168.4.64 5 PREFIX=24 6 GATEWAY=192.168.4.61 [root@RS1/etc/sysconfig/network-scripts]#vim ifcfg-eth1 1 DEVICE=eth1 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=192.168.4.63 5 PREFIX=32 关闭arp广播 [root@RS1~]#echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore [root@RS1~]#echo 1 &gt; /proc/sys/net/ipv4/conf/eth1/arp_ignore [root@RS1~]#echo 1 &gt; /proc/sys/net/ipv4/conf/eth1/arp_announce [root@RS1~]#echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_announce RS2和RS1配置类似就不陈述 注意：如果配置VIP地址在lo网卡上需要关闭如下选项 net.ipv4.conf.lo.arp_ignore = 1 net.ipv4.conf.lo.arp_announce = 2 net.ipv4.conf.all.arp_ignore = 1 net.ipv4.conf.all.arp_announce = 2 如果配置VIP地址在真实网卡需要关闭如下 net.ipv4.conf.ethN.arp_ignore = 1 net.ipv4.conf.ethN.arp_announce = 2 （N 为网卡接口） net.ipv4.conf.all.arp_ignore = 1 net.ipv4.conf.all.arp_announce = 2 （2）VS添加规则 [root@VS~]#ipvsadm -A -t 192.168.4.63:80 -s rr [root@VS~]#ipvsadm -a -t 192.168.4.63:80 -r 192.168.4.64:80 -g [root@VS~]#ipvsadm -a -t 192.168.4.63:80 -r 192.168.4.65:80 -g [root@VS~]#ipvsadm -ln IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConn TCP 192.168.4.63:80 rr -&gt; 192.168.4.64:80 Route 1 0 0 -&gt; 192.168.4.65:80 Route 1 0 0 （3）在客户端测试 问题1：如果RS中VIP的子网掩码不是32结果怎么样呢？ 修改RS1和RS2VIP [root@RS1/etc/sysconfig/network-scripts]#vim ifcfg-eth1 1 DEVICE=eth1 2 BOOTPROTO=none 3 ONBOOT=yes 4 IPADDR=192.168.4.63 5 PREFIX=24 重启网络服务测试 [root@RS1/etc/sysconfig/network-scripts]#systemctl restart network 小结- 1、当客户端发起访问VIP 对应的域名的请求时，根据网络通信原理会产生ARP 广播，因为负载均衡器和真实的服务器在同一网络并且VIP设置在集群中的每个节点上，此时集群内的真实服务器会尝试回答来自客户端计算机的查找VIP的ARP广播，这就会产生问题，大家都说我是”VIP”。 为了达到负载均衡的目的，必须想法办让真实服务器忽略来自客户端计算机的ARP广播请求。所以要修改arp_igonre和arp_announce这两个内核参数 2、RS中VIP的子网掩码不一定要为255.255.255.255。但是通过查询资料可知，因为若干机器要使用同一个IP地址，用本身做广播地址和把子网掩码设置为255.255.255.255就不会造成IP地址冲突。 3、如果是这种框架：RShe Director必须在同一个物理网段中。 lvs-dr集群web服务-]]></content>
      <categories>
        <category>调度器</category>
        <category>LVS实战</category>
      </categories>
      <tags>
        <tag>lvs，实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DHCP]]></title>
    <url>%2F2017%2F11%2F28%2FDHCP%2F</url>
    <content type="text"><![CDATA[一、DHCP服务1、DHCP概念DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一个局域网的网络协议，使用UDP协议工作， 主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段，。DHCP有3个端口，其中UDP67和UDP68为正常的DHCP服务端口，分别作为DHCP Server和DHCP Client的服务端口；546号端口用于DHCPv6 Client，而不用于DHCPv4，是为DHCP failover服务，这是需要特别开启的服务，DHCP failover是用来做“双机热备”的。 ###2、DHCP过程（1）DHCP Client以广播的方式发出DHCP Discover报文。 （2）所有的DHCP Server都能够接收到DHCP Client发送的DHCP Discover报文，所有的DHCP Server都会给出响应，向DHCP Client发送一个DHCP Offer报文。DHCP Offer报文中“Your(Client) IP Address”字段就是DHCP Server能够提供给DHCP Client使用的IP地址，且DHCP Server会将自己的IP地址放在“option”字段中以便DHCP Client区分不同的DHCP Server。DHCP Server在发出此报文后会存在一个已分配IP地址的纪录。 （3）DHCP Client只能处理其中的一个DHCP Offer报文，一般的原则是DHCP Client处理最先收到的DHCP Offer报文。DHCP Client会发出一个广播的DHCP Request报文，在选项字段中会加入选中的DHCP Server的IP地址和需要的IP地址。 （4）DHCP Server收到DHCP Request报文后，判断选项字段中的IP地址是否与自己的地址相同。如果不相同，DHCP Server不做任何处理只清除相应IP地址分配记录；如果相同，DHCP Server就会向DHCP Client响应一个DHCP ACK报文，并在选项字段中增加IP地址的使用租期信息。 （5）DHCP Client接收到DHCP ACK报文后，检查DHCP Server分配的IP地址是否能够使用。如果可以使用，则DHCP Client成功获得IP地址并根据IP地址使用租期自动启动续延过程；如果DHCP Client发现分配的IP地址已经被使用，则DHCP Client向DHCPServer发出DHCP Decline报文，通知DHCP Server禁用这个IP地址，然后DHCP Client开始新的地址申请过程。 （6）DHCP Client在成功获取IP地址后，随时可以通过发送DHCP Release报文释放自己的IP地址，DHCP Server收到DHCP Release报文后，会回收相应的IP地址并重新分配。 ###3、DHCP的状态||状态|解释||DHCP discover|客户端到服务器端||DHCP offer|服务器端到客户端||DHCP request|客户端到服务端||DHCP nack|服务器端到客户端指示客户端的网络地址是不正确的||DHCP ack|服务器端到客户端||DHCP decline|客户端到服务器端，指示地址已经被使用||DHCP release|客户端到服务器端，放弃网络地址和取消剩余的租约时间||DHCP inform|客户端到服务器端，只要求本地配置参数，客户端已经具有外部配置的网络地址| ###4、如何续租呢？当客户端向服务器端取得地址以后得到租期，当租期达到某个期限时，客户端主动向服务器端发起广播请求 %50：租赁时间达到50%时来续租，刚想DHCP服务器发现新的DHCP request请求。如果dhcp服务没有拒绝的理由，则回应DHCP ack信息。当DHCP客户端收到应答信息后，就重新开始新的租用期限。 87.5%：如果之前DHCP server没有回应，等到租约期的87.5%时，主动再发送一次广播请求。 ###5、DHCP的配置文件主配置文件 /etc/dhcp/dhcpd.conf /etc/dhcp/dhcpd6.conf启动配置文件 /etc/rc.d/init.d/dhcpd /etc/rc.d/init.d/dhcpd6中继器 /usr/sbin/dhcrelay /etc/rc.d/init.d/dhcrelay ###6、/etc/dhcp/dhcpd.conf配置文档详解 # option definitions common to all supported networks... option domain-name &quot;example.org&quot;; #searchname option domain-name-servers ns1.example.org, ns2.example.org; #设置DNS服务器地址 default-lease-time 600; #设置租约时长 max-lease-time 7200; #设置客户端最长租期 # Use this to enble / disable dynamic dns updates globally. #ddns-update-style none; #设置DHCP更新 # If this DHCP server is the official DHCP server for the local # network, the authoritative directive should be uncommented. #authoritative; # Use this to send dhcp log messages to a different log file (you also # have to hack syslog.conf to complete the redirection). log-facility local7; #设置日志级别 # No service will be given on this subnet, but declaring it helps the # DHCP server to understand the network topology. subnet 10.152.187.0 netmask 255.255.255.0 { } # This is a very basic subnet declaration. subnet 10.254.239.0 netmask 255.255.255.224 { range 10.254.239.10 10.254.239.20; #设置可分配IP的范围 option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org; #设置客户端默认网关 } filename #指明引导文件名称 next-server #提供引导文件的服务器IP地址 当我们配置完时候，不知道是否出现问题这时候就需要对配置文件尽心检查 service dhcp configtest 示例： （1）安装dhcp服务[root@localhost ~]# yum install -y dhcp（2）将配置文件复制到/etc/dhcp/目录下[root@localhost ~]# cp /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example /etc/dhcp/dhcpd.conf（3）编辑配置文件[root@localhost ~]# vim /etc/dhcp/dhcpd.conf（4）重启dhcp服务[root@localhost ~]# systemctl restart dhcpd（5）在另外一个机器上测试，是否可以拿到地址。[root@localhost ~]#service restart dhcpd 注意： 1、在进行编辑注意每行完成以后要以“；”结尾。 2、在配置DHCP服务时，有时获取到地址并不能ping，很有可能dhcp服务IP变化。]]></content>
      <categories>
        <category>服务</category>
        <category>DHCP</category>
      </categories>
      <tags>
        <tag>dhcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS实战]]></title>
    <url>%2F2017%2F11%2F28%2FDNS%E5%AE%9E%E6%88%98%E4%B8%80%2F</url>
    <content type="text"><![CDATA[实战（1）搭建主DNS服务器（a）[root@localhost ~]# yum install -y bind #安装包（b）[root@localhost ~]# vim /etc/named.conf #修改主配置文件 方式一： 方式二： （c）[root@localhost ~]# vim /etc/ named.rfc1912.zones #修改zone文件 zone &quot;test.com&quot; IN { type master; file &quot;test.com.zone&quot; #此地方可以写绝对路径和相对路径，如果写相对路径，默认为`/var/named/test.com.zone`，因此在`/var/named`目录下文件名一定要与这里的文件名一致。 }; （d）[root@localhost ~]# named-checkconf #使用命令对配置文件检查 /etc/named.rfc1912.zones:27: missing &apos;;&apos; before &apos;}&apos; #此时检查为27行处没有加&quot;;&quot;修改完再检查即可。 注意：修改rfc1912.zones文件时，要以“；”结尾；参数与选项之间必须有空格隔开。 （e）修改zone文件[root@localhost named]# cp named.localhost test.com.zone 但是这里有一个问题，bind程序是以who的身份运行呢？下面通过命令查询看下：[root@localhost named]# ps aux |grep named named 4002 0.2 1.2 161124 13028 ? Ssl 09:55 0:00 /usr/sbin/named -u named 通过命令查看我们看到是以name身份运行的，但是我们在复制文件时，文件名时root，如下图；所以在复制过来以后记得修改文件的权限。 方法一：修改文件的所属组 [root@localhost named]# chgrp named test.com.zone 方法二：复制模板文件时，直接加“-p” [root@localhost named]# cp -p named.localhost test.com.zone[root@localhost named]# vim test.com.zone #修改ZONE文件 $TTL 1D @ IN SOA dns1 mail.test.com. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 dns1 A 192.168.4.132 （f）加载zone文件 [root@localhost named]# rndc reload （g）查看是否可以解析 [root@localhost named]# dig-t ns test.com @192.168.4.132 #在本机测试 在另外一台机器上测试 修改这台机器上的DNS 测试 [root@localhost/etc/sysconfig/network-scripts]#dig -t ns test.com @192.168.4.132 （2）搭建从DNS服务器在主机IP地址为192.168.4.144搭建从服务器 （a）安装bind包 （b）编辑/etc/named.conf （c）编辑配置zone文件/etc/named.rfc1912zones zone &quot;test.com&quot; IN { type slave; #修改类型 masters { 192.168.4.132; }; #主DNS服务器的地址 file &quot;slaves/test.com.slave.zone&quot;; #从DNS服务文件存放的位置 }; （d）启动bind服务，使其生效 [root@localhost~]#systemctl restart named[root@localhost~]#ls /var/named/slaves/test.com.slave.zone （e）测试 [root@localhost~]#dig www.test.com @192.168.4.144 （3）实现转发功能假如一个公司有三台DNS服务器，A,B,C并且这三台主机不在同一个位置；A机器可以直接连接互联网，而B，C不可以直接连接互联网。用户使用电脑想访问www.qq.com，只能通过专线先到C再到A，然后才能访问www.qq.com，通过C转发到A。 方式一：全局转发 （1）分别在CentOS 6和CentOS 7 主机上设置，CentOS 7为转发 (A)在CentOS 6主机上配置 [root@localhost ~]# vim /etc/named.conf [root@localhost ~]# vim /etc/named.rfc1912.zones zone &quot;test.com&quot; IN { type master; file &quot;test.com.zone&quot;; }; 重启服务 [root@localhost ~]# service named restart (B)在CentOS 7主机上配置 [root@localhost~]#vim /etc/named.conf 切记，做这个实验室一定要关闭dnssec功能；dnssec-enable no; dnssec-validation no。 重启服务 [root@localhost~]#systemctl restart named (C)修改客户端机器的dns [root@localhost~]#vim /etc/sysconfig/network-scripts/ifcfg-ens33 (D)在客户端机器上测试 [root@localhost~]#dig www.test.com @192.168.4.148 在这里给大家提个醒：自己搞这个明明很简单的搞了一个多小时都没有成功，原因在于没有关闭dnssce功能。 方式二：特定区域转发 在CentOS 主机上配置 [root@localhost~]#vim /etc/named.rfc1912.zones zone &quot;test.com&quot; IN { type forward; forward first; forwarders {192.168.4.132;}; }; [root@localhost~]#systemctl restart named #重启服务 在客户端主机上测试 （4）实现父域与子域的关系在前面实验的基础上，执行如下操作： （A）在CentOS 7主机上 [root@localhost~]#vim /etc/named.rfc1912.zones 创建zone zone &quot;do.test.com&quot; IN { type master; file &quot;do.test.com.zone&quot;; }; [root@localhost/var/named]#vim do.test.com.zone #配置解析库 $TTL 1D @ IN SOA dns1 rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 dns1 A 192.168.4.148 webserver A 192.168.4.148 www CNAME webserver (B)[root@localhost named]# vim test.com.zone #在CentOS 6主机上修改解析库 [root@localhost named]# service named restart #重启服务 (C)重启服务测试 （5）主从服务器案例前提：准备4台虚拟机 （A）CentOS6主机作为主DNS服务器，同上面的配置类似，这里就不再阐述。 （B）在CentOS 7两台主机上做从DNS服务器，进行如下配置： [root@localhost ~]# vim /etc/named.conf [root@localhost~]#vim /etc/named.rfc1912.zones#创建zone zone &quot;test.com&quot; IN { type slave; masters {192.168.4.132;}; file &quot;slaves/test.com.slave.zone&quot;; }; 启动bind的服务即可以同步到/var/named/slaves目录下 [root@localhost~]#systemctl restart named[root@localhost~]#ll /var/named/slaves/test.com.slave1.zone -rw-r--r--. 1 named named 382 Sep 20 19:08 /var/named/slaves/test.com.slave1.zone 如果主从服务器想指定从DNS服务器，可以在/etc/named.conf配置文件中添加选项 allow-transfer {IP;}； 在从服务器上添加“allow-transfer {none;};”在主DNS服务器上“allow-transfer {IP;};”这样就限制了。 注意：通过以上几个实验总结出需要注意的一些地方 1、在做实验过程中一定要关闭dnssec功能； 2、复制文件/var/named/named.localhost做模板时，一定要加选项“-a”或“-p”选项。复制完成后一定看所有者、所属组和权限。]]></content>
      <categories>
        <category>服务</category>
        <category>DNS</category>
        <category>DNS实战一</category>
      </categories>
      <tags>
        <tag>主从，转发，子域和父域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS实战]]></title>
    <url>%2F2017%2F11%2F28%2FDNS%E5%AE%9E%E6%88%98%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[实战二 如何实现上述的拓扑图呢？先从底部网上一步一步的搭建 （1）实现主从DNS服务器 （a）修改主DNS服务器 [root@localhost~]#vim /etc/named.conf #修改主配置文件 [root@localhost~]#vim /etc/named.rfc1912.zones #创建zone zone &quot;test.com&quot; IN { type master; file &quot;test.com.zone&quot;; }; [root@localhost ~]# vim /var/named/test.com.zone #创建解析库文件 $TTL 1D @ IN SOA dns1 test.com. ( 2 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum IN NS dns1 dns1 A 192.168.4.132 webserver IN A 192.168.4.132 www IN CNAME webserver [root@localhost~]#vim /var/named/named.ca #修改根服务器文件 [root@localhost ~]# service named restart #重启bind服务 （b）配置从DNS服务器 主配置文件和配置从服务器一样，这里就不再阐述[root@localhost~]#vim /etc/named.rfc1912.zones zone &quot;localhost&quot; IN { type master; file &quot;named.localhost&quot;; allow-update { none; }; }; [root@localhost~]#systemctl restart named#重启服务[root@localhost~]#ll /var/named/slaves/test.com.slave.zone #查看是否成功 （2）配置子域 [root@localhost~]#vim /etc/named.rfc1912.zones #创建zone zone &quot;com&quot; { type master; file &quot;com.zone&quot;; }; [root@localhost~]#vim /var/named/com.zone #创建解析库 $TTL 1D @ IN SOA dns1 rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 test NS dns2 dns1 A 192.168.4.147 dns2 A 192.168.4.132 www A 192.168.4.66 [root@localhost~]#systemctl restart named #重启bind服务 （3）根 [root@localhost~]#vim /etc/named.rfc1912.zones zone &quot;.&quot; IN { type master; file &quot;root.zone&quot;; }; 删除配置文件中/etc/named.conf如下内容 [root@localhost/var/named]#vim root.zone #创建解析库 $TTL 1D @ IN SOA dns1 rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 com NS dns2 dns1 A 192.168.4.146 dns2 A 192.168.4.147 [root@localhost/var/named]#systemctl restart named重启服务 这样我们搭建完成了。是否是很有成就感呢？哈哈。当大家看到这里的时候是不是发现我们没有对从DNS服务器做设置呢？如果主DNS挂了，那么从DNS能工作么？下面我们就来说道说道。 假设主DNS服务器down（IP 192.168.4.132 ） [root@localhost ~]# ifconfig eth0 down #将主DNS服务器down掉 [root@localhost ~]# rndc flush #清除主DNS服务器的缓存 在Client客户机测试 （IP 192.168.4.149） [root@localhost~]#dig www.test.com @192.168.4.147 如图所示，没有解析成功，说明我们的从DNS服务器没有起作用，没有实现负载均衡作用。有没有想过为什么出现这种情况呢？因为我们没有在com域中没有添加这条域，下面我们在com域中添加此从DNS服务器的dns记录测试 在com域中添加如下记录 [root@localhost/var/named]#vim com.zone [root@localhost/var/named]#rndc flush #清除缓存 在client客户机上测试 [root@localhost~]#dig www.test.com @192.168.4.148 这样说明我们从DNS服务器起到了，达到了容错功能。是不是有点小小的成就感呢？]]></content>
      <categories>
        <category>服务</category>
        <category>DNS</category>
        <category>DNS实战二</category>
      </categories>
      <tags>
        <tag>主从，转发，子域和父域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS访问控制和智能DNS]]></title>
    <url>%2F2017%2F11%2F28%2FDNS%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E6%99%BA%E8%83%BDDNS%2F</url>
    <content type="text"><![CDATA[DNS的管理功能你是不是有这样的想法，只想让某个IP或者某个IP端的地址进行访问，实现访问控制功能。DNS服务给我们提供了很好的解决方法。 1、选项||allow-query {}；| 允许查询的主机，相当于白名单|allow-transfer {}；|允许区域传送的主机|allow-recursion{};|允许递归的主机，这个选项建议在options中使用|allow-update{}；|允许更新区域数据库中的内容 2、acl acl：是把某个IP或IP端合并为一个集合，通过一个统一的名称调用；可以把这个理解为bash函数的功能。 （1）acl内置的选项 ||none|没有一个主机||any|任意主机||localhost|本机||localnet|本机的IP同掩码运算后得到的网络地址| 注意：acl只能先定义再使用；建议一般定义再options的前面。 （2）示例 [root@localhost ~]# vim /etc/named.conf 重新启动服务然后在本机测试[root@localhost ~]# dig www.test.com @127.0.0.1 由于我们设置了acl功能，所有本机也不能访问了。实现我们的预期效果。 view大家小时候去网吧的时候有没有遇到这样一个问题，如果你玩问道在电信1玩，而你的网络是联通的网络，这样开始玩游戏的过程中，我们的屏反应会迟钝，频很高；但是网络提供一个网络转换程序，如果你切换到电信网络，问道游戏运行流畅；这相当于我们这里view的功能。实现只能DNS解析，不过不需要我们手动切换网络。 （1）一个bind服务器可以定义多个view；每个view可以定义多个zone。每个view匹配一组客户端。 （2）如果多个view对同一个zone进行解析时，使用不同的zone解析库文件。 实战如果我们在北京和广州有两台DNS服务器，北京和广州用户通过访问www.test.com的时候，我希望北京访问直接在北京DNS解析并返回，广州与它相同，如何实现嗯？ 在一台由于我电脑有两个不同的IP段，在一台机器上实现这个功能 （a）修改/etc/named.conf文件 （b)创建/etc/named.rfc1912.zones.test和/etc/named.rfc1912.zones.app分别修改 （3）创建zone文件 /var/named/app.com.zone和/var/named/app.com.zone分别修改 （4）重启dns服务[root@localhost named]# service named restart 在Clinet客户机上测试（IP 192.168.4.148和172.18.253.86）]]></content>
      <categories>
        <category>服务</category>
        <category>DNS</category>
        <category>DNS访问控制和智能DNS</category>
      </categories>
      <tags>
        <tag>acl，view，智能DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS简单介绍]]></title>
    <url>%2F2017%2F11%2F28%2FDNS%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、DNS1、DNS概念DNS（Domain Name System，域名系统）是互联网的一项服务。它将域名和IP地址相互映射的一个分布式数据库，能够使人方便地访问互联网。 2、使用的端口（1）53/TCP 53/UDP （2）不同协议的端口作用是什么呢？ 53/UDP:提供客户端查询功能 53/TCP和53/UDP:实现dns主从复制功能 3、DNS域名开头我们述说DNS是分布式数据库，想必大家猜到了DNS是层级结构的。 从图中可以看出DNS的层级结构 （1）根域（Top Level Domain，tld） （2）顶级域 （a）组织域， com，org，gov，mil等 （b）国家域，cn，ca，hk，tw等 （c）反向域，arpa （3）二级域 … 4、DNS服务器类型（1）主DNS服务器 作用：管理和维护负责解析的域内解析库的服务器 。（2）从DNS服务器 作用：从主服务器或从服务器“复制”（区域间传输）解析库副本。 这里我们需要注意一下，区域传输分为两种 （a）完全传输（axfr）：传送整个解析库； （b）增量传输（ixfr）：传递解析库变化的内容； 是不是大家想，主从DNS服务器时如何工作的呢？ 有两种工作机制“PUSH”和“PULL”。当主DNS服务器配置文件中序列号发生递增，重新DNS服务；主DNS服务器会主动向从DNS服务器同步信息；这个过程称为&apos;PUSH&apos;。如果区域传输终端，没有同步成功，从服务器会根据配置文件中的”retry“指定的时间重新尝试同步信息，这个过程称为“PULL”。 5、DNS解析DNS解析分为两种 （a）正向解析：FQDN--&gt;IP （b）反向解析: IP--&gt;FQDN 注意：正向解析是两个不同的名称空间，是两个不同的解析树，如果为子域则写DNS服务IP。 DNS查询类型： （a）递归查询 （b）迭代查询 一次完整的DNS查询请求的过程：Client–&gt;host文件–&gt;DNS server Local Cache –&gt;DNS server（recursion）–&gt;Server Cache–&gt;Iteration（迭代）–&gt;Root–&gt;TLD–&gt;二级域名–&gt;… 6、DNS资源类型区域解析库由众多的RR（resource record）组成。存在不同的类型：A,AAAA,SOA,CNAME,MX,PTR,NS。 资源记录的格式： NAME [TTL] IN RR_TYPE VALUE 下面有几点需要注意的： （a）$TTL变量，全局继承此处的缓存周期，默认单位为秒。 （b）@代替/etc/named.rfc1912.zones配置的ZONE_NAME. （c）同一个名字可以通过多条记录定义多个不同的值，此时DNS服务器会以轮询方式进行相应。 （d）同一个值可能有多个不同定义的名字；通过多个不同的名字指向同一个值进行定义。此仅表示通过多个不同的名字可以找到同一个主机。 （1）SOA：Start Of Authority，起始授权记录。value的构成： （a）当前区域的主DNS服务器的 FQDN，也可以使用/etc/named.rfc1912.zones配置的ZONE_NAME。 （b）当前区域管理员的邮箱地址，但地址中不能使用”@“，一般使用“.”替代。因为在配置文件中“@”表示特殊含义。 （c）主从服务区域传输相关定义以及否定的答案的同一TTL。 @ IN SOA @ rname.invalid. ( 0 ; serial #解析库序列号，主服务器解析库变化时，递增，最长只能为十位数组成，一般为了方便管理这样管理“当前日期+版本号” 1D ; refresh #刷新时间，从服务器从主服务器请求同步解析库的时间 1H ; retry #重试时间，从服务器从主DNS服务器请求失败时，再次尝试的时间 1W ; expire #过期时长，从服务器联系不到主服务器时，多久后停止服务 3H ) ; minimum #错误解析存活时长 注意：一个区域解析库只能有且仅有一个SOA记录，必须位于解析库的第一条记录。 （2）NS，Name Server ，名称服务value：当前区域的某DNS服务器名称 注意： （a）相邻的两个资源记录的NAME相同时，后续可省略。 （b）任何一个NS记录后面的服务器名字，都应该在后续有一个A记录。 （3）MX，Mail eXchange，邮件转换value：当前区域的某邮件服务器的主机名 注意： （1）在一个区域内可以有多个MX记录,但是每个MX记录前应该有一个数字（0-99），表示服务器的优先级，数字越小优先级越高。 （2）任何一个MX记录后应该有一个A记录。 （4）A 记录value：主机名对应的IP地址 对于A记录有以下几种定义格式: (a)可以使用FQDN (b)可以使用泛域名 *.ZONE_NAME,这种方式的好处是避免用户写错名称时给错误答案，将错误答案指向某特性的地址。 (c)如果一个网段中地址不确定可以是使用 $GGENERATE #-# NAME$ 后面对应的地址也是，网段加$ 示例：$GENERATE 100-150 host$ IN A 192.168.4.$ (5)AAAA记录(6)PTR PoinTeR IP，反向域名解析格式：IP PTR FQDN 完整格式：135.4.168.192-in.adder.arpa IN PTR dns1 如果192.168.4为网络地址，可以这样写 135 IN PTR DNS1 注意:主机地址要反着写。 （7）CNAME 别名有时候我们访问一个网站是www主机不一定是真正的主机。有可能使用了这种别名机制 示例： www IN CNAME websrv 我们在访问一个网址时，有可能为如下地址www.test.server.com对整个地址来说真正的，test为server的子域。server为com的子域。n那么父域如何对子域进行授权呢？ 子域授权：每个域的名称服务器，都是通过父域服务器在解析库进行授权。 如图所述：想必大家多DNS的名称，过程有了一定的了解，下面通过看上面这张图，可以看出子域与父域的管理。通过观察图中，一个zone可有多个RR组成。可以粗略的看出DNS的容错功能，实现负载的作用。父域通过委派子域进行管理。 如图所示：DNS是工作在内核中的，用户是没有办法直接管理DNS服务，那要如何管理DNS服务呢？前人想出了Bind进行管理DNS服务。这样用户通过用户空间借助于Bind管理工具或配置文件就可以管理DNS服务了。]]></content>
      <categories>
        <category>服务</category>
        <category>DNS</category>
        <category>DNS简单介绍</category>
      </categories>
      <tags>
        <tag>dns，bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CURL、elinks工具]]></title>
    <url>%2F2017%2F11%2F28%2FCURL%E3%80%81elinks%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[CURL工具curl是居于URL语法在命令行方式下工作的文件传输工具，它支持FTP,FTPS,HTTP,HTTPS,GOPHER,TELNET,DICT,FILE及LDAP等协议。curl支持HTTPS认证，并且支持HTTP的POST、PUT等方法，FTP上传，kerberos认证，HTTP上传，代理服务器，cookies，用户名/密码认证，下载文件断电续传，上传文件断电续传，httpd代理服务器通道，还支持IPv6，socket5代理服务器，通过http代理服务器上传文件到FTP服务器等。 格式： curl [OPTIONSS] [URL...] -A/--user-agent &lt;string&gt;:设置用户代理发送给服务器 -e/-referer &lt;URL&gt;:查看此网址从那个网址转发过来 --cacert &lt;file&gt;:CA证书 -k/--insecure:允许忽略证书进行SSL连接 --compressed:要求返回时压缩的格式 --H/--header &lt;line&gt;：自定义首部信息传递给服务器，构造请求首部 -i：显示页面内容，包括报文首部信息 -I/--head：只显示响应报文首部信息 -D/--dump-header &lt;file&gt;：将url的header信息存放在指定文件中 --limit-rate &lt;rate&gt;：设置传输速度，默认为k --basic：使用HTTP基本认证 -u/--user&lt;user[:passwd]&gt;:设置服务器的用户和密码 -L：如果有3XX响应吗，重新发请求到新位置 -o &lt;file&gt;：将网络文件保存为指定的文件中 -O：使用url中默认的文件名保存文件到本地 -0/--http1.0：使用http1.0协议 -C：选项可对文件使用断电续传功能 -c/--cookie-jar &lt;filename&gt; :将url中cookie存放在指定文件中 -x/--proxy&lt;proxyhost[:port]&gt;：指定代理服务器地址 -X/--request &lt;command&gt;：向服务器发送指定请求方法 -U/--proxy-user &lt;user:password&gt;：代理服务器用户和密码 -T：将指定本地文件上传到FTP服务器上 --date/-d:指定使用POST方式传递数据 elinks命令格式：elinks [option] [url]… -dump:非交互式模式，将URL的内容输出至标准输出 -source：打印源码]]></content>
      <categories>
        <category>命令</category>
        <category>网页工具</category>
      </categories>
      <tags>
        <tag>命令使用，curl，elinks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP安装及配置文件介绍]]></title>
    <url>%2F2017%2F11%2F28%2FHTTP%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Http安装及文件介绍1、文件类型 主配置文件 /etc/httpd/conf/httpd.conf /etc/httpd/conf.d/*.conf 服务脚本文件 /etc/rc.d/init.d/httpd /etc/sysconfig/httpd #脚本配置文件 站点网页文档默认目录 /var/www/html 模块文件路径 /etc/httpd/modules /usr/lib64/httpd/modules 主程序文件 /usr/sbin/httpd /usr/sbin/httpd.worker /usr/sbin/httpd.event 主进程文件 /etc/httpd/run /httpd.pid #如果这个文件之前存在，系统重启之后会覆盖此配置文件。如果没有会自动创建之。 日志文件目录 /var/log/httpd/access_log /var/log/httpd/err_log 帮助文档包 httpd-manual #如果需要使用可以安装，访问示例http:192.168.4.135/manual 2、/etc/httpd/conf/httpd.conf文件选项介绍 httpd.conf文件的主要分类 [root@localhost ~]# grep &#39;###&#39; /etc/httpd/conf/httpd.conf ### Section 1: Global Environment #全局配置 ### Section 2: &apos;Main&apos; server configuration #主机配置 ### Section 3: Virtual Hosts #虚拟主机配置 选项介绍 （1）ServerTokens 显示服务器版本信息 syntax：ServerTokens Major|Minor|Min[imal]|Prod[uctOnly]|OS|Full ServerTokens Prod[uctOnly] #仅显示类型 Server sends (e.g.): Server: Apache ServerTokens Major #显示版本及主版本号 Server sends (e.g.): Server: Apache/2 ServerTokens Minor #显示类型主板本号及此版本号 Server sends (e.g.): Server: Apache/2.0 ServerTokens Min[imal] Server sends (e.g.): Server: Apache/2.0.41 ServerTokens OS #显示类型版本号及系统类型 Server sends (e.g.): Server: Apache/2.0.41 (Unix) ServerTokens Full (or not specified) #全部显示 #系统默认# Server sends (e.g.): Server: Apache/2.0.41 (Unix) PHP/4.2.2 MyMod/1.2 建议使用ServerTokens prod，防止此版本有漏洞被入侵。建议一般不要显示版本号。 （2）Listen 修改监听的IP和Port Syntax: Listen [IP-address:]portnumber [protocol] 省略IP 表示为0.0.0.0 Listen指令至少一个，可重复出现多次 修改监听socket，重启或重新加载服务进程方可生效 示例： Listen 80 Listen 8080 Listen 192.168.4.150:80 （3）持久连接建立连接，每个资源获取完成后不断开连接，而好似继续等待其他的请求完成，默认关闭 KeepAlive Syntax: KeepAlive On|Off #默认为关闭 MaxKeepAliveRequests Synatax:MaxKeepAliveRequests number #默认最大连接请求100 KeepAliveTimeout Syntax：KeepAliveTimeout seconds #默认持久连接超时时间为5秒 缺点：对并发量较大的服务器，持久连接功能会使其它有些请求得不到回应。 解决方法：使用较短的持久时间设置。 （4）MPM（Multi-Processing Module） 多进程处理模块 MPM的类型在前面已经详细的介绍，这里来说说在配置文件中怎么配置 prefork配置 &lt;IfModule prefork.c&gt; StartServer number #初始化开启几个进程 MinSpareServers number #最小空闲进程 MaxSpareServers number #最大空闲进程 ServerLimit number #最大开启的进程数 ，最大为20000个 MaxClients number #最大并发量 MaxRequestsPerChild number #最多处理的请求数量 默认为10000。在子进程请求之后，子进程会被父进程终止，子进程占用的内容就会释放（为0是永远释放）。 &lt;/IfModule&gt; worker配置 &lt;IfModule worker.c&gt; StartServers number #初始化开启几个进程 MaxClients number #最大并发量 MinSpareThreads number #最小空闲线程 MaxSpareThreads number #最大空闲进程 ThreadsPerChild number #一个子进程最多开启几个线程 MaxRequestsPerChild number #一个子进程最多有多个访问请求 默认10000 &lt;/IfModule&gt; 配置文件默认内容 &lt;IfModule worker.c&gt; StartServers 4 MaxClients 300 MinSpareThreads 25 MaxSpareThreads 75 ThreadsPerChild25 MaxRequestsPerChild 0 &lt;/IfModule&gt; 这里需要注意: StartServers*ThreadsPerChild&gt;MaxSpareThreads 所以系统初始时会少开一个进程。 如何更改工作模式呢？ [root@localhost ~]# vim /etc/sysconfig/httpd 如何计算PV的值呢？ 假设每秒中开启256进程，持久连接，每个进程能处理5个资源；每个网页有100个资源，如何计算PV？ pv：256586400/100=1105920 带宽10245256/1024/1024*8=8M 网络中计算是以位为单位 （5）DSO：Dynamic Shared Object 动态加载模块 httpd -M #查看动态加载模块 httpd -l #查看静态加载模块 格式： LoadModule &lt;mod_name&gt; &lt;mod_path&gt; mod_path写路径时要写相对路径：相对于ServerRoot （6）DocumentRoot 定义Main server 中文档页面路径 Syntax: DocumentRoot directory-path 文档路径映射：DocumentRoot指向的路径为URL路径的起始位置。 示例： # http://HOST:PORT/test/index.html \|/ /app/data/test/index.html （7）DirectoryIndex 定义站点页面 Syntax: DirectoryIndex local-url [local-url] … /etc/httpd/conf.d/welcome.conf如果主站点出错可以跳转至此页面 （8）站点访问控制常见机制 可基于两种机制指明对哪些资源进行何种访问控制 文件系统路径： &lt;directory &quot;/PATH&quot;&gt; ... &lt;/directory&gt; &lt;File &quot;/PATH/FILE&quot;&gt; ... &lt;/File&gt; &lt;FileMatch&gt; ... &lt;/FileMatch&gt; URL路径： &lt;Location URL-path|URL&gt; ... &lt;/Location&gt; &lt;LocationMatch regex&gt; ... &lt;/LocationMatch&gt; 其上的路径都可以使用正则表达式和通配符 通配符： 通配符 说明 * 匹配任意长度字符 ? 匹配任意单个字符 [] 匹配中括号内的任意单个字符 [^] 除中括号里的都匹配 正则表达式： 符号 说明 . 匹配任意单个字符 * 匹配前一个字符任意长度，0次或多次 ？ 匹配前一个字符一次或0次 + 匹配前一个字符一次或多次 [] 匹配括号里的任意单个字符 … 示例： &lt;FilesMatch &quot;\.(gif|jpe?g|png)$&quot;&gt; &lt;Files “?at.*”&gt; &lt;Location /status&gt; &lt;LocationMatch &quot;/(extra|special)/data&quot;&gt; 注意：使用正则表达式比较耗费资源，会遍历整个路径去寻找，建议不要使用。 （9）中“基于源地址”实现访问控制 Options Syntax: Options [+|-]option [[+|-]option] … 常见选项： 选项 说明 Indexes 指明的URL路径下不存在于定义的主页面资源相符的资源文件时，返回索引列表给用户 FollowSymlinks 允许访问符号链接文件所指向的源文件，默认支持软连接。 None 全部禁用 All 全部允许，系统默认选项 MultiViews 允许使用多视图 注意：Options只对有效。 示例： （1）在/etc/httpd/conf.d/目录下创建custom.conf文件 [root@localhost conf.d]# vim custom.conf &lt;Directory &quot;/app/testweb&quot;&gt; Options None #全部禁用 &lt;/Directory&gt; （2）把welcome.conf文件删除或修改名字 [root@localhost conf.d]# mv welcome.conf welcome.conf.bak （3）重启服务测试 现在我们再修改配置文件修改为Options Indexes &lt;Directory &quot;/app/testweb&quot;&gt; Options Indexes &lt;/Directory&gt; 重启服务测试 AllowOverride 与访问控制相关的的指令可以放在指定目录下.htaccess文件中，覆盖之前配置指令。 常见选项： 选项 说明 AuthConfig 允许使用与认证授权相关的指令 FileInfo 允许使用控制文档类型的指令 Indexes 允许使用控制目录索引的指令 Limit 允许使用控制主机访问的指令 Options[=Option,…] 允许使用控制指定目录功能的指令 None .htaccess文件失效 示例 在上面的基础上我们再/app/testweb.htaccess此文件 [root@localhost testweb]# vim .htaccess Options Indexes 在custom.conf编辑 [root@localhost conf.d]# vim custom.conf &lt;Directory &quot;/app/testweb&quot;&gt; Options None AllowOverride All &lt;/Directory&gt; 由于我们在上面测试的时候如果Options为None时候网页出现如下情况 先我们再测试 这时你会不会想到放到站点目录下会不会被访问到呢？这样显然就不安全了，开发人员已经想到了这点如下： &lt;Files ~ &quot;^\.ht&quot;&gt; Order allow,deny Deny from all Satisfy All &lt;/Files&gt; 现在我们真正了解了AllowOverride选项作用了。使用这种方法我们控制一些内容。 Order 和allow 、deny 定义生效次序；写在后面的表示默认规则，优先级高。 匹配次序 条件 结果 Match Allow,Deny result Deny,Allow result Match Allow only Request allowed Request allowed Match Deny only Request denied Request denied No match Default to second directive: Denied Default to second directive: Allowed Match both Allow &amp; Deny Final match controls: Denied Final match controls: Allowed 格式： A (partial) domain-name Example: Allow from apache.org deny from .net example.edu A full IP address Example: Allow from 10.1.2.3 deny from 192.168.1.104 192.168.1.205 A partial IP address Example: Allow from 10.1 deny from 10 172.20 192.168.2 A network/netmask pair Example: Allow from 10.1.0.0/255.255.0.0 deny from 20.1.0.0/255.255.0.0 A network/nnn CIDR specification Example: Allow from 10.1.0.0/16 deny from 20.1.0.0/16 示例 编辑custom.conf文件 &lt;Directory &quot;/app/testweb&quot;&gt; Options Indexes Order allow,deny Deny from 192.168 &lt;/Directory&gt; 重启服务测试 如果修改为Allow &lt;Directory &quot;/app/testweb&quot;&gt; Options Indexes Order allow,deny Allow from 192.168 &lt;/Directory&gt; （10）日志设定 LogLevel 设定日志级别 LogFormat 定义日志格式 示例 LogFormat “%h %l %u %t \”%r\” %&gt;s %b \”%{Referer}i\” \”%{User-Agent}i\”” combined Syntax: CustomLog file|pipe format|nickname [env=[!]environment-variable 示例 CustomLog logs/access_log combined /var/log/error_log 错误日志存放位置 /var/log/access_log 访问成功日志存放位置 选项 说明 %h 客户端IP地址 %L 远程用户，启动mod_ident才有效，通常为“-” %u 验证远程用户，非登录访问时，为一个“-” %t 服务器收到请求时的时间 %r 表示请求报文的首行，记录了此次请求的方法、URL以及协议版本 %&gt;s 响应状态码 %b 响应报文的大小，单位为字节；不包括响应报文http首部 %{Referer}i 请求报文中首部“referer”的值，即从哪个页面中的超链接跳转至当前页面 %{User-Agent}i 请求报文中首部“User-Agent”的值，即发出请求的应用程序 示例： 192.168.4.1 - - [18/Sep/2017:17:14:09 +0800] “GET / HTTP/1.1” 403 281 “-“ “Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:56.0) Gecko/20100101 Firefox/56.0” （11）AddDefaultCharset 设定默认字符集 Syntax: AddCharset charset extension [extension] … 常用类型：UTF-8 GBK GB2312 GB18030 （12）定义路径别名 Syntax: Alias URL-path file-path|directory-path Syntax: AliasMatch regex file-path|directory-path #可以使用通配符和正则表达式 示例 修改custom.conf文件 Alias /test /app/testweb &lt;Directory &quot;/app/testweb&quot;&gt; Options Indexes &lt;/Directory&gt; 重启服务测试 [root@localhost testweb]# curl -I 192.168.4.132/test HTTP/1.1 301 Moved Permanently Date: Mon, 18 Sep 2017 09:38:50 GMT Server: Apache/2.2.15 (CentOS) Location: http://192.168.4.132/test/ Connection: close Content-Type: text/html; charset=iso-8859-1 （13）基于用户的访问控制 认证质询：WWW-Authenticate Authorization：客户端用户填入账号和密码后再次发送请求报文；认证通过时，服务器发送响应的资源。 认证方式类型： basic：明文 digest：消息摘要认证，兼容性查 安全域：需要用户认证后才能访问的路径；通过名称对齐进行标识，以便于告知用户认证原因。 虚拟账户：仅用于访问某服务时用到的认证标识。创建文件的位置在/etc/httpd/conf.d/目录下。 basic认证示例（1）定义安全域 &lt;Directory “/PATH”&gt; AuthType #认证类型 AuthName #提示信息 AuthUserFile #认证文件位置 Require user UserName1 UserName2 .. #从认证文件中挑选出的用户可以访问 Requie vaild-user #允许账户文件中的所有用户登录访问 AuthGroupFile 组文件存放的位置 Require group GrpName1 GrpName1.. #允许指定组用户登录访问 &lt;/Directory&gt; （2）提供账号和密码存储的位置，一般为隐藏文件 #####htpasswd命令 htpasswd ：Manage user files for basic authentication 选项： -c：自动创建文件，仅在文件不存在创建时使用 -m：使用md5加密 -s：使用sha格式加密 -D：删除指定用户 （3）创建组账号文件 组名称：user1 user2 ... 远程客户端和用户验证的控制Satisfy： Interaction between host-level access control and user authentication 主机访问控制和用户认证之间的交互 ||All|客户机IP和用户验证都需要通过才能访问|Any|客户机IP和用户验证有一个满足就可以访问 示例一 基于用户认证控制 （1）创建存放密码的配置文件 [root@localhost conf.d]# htpasswd -c .htusers wang[root@localhost conf.d]# htpasswd -s .htusers li[root@localhost conf.d]# htpasswd -s .htusers joah （2）修改custom.conf配置文件 Alias /test /app/testweb &lt;Directory &quot;/app/testweb&quot;&gt; Options Indexes AuthType basic AuthName &quot;welcom visit...&quot; AuthUserFile &quot;/etc/httpd/conf.d/.htusers&quot; Require user wang &lt;/Directory&gt; （3）重启服务测试 输入wang账户后 示例二 基于组账户认证 在上述基础之上进行如下操作 （1）将上述用户加入组中[root@localhost conf.d]# groupmems -a wang -g webtest [root@localhost conf.d]# groupmems -a li -g webtest [root@localhost conf.d]# groupmems -a joah -g webtest （2）创建组用户文件 [root@localhost conf.d]# vim .htgrps webtest:wang li （3）修改custom.conf文件Alias /test /app/testweb &lt;Directory &quot;/app/testweb&quot;&gt; Options Indexes AuthType basic AuthName &quot;welcom visit...&quot; AuthUserFile &quot;/etc/httpd/conf.d/.htusers&quot; AuthGroupFile &quot;/etc/httpd/conf.d/.htgrps&quot; Require group webtest &lt;/Directory&gt; （4）重启服务测试 输入li账户后 （14）虚拟主机 虚拟主机有三种实现方式： 基于IP，为每个虚拟主机准备至少一个IP地址 基于Port，为每个虚拟主机使用至少一个独立的Port 基于FQDN，为每个虚拟主机使用至少一个FQDN 注意：一般虚拟主机不要与Main主机混用；如果要使用虚拟主机，一般先禁用Main主机。如果要禁用Main主机，直接禁用DocumentRoot即可。 示例一：基于IP的虚拟主机 （1）编辑配置文件custom.conf &lt;VirtualHost 192.168.4.132:80&gt; DocumentRoot &quot;/app/a.com/htdocs&quot; &lt;/VirtualHost&gt; &lt;VirtualHost 192.168.4.133:80&gt; DocumentRoot &quot;/app/b.net/htdocs&quot; &lt;/VirtualHost&gt; &lt;VirtualHost 192.168.4.134:80&gt; DocumentRoot &quot;/app/c.org/htdocs&quot; &lt;/VirtualHost&gt; （2）创建所需文件 [root@localhost conf.d]# mkdir /app/a.com/htdocs -pv [root@localhost conf.d]# mkdir /app/b.net/htdocs -pv [root@localhost conf.d]# mkdir /app/c.org/htdocs -pv [root@localhost conf.d]# echo www.a.com &gt; /app/a.com/htdocs/index.html [root@localhost conf.d]# echo www.b.net&gt; /app/b.net/htdocs/index.html [root@localhost conf.d]# echo www.c.org&gt; /app/c.org/htdocs/index.html （3）添加IP地址 [root@localhost conf.d]# ip addr add 192.168.4.133/24 dev eth0 [root@localhost conf.d]# ip addr add 192.168.4.134/24 dev eth0 （4）重启服务测试 示例二：基于Port的虚拟主机 （1）编辑custom.com文件 Listen 192.168.4.132:81 Listen 192.168.4.132:82 Listen 192.168.4.132:83 &lt;VirtualHost 192.168.4.132:80&gt; DocumentRoot &quot;/app/a.com/htdocs&quot; &lt;/VirtualHost&gt; &lt;VirtualHost 192.168.4.132:81&gt; DocumentRoot &quot;/app/b.net/htdocs&quot; &lt;/VirtualHost&gt; &lt;VirtualHost 192.168.4.132:82&gt; DocumentRoot &quot;/app/c.org/htdocs&quot; &lt;/VirtualHost&gt; （2）重启服务器测试 示例三：基于FQDN的虚拟主机 我们准备三台虚拟主机，一台CentOS 6 配置3个FQDN，一台CentOS 7配置DNS，一台CentOS 7测试 第一步：在CentOS 6 上配置3个FQDN NameVirtualHost *:80 #注意这项配置在CentOS 6 中必须开启，切记！！！ NameVirtualHost *:80 &lt;VirtualHost *:80&gt; ServerName &quot;www.a.com&quot; DocumentRoot &quot;/app/a.com&quot; &lt;/VirtualHost&gt; &lt;VirtualHost *:80&gt; ServerName &quot;www.b.com&quot; DocumentRoot &quot;/app/b.com&quot; &lt;/VirtualHost&gt; &lt;VirtualHost *:80&gt; ServerName &quot;www.c.com&quot; DocumentRoot &quot;/app/c.com&quot; &lt;/VirtualHost&gt; 第二步：在CentOS 7上配置DNS服务器 [root@localhost~]#yum install -y bind [root@localhost/etc/named]#vim /etc/named.conf #修改图中方框内容 [root@localhost/etc/named]#vim /etc/named.rfc1912.zones [root@localhost/var/named]#vim a.com.zone #b.com.zone 和c.com.zone类似这里就不累述。 1 $TTL 1D 2 @ IN SOA dns1 mail.a.com. ( 3 0 ; serial 4 1D ; refresh 5 1H ; retry 6 1W ; expire 7 3H ) ; minimum 8 NS dns1 9 dns1 A 192.168.4.164 10 www A 192.168.4.132 重启服务 第三步：在另一台CentOS 7 主机上测试 [root@localhost~]#vim /etc/resolv.conf #修改DNS 1 # Generated by NetworkManager 2 search localdomain 3 nameserver 192.168.4.164 （15）status页面 要实现这个功能需要加载模块mod_status.so 格式： LoadModule status_module modules/mod_status.so &lt;Location /server-status&gt; SetHandler server-status Order allow,deny Allow 192.168.4 &lt;/Location&gt; ExtendedStatus On #开启此选项显示更多内容 建议：不要开启此选项，如果处于测试状态可以开启拍错。 （16）mod_deflate模块 压缩页面优化传输速度 适用场景： 节约带宽，额外消耗CPU； 压缩适于压缩的资源，如文本文件 如何启用压缩功能？ SetOutputFilter DEFLATE AddOutputFilterByType DEFLATE text/plain AddOutputFilterByType DEFLATE text/html AddOutputFilterByType DEFLATE application/xhtml+xml AddOutputFilterByType DEFLATE text/xml AddOutputFilterByType DEFLATE application/xml AddOutputFilterByTypeDEFLATE application/x-javascript AddOutputFilterByType DEFLATE text/javascript AddOutputFilterByType DEFLATE text/css Level of compression 指定压缩比 （1-9），默认为9 （17）mod_ssl模块 认证模块 http基于ssl认证过程： （1）客户端发送可供选择的加密方式，并向服务器请求证书 （2）服务器端发送证书以及选定的加密方式给客户端 （3）客户端取得证书并进行证书验证如果信任给其发证书的CA 验证证书的来源的合法性：用CA的公钥解密证书上数字签名 验证证书内容的合法性：完整性验证 验证证书有效期限 检查证书是否被吊销 （4）客户端生成临时会话密钥，并使用服务器端的公钥加密此数据发送给服务器，完成密钥交换 （5）服务用此密钥加密用户请求的资源，响应客户端。 注意：SSL是基于IP地址实现，单IP的主机仅可以使用一个HTTPS虚拟主机。 实现https的过程： （1）先建立私有CA；在CentOS 7上 [root@localhost~]#cd /etc/pki/CA/ [root@localhost/etc/pki/CA]#(umask 066；openssl genrsa -out private/cakey.pem 2048） [root@localhost/etc/pki/CA]#openssl req -new -x509 -key private/cakey.pem -out casert.pem -days 4650 [root@localhost/etc/pki/CA]#echo 01 &gt; serial [root@localhost/etc/pki/CA]#touch index.txt （2）在CentOS 6上创建请求认证证书 [root@localhost ssl]# (umask 066；openssl genrsa -out httpd.key 2048） [root@localhost ssl]# openssl req -new -key httpd.key -out httpd.csr [root@localhost ssl]# scp httpd.csr 192.168.4.163:/etc/pki/CA/certs/ （3）CentOS 7对收到的证书签证并返回 [root@localhost/etc/pki/CA/certs]#openssl ca -in httpd.csr -out httpd.crt -days 300 [root@localhost/etc/pki/CA/certs]#scp httpd.crt 192.168.4.132:/etc/httpd/conf/ssl （4）在CentOS 6上安装此 模块并修改配置文件 [root@localhost conf.d]# yum install -y mod_ssl [root@localhost conf.d]# vim ssl.conf （5）将证书拷贝到本地添加至浏览器中 当我们每次输入http://192.168.4.132时想要直接https://192.168.4.132访问网页怎么做呢？ 将http请求转发至https的URL，可以使用重定向 Redirect [status] URL-path URL status分类： Permanent:Returns a permanent redirect status(301) indicating that the resource has moved permanently Temp:Returns a temporary redirect status (302). This is the default 示例： Redirect temp / https://www.a.com/ Redirect permanent / https://www.a.com/ 注意：设置跳转时，根下的目录也会自动跳转。 [root@localhost conf.d]# vim custom.conf Redirect temp / https://192.168.4.132/ 测试 [root@localhost conf.d]# curl --cacert -L 192.168.4.132/ &lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt; &lt;html&gt;&lt;head&gt; &lt;title&gt;302 Found&lt;/title&gt; #由于之前我们已经介绍了状态码，所以看到302代表临时跳转。 &lt;/head&gt;&lt;body&gt; &lt;h1&gt;Found&lt;/h1&gt; &lt;p&gt;The document has moved &lt;a href=&quot;https://192.168.4.132/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;hr&gt; &lt;address&gt;Apache/2.2.15 (CentOS) Server at 192.168.4.132 Port 80&lt;/address&gt; &lt;/body&gt;&lt;/html&gt; （18）HSTS:HTTP Strict Transport Security 如果我们使用HTTPS 访问一个网站，我们大多数情况习惯按http://这样的方式去访问，在配置文件中添加Redirect temp / https:// 或Redirect permanent / https://这种方式解决；其工作方式如下 当浏览器第一次发出HTTP请求时是明文发送的，这种容易被攻击者拦截下来，攻击者作为代理，把当前请求转发至钓鱼网站，钓鱼网站返回假冒的网页内容，攻击者把假冒的网页返回给浏览器；如下图 为了解决这个文件就有人提出了HSTS方案：服务器端配置支持HSTS后，会在给浏览器返回的HTTP首部中携带HSTS字段。浏览器获取到该信息后，会将所有HTTP访问请求在内部做307跳转到HTTPS，而无需任何网络过程；从而使得中间人攻击失效。 如何设置HSTS呢？ Strict-Transport-Security: [; includeSubDomains][; preload] max-age：过期时间，默认单位为秒，你每次访问它都会在访问时间之后的值时间。 includeSubDomains：是可选参数，如果包含它意味着当前域名或子域均开启HSTS保护 preload：是可选参数，只有当你申请将自己的加入到浏览器内置列表的时候才需要使用到它。 重定向的另外一种方式：使用模块mod_rewrite 在使用这种方式之前我们先确认mod_rewrite是否被加载 格式： 示例 Header always set Strict-Transport-Security &quot;max-age=15768000&quot; RewriteEngine on #是否开启重启引擎 RewriteRule ^(/.*)$ https://%{HTTP_HOST}$1 [redirect=301] （19）httpd自带的工具程序 ab命令：压力测试工具 usage：ab [OPTIONS] URL -n：总请求数 -c：模拟的并行数 -k：以持久连接模式测试 htpasswd：基于认证basci时，用到的账户密码文件生成工具 usage： htpasswd [ -c ] [ -m ] [ -D ] passwdfile username -c：如果passwdfile文件不存在使用 -D：删除用户 -m：使用md5加密，默认 -s：使用SHA格式加密]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>HTTP安装及配置文件介绍</category>
      </categories>
      <tags>
        <tag>httpd，配置文件，认证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP的工作机制]]></title>
    <url>%2F2017%2F11%2F28%2FHTTP%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[HTTP的工作机制当我们去访问一个网站是一个网页并不是单单的一个资源，是由多个资源展示出来；每个资源都要单独的请求。 现在我们需要区分两个概念静态文件和动态文件 静态文件：无需服务端做出额外处理，说白了就是写死的，任何人访问此资源时，都显示同一个页面内容。文件后缀：.jpg .html .txt .js .css .mp3 .avi 动态文件：服务端执行程序之后，返回执行结果。说白了就是不同的人、不同时候访问此页面，显示的内容可能不同。文件后缀：.asp .php .jsp 非持久连接和持久连接 非持久连接：一个请求与服务器连接传输完成之后，端口。如果下一个请求过来，再建立连接。 缺点 (1)客户为每个待请求的对象建立并维护一个新得连接。对于每个这个的连接，TCP必须同时在客户端和服务器端分配TCP缓冲区，并维护TCP变量。对于有可能同时为来自数百个不同客户的请求提供服务的Web服务器来说，这会严重增加服务器的负担； (2)对每个对象请求都有2个RTT(Round-Trip Time 往返时延)的响应延迟：一个RTT用于建立TCP连接，另一个RTT用于请求和接收对象；http://blog.csdn.net/jackywangjia/article/details/27643379 (3)每个对象都要经历 TCP 缓启动，因为每个TCP连接都要起始于slow start 阶段。并行TCP连接的使用能够部分减轻RTT延迟和缓启动的影响。 持久连接：当完成一次请求之后，服务器在发出响应后让TCP连接继续打开着。同一对客户/服务器之间的后续请求和响应可以通过这个连接发送。 缺点：服务器送出一个对象后开始等待下一个请求，而这个新请求却不能马上到达。这段时间服务器资源便闲置了。 如何提高HTTP连接性能呢？ 并行连接：通过多条TCP连接发起并发的HTTP请求 持久连接：keep-alive,长连接，重用TCP连接，以消除连接和关闭的时延,以事务个数和时间来决定是否关闭连接 管道化连接：通过共享TCP连接发起并发的HTTP请求 复用的连接：交替传送请求和响应报文（实验阶段） Web响应模型介绍 单进程I/O模型：启动一个进程处理用户请求，而且一次只处理一个，当发出多个请求时，被串联响应。 多进程I/O模型：并行启动多个进程，每个进程响应一个连接请求。 复用I/O请求：启动一个进程，同时响应N个连接请求。 复用多进程I/O模型：启动M个进程，每个进程响应N个请求，同时接受M*N个请求。]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>HTTP的工作机制</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Httpd-2.4特性]]></title>
    <url>%2F2017%2F11%2F28%2FHttpd-2.4%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[新特性 MPM支持运行为DSO机制，以模块形式按需加载 event MPM生产环境可用 异步读写机制 支持每模块及每目录的单独自制级别定义 每请求相关的专用配置 增强版的表达式分析式 毫秒级持久连接时长定义 基于FQDN的虚拟主机不需要NameVirtualHost指令 新指令，AllowOverList 支持用户自定义变量 更低的内存消耗 不再支持使用Order，Deny,Allow来做基于IP的访问控制新模块 httpd-2.4文件介绍-配置文件 /etc/httpd/conf/httpd/conf /etc/httpd/conf.d/*.conf 模块相关的配置文件 /etc/httpd/conf.modules.d/*.conf 系统启动文件 /usr/lib/systemd/system/httpd/service 主程序文件 /usr/sbin/httpdd 日志文件 /var/log/httpd/access_log /var/log/httpd/error_log 站点文档 /var/www/html 模块文件路径 /usr/lib64/httpd/moudles /etc/httpd/modules 相关设置介绍（1）切换使用MPM [root@localhost/etc/httpd/conf.modules.d]#vim 00-mpm.conf 如上图所示，如果要使用其他MPM将注释取消重启即可。 （2）认证方式 无明确授权的记录，默认拒绝 允许所有主机访问：Require all granted 拒绝所有主机访问：Require all denied 控制特定的IP访问 Require ip IPADDR :授权指定来源的IP访问 Require not ip IPADDR：拒绝特定的IP访问 控制特定的主机访问 Require host HOSTNAME :授权特定主机访问 Require not host HOSTNAME：拒绝特定主机访问 HOSTNAME: FQDN:特定主机 domain.tld：指定域名下的所有主机 使用示例 &lt;RequireAll&gt; Require all granted Require not ip 192.168.4.150 &lt;/RequireAll&gt; 不能又失败，至少有一个成功匹配。 &lt;RequireAny&gt; Require all deny Require not ip 192.168.4.150 &lt;/RequireAny&gt; 多个语句有一个成功，即成功优先。 （3）虚拟主机 注意：基于FQDN的虚拟主机也不需要NameVirtualHost指令 示例 &lt;VirtualHost *:80&gt; ServerName www.x.com DocumentRoot &quot;/app/www/x.com&quot; &lt;Document &quot;/app/www/x.com&quot;&gt; Option None AllowOverride None Require all granted &lt;/Document&gt; &lt;/VirtualHost&gt; 注意：任意目录下的页面只有显示授权才能被访问。 （4）Sendfile机制 不使用Sendfile的过程 1、系统调用read()产生一个上下文切换：从user mode 切换到Kernel mode，然后DMA(Direct Memory Access，直接内存存取)执行拷贝，把文件数据从硬盘读到一个Kernel buffer里。 2、数据从Kernel buffer拷贝到user buffer，然后系统调用read()返回，这时又产生一个上下文切换：从kernel mode 切换到user mode 3、系统调用write()产生一个上下文切换：从user mode 切换到kernel mode，然后把步骤2读到user buffer的数据拷贝到kernel buffer，不过关这次是相关联的。 4、系统调用write()返回，产生一个上下文切换：从Kernel mode 切换到User mode，然后DMA从kernel buffer拷贝数据到协议栈。 使用Sendfile机制过程 1、系统调用sendfile()通过DMA把硬盘数据拷贝到Kernel buffer，然后数据被kernel直接拷贝到另一个与socket相关的kernel buffer。这里没有user mode和kernel mode 之间的切换。在kernel中直接完成了从一个buffer到另一个buffer的拷贝。 2、DMA把数据从kernel buffer直接拷贝给协议栈，没有切换也不需要把数据从user mode拷贝到kernel mode，以为数据就在Kernel 里。 （5）方向代理功能 ProxyPass “/” &quot;http://www.example.com/&quot; ProxyPassReverse &quot;/&quot; &quot;http://www.example.com/&quot; 特定URL反向代理 ProxyPass “/image” &quot;http://www.example.com/&quot; ProxyPassReverse &quot;/image&quot; &quot;http://www.example.com&quot; 示例 &lt;VirtualHost *:80&gt; ServerName www.x.com ProxyPass / http://localhost:8080 ProxyPassReserver / http://localhost:8080 &lt;/VirtualHost&gt; 准备三台虚拟注意，CentOS 7 做web服务器，CentOS 7做代理服务器，另一台CentOS 6 做客户端 （5）APR（Apache Portalbe Run-time Libararies，Apache 可移植运行库） 主要为上层的应用程序提供一个可以跨越多操作系统平台使用的底层支持接口库。在早起的Apache版本中，应用程序本身必须能够处理各种具体操作系统平台的细节，并针对不同的平台调用不同的处理函数。]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>Httpd-2.4特性</category>
      </categories>
      <tags>
        <tag>httpd，2.4版本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP介绍]]></title>
    <url>%2F2017%2F11%2F28%2FHttpd%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[HTTP概念及相关术语1、概念HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 2、HTTP协议介绍 http/0.9 1991，原型版本，功能简陋，只有一个命令GET。GET /index.html ,服务器只能回应HTML格式字符串，不能回应别的格式 http/1.0 1996年5月,支持cache, MIME, method每个TCP连接只能发送一个请求，发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。（1）引入了POST命令和HEAD命令头信息是 ASCII 码，后面数据可为任何格式。服务器回应时会告诉客户端，数据是什么格式，即Content-Type字段的作用。这些数据类型总称为MIME 多用途互联网邮件扩展，每个值包括一级类型和二级类型，预定义的类型，也可自定义类型。 http/1.1 1997年1月（1）引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。对于同一个域名，大多数浏览器允许同时建立6个持久连接。（2）引入了管道机制（pipelining），即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率。新增方法：PUT、PATCH、OPTIONS、DELETE。 同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只能顺序处理回应，前面的回应慢，会有许多请求排队，造成”队头堵塞”（Head-of-line blocking）。为避免这种问题出现：一是减少请求数，二是同时多开持久连接。 网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等。 HTTP 协议不带有状态，每次请求都必须附上所有信息。请求的很多字段都是重复的，浪费带宽，影响速度Spdy：2009年,谷歌研发,解决 HTTP/1.1 效率不高问题。 http/2.0 2015年头信息和数据体都是二进制，称为头信息帧和数据帧。（1）复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免了“队头堵塞“,此双向的实时通信称为多工（Multiplexing）。（2）引入头信息压缩机制（header compression）,头信息使用gzip或compress压缩后再发送；客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，不发送同样字段，只发送索引号，提高速度。（3）HTTP/2 允许服务器未经请求，主动向客户端发送资源，即服务器推送（server push）。 3、MIME（Multiprocess Internet Mail Extensions）1、概念多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。 2、MIME类型 魔法分类：Apache web服务器可以扫描每个资源的内容，并将其与一个已知模式表(被称为魔法文件)进行匹配，以决定每个文件的MIME类型。这样做可能比较慢，但很方便，尤其是文件没有标准扩展名的时候 显式分类：可以对Web服务器进行配置，使其不考虑文件的扩展名或内容，强制特定文件或目录内容拥有某个MIME类型 类型协商： 有些Web服务器经过配置，可以以多种文档格式来存储资源。在这种情况下，可以配置Web服务器，使其可以通过与用户的协商来决定使用哪种格式(及相关的MIME类型)”最好” 3、MIME格式Content-Type: [type]/[subtype]; parameter type类型 类型 说明 Text 用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的； Multipart 用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据； Application 用于传输应用程序数据或者二进制数据； Message 用于包装一个E-mail消息； Image 用于传输静态图片数据； Audio 用于传输音频或者音声数据； Video 用于传输动态影像数据，可以是与音频编辑在一起的视频数据格式 subtype类型 subtype是用于指定type详细形式。 子类型 说明 text/plain 纯文本，文件扩展名.txt text/html HTML文，文件扩展名.html 或.htm application/xhtml+xml XHTML文 image/gif GIF图像 image/jpeg JPEG图像 image/png PNG图像 video/mpeg MPEG动画 application/octet-stream 任意的二进制数据 application/pdf PDF文档 application/msword Microsoft Word文件 application/vnd.wap.xhtml+xml wap1.0+ application/xhtml+xml wap2.0+ message/rfc822 RFC 822形式 multipart/alternative HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示 application/x-www-form-urlencoded 使用HTTP的POST方法提交的表单 multipart/form-data 同上，但主要用于表单提交时伴随文件上传的场合 parameter 可用来指定附加的信息，更多情况下是用于指定text/plain和text/html等的文字编码方式的charset参数。 Content-Transfer-Encoding: [mechanism] 内容传输编码，指定ASCII意外的字符编码方式，用来对附件进行解码。 编码格式 说明 7bit 用在US ASCII字符集上 8bit和binary 一般不使用 quoted printable 可读的标准文本，如果传输要经过对格式有影响的网关时对其进行保护 base64 通用方法，通常在二进制中，非文本数据 如果想查看MIME的类型可以查看文件/etc/mime.types 4、URI统一资源标识符（Uniform Resource Identifier，或URI）是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对网络中（一般指万维网）的资源通过特定的协议进行交互操作。分为两种URL（Uniform Resource Location）和URN（Uniform Resource Name）。URL用于描述某服务器某特定资源位置。URN其目的是通过提供一种途径，用于在特定的命名空间资源的标识，以补充网址并不指定地址。说白了URL就是一个人的住址，URN是一个人的名字。URN定义某事物的身份，而URL提供查找该事物的方法。 URL组成 hierarchical part ┌───────────────────┴─────────────────────┐ authority path ┌───────────────┴───────────────┐┌───┴────┐ abc://username:password@example.com:123/path/data?key=value&amp;key2=value2#fragid1 └┬┘ └───────┬───────┘ └────┬────┘ └┬┘ └─────────┬─────────┘ └──┬──┘ scheme user information host port query fragment urn:example:mammal:monotreme:echidna └┬┘ └──────────────┬───────────────┘ scheme path 解释 种类 说明 scheme 方案，访问服务器以获取资源时要使用哪种协议 user 用户，某些方案访问资源时需要用户名 password 用户对应的密码；user:password host 资源宿主机主机名或IP地址 part 资源宿主机正在监听的端口号，很多方案都有默认的端口号 path 服务器资源的本地名，有一个/将其与前面的URL组件分割 params 指定输入的参数，参数为名/值对，用“；”分隔 query 查询，传递参数给程序，用”?”分隔，多个查询使用“&amp;”分隔 frag 片段，一小片或一部分资源的名字，此组件在客户端使用，用“#”分隔 示例： http://www.test.com:8080/images/logo.jpg ftp://xiaoming:password@192.168.4.150/pub/linux.ppt rtsp://videoserver/video_demo/Real Time Streaming Protocol http://wwwtest.com/bbs/hello;gender=f/send;type=title https://list.jd.com/list.html?cat=670,671,672&amp;ev=149 _2992&amp;sort=sort_totalsales15_desc&amp;trans=1 http://apache.org/index.html#projects-list]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>Httpd</category>
      </categories>
      <tags>
        <tag>HTTP，https，web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP请求报文]]></title>
    <url>%2F2017%2F11%2F28%2FHTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%2F</url>
    <content type="text"><![CDATA[HTTP请求报文在之前我们介绍了Web请求的过程里面说了当Client向Serve发送建立请求时即发送请求报文。Server处理完成之后向Client发送响应报文，即响应报文。下面我们来具体说说这两个的结构。 请求报文语法格式： &lt;Method&gt;&lt;Request-URL&gt;&lt;VERSION&gt; &lt;Headers&gt; &lt;Entity-body&gt; 响应报文语法格式： &lt;Version&gt;&lt;Status-code&gt;&lt;Reson-phrase&gt; &lt;Headers&gt; &lt;Entity-body&gt; 具体解释说明 method方法类型： method方法类型 说明 GET 从服务器获取一个资源 HEAD 只从服务器获取文档的响应头部 POST 向服务器输入数据，通常会再由网关程序继续处理 PUT 将请求的主体部分存储在服务器上，如上传文件 DELETE 请求删除服务器上指定的文档 TRACE 追踪请求到达服务器中间经过的代理服务器 OPTIONS 请求服务器返回对指定资源支持使用的请求方法 VERSION构成： HTTP/&lt;major&gt;.&lt;minor&gt; Header 每个请求或响应报文可包含任意首部；每个首部都有首部名称，后面跟一个冒号，而后跟一个可选空格，接着一个值。 Entity-body 请求时附加的数据或响应时附加的数据 Reson-phrase 状态码所标记状态简要描述 状态码种类 HTTP状态码分类 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 状态码详解说明 状体码 描述 简要描述 200 成功，请求数据通过响应报文的Eentity-body部分发送 ok 301 请求的URL指向的资源已经删除；但在响应报文中通过首部Location指明了资源现有资源所处的新位置 Moved Permanently 302 响应报文Location指明资源临时位置 Moved Temporarily 304 客户端发出了条件式请求，但服务器上的资源未曾发生改变，则通过此响应状态码通知客户端 Not Modified 401 需要填入账号和密码认证才能访问资源 Unautorized 403 访问被禁止 Forbidden 404 服务器无法找到客户端请求资源 Not Found 500 服务器内部错误 Internal Server Error 502 代理服务器从后端服务器收到了一条伪响应，如无法连接网关 Bad Gateway 503 服务不可用，临时服务器维护或过载，服务器无法处理请求 Service Unavailable 504 网关超时 Gateway Timeout 505 服务器不支持请求的HTTP协议的版本，无法完成处理 HTTP Version Not Support 示例： [root@localhost ~]# curl -i www.360buy.com #响应报文示例 HTTP/1.1 301 Moved Permanently Age: 2822 Content-Type: text/html Date: Thu, 28 Sep 2017 13:23:54 GMT Location: http://www.jd.com/ Server: JDWS Via: BJ-H-NX-112(), http/1.1 LA-1-JCS-40 ( [cRs f ]) Content-Length: 272 &lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt; &lt;body bgcolor=&quot;white&quot;&gt; &lt;h1&gt;301 Moved Permanently&lt;/h1&gt; &lt;p&gt;The requested resource has been assigned a new permanent URI.&lt;/p&gt; &lt;hr/&gt;Server: JDWS&lt;/body&gt; &lt;/html&gt; http协议头部 通用首部 首部信息 说明 Date 报文的创建时间 Connnection 连接状态，如keep-alive，close Via 显示报文经过的中间节点 （代理、网关） Cache-Control 控制缓存，如缓存时长 MIME-Version 发送端使用的MIME版本 请求首部 请求首部信息 说明 Accept 通知服务器自己可接受的媒体类型 Accept-Charset 客户端可接受的字符集 Accept-Encoding 客户端可接受编码格式 Accept-Language 客户端可接受的语言 Client-IP 请求客户端IP Host 请求服务器名称和端口号 Referer 跳转至当前URL的前一个URL User-Agent 客户端代理，浏览器版本 条件式请求首部 条件请求首部信息 说明 Expect 允许客户端列出某请求所要求的服务器行为 If-Modified-Since 自从指定的时间之后，请求的资源是否发生过修改 If-Unmodified-Since 自从指定的时间之后，请求的资源是否没有发生过修改 If-None-Match 本地缓存中存储的文档的ETag标签是否与服务器文档的ETag不匹配 If-Match 本地缓存中的存储文档ETag标签是否与服务器文档的ETag匹配 安全请求首部 安全请求首部 说明 Authorization 向服务器发送认证信息，如账号和密码 Cookie 客户端向服务器发送cookie Cookie2 用于说明请求端支持的cookie版本 代理服务请求首部 Proxy-Authorization 向代理服务器认证 响应首部 响应首部信息 说明 Age 从最初创建开始响应持续时长 Server 服务器程序软件名称和版本 Accept-Ranges 服务器可接受的请求范围类型 Vary 服务器查看的其他首部列表 安全响应首部 安全首部信息 说明 Set-Cookie 向客户端设置cookie Set-Cookie 向客户端发送cookie2版本 WWW-Authenticate 来自服务器对客户端的质询列表 实体首部： 实体首部信息 说明 Allow 列出对此资源实体可使用的请求方法 Location 告诉客户端真正的实体位于何处 Content-Encoding 对主体执行的编码 Content-Language 文本使用的语言 Content-Location 实体真正所处的位置 Content-type 主体的对象类型 ETag 实体的扩展标签 Expires 实体的过期时间 Last-Modified 最后一次修改时间]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>HTTP请求报文</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MPM工作模式]]></title>
    <url>%2F2017%2F11%2F28%2FMPM%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[MPM（MultiProcess Modules ）工作模式 prefork 多进程I/O模型，每个进程响应一个请求，默认模型一个主进程生成N个子进程，创建套接字，每个子进程响应一个请求；而主进程不响应请求，只负责管理接受请求。系统初始化时，预先生成多个空闲进程，等待请求，多大不超过1024个（由pam.limits.so控制，可使用ulimit -n # 设置） worker 复用多进程I/O模型，多进程多线程。一个主进程生成m个子进程，每个子进程负责生产n个线程，每个线程响应一个请求，并发响应请求为m*n。 event 一个主进程生成m个子进程，每个进程直接响应n个请求；并发响应请求为m*n。event中有专门的线程来管理这些Keep-Alive类型的线程，当有真实请求时，将请求传递给服务线程，执行完毕后，又允许释放，增强了高并发场景下的处理请求能力。]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>MPM（MultiProcess Modules ）工作模式</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP三次握手]]></title>
    <url>%2F2017%2F11%2F28%2FTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%2F</url>
    <content type="text"><![CDATA[一、Socket1、概念 socket是“孔”和“插座”之意。在linux中显然是插座的意思，相当于我们家中插头和插座之意，它们连接才能通电。在Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。实现进程间通信，允许位于不同主机（或同一主机）上不同进程之间进行通信和数据交换。Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。 2、Socket的类型（1）Socket DomainAF_INET：Address Family IPv4 AF_INET6：Address Family IPv6 AF_UNIX：同一台主机不同进程之间通信使用。 （2）Socket TypeSOCK_STREAM：流套接字，TCP套接字；可靠传输，面向对象传输。 SOCK_DGRAM：数据报，UDP套接字；不可靠传输，无直接连接。 SOCK_RAW：裸套接字，无须TCP或UDP，应用程序直接通过IP 包通信。 （3）Socket Protocol指定实际使用的传输协议。常见IPPROTO_TCP、IPPROTO_UDP等。 3、Socket函数 socket（） 为通讯创建一个端点，为套接字返回一个文件描述符。 注意：当调用socket（）创建一个socket时，只赋予其所使用的协议，没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind（），否则就当调用connect（）、listen（）时系统会自动随机分配一个端口。 bind() 为一个套接字分配地址。对应的Socket protocol把一个IPv4 或IPv6地址和端口组合赋给socket。 通常服务器在启动时会绑定IP地址和端口，用于提供服务；而客户端就不用指定，系统自动分配一个端口和自身的IP 地址。这就是为什么通常服务器端在listen之前要bind（），而客户端不会调用，而是在connect（）时由系统自动生成一个。 listen（） 当socket和一个地址（IP和端口）绑定之后，listen（）函数就开始监听可能的链接请求。socket（）函数创建的socket默认是一个主动类型，listen函数将socket变为被动类型，等待客户的连接请求。一旦连接被接受，返回0表示成功，-1表示错误。 accept（） 当应用程序监听来自其他主机的面对数据流的连接时，通过时间通知它。必须用accept（）函数初始化连接，TCP服务器监听到这个请求之后，就会调用accept（）函数接受请求。这样就连接就建立好了。之后就可以进行I/O操作了。 accept默认会阻塞进程，直到有一个客户连接建立后返回，返回一个新可用的套接字，这个套接字是连接套接字。 监听套接字：在调用函数listen函数之后，是服务器开始调用socket（）生成的；存在于服务器整个生命周期。 连接套接字：一个套接字会从主动连接变为一个监听套接字；accept函数返回值是已经连接socket描述符，它代表着一个网络已经存在的点点连接；利用I/O可以实现不同进程间的通信。 connect() 系统调用为一个套接字设置连接，参数有文件描述符和主机地址。 某些类型的套接字是无连接的，如DUP协议，连接时默认发送和接受数据的主机由给定的地址确定，可以使用send（）和recv（）。 read()、write() 服务器与客户已经建立连接。就可以使用不同进程之间的通信了。 close（） 在服务器与客户建立连接之后，会进行一些读写操作，完成之后就要关闭响应的socket描述子。 注意：close只是在相应的socket描述字的引用计数-1，只有当计数为0时，才会触发TCP客户端向服务器发送终止请求。 4、Socket工作 二、TCP三次握手和TCP四次挥手我们先来举一个示例想必大家就懂了它的工作流程了。 小明：您好，请问您是小红么？ 小红：是的，您是谁？ 小明：我是小明。 小红：有什么事情呢？ 然后他们就开始友好的聊天了 。这个过程和我们TCP三次握手一样，TCP三次握手也是分为三步，然后建立连接实现通信。 第一步 Client主动向和Server发送请求；发送SYN=1，seq=x(Synchronize Sequence Numbers)，此时Client由状态CLOSED进入SYS_SENT状态。 第二步 Server接受到Client请求时，此时状态由LISTEN进入SYN_RECV状态。并向Client发送自己的SYN=1，ACK=1，seq=y，并确定Client同步序列号seq+1并返回，即ack=x+1。 第三步 Client接受到Server请求时,并向Server发送ACK=1，seq=x+1代表要进行通信的序列号，发送希望Server下次通信的数据包的ack=y+1。这里需要注意只有Server接受到ack=y+1时才代表通讯成功。此时就可以愉快的通信了；此时状态进入ESTABLISHED。 TCP和Socket怎么结合工作呢？如下表。 Server Server服务器端调用socket()，生成socket 调用bind()绑定，为socket分配一个地址（IP和端口） 调用listen()进行监听；默认socket为主动连接状态，变为被动监听状态 调用accept()阻塞，等待客户端连接。 Clinet Client调用socket()生成socket 调用connect()阻塞，等待服务端的回应 接下来就是TCP三次握手的过程： 第一步 Client主动向和Server发送请求；发送SYN=1，seq=x(Synchronize Sequence Numbers)，此时Client由状态CLOSED进入SYS_SENT状态。 第二步 Server接受到Client请求时，此时状态由LISTEN进入SYN_RECV状态。并向Client发送自己的SYN=1，ACK=1，seq=y，并确定Client同步序列号seq+1并返回，即ack=x+1。 第三步 Client接受到Server请求时,并向Server发送ACK=1，seq=x+1代表要进行通信的序列号，发送希望Server下次通信的数据包的ack=y+1。这里需要注意只有Server接受到ack=y+1时才代表通讯成功。此时就可以愉快的通信了；此时状态进入ESTABLISHED。 那么Client想和Server分手怎么办呢？ 假如小明和小红在一起久了，觉得双方在一起不合适，这是就会发生如下事情 小明：我发现我们在这么久了，不太适合，我们分手吧！ 假如这时候小明和小红有一些经济的往来，借了一些钱 小红：为什么呢？我还没有还你那些钱呢，等我换一阵子我们了清了就分手！！！ 过了一段时间小红把小明的钱还了之后，并和小明说 小红：我们分手吧 小明：这时小明收到小红的分手信，好的，那就分手吧，从此一段姻缘就这样结束了。]]></content>
      <categories>
        <category>服务</category>
        <category>TCP</category>
        <category>三次握手</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP四次挥手]]></title>
    <url>%2F2017%2F11%2F28%2FTCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[TCP四次挥手的过程 第一步 Client和Server相互传送完包以后，Client主动向Server发送关闭连接的信息：FIN=1，seq=u；此时进入FIN_WAIT状态 第二步 Server接收到Client请求之后，假如他们过程中还有一些包传输没有完成，这就Server向Client发送：ACK=1，seq=y（自己的序列号），ack=u+1（确认Client发送过程的请求号），此时进入CLOSE_WAIT。 第三步 当数据包全部传送完成之后，Server主动向Client发送回应：FIN=1，ACK=1，seq=w（此时完成传送的序列号），ack=u+1（这是这个确认好还是确认那序列号），此时进入LASET_ACK状态 第四步 Client接受到Server指令，并向Server发送：ACK=1，seq=u+1，ack=w+1，此时进入`TIME_WAIT状态，而不是直接关闭，原因是如果网络不通畅，重新发送包，相当于防止zombie状态。 Client调用close()主动关闭连接，TCP发送一个FIN 1,seq=u Server接收到FIN 1,seq=u之后，执行被动关闭，对这个seq=u进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；这是并不能立即关闭连接，如果有数据传送ACK=1，seq=y,ack=u+1，但没有发送FIN信号。 一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。ServerTCP也发送一个FIN 1，ACK=1，seq=w,ack=u+1 Client接收到这个FIN它进行确认,并向Server发送ACK=1，seq=u+1，ack=w+1。此时进入TIME_WAIT 1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？ 因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 2．为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？ 因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态但是网络并不能保证通畅，无法确保发送的ACK报文会Server能接受到；因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。]]></content>
      <categories>
        <category>服务</category>
        <category>TCP</category>
        <category>四次挥手</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible中playbook]]></title>
    <url>%2F2017%2F11%2F28%2Fansible%E4%B8%ADplaybook%2F</url>
    <content type="text"><![CDATA[Playbook1、Playbook核心元素 Hosts：运行指定任务的目标主机 remote_user：在远程主机上执行任务的用户 sudo_user：切换用户 Tasks：任务列表 格式： （1）action：module argument （2）module：arguments 注意：shell和command模块后面直接跟命令，而不是key:value的参数列表 Variables：变量 （1）facts：可直接调用的变量 可以使用ansible HOSTS -m setup查看 （2）用户自定义的变量 （a）在命令行中指定使用 -e ARGS或--extra-vars=VARS （b）在playbook中定义变量的方法 vars： - var1：values1 - var2：values2 ... （3）通过roles传递变量 （4）Host Inventory （a）用户自定义变量 向不同主机传递不同的变量： IP/HOSTNAME variable=value var1=vaule1 向组中的主机传递相同的变量可以定义成一个组,可以引用多次 [groupname:vars] variable=value （b）invertory参数 用于定义ansible远程连接目标主机时使用的参数，而非传递给playbook的变量 ansible_ssh_host ansible_ssh_port ansible_ssh_user ansible_ssh_pass ansbile_sudo_pass 变量引用方法： Template：模板文件 注意文件名必须以“j2”结尾。 格式说明： 字符串：使用单引号或双引号 数字：整数、浮点数 列表：[item1,item2..] 元组：（item1，item2...） 字典：{key1:values1,key2:value2...} 布尔型：true/false 算数运算：+ - / *% ** 逻辑运算：and or not Handers：由特定触发的任务 当某个文件参数修改时，这样我们修改了但是并不会立即生效；有没有一个办法当我们修改以后如果某个参数只修改这个文件呢？ notify和tags就是帮我们解决这个问题的。notify通知给相应的handler被触发；tags指定某个服务重启。 条件测试有时我们管理的主机会使不同版本的服务器，每类型服务的执行的命令有些不同，这时就需要条件判断执行。 when语句：在task中使用，jinja2的语法格式 - hosts: websrvs remote_user: root tasks: - name: install conf file to centos7 template: src=/root/nginx.conf.j2 dest=/etc/nginx/nginx.conf when: ansible_distribution_major_version == &quot;7&quot; - name: install conf file to centos6 template: src=/root/nginx.conf2.j2 dest=/etc/nginx/nginx.conf when: ansible_distribution_majoe_version == &quot;6&quot; 循环迭代，需要重复执行的任务 对迭代项的引用，固定变量名为“item”，要在task中使用with_items给定要迭代的元素列表 方式一： name: install some packageyum: name= state=presentwith_items： nginx memcache php-fpm 方式二： name: add some usersuser: name= group= state=presentwith_items: { name: ‘user1’,group: ‘group1’ } { name: ‘user2’,group: ‘group2’ } 在playbook调用角色方法一： - hosts: websrvs remote_user: root roles: - mysql - memcached - nginx 在playbook调用角色方法二： hosts: websrsremote_user: rootroles: { role:nginx, username: nignx } 键role用于指定角色名称，后续的k/v用于传递变量给角色]]></content>
      <categories>
        <category>监控工具</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>playbook</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB工作过程]]></title>
    <url>%2F2017%2F11%2F28%2FWEB%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Web服务请求处理过程 此图为经过的OSI模型 （1）Client需要和Server通信，这时需要发出建立连接请求 （2）Client与Server进行传输数据包时，需要经应用层–&gt;传输层–&gt;网络层–&gt;链路层:层层打包然后传输至Server，Server对此包进行 链路层–&gt;网络层–&gt;传输层–&gt;应用层：层层解封装。http协议工作在应用层，TCP/IP协议工作在网络层，这时就要经过三次握手进行连接（具体想看上述过程） （3）Server接受Client发过的请求 （4）Server接受请求之后需要对处理请求，对请求报文进行解析，获取Client请求的资源及请求资源使用的方法等相关信息；Server根据解析到的结果进行处理 （5）Server这时获取报文中需要请求的资源Web服务器，即存放了Web资源的服务器，此服务器存Client请求的静态文静或运行后生成的资源（6）存放Web资源的服务器识别了请求的资源，执行Client要求的动作并将返回响应报文。响应报文中包括：响应状态码、响应头部、如果生成了响应主体并返回响应主体。 （7）构建完报文之后需要就此报文发送给Client，但是这时Server需要面对一个严重的问题：Server到Client有很多连接，有些是空闲的，有些是正向Server发送数据，还有一些在向客户端回送响应数据。在连接中存在非长连接（服务器应该在发送了整条报文之后关闭自己这条连接）和长连接（在传输完成之后可能还扔保持打开状态）。这时Server就需要精确计算除Content-Length首部，目的是为了知道传送什么时候才能结束。（8）当传输完成之后，理应是把这个通道关闭，这时就要出发TCP四次挥手过程（详细过程请查看上述过程），这种情况是对非长连接说的。如果是长连接，此通道会保持此状态。直到KeepAliveTimeout时间到之后触发TCP四次挥手，结束连接。 （9）如果你有一个好习惯的话，做完一件事情之后要对这件事请求有一个总结，不能做完之后什么都得不到把。Server跟这个性质一样。当完成传输之后在日志文件中记录这条信息。方便以后出现什么情况好解决。]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>WEB工作过程</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible初级认识]]></title>
    <url>%2F2017%2F11%2F28%2Fansible%E5%88%9D%E7%BA%A7%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[一、ansible介绍1、概念ansible是自动化运维工具，基于Python开发，集合了众多的运维工具的优先，实心了批量系统配置、批量程序部署、批量运行命令等功能。 2、特性 模块化：调用特定的模块完成特定的任务 基于Python语言实现，由Paramiko、PyYAML和Jinja2三个关闭模块 部署简单，agentless 支持自定义模块 支持playbook 3、ansible工作原理 由图中我们可以看出ansible的组成结构： Host Inventory ：主机库设置 Playbook：剧本，按照事先设定的顺序完成安排的任务 Core Modules：核心模块 Custom Modules：自定义模块 Connection Plugins：连接插件，一般基于ssh连接，加密传输，相对安全。 后面的Host1、Host2等都是在Host Inventory定义的主机。 用户通过命令执行，Ansible使用ssh等方式连接到Host Inventory定义的主机；执行事先好的Playbook，调用Core Modules或Custom Modules等完成任务。 4、ansible安装[root@localhost~]#yum install -y ansible 由于ansible是由Python开发，所以依赖于有关Python包，需要epel源环境。 配置文件 主配置文件：/etc/ansible/ansible.cfg 设置主机清单：/etc/ansible/hosts 定义格式： 定义单个主机： green.example.com blue.example.com 192.168.100.1 192.168.100.10 定义一组主机 [webservers] alpha.example.org beta.example.org 192.168.1.100 192.168.1.110 如果有一组主机格式相同可以使用如下格式： www[001:006].example.com 如果一个主机属于多个组可以写入不同的组中。 设置角色路径：/etc/ansible/roles 定义每个角色时，均需在此目录创建目录，在新创建的目录下创建目录： files/：存放由copy或script模块等调用的文件 templates/：template模块查找所需要的模板文件的目录，文件均需以“.j2”结尾 tasks/：定义任务的目录；至少应该包含一个名为main.yml的文件，其他的文件需要在此文件中通过include进行包含 handlers/：定义触发条件的目录；至少应该包含一个名为main.yml的文件，其他的文件需要通过include进行包含 vars/：定义变量的目录；至少应该包含一个名为main.yml文件，其他的文件需要在此文件中通过include进行包含 meta/：定义元数据目录；至少应该包含一个名为main.yml的文件，定义当前角色的特殊设定及其依赖关系；其他的文件需要在此文件中通过include进行包含。 default/：设定默认值变量时使用此目录的main.yml文件 命令介绍（1）ansible - run a task on a target host(s) 是一个额外简单的tool/framework/API管理远程主机。允许运行一个简单的任务剧本的adhoc命令。 使用格式: ansible &lt;host-pattern&gt; [-m module_name] [-a args] [options] # 选项 说明 -a ‘ARGUMENTS’, –args=’ARGUMENTS’ 设定参数 -C, –check 在远程不做任何修改，相当于干跑 -c CONNECTION, –connection=CONNECTION 指定使用的连接类型，如ssh、winrm和local，默认为ssh -e EXTRA_VARS, –extra-vars=’EXTRA_VARS 指定额外的变量插入到剧本中，变量需要使用“‘’”引起来，并且命令行的优先级大于剧本中变量的优先级 -f NUM, –forks=NUM 指定并行级别。默认为5 -i PATH, –inventory=PATH 指定主机库，默认为/etc/ansible/hosts –list-hosts 列出指定主机 -m NAME, –module-name=NAME 指定模块名称，默认为command模块 -M DIRECTORY, –module-path=DIRECTORY 指定模块路径，默认为/usr/share/ansible -o, –one-line 输出信息在一行 -u USERNAME, –user=USERNAME 设定连接主机的名称，默认为root （2） ansible-doc - show documentation on Ansible modules显示模块信息 使用格式： ansible-doc [-M module_path] [-l] [-s] [module...] # 选项 说明 -M DIRECTORY, –module-path=DIRECTORY 指定模块路径，默认为/usr/share/ansible -s, –snippet= 列出模块使用方法 -l, –list= 列出所有模块信息 （3）ansible-playbook - run an ansible playbook管理剧本 使用格式： ansible-playbook &lt;filename.yml&gt; ... [options] # 选项 说明 -C, –check 检查脚本是否正确 -c CONNECTION, –connection=CONNECTION 连接使用的方法 -e EXTRA_VARS, –extra-vars=EXTRA_VARS 设定变量 –list-tasks 列出任务 –list-tags 列出标签 –list-hosts 列出主机]]></content>
      <categories>
        <category>监控工具</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>playbook</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible模块]]></title>
    <url>%2F2017%2F11%2F28%2Fansible%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[常用模块介绍ansible中执行命令时，必须考虑其幂等性；即返回的结果不是错误的。如果一个文件存在则不再创建等等情况。 （1）command模块：在远程节点执行命令，此模块为默认模块 action 说明 chdir 执行命令切换工作目录至指定位置 creates 如果此处给定的文件或目录存在，则不执行命令 remove 如果给定的文件后目录不存在，则不执行命令；即存在才执行此命令 示例： [root@localhost~]#ansible all -m command -a &quot;pwd chdir=/etc/&quot; [root@localhost~]#ansible all -m command -a &quot;pwd chdir=/etc/ansible creates&quot; （2）shell模块：执行命令在节点上。 这个模块解决了echo等情况的问题，如果给一个用户添加密码执行如下指令会报错： [root@localhost~]#ansible all -m command -a &quot;echo test | passwd --stdin test&quot; 因此shell解决了这个问题，支持管道传输命令。 action 说明 chdir 在执行命令前切换目录 creates 如果一个文件已经存在则不执行命令 removes 如果一个给定的文件不存在则不执行命令 excutable 指定运行命令使用的shell解释器 [root@localhost~]#ansible all -m command -a &quot;useradd joah &quot; [root@localhost~]#ansible all -m shell -a &quot;echo centos |passwd --stdin joah&quot; （3）copy模块：复制文件到远程主机 action 说明 dest 指定远程绝对路径 group 设置文件的所属组 mode 设置文件的权限 owner 设置文件的所有者 src 设定本地的文件路径，可以使用相对路径也可以使用绝对路径 content 指定复制的内容 [root@localhost~]#ansible all -m copy -a &quot;src=&#39;/etc/hosts&#39; dest=/root/hosts group=joah owner=joah mode=644 &quot; [root@localhost~]#ansible all -m copy -a &quot;context=&#39;hello ansible&#39; dest=/tmp owner=joah group=joah mode=666&quot; 这种使用方法需要在template中使用 （4）fetch模块：把远程文件复制到本地，此时只能点对点复制 action 说明 dest 目标地址 src 源文件路径或文件 [root@localhost~]#ansible 192.168.4.61 -m fetch -a &quot;src=&#39;/etc/fstab&#39; dest=&#39;/root/&#39;&quot; （5）file模块：设置文件属性 action 说明 group 设置所属组 mode 设置权限 owner 设置所有者 path 要修改文件的路径 src 原文件路径 state 如果为link设置软连接；如果是hard设置硬链接；如果是absent，如果存在则删除；如果为touch，如果要创建的文件不存在则创建一个空文件； 示例： [root@localhost~]#ansible all -m file -a &quot;path=/root/test1 state=directory&quot; 创建目录 [root@localhost~]#ansible all -m file -a &quot;path=/root/test1/hidb state=touch&quot; 创建空文件 [root@localhost~]#ansible all -m file -a &quot;path=/root/host src=/root/test1/hidb state=link&quot; 创建软连接 [root@localhost~]#ansible all -m file -a &quot;path=/root/host src=/root/test1/hidb state=absent&quot; 删除软连接 （6）user模块：管理用户账户 action 说明 name 用户名 password 设置用户的密码 createhome 是否创建家目录 local 设定时区 system 是否设置为系统用户 uid 指定uid shell 设置使用的shell类型 group 设置组 groups 设置附加组 comment 添加注释信息 home 指定家目录位置 注意：如果用户的属性修改可以直接执行命令修改 示例： [root@localhost~]#ansible all -m user -a &quot;name=hello password=centos createhome=yes system=no shell=/sbin/nologin &quot; （7）group模块：管理组 action 说明 gid 设置组ID name 设置组名 state 如果present，如果用户存在则不创建，如果absent，用户删除时需存在组 system 是否创建系统用户 示例： [root@localhost~]#ansible all -m group -a &quot;name=hi gid=1005 state=present&quot; 创建组 [root@localhost~]#ansible all -m group -a &quot;name=hi state=absent&quot; 删除用户 （8）get_url：下载文件从HTTP、HTTPS、或者FTP到节点上 action 说明 checksum 是否检查 dest 目标地址 force no，如果目标路径存在且为空则下载；yes如果目标不是目录则覆盖原来的文件 url 指定url url_password 如果下载链接需要使用密码则给定 url_username 如果下载链接需要使用用户则给定 use_proxy 如果为no则不使用代理 示例： [root@localhost~]#ansible all -m get_url -a &quot;url=https://www.percona.com/downloads/percona-toolkit/3.0.4/binary/redhat/7/x86_64/percona-toolkit-3.0.4-1.el7.x86_64.rpm dest=/root&quot; （9）hostname模块：管理主机名 action 说明 name 主机名称 示例： [root@localhost~]#ansible 192.168.4.61 -m hostname -a &quot;name=node6&quot; （10）pip模块：Manages Python library dependencies.管理Python库依赖关系 action 说明 chdir 切换目录 state forcereinstall是否强制重装 （11）yum模块：管理yum包 action 说明 name 包名 state 是否安装；present、installed和latest表示安装；remove、absent和remove表示卸载 list 列出 示例： [root@localhost~]#ansible all -m yum -a &quot;name=nginx state=latest&quot; （12）service模块：管理服务 action 说明 arguments 添加参数 enabled 是否设置为开启启动 name 服务名 state started启动；stopped停止；restarted重启； runlevel 设定运行级别 示例： [root@localhost~]#ansible all -m service -a &quot;name=nginx state=started enabled=yes&quot; （13）git模块：部署软件从git导出 action 说明 repo 仓库路径 dest 目标路径 version 版本 示例： [root@localhost~]#ansible all -m git -a &quot;repo=https://github.com/mbdavid/FileDB.git dest=/root/test1&quot; （14）haproxy模块：管理代理 action 说明 backend 代理后端池 host 修改后端主机名称 state 后端主机状态 weight 设置权重 （15）cron模块：管理计划任务 action 说明 minute 设定分钟，0-59, , /2, month 设定月份， 1-12, , /2, name 计划任务名称， hour 设定小时 day 设置天 job 设定任务 disabled 是否禁用任务 state 如果为present则创建，如果为absent删除 注意：若果name没有设置并且state=present，如果一个新的任务创建，将覆盖原来的任务 示例： [root@localhost~]#ansible all -m cron -a &quot;name=test job=&#39;ntpdate 172.18.0.1 &amp;&gt; /dev/null&#39; hour=*/2&quot; （16）setup模块：收集远程主机信息]]></content>
      <categories>
        <category>监控工具</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>自动化</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible示例]]></title>
    <url>%2F2017%2F11%2F28%2Fansible%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[完整示例-安装httpd并配置（1）方式一： 创建目录[root@localhost/etc/ansible/roles]#mkdir -pv http/{tasks,templates,files,handlers,vars,meta,default} 创建task文件[root@localhost/etc/ansible/roles/http]#vim tasks/main.yml 1 - name: install package httpd 2 yum: name=nginx state=latest 3 - name: create webdoc 4 file: path={{ http_doc_root }} state=directory 5 - name: service httpd service 6 service: name=nginx state=started 7 - name: configure httpd conf 8 template: src=httpd.conf.j2 dest=/etc/httpd/conf.d/ 9 tags: httpconf 10 notify: reload httpd 创建handler文件[root@localhost/etc/ansible/roles/http]#vim handlers/main.yml 1 - name: relad httpd 2 service: name=httpd state=reloaded 创建vars文件[root@localhost/etc/ansible/roles/http]#vim vars/main.yml 1 http_server_port: 8080 2 http_server_name: www.test.com 3 http_doc_root: /webdate 创建template文件[root@localhost/etc/ansible/roles/http]#vim templates/httpd.conf.j2 1 listen {{ http_server_port }} 2 ServerName {{ http_server_name }} 3 DocumentRoot {{ http_doc_root }} 4 &lt;Directory {{ http_doc_root }}&gt; 5 Require all granted 6 &lt;/Directory&gt; 创建剧本[root@localhost/etc/ansible]#vim http.yml 1 - hosts: websrvs 2 remote_user: root 3 roles: 4 - http 测试[root@localhost~]#ansible-playbook /etc/ansible/http.yml 实战：基于msm的tomcat集群- 实验环境 主机名 IP 安装的包 node1 192.168.4.61 nginx、keepalived node2 192.168.4.62 nginx、keepalived node3 192.168.4.63 tomcat、tomcat-docs-webapp、tomcat-webapps、tomcat-adim-webapps、java-1.8.0-openjdk、memcached-session-manager-2.1.1.jar 、memcached-session-manager-tc7-2.1.1.jar、spymemcached-2.12.3.jar 、msm-javolution-serializer-2.1.1.jar 、javolution-5.4.3.1 node4 192.168.4.64 tomcat、tomcat-docs-webapp、tomcat-webapps、tomcat-adim-webapps、java-1.8.0-openjdk、memcached-session-manager-2.1.1.jar 、memcached-session-manager-tc7-2.1.1.jar、spymemcached-2.12.3.jar 、msm-javolution-serializer-2.1.1.jar 、javolution-5.4.3.1 node5 192.168.4.65 ansible、memcached 基于ssh密钥认证[root@node5~]#vim ssh.sh 1 #!/bin/bash 2 [ ! -f /root/.ssh/id_rsa.pub ] &amp;&amp; ssh-keygen -t rsa -P &apos;&apos; &amp;&gt; /dev/null 3 while read line;do 4 expect &lt;&lt; EOF 5 spawn ssh-copy-id -i /root/.ssh/id_rsa.pub root@$line 6 expect { 7 &quot;yes/no&quot; { send &quot;yes\n&quot;;exp_continue } 8 &quot;password&quot; { send &quot;magedu\n&quot; } 9 } 10 expect eof 11 EOF 12 13 done &lt; /root/ip.txt [root@node5~]#vim ip.txt 1 192.168.4.61 2 192.168.4.62 3 192.168.4.63 4 192.168.4.64 5 192.168.4.65 [root@node5~]#chmod +x ssh.sh ansible中修改主机库文件[root@node5~]#vim /etc/ansible/hosts 25 [nginx-keep] 26 192.168.4.61 27 192.168.4.62 28 [tomcat-cluster] 29 192.168.4.63 30 192.168.4.64 31 [memcached] 32 192.168.4.65 同步时间[root@node5/etc/ansible]#vim ntp.yml 1 - hosts: all 2 remote_user: root 3 tasks: 4 - name: sync time 5 command: ntpdate 172.18.0.1 6 - name: chrony conf 7 file: src=/etc/chrony.conf dest=/etc/chrony.conf 8 tags: chrony 9 notify: restart chronyd.service 10 - name: start chrony 11 service: name=chronyd state=started 12 handlers: 13 - name: restart chronyd.service 14 service: name=chronyd state=restarted [root@node5~]#vim /etc/chrony.conf 7 server 172.18.0.1 iburst [root@node5/etc/ansible]#ansible-playbook --syntax-check ntp.yml #检测语法是否正确 注意：由于yaml格式对于初学者来说有一定的坑，需要严格按照格式写。[root@node5/etc/ansible]#ansible-playbook ntp.yml #语法检测没有问题后，执行剧本 温馨提示：为了以后不必要的错误，建议没此执行完以后，都要确认是否执行正确后再进行下一步基于主机名解析[root@node5/etc/ansible]#ansible all -m copy -a &quot;src=/etc/hosts dest=/etc/hosts&quot; 挂载光盘[root@node5~]#ansible all -m mount -a &quot;name=/media/cdrom src=/dev/sr0 state=mounted fstype=iso9660&quot; 配置nginx角色 创建所需要的目录 [root@node5/etc/ansible/roles]#mkdir haproxy/{tasks,handler,files,templates,vars,default,meta} -pv 创建任务文件 [root@node5/etc/ansible/roles/haproxy]#vim tasks/main.yml 1 - name: install haproxy package 2 yum: name=haproxy state=latest 3 - name: modify haproxy conf 4 template: src=haproxy.cfg.j2 dest=/etc/haproxy/haproxy.cfg 5 tags: haproxy 6 notify: haproxy restart 7 - name: start haproxy service 8 service: name=haproxy state=started 9 handlers: 10 - name: haproxy restart 11 service: name=haproxy state=restarted 创建模板文件 [root@node5/etc/ansible/roles/haproxy]#cp /etc/haproxy/haproxy.cfg templates/haproxy.cfg.j2 42 defaults 43 mode http 44 log global 45 option httplog 46 option dontlognull 47 option http-server-close 48 option forwardfor except 127.0.0.0/8 43 mode http 44 log global 45 option httplog 46 option dontlognull 47 option http-server-close 48 option forwardfor except 127.0.0.0/8 49 option redispatch 50 retries 3 51 timeout http-request 10s 52 timeout queue 1m 53 timeout connect 10s 54 timeout client 1m 55 timeout server 1m 56 timeout http-keep-alive 10s 57 timeout check 10s 58 maxconn 3000 59 60 frontend tomcat #定义前段并指定名称 61 bind 172.18.4.60:{{ tomcat_server_port }} #绑定地址和端口 62 63 backend tomcat-cluster #定义后端服务 64 balance roundrobin 65 server node3 192.168.4.63 check 66 server node4 192.168.4.64 check 67 listen #定义管理界面 68 bind 127.0.0.1:9000 69 stats enable 70 stats uri /stats 71 stats auth joah:centos 72 stats relam &quot;tomcat&quot; 73 stats hide-version 74 stats refresh 10s 75 stats admin if TRUE 注意：模板文件必须以“j2”结尾。 创建变量文件 [root@node5/etc/ansible/roles/haproxy]#vim vars/main.yml 1 tomcat_server_port: 80 创建触发文件 [root@node5/etc/ansible/roles/haproxy]#vim handlers/main.yml 1 - name: haproxy restart 2 service: name=haproxy state=restarted 注意：创建tasks、templates、vars文件时必须以main.yml文件为入口，如果定义别的文件使用include指定即可。 添加IP[root@node5/etc/ansible/roles/haproxy]#ansible tomcat-cluster -m shell -a &quot;ip addr add 192.168.4.60/24 dev eth0 &quot; 创建keepalived角色 创建所需目录 [root@node5/etc/ansible/roles]#mkdir keepalived/{tasks,handler,files,templates,vars,default,meta} -pv 创建任务文件 [root@node5/etc/ansible/roles/keepalived]#vim tasks/main.yml 1 - name: install keepalived package 2 yum: name=keepalived state=latest 3 - name: modify keepalived conf 4 template: src=keepalived.conf.j2 dest=/etc/keepalived/keepalived.conf 5 when: ansible_hostname == &quot;node1&quot; 6 notify: keepalived reloaded 7 tags: keepalived 8 - name: modify keepalived conf 9 template: src=keepalived.conf.j2 dest=/etc/keepalived/keepalived.conf 10 when: ansible_hostname == &quot;node2&quot; 11 notify: keepalived reloaded 12 tags: keepalived 13 - name: start keepalived 14 service: name=keepalived state=started 创建触发文件 [root@node5/etc/ansible/roles/keepalived]#vim handlers/main.yml 1 - name: keepalived reloaded 2 service: name=keepalived state=reloaded 创建模板文件 [root@node5/etc/ansible/roles/keepalived]#vim templates/keepalived.conf.j2 #创建master 1 ! Configuration File for keepalived 2 3 global_defs { 4 notification_email { 5 locahost@qq.com 6 } 7 notification_email_from haproxy@qq.com 8 smtp_server 127.0.0.1 9 smtp_connect_timeout 30 10 router_id node3 11 route_mcast_group4 224.0.100.4 12 vrrp_strict chk_haproxy { 13 script &quot;killall -0 haporxy&quot; 14 interval 3 15 weight -15 16 } 17 } 18 19 vrrp_instance VI_1 { 20 state MASTER 21 interface eth0 22 virtual_router_id 4 23 priority 100 24 advert_int 1 25 authentication { 26 auth_type PASS 27 auth_pass 152369 28 } 29 virtual_ipaddress { 172.18.4.60/16 32 } 33 track_script { 34 chk_haproxy 35 } 36 } [root@node5/etc/ansible/roles/keepalived]#cp templates/keepalived.conf.j2 templates/keepalived.conf2.j2 创建backup 1 ! Configuration File for keepalived 2 3 global_defs { 4 notification_email { 5 locahost@qq.com 6 } 7 notification_email_from haproxy@qq.com 8 smtp_server 127.0.0.1 9 smtp_connect_timeout 30 10 router_id node2 11 route_mcast_group4 224.0.100.4 12 vrrp_strict chk_haproxy { 13 script &quot;killall -0 haporxy&quot; 14 interval 3 15 weight -15 16 } 17 } 18 19 vrrp_instance VI_1 { 20 state BACKUP 21 interface eth0 22 virtual_router_id 4 23 priority 90 24 advert_int 1 25 authentication { 26 auth_type PASS 27 auth_pass 152369 28 } 29 virtual_ipaddress { 172.18.4.60/16 32 } 33 track_script { 34 chk_haproxy 35 } 36 } 注意： （1）master和backup中priority、state需要修改，其他的配置不需要修改。 （2）如果使用auth_type认证，需要双方auth_pass必须相同 （3）如果你想使用脚本检测，vrrp_script可以指定脚本位置/PATH/TO/SCRIPT.sh 创建tomcat角色 创建所需要的目录 [root@node5/etc/ansible/roles]#mkdir tomcat/{tasks,handlers,files,templates,vars,default,meta} -pv 创建tomcat任务 [root@node5/etc/ansible/roles/tomcat]#vim tasks/main.yml 1 - name: install tomcat package 2 yum: name={{ item }} state=latest 3 with_items: 4 - java-1.8.0-openjdk 5 - tomcat 6 - tomcat-docs-webapp 7 - tomcat-admin-webapps 8 - tomcat-webapps 9 - memcached 10 - name: modify tomcat conf 11 template: src=server.xml.j2 dest=/etc/tomcat/server.xml 12 notify: tomcat reload 13 tags: tomcat 14 - name: kryo jar 15 copy: src=/root/{{ item }}.jar dest=/usr/share/tomcat/lib/ 16 with_items: 17 - asm-6.0 18 - kryo-4.0.1 19 - kryo-serializers-0.42 20 - memcached-session-manager-2.1.1 21 - memcached-session-manager-tc7-2.1.1 22 - minlog-1.3.0 23 - msm-kryo-serializer-2.1.1 24 - objenesis-2.6 25 - reflectasm-1.11.3 26 - spymemcached-2.12.3 27 - name: start tomcat 28 service: name=tomcat state=started 29 - name: mkdir directory 30 file: path=/usr/share/tomcat/webapps/test state=directory 31 - name: touch file 32 file: path=/usr/share/tomcat/webapps/test/{{ item }} state=touch 33 with_items: 34 - WEB-INF 35 - classes 36 - lib 37 - name: copy index.jsp 38 copy: src=index.jsp.j2 dest=/usr/share/tomcat/webapps/index.jsp 39 when: ansible_hostname == &quot;node3&quot; 40 notify: tomcat reload 41 tags: tomcat 42 - name: copy index.jsp 43 copy: src=index2.jsp.j2 dest=/usr/share/tomcat/webapps/index.jsp 44 when: ansible_hostname == &quot;node4&quot; 45 notify: tomcat reload 46 tags: tomcat 创建模板文件 [root@node5/etc/ansible/roles/tomcat/templates]#vim server.xml.j2 126 &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; 127 unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt; 128 &lt;Context path=&quot;&quot; docBase=&quot;test&quot; reloadable=&quot;&quot; /&gt; 129 &lt;Context&gt; 130 &lt;Manager className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot; 131 memcachedNodes=&quot;n1:192.168.4.63:11211,n2:192.168.4.64:11211&quot; #指定位置 132 failoverNodes=&quot;n1&quot; 133 requestUriIgnorePattern=&quot;.*\.(ico|png|gif|jpg|css|js)$&quot; 134 transcoderFactoryClass=&quot;de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory&quot; 135 /&gt; 136 &lt;/Context&gt; [root@node5/etc/ansible/roles/tomcat/templates]#vim index.jsp.j2 1 &lt;%@ page language=&quot;java&quot; %&gt; 2 &lt;html&gt; 3 &lt;head&gt;&lt;title&gt;TomcatA&lt;/title&gt;&lt;/head&gt; 4 &lt;body&gt; 5 &lt;h1&gt;&lt;font color=&quot;red&quot;&gt;TomcatA.test.com&lt;/font&gt;&lt;/h1&gt; 6 &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt; 7 &lt;tr&gt; 8 &lt;td&gt;Session ID&lt;/td&gt; 9 &lt;% session.setAttribute(&quot;test.com&quot;,&quot;test.com&quot;); %&gt; 10 &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt; 11 &lt;/tr&gt; 12 &lt;tr&gt; 13 &lt;td&gt;Created on&lt;/td&gt; 14 &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt; 15 &lt;/tr&gt; 16 &lt;/table&gt; 17 &lt;/body&gt; 18 &lt;/html&gt; [root@node5/etc/ansible/roles/tomcat/templates]#vim index2.jsp.j2 1 &lt;%@ page language=&quot;java&quot; %&gt; 2 &lt;html&gt; 3 &lt;head&gt;&lt;title&gt;TomcatB&lt;/title&gt;&lt;/head&gt; 4 &lt;body&gt; 5 &lt;h1&gt;&lt;font color=&quot;blue&quot;&gt;TomcatB.test.com&lt;/font&gt;&lt;/h1&gt; 6 &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt; 7 &lt;tr&gt; 8 &lt;td&gt;Session ID&lt;/td&gt; 9 &lt;% session.setAttribute(&quot;test.com&quot;,&quot;test.com&quot;); %&gt; 10 &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt; 11 &lt;/tr&gt; 12 &lt;tr&gt; 13 &lt;td&gt;Created on&lt;/td&gt; 14 &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt; 15 &lt;/tr&gt; 16 &lt;/table&gt; 17 &lt;/body&gt; 18 &lt;/html&gt; 编辑触发文件 [root@node5/etc/ansible/roles/tomcat]#vim handlers/main.yml 1 - name: tomcat reload 2 service: name=tomcat state=reloaded 编辑剧本 [root@node5/etc/ansible]#vim tomcat.yml 1 - hosts: nginx-keep 2 remote_user: root 3 roles: 4 - keepalived 5 - haproxy 6 - hosts: tomcat-cluster 7 remote_user: root 8 roles: 9 - tomcat]]></content>
      <categories>
        <category>监控工具</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>自动化</tag>
        <tag>示例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译安装httpd-2.4]]></title>
    <url>%2F2017%2F11%2F28%2F%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85httpd-2.4%2F</url>
    <content type="text"><![CDATA[编译安装httpd-2.4（1）准备安装前环境 [root@localhost ~]# yum groupinstall -y &quot;development tools&quot; （2）编译安装apr [root@localhost src]# tar xf apr-1.6.2.tar.gz[root@localhost apr-1.6.2]# ./configure --prefix=/app/apr[root@localhost apr-1.6.2]# make &amp;&amp; make install （3）编译安装apr-util [root@localhost src]# tar xf apr-util-1.6.0.tar.gz[root@localhost apr-util-1.6.0]# ./configure --prefix=/app/apr-util --with-apr=/app/apr[root@localhost apr-util-1.6.0]# yum install -y expat-devel #编译依赖与这个包（Expat是一个用C语言开发的、用来解析XML文档的开发库）[root@localhost apr-util-1.6.0]# make &amp;&amp; make install （4）编译安装httpd-2.4[root@localhost src]# useradd -r -m -d /app/website -s /sbin/nologin apache [root@localhost src]# tar xf httpd-2.4.27.tar.bz2 [root@localhost httpd-2.4.27]# yum install -y pcre-devel openssl-devel [root@localhost httpd-2.4.27]# ./configure --prefix=/app/httpd24 --enable-so --enable-ssl --enable-cgi --enable-rewrite --with-zlib --with-pcre --with-apr=/app/apr/ --with-apr-util=/app/apr-util/ --enable-modules=most --enable-mpms-shared=all --with-mpm=prefork [root@localhost bin]# make &amp;&amp; make install 修改PATH路径 [root@localhost bin]# vim /etc/profile.d/http24.sh export PATH=/app/httpd24/bin:$PATH [root@localhost bin]# source /etc/profile.d/http24.sh #使其生效[root@localhost bin]# echo $PATH /app/httpd24/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin 修改配置文件 [root@localhost conf]# vim httpd.conf 配置启动脚本 方法一： [root@localhost conf]# scp 192.168.4.132:/etc/init.d/httpd /etc/init.d/httpd24 #如果其他主机上有可以拷贝一份 [root@localhost httpd-2.4.27]# vim /etc/init.d/httpd24 apachectl=/app/httpd24/apachectl httpd=${HTTPD-/app/httpd24/httpd} prog=httpd pidfile=${PIDFILE-/app/httpd24/logs/httpd.pid} lockfile=${LOCKFILE-/var/lock/subsys/httpd} RETVAL=0 STOP_TIMEOUT=${STOP_TIMEOUT-10} [root@localhost conf]# chkconfig --add httpd24 #将此服务加到服务中心[root@localhost conf]# chkconfig httpd24 on设为开机启动 方法二：由于CentOS 6中支持rc.local脚本所有我们可以把命令写到脚本中，设为开机启动 [root@localhost conf]# vim /etc/rc.d/rc.local /app/httpd24/apachectl start [root@localhost conf]# chmod +x /etc/rc.d/rc.local 测试 [root@localhost website]# echo index.html &gt; index.html [root@localhost website]# apachectl start 安装方式二 （1）准备安装前环境 [root@localhost ~]# yum groupinstall -y &quot;development tools&quot; （2）解压apr包 [root@localhost src]# tar xf apr-1.6.2.tar.gz （3）解压apr-util包 [root@localhost src]# tar xf apr-util-1.6.0.tar.gz （4）编译安装httpd-2.4[root@localhost src]# useradd -r -m -d /app/website -s /sbin/nologin apache [root@localhost src]# tar xf httpd-2.4.27.tar.bz2 [root@localhost httpd-2.4.27]# yum install -y pcre-devel openssl-devel 将解压包移动到srclib目录下[root@localhost src]# mv apr-1.6.2 httpd-2.4.27/srclib/apr [root@localhost src]# mv apr-util-1.6.0 httpd-2.4.27/srclib/apr-util [root@localhost httpd-2.4.27]# ./configure --prefix=/app/httpd24 --enable-so --enable-ssl --enable-cgi --enable-rewrite --with-zlib --with-pcre --with-included-apr --enable-modules=most --enable-mpms-shared=all --with-mpm=prefork [root@localhost httpd-2.4.27]# make &amp;&amp; make install 修改配置文件 [root@localhost conf]# vim httpd.conf 配置启动脚本 方法一： [root@localhost conf]# scp 192.168.4.132:/etc/init.d/httpd /etc/init.d/httpd24 #如果其他主机上有可以拷贝一份 [root@localhost httpd-2.4.27]# vim /etc/init.d/httpd24 apachectl=/app/httpd24/apachectl httpd=${HTTPD-/app/httpd24/httpd} prog=httpd pidfile=${PIDFILE-/app/httpd24/logs/httpd.pid} lockfile=${LOCKFILE-/var/lock/subsys/httpd} RETVAL=0 STOP_TIMEOUT=${STOP_TIMEOUT-10} [root@localhost conf]# chkconfig --add httpd24 #将此服务加到服务中心[root@localhost conf]# chkconfig httpd24 on设为开机启动 方法二：由于CentOS 6中支持rc.local脚本所有我们可以把命令写到脚本中，设为开机启动 [root@localhost conf]# vim /etc/rc.d/rc.local /app/httpd24/apachectl start [root@localhost conf]# chmod +x /etc/rc.d/rc.local 方法三：将/app/httpd24/bin/apachectl文件拷贝至/etc/init.d/httpd [root@localhost httpd24]# cp /app/httpd24/bin/apachectl /etc/init.d/httpd24 测试 [root@localhost website]# echo index.html &gt; index.html [root@localhost website]# apachectl start]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>编译安装httpd-2.4</category>
      </categories>
      <tags>
        <tag>源码编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dig、nslookup等工具]]></title>
    <url>%2F2017%2F11%2F28%2Fdig%E3%80%81nslookup%E7%AD%89%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[管理命令1、dig命令作用：只能用于测试DNS系统，不会查询hosts文件进行解析。 格式： dig [@server] [-b address] [-c class] [-f filename] [-k filename] [-m] [-p port#] [-q name] [-t type] [-x addr] [-y [hmac:]name:key] [-4] [-6] [name] [type] [class] [queryopt...] simple usage： dig @server name type 选项： -b：绑定源IP -4：仅使用IPv4 -t：指定RR类型，默认为A记录，atfr（反向解析） -x：反向解析 +[no]trace:跟踪解析过程 +[no]recure：递归解析 2、host命令格式： host [-aCdlnrsTwv] [-c class] [-N ndots] [-R number] [-t type] [-W wait] [-m flag] [-4] [-6] {name} [server] 选项： -t：指定RR类型 3、nslookup格式：nslookup [-option] [name | -] [server] nslookup&gt; server IP: 指明使用哪个DNS server进行查询 set q=RR_TYPE: 指明查询的资源记录类型 NAME: 要查询的名称 4、rndc命令(953/tcp)格式： rndc [-b source-address] [-c config-file] [-k key-file] [-s server] [-p port] [-V] [-y key_id] {command} reload：重载主配置文件和区域解析库文件 retranfer：手动启动区域传送，而不管序列号是否增减； notify：重新对区域传送发通知； reconfig：重载主配置文件 querylog：开启或关闭查询日志文件`/var/log/message` trace：递增debug一个级别 trace LEVEL：指定使用的级别 notrace：将调试级别设置为0 flush：清空DNS服务器的所有缓存记录]]></content>
      <categories>
        <category>命令</category>
        <category>dig、nslookup等工具</category>
      </categories>
      <tags>
        <tag>命令使用，dig，nslookup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站访问量计算方式]]></title>
    <url>%2F2017%2F11%2F28%2F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E9%87%8F%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[网站访问量计算方式 IP(独立IP)：即Internet Protocol,指独立IP数。一天内来自相同客户机IP地址只计算一次，记录远程客户机IP地址的计算机访问网站的次数，是衡量网站流量的重要指标。 PV(访问量)： 即Page View, 页面浏览量或点击量，用户每次刷新即被计算一次，PV反映的是浏览某网站的页面数，PV与来访者的数量成正比，PV并不是页面的来访者数量，而是网站被访问的页面数量。 UV(独立访客)：即Unique Visitor,访问网站的一台电脑为一个访客。一天内相同的客户端只被计算一次。可以理解成访问某网站的电脑的数量。网站判断来访电脑的身份是通过来访电脑的cookies实现的。如果更换了IP后但不清除cookies，再访问相同网站，该网站的统计中UV数是不变的 http://www.alexa.cn/rank/可以查看全球网站的统计量 示例： 小明在家用ADSL拨号上网，早上8点访问了www.baidu.com下的2个页面，下午2点又拨号访问了www.baidu.com3个页面。那么，对于www.baidu.com来讲，今天的PV、UV、VV、IP各项指标该如何计算呢 ？ IP 2 PV 5 UV 1]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>网站访问量计算</category>
      </categories>
      <tags>
        <tag>访问量计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FTP简单介绍]]></title>
    <url>%2F2017%2F11%2F28%2FFTP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、FTP1、FTP介绍用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。”下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。 2、FTP的工作模式（1）主动模式 Client（PORT/TCP）向Server（22/TCP）发送连接请求，建立三次握手 Client告知Server数据连接端口为PORT+1 Server（20/TCP）主动向Client发送连接请求，建立数据通信。 （2）被动模式 Client（PORT/TCP）和Server建立三次握手 Client向Server发起PASSIVE请求 Server告知Client数据端口 Client（PORT+1/TCP）再次向Server发送数据连接请求 这里需要注意一下，Server数据端口需要计算得出来的一个随机端口号 示例： 192,168,4,60,140,28 服务器数据端口为：140*256+28=35868即此端口为数据连接端口 TCP三次握手过程被动模式下通信过程，产生随机端口通信。 3、FTP服务状态码 状态码 说明 1XX 信息 2XX 成功类响应码 3XX 提示需进一步提供补充类信息的状态码 4XX 客户端错误 5XX 服务器端错误 4、FTP服务用户认证方式 匿名用户：ftp，anonymous，对应linux用户为ftp 匿名用户映射为ftp用户共享资源位置:/var/ftp/pub 系统用户：linux用户，用户/etc/passwd,密码/etc/shadow 系统用户通过ftp访问的资源的位置：用户自己的家目录 虚拟用户：特定服务的专用用户，独立于用户/密码的文件;仅用于访问某特定功能的资源 虚拟用户通过ftp访问资源的位置：给虚拟用户指定的映射成系统用户的家目录 二、vsftpd服务1、vsftpd服务配置文件用户认证配置文件 /etc/pam.d/vsftpd 服务脚本 /usr/lib/systemd/system/vsftpd.service (CentOS 7) /etc/rc.d/init.d/vsftpd 配置文件 /etc/vsftpd/vsftpd.conf 2、主配置文件/etc/vsftpd/vsftpd.conf 匿名了用户配置 anonymous_enable 是否启用匿名用户 anon_upload_enable 是否允许匿名用户上传 anon_mkdir_write_enable 是否允许匿名用户创建目录 anon_other_write_enable 是否允许匿名用户删除目录 系统用户配置 local_enable 是否开启系统用户 write_enable 是否允许创建、删除文件 local_mask 控制本地上传文件权限 chroot_local_user 锁定所有用户在家目录中 chroot_list_enable 运行列表中的用户切换为家目录 chroot_list_file 指定用户文件存放位置 dirmessage_enable 在指定目录下创建.message文件提示用户登录信息 local_root 非匿名了用户登录所有目录 guest_enable 所有系统用户都映射成guest用户 guest_username 指定guest用户，一定要与guest_enable使用 nopriv_user vsftpd指定用户身份运行 日志 xferlog_enable 是否开启传输日志 xferlog_std_format 是否开启标准格式 xferlog_file 指定存放日志文件 dual_log_enable 使用vsftpd日志格式，默认不启用 vsftpd_log_fiel=/var/log/vsftpd.log 可自动生成 改变上传文件的所有者 chown_uploads 是否开启改变上传并修改所有者 chown_username 设置修改为who 欢迎信息 ftpd_banner 设置欢迎信息 vsftpd使用pam完成认证使用的pam配置文件 pam_service_name 是否启用控制用户登录的列表文件 userlist_enable 是否启用用户列表 userlist_deny 是否允许这个文件中的用户可以登录 连接限制 max_client 最大并发连接数 max_per_ip 每个IP可同时发起的并发请求数 传输速率 anon_max_rate 匿名用户最大传输率，单位为字节/秒 local_max_rate 本地用户最大传输速率 -主动模式端口 connect_from_port_20 主动模式端口为20 ftp_data_port 指定主动模式端口 此处注意：一定不能把connect_from_port设置为NO 被动模式端口 pasv_min_port 被动模式最小端口，0为随机端口 pasv_max_port 被动模式最大端口 是否使用当地时间，即系统时间 use_localtime 连接时间 connect_timeout 主动模式数据连接超时时长 accept_timeout 被动模式数据连接超时时长 data_connection_timeout 数据无数据传输超时时长 idle_session_timeout 无命令超时时长-优先以文本传输 ascii_upload_enable 是否开启文本传输 ascii_download_enable 注意：vsftpd默认不允许直接修改根目录权限。 3、CentOS 6如何使vsftpd以非独立服务方式运行（1）修改/etc/vsftpd/vsftpd.conf listen=NO 将此项设置为NO ，即关闭自己监听 （2）安装xinetd服务 [root@localhost ~]# yum install -y xinetd （3）复制模板并修改启动xinetd服务 [root@localhost xinetd.d]# cp rsync vsftpd[root@localhost xinetd.d]# vim vsftpd service vsftpd #修改服务名称 { disable = no 是否开启 flags = IPv6 socket_type = stream wait = no user = root server = /usr/sbin/vsftpd server_args = --daemon log_on_failure += USERID } [root@localhost xinetd.d]# service xinetd restart （4）验证是否成为非独立服务 [root@localhost xinetd.d]# ss -tnl LISTEN 0 64 :::21 :::* users:((&quot;xinetd&quot;,48493,5)) 4、实现基于SSL的FTPS（1）确认是否支持ssl [root@localhost ~]# lddwhich vsftpd|grep ssl libssl.so.10 =&gt; /usr/lib64/libssl.so.10 (0x00007f56e8de8000) （2）创建证书 [root@localhost/etc/pki/tls/certs]#make vsftpd.pem[root@localhost/etc/pki/tls/certs]#openssl x509 -in vsftpd.pem -noout -text #查看证书内容[root@localhost/etc/pki/tls/certs]#mv vsftpd.pem /etc/vsftpd/ #将证书移动至此目录下方便管理 （3）配置vsftpd服务支持SSL [root@localhost~]#vim /etc/vsftpd/vsftpd.conf #在文件下追击如下几行 128 ssl_enable=YES #是否开启SSL 129 allow_anon_ssl=NO #是否允许匿名用户支持SSL 130 force_local_logins_ssl=YES #本地用户登录加密 131 force_local_data_ssl=YES #本地用户数据传输加密 132 rsa_cert_file=/etc/vsftpd/vsftpd.pem #证书存放的位置 （4）测试是否使用加密传输 [root@localhost ~]# ftp 192.168.4.60 Connected to 192.168.4.60 (192.168.4.60). 220 (vsFTPd 3.0.2) Name (192.168.4.60:root): wang 530 Non-anonymous sessions must use encryption. #禁止匿名用户登录 Login failed. 421 Service not available, remote server has closed connection 使用Fileilla工具测试 三、vsftpd虚拟用户1、虚拟用户介绍所有虚拟用户会被统一映射为一个指定的系统账号，访问的共享位置即此系统账号的目录； 每个虚拟用户可被赋予不同的访问权限，通过匿名用户的权限控制参数进行指定； ##2、虚拟用户账号的存储方式 文本存储：编辑文本文件，此文件需要被编码为hash格式 格式：奇数行为账户，偶数行为密码 不过需要对此文件加密，使用的工具为db_load db_load -T -t hash -f Filename.txt Filename.db -T 转换 -t 指定类型 -f 指定文件 存储在关系型数据库表中，可以实现查询数据库完成用户认证 #四、实现不同方式存储的方式 ##1、基于文本文件存储（1）创建用户并写入一个文本文件中 [root@localhost/etc/vsftpd]#vim vusers 1 joah 2 123456 3 wang 4 123456 （2）创建用户数据库文件 [root@localhost/etc/vsftpd]#db_load -T -t hash -f vusers vusers.db[root@localhost/etc/vsftpd]#chmod 600 vusers.db #修改文件权限 （3）创建用户和访问的目录[root@localhost~]#useradd -s /sbin/nologin -d /app/ftproot vuser[root@localhost~]#chmod +rx /app/ftproot/[root@localhost~]#chmod -w /app/ftproot/ #由于CentOS 7 上不允许系统用户直接修改家目录所有需要去掉此权限[root@localhost~]#mkdir /app/ftproot/upload[root@localhost~]#setfacl -m u:vuser:rwx /app/ftproot/upload/ （4）创建pam配置文件 [root@localhost~]#ls /usr/lib64/security/ |grep userdb #查看是否已有此模块 pam_userdb.so [root@localhost/etc/pam.d]#vim vsftpd.db 1 auth required pam_userdb.so db=/etc/vsftpd/vusers 2 account required pam_userdb.so db=/etc/vsftpd/vusers （5）创建虚拟用户独立的配置文件 [root@localhost/etc/vsftpd]#mkdir vdocs[root@localhost/etc/vsftpd]#cd vdocs/[root@localhost/etc/vsftpd/vdocs]#vim wang[root@localhost/etc/vsftpd/vdocs]#vim joah 1 anon_upload_enable=YES 2 anon_mkdir_write_enable=YES 3 anon_other_write_enable=YES 注意：默认不创建用户文件，只有下载权限。 （6）修改/etc/vsftpd/vsftpd.conf文件 133 guest_enable=YES #所有系统用户映射为guest用户 134 guest_username=vuser #指定guest用户 135 pam_service_name=vsftpd.db #pam服务的名称 136 user_config_dir=/etc/vsftpd/vdocs #文本文件用户的配置文件所在位置 （7）测试]]></content>
      <categories>
        <category>文件管理</category>
        <category>FTP</category>
        <category>FTP简单介绍</category>
      </categories>
      <tags>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于数据库验证vsftpd虚拟用户]]></title>
    <url>%2F2017%2F11%2F28%2F%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AA%8C%E8%AF%81vsftpd%E8%99%9A%E6%8B%9F%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[基于数据库验证vsftpd虚拟用户CentOS7 环境 （1）编译安装pam_mysql,提供pam_mysql.so模块[root@localhost/usr/local/src/pam_mysql-0.7RC1]#yum install -y mariadb-devel pam-devel[root@localhost/usr/local/src/pam_mysql-0.7RC1]#./configure --with-mysql=/usr --with-pam=/usr --with-pam-mods-dir=/lib64/security[root@localhost/usr/local/src/pam_mysql-0.7RC1]#make &amp;&amp; make install （2）准备数据库和相关表 [root@localhost~]#mysql -uroot -p MariaDB [(none)]&gt; CREATE DATABASE ftpdb; MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON ftpdb.* TO ftpuser@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;; MariaDB [(none)]&gt; USE ftpdb; MariaDB [ftpdb]&gt; CREATE TABLE vuser (ID int unsigned auto_increment primary key,username char(40),password char(50)); [root@localhost~]#useradd -d /app/ftproot -s /sbin/nologin ftpuser[root@localhost~]#chmod 555 /app/ftproot/ #修改目录权限，因为CentOS7中默认不允许父目录有写权限 （3）添加虚拟用户 MariaDB [ftpdb]&gt; INSERT INTO vuser(username,password) VALUES(&apos;joah&apos;,password(&apos;123456&apos;)); MariaDB [ftpdb]&gt; INSERT INTO vuser(username,password) VALUES(&apos;li&apos;,password(&apos;123456&apos;)); （4）建立pam认证所需文件 [root@localhost~]#vim /etc/pam.d/vsftpd.mysql 1 auth reuqired pam_mysql.so user=ftpuser passwd=123456 host=localhost db=ftpdb table=vu ser usercolumn=username passwdcolumn=password crypt 2 2 account reuqired pam_mysql.so user=ftpuser passwd=123456 host=localhost db=ftpdb table =vuser usercolumn=username passwdcolumn=password crypt 2 选线说明： auth 表示认证 account 验证账号密码正常使用 reuqired 表示认证通过 user 为登录mysql的用户 passwd 登录mysql的密码 host mysql服务器的主机名或IP地址 db 指定连接mysql的数据库名称 table 指定连接数据库中的表名 usercolumn 当做用户名的字段 passwdcolumn 当做用户名字段的密码 crypt 表示加密方式，0表示不加密；1表示crypt（3）加密；2表示使用mysql password（）函数加密；3表示md5加密；4表示sha1加密 （5）创建虚拟用户配置文件 [root@localhost/etc/vsftpd]#mkdir vdocs[root@localhost/etc/vsftpd]#cd vdocs/[root@localhost/etc/vsftpd/vdocs]#vim joah [root@localhost/etc/vsftpd/vdocs]#vim li （6）修改/etc/vsftpd/vsftpd.conf 在配置文件中添加如下内容 128 guest_enable=YES 129 guest_username=ftpuser 130 pam_service_name=vsftpd.mysql 131 user_config_dir=/etc/vsftpd/vdocs （7）重启服务并测试]]></content>
      <categories>
        <category>文件管理</category>
        <category>FTP</category>
        <category>基于数据库验证vsftpd虚拟用户</category>
      </categories>
      <tags>
        <tag>数据库，vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axel]]></title>
    <url>%2F2017%2F11%2F28%2Faxel%2F</url>
    <content type="text"><![CDATA[axelaxel是 Linux 下一个不错的HTTP/FTP高速下载工具。支持多线程下载、断点续传，且可以从多个地址或者从一个地址的多个连接来下载同一个文件。适合网速不给力时多线程下载提高下载速度 --max-speed=x -s x 最大速度（字节/秒） --num-connections=x -n x 最大连接数 --output=f -o f 指定文件名 --search[=x] -S [x] 从镜像搜索并下载 --header=x -H x 添加头部 --user-agent=x -U x 设置用户代理 --no-proxy -N 不使用任何代理 --quiet -q 静默 --verbose -v 显示更多状态信息 --alternate -a 显示简单进度条 --version -V 显示版本信息 示例： [root@localhost~]#axel -n 3 -o /root ftp://172.18.0.1/pub/ISOs/CentOS-6.9-x86_64-bin-DVD1.iso]]></content>
      <categories>
        <category>命令</category>
        <category>axel</category>
      </categories>
      <tags>
        <tag>命令使用，curl，elinks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AIDE]]></title>
    <url>%2F2017%2F11%2F28%2FAIDE%2F</url>
    <content type="text"><![CDATA[一、AIDE当一个入侵者进入了你的系统并且种植了木马，通常会想办法来隐蔽这个木马（除了木马自身的一些隐蔽特性外，他会尽量给你检查系统的过程设置障碍），通常入侵者会修改一些文件，比如管理员通常用ps -aux来查看系统进程，那么入侵者很可能用自己经过修改的ps程序来替换掉你系统上的ps程序，以使用ps命令查不到正在运行的木马程序。如果入侵者发现管理员正在运行crontab作业，也有可能替换掉crontab程序等等。所以由此可以看出对于系统文件或是关键文件的检查是很必要的。目前就系统完整性检查的工具用的比较多的有两款：Tripwire和AIDE，前者是一款商业软件，后者是一款免费的但功能也很强大的工具。 1、AIDE 概念AIDE(Adevanced Intrusion Detection Environment)高级入侵检测环境)是一个入侵检测工具，主要用途是检查文件的完整性，审计计算机上的那些文件被更改过了。 2、工作机制AIDE能够构造一个指定文件的数据库，它使用aide.conf作为其配置文件。AIDE数据库能够保存文件的各种属性，包括：权限(permission)、索引节点序号(inode number)、所属用户(user)、所属用户组(group)、文件大小、最后修改时间(mtime)、创建时间(ctime)、最后访问时间(atime)、增加的大小以及连接数。AIDE还能够使用下列算法：sha1、md5、rmd160、tiger，以密文形式建立每个文件的校验码或散列号。 建议：这个数据库不应该保存那些经常变动的文件信息，例如：日志文件、邮件、/proc文件系统、用户起始目录以及临时目录。 二、AIDE使用介绍1、安装AIDE包[root@centos6~]#yum install -y aide 2、AIDE的配置文件/etc/aide.conf The location of the database to be read. aide检查是从下面的文件中读取database=/var/lib/aide/aide.db.gz The location of the database to be written.aide更新数据库是写到下面文件中database_out=/var/lib/aide/aide.db.new.gz 设定选项 解释 p permissions i inode n number of links u user g group s size b block count m mtime a atime c ctime S check for growing size acl Access Control Lists selinux SELinux security context xattrs Extended file attributes md5 md5 checksum sha1 sha1 checksum sha256 sha256 checksum sha512 sha512 checksum rmd160 rmd160 checksum tiger tiger checksum 定义检测属性时可以组合定义，相当于alias作用。 3、aide命令介绍 选项 解释 -i，–init 初始化数据库 -C，–check 检查数据库 -u，–update 更新数据库 初始化数据库： [root@centos6~]#aide --init 查看/var/lib/aide/目录下是否生成数据库 检查数据库时，必须把命令该为aide.db.gz才能检查数据库。 [root@centos6/var/lib/aide]#mv aide.db.new.gz aide.db.gz[root@centos6~]#aide -C 更新数据库 [root@centos6~]#aide -u]]></content>
      <categories>
        <category>安全</category>
        <category>AIDE</category>
      </categories>
      <tags>
        <tag>AIDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LAMP源码编译安装]]></title>
    <url>%2F2017%2F11%2F28%2FLAMP%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[编译安装LAMP环境在实际环境中我们经常根据自己所处的公司环境进行配置，适合自己公司的配置。下面我们来介绍如何进行编译安装 安装前提在CentOS7 系统: 关闭iptables 将selinux设置为disabled apr-1.6.2.tar.gz httpd-2.4.27.tar.bz2 php-7.1.10.tar.xz apr-util-1.6.0.tar.gz mariadb-10.2.8-linux-x86_64.tar.gz wordpress-4.8.1-zh_CN.tar.gz 安装工具包development tools 注意：这里安装需要按顺序进行的mariadb–&gt;httpd–&gt;php，mariadb和httpd安装顺序没有关系 源码编译httpd服务在之前的apache博客中讲过为什么要安装apr和apr-util包，如果不懂请查看apache博客。 （1）源码编译安装apr[root@localhost/usr/local/src]#tar xvf apr-1.6.2.tar.gz[root@localhost/usr/local/src/apr-1.6.2]#./configure --prefix=/app/apr[root@localhost/usr/local/src/apr-1.6.2]#make &amp;&amp; make install （2）源码编译安装apr-util[root@localhost/usr/local/src]#tar xf apr-util-1.6.0.tar.gz[root@localhost apr-util-1.6.0]# yum install -y expat-devel[root@localhost/usr/local/src/apr-util-1.6.0]#./configure --prefix=/app/apr-util --with-apr=/app/apr[root@localhost/usr/local/src/apr-util-1.6.0]#make &amp;&amp; make install （3）源码安装httpd首先确认系统上是否有apache用户，如果没有需要创建 [root@localhost/usr/local/src]#useradd -r -m -d /app/website -s /sbin/nologin apache[root@localhost/usr/local/src]#tar xf httpd-2.4.27.tar.bz2 在编译安装httpd之前需要安装几个依赖包 [root@localhost/usr/local/src/httpd-2.4.27]#yum install -y pcre-devel apr-devel apr-util-devel openssl-devel [root@localhost/usr/local/src/httpd-2.4.27]#./configure --prefix=/app/httpd24 --enable-so --enable-ssl --enable-cgi --enable-rewrite --with-zlib --with-pcre --with-apr=/app/apr/ --with-apr-util=/app/apr-util/ --enable-modules=most --enable-mpms-shared=all --with-mpm=prefork [root@localhost/usr/local/src/httpd-2.4.27]#make -j 4 &amp;&amp; make install （4）设置环境变量[root@localhost/etc/profile.d]#vim httpd24.sh export PATH=/app/httpd24/bin:$PATH [root@localhost/etc/profile.d]#source httpd24.sh （5）设置man手册位置[root@localhost/etc]#vim /etc/man_db.conf 23 MANDATORY_MANPATH /app/httpd24/man （6）配置启动脚本[root@localhost/app/httpd24]#cp bin/apachectl /etc/init.d/httpd24 （7）测试服务是否正常启动已经监听80端口说明可以启动 http://192.168.4.60/ ###二进制安装mariadb（1）二进制安装mariadb[root@localhost/usr/local]#useradd -r -m -d /app/mysqldb -s /sbin/nologin mysql[root@localhost/usr/local/src]#tar xf mariadb-10.2.8-linux-x86_64.tar.gz -C /usr/local/[root@localhost/usr/local]#ln -sv mariadb-10.2.8-linux-x86_64/ mysql （2）添加环境变量[root@localhost/etc/profile.d]#vim mysql.sh PATH=/usr/local/mysql/bin:$PATH （3）配置man手册[root@localhost/usr/local/mysql/bin]#vim /etc/man_db.conf 24 MANDATORY_MANPATH /usr/local/mysql/man （4）创建启动脚本 [root@localhost/usr/local/mysql]#cp support-files/mysql.server /etc/init.d/mysqld[root@localhost/usr/local/mysql]#chkconfig --add mysqld （5）配置主配置文件[root@localhost/usr/local/mysql]#mkdir /etc/mysql[root@localhost/usr/local/mysql]#cp support-files/my-large.cnf /etc/mysql/my.cnf[root@localhost/usr/local/mysql]#vim /etc/mysql/my.cnf 27 [mysqld] 28 datadir = /app/mysqldb （6）创建日志目录[root@localhost/usr/local/mysql]#mkdir /var/log/mariadb[root@localhost/usr/local/mysql]#setfacl -Rm u:mysql:rwx /var/log/mariadb/（7）安装数据库[root@localhost/usr/local/mysql]#scripts/mysql_install_db --user=mysql --datadir=/app/mysqldb （8）初始化数据库[root@localhost~]#mysql_secure_installation（9）测试数据库是否安装成功 [root@localhost~]#mysql -u root -p MariaDB [(none)]&gt; CREATE DATABASE wpdb; Query OK, 1 row affected (0.00 sec) MariaDB [(none)]&gt; GRANT ALL ON wpdb.* TO &apos;joah&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;; Query OK, 0 rows affected (0.00 sec) MariaDB [(none)]&gt; GRANT ALL ON wpdb.* TO &apos;joah&apos;@&apos;127.0.0.1&apos; IDENTIFIED BY &apos;123456&apos;; 源码安装php（1）解压缩并编译安装[root@localhost/usr/local/src/php-7.1.10]#yum install -y libxml2-devel bzip2-devel libmcrypt-devel[root@localhost/usr/local/src/php-7.1.10]#./configure --prefix=/app/php --enable-mysqlnd -- with-mysqli=mysqlnd --with-openssl --with-pdo-mysql=mysqlnd --enable-mbstring --with freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml --enable-sockets -- with-apxs2=/app/httpd24/bin/apxs --with-mcrypt -- with-config-file-path=/etc --with-config-file-scan-dir=/etc/php.d --enable-maintainer-zts --disable-fileinfo[root@localhost/usr/local/src/php-7.1.10]#make &amp;&amp; make install（2）配置主配置文件[root@localhost/usr/local/src/php-7.1.10]#cp php.ini-production /etc/php.ini（3）修改/etc/httpd/conf/httpd.conf 259 &lt;IfModule dir_module&gt; 260 DirectoryIndex index.php index.html 261 &lt;/IfModule&gt; 512 AddType Application/x-httpd-php .php 513 AddType Application/x-httpd-php-source .phps （4）测试能否与httpd连接成功[root@localhost/app/httpd24/htdocs]#vim index.php 1 &lt;?php 2 phpinfo(); 3 ?&gt; （5）测试是否能否可以和mariadb连接成功[root@localhost/app/httpd24/htdocs]#vim index.php &lt;?php $mysqli=new mysqli(&quot;localhost&quot;,&quot;root&quot;,&quot;centos&quot;); if(mysqli_connect_errno()){ echo &quot;连接数据库失败!&quot;; $mysqli=null; exit; } echo &quot;连接数据库成功!&quot;; $mysqli-&gt;close(); phpinfo(); ?&gt; 安装wordpress（1）解压缩[root@localhost/usr/local/src]#tar xf wordpress-4.8.tar.gz -C /app/httpd24/htdocs （2）配置主配置文件[root@localhost/app/httpd24/htdocs/wordpress]#cp wp-config-sample.php wp-config.php[root@localhost/app/httpd24/htdocs/wordpress]#vim wp-config.php 23 define(&apos;DB_NAME&apos;, &apos;wpdb&apos;); 24 25 /** MySQL database username */ 26 define(&apos;DB_USER&apos;, &apos;joah&apos;); 27 28 /** MySQL database password */ 29 define(&apos;DB_PASSWORD&apos;, &apos;123456&apos;); 30 31 /** MySQL hostname */ 32 define(&apos;DB_HOST&apos;, &apos;localhost&apos;); http://192.168.4.59/wordpress/wp-admin/setup-config.php 测试其性能如何[root@localhost/app/httpd24/htdocs/wordpress]#ab -c 10 -n 100 http://192.168.4.60/wordpress/ HTML transferred: 5209700 bytes Requests per second: 25.25 [#/sec] (mean) #在没有加速器性能还不错 Time per request: 396.061 [ms] (mean) CentOS 6 源码编译安装前环境准备 apr-1.6.2.tar.gz httpd-2.4.27.tar.bz2 php-5.6.31.tar.xz xcache-3.2.0.tar.bz2 apr-util-1.6.0.tar.gz mariadb-5.5.57-linux-x86_64.tar.gz wordpress-4.8.1-zh_CN.tar.gz 二进制安装mariadb（1）二进制安装mariadb[root@localhost/usr/local]#useradd -r -m -d /app/mysqldb -s /sbin/nologin mysql[root@localhost/usr/local/src]#tar xf mariadb-10.2.8-linux-x86_64.tar.gz -C /usr/local/[root@localhost/usr/local]#ln -sv mariadb-10.2.8-linux-x86_64/ mysql （2）添加环境变量[root@localhost/etc/profile.d]#vim mysql.sh PATH=/usr/local/mysql/bin:$PATH （3）配置man手册[root@localhost/usr/local/mysql/bin]#vim /etc/man_db.conf 24 MANDATORY_MANPATH /usr/local/mysql/man （4）创建启动脚本 [root@localhost/usr/local/mysql]#cp support-files/mysql.server /etc/init.d/mysqld[root@localhost/usr/local/mysql]#chkconfig --add mysqld （5）配置主配置文件[root@localhost/usr/local/mysql]#mkdir /etc/mysql[root@localhost/usr/local/mysql]#cp support-files/my-large.cnf /etc/mysql/my.cnf[root@localhost/usr/local/mysql]#vim /etc/mysql/my.cnf 27 [mysqld] 28 datadir = /app/mysqldb （6）创建日志目录[root@localhost mysql]# touch /var/log/mysqld.log （7）安装数据库[root@localhost/usr/local/mysql]#scripts/mysql_install_db --user=mysql --datadir=/app/mysqldb （8）初始化数据库 [root@localhost~]#mysql_secure_installation （9）测试数据库是否安装成功 [root@localhost~]#mysql -u root -p MariaDB [(none)]&gt; CREATE DATABASE wpdb; Query OK, 1 row affected (0.00 sec) MariaDB [(none)]&gt; GRANT ALL ON wpdb.* TO &apos;joah&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;; Query OK, 0 rows affected (0.00 sec) MariaDB [(none)]&gt; GRANT ALL ON wpdb.* TO &apos;joah&apos;@&apos;127.0.0.1&apos; IDENTIFIED BY &apos;123456&apos;; 编译安装httpd服务（1）解压缩httpd源码包[root@localhost httpd-2.4.27]# yum install -y apr-devel apr-util-devel openssl-devel pcre-devel[root@localhost httpd-2.4.27]# tar xf apr-1.6.2.tar.gz[root@localhost httpd-2.4.27]# tar xf apr-util-1.6.0.tar.gz[root@localhost httpd-2.4.27]# mv apr-1.6.2 httpd-2.4.27/srclib/[root@localhost httpd-2.4.27]# mv apr-util-1.6.0 httpd-2.4.27/srclib/apr-util[root@localhost httpd-2.4.27]# ./configure --prefix=/app/httpd24 --enable-so --enable-ssl --enable-rewrite --with-zlib --with-pcre --with-included-apr --enable-modules=most --enable-mpms-shared=all --with-mpm=prefork[root@localhost httpd-2.4.27]# make &amp;&amp; make install （2）配置环境变量 [root@localhost httpd24]# vim /etc/profile.d/httpd24.sh PATH=/app/httpd24/bin:$PATH（3）配置启动脚本 [root@localhost httpd24]# cp /etc/init.d/httpd /etc/init.d/httpd24[root@localhost httpd24]# vim /etc/init.d/httpd24 apachectl=/app/httpd24/bin/apachectl httpd=${HTTPD-/app/httpd24/bin/apachectl} prog=httpd pidfile=${PIDFILE-/app/httd24/logshttpd.pid} lockfile=${LOCKFILE-/var/lock/subsys/httpd24} RETVAL=0 STOP_TIMEOUT=${STOP_TIMEOUT-10} （4）测试是否配置成功 [root@localhost httpd24]# service httpd24 start 编译安装php安装方式一：基于php模块安装（1）解压缩并编译安装[root@localhost php-5.6.4]#yum install libxml2-devel bzip2-devel libmcrypt-devel[root@localhost php-5.6.31]# ./configure --prefix=/app/php --with-mysql=/usr/local/mysql --with-openssl --with-mysqli=/usr/local/mysql/bin/mysql_config --enable-mbstring --with-png-dir --with-jpeg-dir --with-freetype-dir --with-zlib --with-libxml-dir=/usr --enable-xml --enable-sockets --with-apxs2=/app/httpd24/bin/apxs --with-mcrypt --with-config-file-path=/etc --with-config-file-scan-dir=/etc/php.d --with-bz2 [root@localhost php-5.6.4]# make &amp;&amp; make install （2）配置主配置文件 [root@localhost php-5.6.31]# cp php.ini-production /etc/php.ini （3）在httpd.conf中配置 259 &lt;IfModule dir_module&gt; 260 DirectoryIndex index.php index.html 261 &lt;/IfModule&gt; 512 AddType Application/x-httpd-php .php 513 AddType Application/x-httpd-php-source .phps 接下的步骤和CentOS 7中的配置类似，请参考上述配置。 （4）配置环境变量 [root@localhost php]# vim /etc/profile.d/php.sh PATH=/app/php/bin:$PATH [root@localhost php]# source /etc/profile.d/php.sh （5）测试是否可以与apache通信 [root@localhost htdocs]# vim index.php &lt;?php phpinfo(); ?&gt; （6）测试是否可以与mysql通信 &lt;?php $msyqli=new mysqli(&quot;192.168.4.132&quot;,&quot;root&quot;,&quot;123456&quot;); if(mysqli_connect_errno()){ echo &quot;failure&quot;; $mysqli=null; exit; } echo &quot;ok&quot;; $mysqli-&gt;close; phpinfo(); ?&gt; （7）安装wordpress 步骤和CentOS7安装一样可以参考 （8）源码编译安装加速器 [root@localhost xcache-3.2.0]# phpize #生成configure[root@localhost xcache-3.2.0]# ./configure --enable-xcache --with-php-config=/app/php/bin/php-config[root@localhost xcache-3.2.0]# make &amp;&amp; make install 安装方式二：基于php-fpm模块安装[root@localhost php-5.6.31]# ./configure --prefix=/app/php5 --with-mysql=/usr/local/mysql --with-openssl --with-mysqli=/usr/local/mysql/bin/mysql_config --enable-mbstring --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml --enable-sockets --enable-fpm --with-mcrypt --with-config-file-path=/etc/php5 --with-config-file-scan-dir=/etc/php5.d --with-bz2[root@localhost php-5.6.31]# make &amp;&amp; make install （2）准备启动脚本文件 [root@localhost php-5.6.31]# cp sapi/fpm/init.d.php-fpm.in /etc/rc.d/init.d/php-fpm[root@localhost php-5.6.31]# chmod +x /etc/rc.d/init.d/php-fpm[root@localhost php-5.6.31]# chkconfig --add php-fpm （3）配置环境变量 [root@localhost php-5.6.31]# vim /etc/profile.d/php-fpm.sh[root@localhost php-5.6.31]# source /etc/profile.d/php-fpm.sh （4）创建主配置文件 [root@localhost etc]# mkdir /etc/php5[root@localhost etc]# cp /usr/local/src/php-5.6.31/php.ini-production /etc/php5/php.ini （5）准备服务配置文件 [root@localhost etc]# cp php-fpm.conf.default php-fpm.conf （6）编辑/app/httpd24/conf/httpd.conf 取消注释，启用此模块 LoadModule proxy_module modules/mod_proxy.so LoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so 在配置文件末尾追加如下 AddType Application/x-httpd-php .php AddType Application/x-httpd-php-source .phps ProxyRequests off ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/app/httpd24/htdocs/$1 （7）启动php-fpm服务 [root@localhost etc]# service php-fpm start （8）测试是否可以与mysql和httpd连接成功 http://192.168.4.132/ （9）安装wordpress 安装过程和CentOS 7中安装一样，可以参考上述过程 （10）测试性能如何 Requests per second: 579.84 [#/sec] (mean) Time per request: 17.246 [ms] (mean) Time per request: 1.725 [ms] (mean, across all concurrent requests) Transfer rate: 37900.46 [Kbytes/sec] received]]></content>
      <categories>
        <category>服务</category>
        <category>LAMP</category>
        <category>LAMP源码编译安装</category>
      </categories>
      <tags>
        <tag>LAMP，lamp，php，php-fpm，源码编译安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BIND编译安装]]></title>
    <url>%2F2017%2F11%2F28%2FBIND%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[编译安装bind （1）下载源码包 https://www.isc.org/downloads/ （2）解压缩源码包 [root@localhost~]#mv bind-9.10.6.tar.gz /usr/src/ [root@localhost~]#cd /usr/src/ [root@localhost/usr/src]#tar xvf bind-9.10.6.tar.gz （3）来我们先看看bind包原来有没有安装脚本呢？ [root@localhost ~]# rpm -q --scripts bind 从图中我们可以看出，安装前需要自己创建用户，那么我们来创建一个用户吧 [root@localhost/usr/src/bind-9.10.6]#useradd -r -d /var/named -s /sbin/nologin -m named #这里由于是系统用户，如果不加“-m”的话，是不能创建家目录的，切记！！！ （4）我们接下来看看如何安装bind [root@localhost/usr/src/bind-9.10.6]#cat README 如果直接向定制bind程序，显然这样做是不能满足我们的需求的，我们可以使用如下操作定制我们bind程序 [root@localhost/usr/src/bind-9.10.6]#./configure --help 如上图所示，这里只是截取部分图，这里可以选择我们要安装的包位置，启用或关闭某些功能，实现定制bind，相信很多第一次编译的像我这样的人来说认真研究一种程序源码安装过程，基本可以掌握别的源码包的安装。 [root@localhost/usr/src/bind-9.10.6]#./configure --prefix=/app/bind10 --sysconfdir=/etc/bind10 来来看看，我说什么了，当出现这是不是不知道如何操作，没有人家说的很清楚了，没有gcc，那该如何解决呢？那么我们来安装一个开发包来解决这个问题 [root@localhost/usr/src/bind-9.10.6]#yum groupinstall -y &quot;development tools&quot; 那我们再来尝试一次，看看这次会出现什么幺蛾子。 [root@localhost/usr/src/bind-9.10.6]#./configure --prefix=/app/bind10 --sysconfdir=/etc/bind10 看看我说什么来着，这次又出错啦，为什么呢？它提示我们说没有openssl程序，如果想依赖这个程序，可以安装openssl-devel；一般源码包遇到的情况，都安装相对的开发包即可。 那我们再来测试一次，看看还会出现什么情况呢？ 当当当，哈哈，竟然成功啦 ；不过这只是成功了一部分，如果想继续成功那就实行下面步骤吧 （5）进行编译安装 [root@localhost/usr/src/bind-9.10.6]#make ;make install make 的作用是开始进行源代码编译，以及一些功能的提供，这些功能由他的 Makefile 设置文件提供相关的功能； make install 一般表示进行安装，相当于创建软连接，创建目录等等一些操作。 （6）这样安装的话是没有命令PATH和man帮助的，那如何实现呢？ [root@localhost~]#vim /etc/profile.d/env.sh [root@localhost~]#source !$ source /etc/profile.d/env.sh export PATH=/app/bind10/bin:/app/bind10/sbin:$PATH [root@localhost~]#vim /etc/man_db.conf （7）刚刚在（2）比步骤是不是看看还有安装后脚本呀，对的你没有看错，那么我们来进行安装后脚本需要的操作。安装后脚本需要我们使用命令rndc-confgen创建相当于”暗号“，创建了暗号才能访问，那么我们就看看如何创建暗号呢？ [root@localhost~]#rndc-confgen -r /dev/urandom &gt; /etc/bind10/rndc.conf #如果不重定向只能在终端上显示，写不到文件中 不过我们现在还没有主配置文件named.conf文件，怎么办呢？那就手动创建一个喽 [root@localhost~]#vim /etc/bind10/named.conf 不过刚刚我们了解到bind程序运行者是named用户，但是我们来看看这个文件所有者和所属组是who [root@localhost~]#ll /etc/bind10/named.conf -rw-r--r--. 1 root root 200 Sep 22 10:19 /etc/bind10/named.conf [root@localhost~]#chgrp named /etc/bind10/named.conf #修改所属组 [root@localhost/etc/bind10]#chgrp named bind10/ -R #修改文件都为named所属组 （8）不过DNS中解析当然需要根啦那么我们就创建一个喽 [root@localhost named]# scp named.ca 192.168.4.152:/var/named/ #从远程主机上拷贝一个 [root@localhost/var]#chgrp named named/ -R #修改权限 [root@localhost~]#vim /etc/bind10/named.conf [root@localhost/var/named]#vim test.com.zone #编辑测试域 [root@localhost/var/named]#chgrp named test.com.zone #修改权限 （9）那我们接下来尝试着看看能不能起来服务 [root@localhost~]#named -u named -g -f -d 3 [root@localhost~]#ss -tnul 端口53/tcp 53/udp 953/tcp 已经处于监听状态，说明启动已经成功 （10）我们尝试看看可以解析么？ 那么接下来测测我们dns的性能如何喽 对压力测试工具编译安装 [root@localhost ~]# cd /usr/src/bind-9.10.6/contrib/queryperf #切换至源码包位置 [root@localhost/usr/src/bind-9.10.6/contrib/queryperf]#./configure #进行编译 [root@localhost/usr/src/bind-9.10.6/contrib/queryperf]#make [root@localhost/usr/src/bind-9.10.6/contrib/queryperf]#cp queryperf /app/bind10/bin/ #将程序复制到bind执行程序的目录下 创建一个测试文本 [root@localhost~]#vim test 测试 [root@localhost~]#queryperf -d test -s 127.0.0.1]]></content>
      <categories>
        <category>服务</category>
        <category>DNS</category>
        <category>BIND编译安装</category>
      </categories>
      <tags>
        <tag>BIND编译安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LAMP简单介绍]]></title>
    <url>%2F2017%2F11%2F28%2FLAMP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、LAMP1、概念LAMP指的Linux（操作系统）、ApacheHTTP 服务器，MySQL（有时也指MariaDB，数据库软件） 和PHP（有时也是指Perl或Python） 的第一个字母，一般用来建立web应用平台。 2、web资源的类型静态资源：原始形式与相应内容一致。 动态资源：原始形式通常为程序文件，需要在服务器端执行之后哦，将执行结果返回给客户端。 3、LAMP结构 CGI：Commom Gateway Interface可以让一个客户端从网页浏览器通过http服务器向执行在网络服务器上的程序传输数据；CGI描述了客户端与服务器程序之间传输的一种标准。 程序=指令（代码文件）+数据（数据存储系统、文件） 请求过程： Client--(http协议)--&gt;httpd--&gt;(CGI)--&gt;application server（program file）--&gt;（mysql）--&gt;mysql 二、PHP1、PHP简介PHP（PHP: Hypertext Preprocessor）是通用服务器端脚本编程语言，主要用于web开发实现动态web页面，也是最早实现将脚本嵌入HTML源码文档中的服务器端脚本语言之一。同时，php还提供了一个命令行接口，因此，其也可以在大多数系统上作为一个独立的shell来使用 2、PHP配置（1）配置文件 /etc/php.ini /etc/php.d/*.ini 配置文件在php解释器启动时被读取。 （2）配置文件格式 directive = value 注释符： #：纯粹的注释信息 ;：用于注释可启用的directive；较新的版本中，已经全部使用“；”进行注释。 （3）php.ini配置文件设置 max_execution_time = 30 #最长执行时间30s memory_limit 128 #内存限制，但是实际生产中不够，可调大此值 display——startup_errors off #显示启动时出错信息，建议关闭，如果不关闭，会有可能显示一些重要信息 post_max_size 8M #最大上传数据大小，生产环境中可能临时调大 upload_max_filesize 2M #最大上传文件大小，生产环境中可能要调大。但是要比post_max_size值要小。 max_file_uploads = 20 #同时上传最多文件数 date.timezone = Aisa/shanghai #指定时区 short_open_tag = on 开启端标签，如&lt;?phpinfo()&gt; 如果想了解更多请查看http://php.net/manual/zh/ini.core.php （4）PHP的加速器php的加速器：基于PHP的特殊扩展机制如opcode缓存扩展也可以将opcode缓存于php的共享内存中，从而可以让同一段代码的后续重复执行时跳过编译阶段以提高性能。这些加速器并非真正提高了opcode的运行速度，而仅是通过分析opcode后并将它们重新排列以达到快速执行的目的。 类型 APC (Alternative PHP Cache)遵循PHP License的开源框架，PHP opcode缓存加速器，目前的版本不适用于PHP 5.4 项目地址http://pecl.php.net/package/APC eAccelerator源于Turck MMCache，早期的版本包含了一个PHP encoder和 PHP loader，目前encoder已经不在支持。项目地址 http://eaccelerator.net/ XCache快速而且稳定的PHP opcode缓存，经过严格测试且被大量用于生产环境。项目地址：http://xcache.lighttpd.net/,收录EPEL源 Zend Optimizer和Zend Guard Loader Zend Optimizer并非一个opcode加速器，它是由ZendTechnologies为PHP5.2及以前的版本提供的一个免费、闭源的PHP扩展，其能够运行由Zend Guard生成的加密的PHP代码或模糊代码。 而Zend Guard Loader则是专为PHP5.3提供的类似于Zend Optimizer功能的扩展。项目地址 http://www.zend.com/en/products/guard/runtime-decoders 加速器，它支持装载通过NuSphere PHP Encoder编码的PHP程序文件，并能够实现对常规PHP文件的执行加速。项目地址，http://www.nusphere.com/products/phpexpress.htm 三、LAMP构建我们在构建LAMP服务时，需要每一个服务都要测试成功，必须在安装完此服务之后，测试服务是否工作正常；与其他服务是否能测试成功。在安装之前我们必须得知道php是依赖于mysql\mariadb和apache服务的，所有我们必须按前两个服务再安装php。如果先安装php也不是不可，慢慢的拍错，想必一定会成功的。 下面的过程在CentOS 6 中进行配置。 1、httpd安装（1）使用yum源安装[root@localhost ~]# yum install -y httpd （2）配置主配置文件/etc/httpd/conf/httpd.conf[root@localhost ~]# vim /etc/httpd/conf/httpd.conf ServerTokens prod #修改响应报文显示系统信息 ServerName www.example.com:79 #如果不开启这项，启动会提示如下内容： Starting httpd: httpd: Could not reliably determine the server&apos;s fully qualified domain name, using localhost.localdomain for ServerName （3）设为开机启动并启动httpd服务[root@localhost ~]# chkconfig httpd on[root@localhost ~]# service httpd start[root@localhost ~]# ss -tnl #建议启动后查看端口是否启动 （4）测试是否成功 2、mysql安装（1）使用yum源安装[root@localhost ~]# yum install -y mysql-server （2）设置为开机启动并启动mysql服务[root@localhost ~]# chkconfig mysqld on[root@localhost ~]# chkconfig --list mysqld mysqld 0:off 1:off 2:on 3:on 4:on 5:on 6:off [root@localhost ~]# service mysqld start （3）初始化数据库[root@localhost ~]# mysql_secure_installation详细的内容向看mysql配置http://merit.blog.51cto.com/10757694/1968557 （4）创建用户mysql&gt; CREATE DATABASE wpdb; #创建数据路 mysql&gt; GRANT ALL PRIVILEGES ON wpdb.* TO joah@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;; #授权用户对wpdb权限 mysql&gt; GRANT ALL PRIVILEGES ON wpdb.* TO joah@&#39;127.0.0.1&#39; IDENTIFIED BY &#39;123456&#39;; #授权用户对wpdb权限 mysql&gt; SELECT user,host,password FROM mysql.user; +------+-----------+-------------------------------------------+ | user | host | password | +------+-----------+-------------------------------------------+ | root | localhost | *6B8CCC83799A26CD19D7AD9AEEADBCD30D8A8664 | | root | 127.0.0.1 | *6B8CCC83799A26CD19D7AD9AEEADBCD30D8A8664 | | joah | 127.0.0.1 | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 | | joah | localhost | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 | +------+-----------+-------------------------------------------+ 4 rows in set (0.00 sec) （5）测试是否成功[root@localhost ~]# mysql -ujoah -p 3、php安装（1）使用yum源安装php[root@localhost ~]# yum install -y php php安装相当于添加了一份配置文件在/etc/httpd/conf.d/目录，如果要使其生效重新启动httpd服务即可。 4、测试php和httpd是否配置成功（1）在/var/www/html目录下创建文件测试[root@localhost html]# vim index.php &lt;?php echo &quot;&lt;h&gt;success&lt;/h&gt;&quot;; phpinfo(); ?&gt; [root@localhost html]# service httpd restart #重启测试是否成功 5、测试php是否可以和数据库连接成功（1）php-mysql安装不过在测试之前需安装一个程序包使其能相互关联作用。 The php-mysql package contains a dynamic shared object that will add MySQL database support to PHP. MySQL is an object-relational database management system. PHP is an HTML-embeddable scripting language. If you need MySQL support for PHP applications, you will need to install this package and the php package. 提供了一个动态分享库使mysql数据库支持php [root@localhost ~]# yum install -y php-mysql （2）编辑index.php文件测试方法一： &lt;?php $conn = mysql_connect(&apos;localhost&apos;,&apos;joah&apos;,&apos;123456&apos;); if($conn) echo &quot;ok&quot;; else echo &quot;failure&quot;; mysql_close(); ?&gt; 测试方法二： 编辑index.php文件 &lt;?php $mysqli=new mysqli(&quot;localhost&quot;,&quot;joah&quot;,&quot;123456&quot;); if(mysqli_connect_errno()){ echo &quot;failure&quot;; $mysqli=null; exit; } echo &quot;ok&quot;; $mysqli-&gt;close(); ?&gt; 此时我们就可以使用这个环境构建一些软件等；下面我们从phpMyadmin和wordpress这两个软件进行说明。 安装phpMyadmin（1）上传软件包并进行编译安装[root@localhost ~]# mv phpMyAdmin-4.3.5-all-languages.zip /usr/local/src/ #将上传的软件包移到到此目录下方便管理源码编译的安装包 [root@localhost src]# unzip phpMyAdmin-4.3.5-all-languages.zip -d /var/www/html/ #将此包解压至/var/www/html目录下 （2）配置配置文件[root@localhost html]# ln -sv phpMyAdmin-4.3.5-all-languages/ pma #创建软连接 [root@localhost pma]# cp config.sample.inc.php config.inc.php #准备配置文件[root@localhost pma]# vim config.inc.php #编辑配置文件在下面行输入随机数即可 重启服务测试，测试几次也不行。通过官网上查看原来php此不支持phpMyadim这个版本。 重新下载一个较低版本安装 [root@localhost html]# unzip phpMyAdmin-4.0.5-all-languages.zip [root@localhost html]# ln -sv phpMyAdmin-4.0.5-all-languages pem #创建软连接 [root@localhost pem]# cp config.sample.inc.php config.inc.php [root@localhost pem]# vim config.inc.php 重启服务测试 此时会出现错误提示，安装mbsting包即可 [[root@localhost src]# rpm -ivh php-mbstring-5.3.3-22.el6.x86_64.rpm --force #由于在CentOS6中属于epel所以需要配置epel源，但是由于本机上不了网，所以这种方式安装 重启httpd服务测试是否成功 成功，接下来就是自己配置过程了 ，此时登录的用户名和密码是数据库授权的用户和密码。 wordpress安装WordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。WordPress是一款个人博客系统，并逐步演化成一款内容管理系统软件，它是使用PHP语言和MySQL数据库开发的。用户可以在支持 PHP 和 MySQL数据库的服务器上使用自己的博客。&lt;摘自：百度&gt; （1）解压缩安装[root@localhost src]# tar xvf wordpress-4.8.tar.gz -C /var/www/html/ （2）准备配置文件方式一：[root@localhost wordpress]# cp wp-config-sample.php wp-config.php [root@localhost wordpress]# vim wp-config.php #编辑此配置文件 方式二： [root@localhost wordpress]# setfacl -Rm u:apache:rwx wordpress #由于是基于apache用户运行所有给apache用户对此文件rwx权限即可 （3）测试是否成功http://192.168.4.59/wordpress/wp-admin/setup-config.php 然后下面就可以搭建自己的博客啦！ 注意在装完数据库之后切记一定要把刚刚授权的权限删除[root@localhost html]# setfacl -b blog/]]></content>
      <categories>
        <category>服务</category>
        <category>LAMP</category>
        <category>LAMP简单介绍</category>
      </categories>
      <tags>
        <tag>LAMP，lamp，php，php-fpm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVS简单介绍]]></title>
    <url>%2F2017%2F11%2F28%2FLVS%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[LVS1、lvs（Linux Virtual Server）概念 将一组服务器通过高速的局域网地理分布的广域网相互连接，在他们前段有一个负载调度器（Load Balancer），将网络请求调度到真实的服务器上，客户访问集群系统提供的网络服务就像一台高性能、高可用的服务器一样。 工作原理 VS根据请求报文的目标IP、目标协议和端口将其调度转发至某RS，根据调度算法来挑选RS。 2、lvs集群的特点 适用性，后端服务器可运行任何支持TCP/IP的操作系统 具有良好的伸缩性 可靠性 3、lvs集群类型 LVS/NAT 通过网络地址转换，调度器重写请求报文的目标地址，根据预设的调度算法，将请求分派给后端的真实服务器；真实服务器的响应报文通过调度器时，报文的源地址呗重写再返回给客户，完成整个负载调度过程。 LVS/DR 通过改写请求报文的MAC地址，将请求发送到真是服务器，而真实服务器将响应直接返回给客户；可极大地提高集群系统的伸缩性。不过LVS/DR模型要求调度器和诊室服务器都有一块网卡连在同一个物理网段上。 LVS/TUN 由于LVS/NAT请求和响应报文都必须经过调度器地址重写，当客户端越来越多时，调度器的处理能力将成为瓶颈。为了解决这个问题，调度器把请求报文通过IP隧道转发至真实服务器，而真实服务器将响应直接返回给客户，所以调度器至处理请求报文。 4、负载调度算法###静态调度算法：根据其调度时是否考虑个RS 当前的负载状态 RR（Round Robin）轮叫 调度器通过“轮叫”调度算法将外部请求按顺序轮流分配到集群中的真实服务器上，它均等地对待每一台服务器，而不管服务器上的实际连接数和系统负载。 WRR（Weighted Round Robin）加权轮叫 调度器通过“加权轮叫”调度算法根据真实服务器的不同处理能力来调度访问请求。可以保证处理能力较强的服务器处理更多的访问流量。调度器可以自动问询真实服务器的负载情况，并动态的调整其权值。 DH（Destination Hashing）目标地址散列 根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到服务器，否则返回空。将发往同一个目标地址的请求始终转发至第一次挑中的RS，典型使用场景是正向代理缓存场景中的负载均衡，如：宽带运营商。 SH（Source Hashing）源地址散列 根据请求的源IP地址，作为散列键（Hask Key）从静态分配的散列表找出对应的服务器，若服务器时可用且未超载，将请求发送到服务器，否则返回空。也可以这样理解，实现session sticky，源IP地址Hash将来自于同一个IP地址的请求始终发往第一次挑中的RS，从而实现会话绑定。 动态调度算法；根据每RS当前的负载及调度算法进行调度 LC（Lesat Connextions）最小连接 将网络请求调度到已经建立的链接数最少的服务器上。如果集群系统的真实服务器具有相近的系统性能，采用LC可以较好地均衡负载 overhead=activeconns*256+inactiveconns WLC（Weighted Least Connections）加权最小连接 在集群系统中的服务器性能差异较大的情况下，调度器采用WLC优化均衡性能，具有在较高权值的服务器将承受较大比例的活动连接负载。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。 overhead=（activeconns*256+inactiveconns）/weight 如果第一次调度采用随机调度 LBLC（Locality-Based Least Connections）基于局部性的最少连接 LBLC针对目标IP地址的负载均衡。根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器时可用的且没有超载，将请求发送到服务器；若服务器不存在，或该服务器超载且有服务器处于一半的工作负载，则用LBLC选择出一个可用的服务器，将请求发送到该服务器。 LBLCR（Locality-Based Least Connections with Replication）带复制的基于局部性最少连接 LBLCR要维护从一个目标IP 到一组服务器的映射；根据请求的目标IP地址找出该目标IP地址对应的服务器组。按“最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按最小连接原则从这个集群中选出一台服务器，将该服务器假如到服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。 -SED（Shortest Expection Delay）初始化连接高权重优先 overhead=(activeconns+1)256/weight NQ（Never Queue） 第一轮均匀分配，后续SED算法计算调度 5、LVS集群通用结构体系 如图所示LVS采用三层结构 负载调度器：它是整个集群对外面的前段机，负责将客户的请求发送到一组服务器上执行，而客户认为服务时来自一个IP地址上的。 服务器池：一组真正执行客户请求的服务器，执行的服务如http ftp等 共享存储：为服务器池提供一个共享的存储区，使得服务器池拥有相同的内容，提供向同的服务。通常是数据库、网络文件系统或者分布式文件系统 ##6、IPVS（IP Virtual Server）是运行在LVS下的提供负载均衡功能的一种技术。IPVS软件实现了IP负载均衡技术：LVS/NAT 、LVS/TUN 、LVS/DR。 ###工作机理在基于IP负载调度技术中心，当一个TCP连接的初始SYN报文到达时，调度器就选择一台服务器，将报文转发给它。伺候通过查发报文的IP和TCP报文头地址，保证此连接的后继报文被转发到该服务器。这样，IPVS无法检查到请求的内容再选择服务器，这就要求后端的服务器组是提供相同的服务器，不管请求被发送到哪一台服务器，返回结果都应该是一样。 PS：LVS分成了两个部分，一部分工作在内核空间的一个IPVS模块（工作在Netfilter框架的input链上），另一部分工作在用户空间的一个用来定义集群服务的一个工具ipvsadm，主要定义集群服务传送给工作在内核的IPVS模块。 ipvsadm包构成配置文件 /etc/sysconfig/ipvsadm-config 服务名称 /usr/lib/systemd/system/ipvsadm.service 管理工具 /usr/sbin/ipvsadm /usr/sbin/ipvsadm-restore /usr/sbin/ipvsadm-save ipvsadm命令 管理集群服务 ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]] 选项 说明 -A，–add-service 添加VS（Virtual Server） -E,–edit-service 更改VS -D，–delete-service 删除VS -C,–clear 清空定义的所有内容 -R，–restore 重载VS表 -S,–save 保存VS规则 -t,–tcp-service TCP协议的端口，VIP:TCP_PORT -u, –udp-service UDP协议的端口 -f, –fwmark-service firemall mark标记， -p, –persistent 持久连接，指定timeout，默认为360秒 -s, –scheduler scheduling-method 指定调度算法 -Z,–zero 清空计数器 管理集群上的RS ipvsadm -a|e -t|u|f service-address -r server-address [-g|i|m] [-w weight] 选项 说明 -a, –add-server 将RS添加到VS -e, –edit-server 编辑RS -d, –delete-server 移除RS从VS -r, –real-server server-address 指定RS服务器IP -g, –gatewaying 使用网关（direct routing） -i, –ipip 使用ipip封装（tunneling） -m, –masquerading 使用伪装（NAT） -w, –weight weight 指定权重 查看 选项 说明 -L，-l，–list 列出定义规则 –numeric，-n 以数字形式输出地址和端口号 –exact 扩展信息，精确值 –connection，-c 当前IPVS连接输出 –stats 统计信息 –rate 输出速率信息 保存及重载规则 保存建议保存至/etc/sysconfig/ipvsadm ipvsadm-save &gt;/PATH/TO/IPVSADM_FILE ipvsadm -S &gt; /PATH/TO/IPVSADM_FILE systemctl stop ipvsadm.service 重载 ipvsadm-restore &lt; /PATH/FROM/IPVSADM_FILE ipvsadm -R &lt; /PATH/FROM/IPVSADM_FILE systemctl restart ipvsadm.service]]></content>
      <categories>
        <category>调度器</category>
        <category>LVS简单介绍</category>
      </categories>
      <tags>
        <tag>lvs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVS集群类型]]></title>
    <url>%2F2017%2F11%2F28%2FLVS%E9%9B%86%E7%BE%A4%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[LVS集群类型1、lvs-nat模式 本质是多目标IP 的DNAT，通过将请求报文中的目标地址和目标端口修改为某跳出的RS的RIP和PORT实现转发。 小结 （1）RIP和DIP不一定在同一个IP网络,如果VS和RS中间是相连的路由器，RS的网关需指向路由器的网关；如果VS和RS中间是相连的是交换机，RS的网关要指向DIP。应该使用私网IP（也可以使用公网IP） （2）请求报文和响应报文都必须经由Director 转发，Director容易成为系统瓶颈。 （3）支持端口映射，可以修改请求报文的目标端口 （4）VS必须是Linux系统，RS可以是任意OS系统 2、lvs-dr模式 lvs-dr：Director Routing，直接路由，LVS默认模式应用最广泛，通过为请求报文重新封装一个MAC首部进行转发，源MAC是DIP所在的接口MAC，目标MAC是某挑选出的RS的RIP所在接口的MAC地址；源IP/PORT，以及目标IP/PORT均保持不变。 lvs-dr模式，各主机上均需要配置VIP，解决地址冲突的方式有三种： 在前段网关做静态绑定，这种方法的弊端是如果后端OS坏掉，重新静态绑定 在各RS使用arptables arptables -A IN -d $VIP -j DROP arptables -A OUT -s $VIP -j mangle –mangle-ip-s $RIP 在各RS修改内核参数，来限制arp响应和通告的级别 限制响应级别：arp_ignore 0：默认值，表示可使用本地任意接口上配置的任意地址进行响应 1：仅在请求的目标IP配置在本地主机的接收到请求报文的接口上时，才给予响应 限制通告级别：arp_announce 0：默认值，把本机所有接口的所有信息向每个接口的网络进行通告 1：尽量避免将接口信息向非直接连接网络进行通告 2：必须避免将接口信息向非本网络进行通告 小结 （1）确保前段路由器将目标IP为VIP的请求报文发往Director。在前段网关做静态绑定VIP和DIrector的MAC地址 （2）RS的RIP可以使用私网地址，也可以使用公网地址；RIP的网关不能指向DIP，以确保响应报文不会经由Director。RIP与DIP可以不再同一个IP网络 （3）RS和Director如果中间是路由相连，要在同一个物理网络，逻辑上可以不再一个网段。路由器可以转发。 （4）请求报文要经由Director，但响应报文不经由Director，而由RS直接发往Client （5）不支持端口映射 （6）RS可以使用大多数OS系统 注意：RS必须配置VIP地址，如果不配置CIP接收到的响应报文不是自己目标的响应报文，拒收。 3、lvs-tun模式不修改请求报文的IP首部（源IP为CIP，目标IP为VIP），而在源IP报文之外再封装一个IP首部（源IP是DIP，目标IP是RIP），将报文发往挑选出的目标RS；RS直接响应给客户端（源IP是VIP，目标IP是CIP）。支持源距离通信。 小结 （1）DIP、VIP、RIP都应该是公网地址，也可以是私网地址（如果拉的是专线） （2）RS的网关不能指向DIP （3）请求报文要经由DIrector，但响应报文不能经由Director （4）不支持端口映射 （5）RS的OS 系统必须支持隧道功能]]></content>
      <categories>
        <category>调度器</category>
        <category>LVS集群类型</category>
      </categories>
      <tags>
        <tag>lvs，集群类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVS简单介绍二]]></title>
    <url>%2F2017%2F11%2F28%2FLVS%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Firewall Mark借助于防火墙类分类报文，而后基于标记定义集群服务；可将多个不同应用使用同一个集群服务进行调度 步骤： （1）在Director主机打标记： iptables -t mangle -A PREROUTING -d $vip -p $proto –m multiport --dports $port1,$port2,… -j MARK --set-mark NUMBER （2）在Director主机基于标记定义集群服务 ipvsadm -A -f NUMBER [options] ipvsadm -a -f NUMBER -r RIP -m 持久连接session绑定：对共享同一组RS的多个集群服务，需要统一进行绑定，lvs中sh算法无法实现。 持久连接：实现无论使用任何调度算法，在一段时间内（默认360s），能够实现将来自同一个地址的请求始终发往同一个RS。 ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]] 持久连接实现方式 每端口持久（PPC ）：每个端口对应定义为一个集群服务，每集群服务单独调度 每防火墙标记持久（PFWMC）:基于防火墙标记定义集群服务；可实现将多个端口上的应用同一调度，即所谓port affinity 每客户端持久（PCC）：基于0端口（表示所有服务）定义集群服务，即将客户端对所有应用的请求都调度至后端主机，必须定义为持久模式 LVS高可用性如果Director不可用，整个系统将不可用，SPOF（单点故障）；如果RS不可用时，Director依然会调度请求到RS上。 解决方案：由Director对个RS健康状态进行检查，失败时禁用，成功时启用。 检查方式： （1）网络层检测，icmp （2）传输层检查：端口探测 （3）应用层检测：请求某关键资源 如果RS全不能使用时，back server，sorry server ldirector：监控远程服务和控制LVS主配置文件 /etc/ha.d/ldirectord.cf 配置模版 /usr/share/doc/ldirectord-3.9.6/ldirectord.cf 服务 /usr/lib/systemd/system/ldirectord.service 主程序 /usr/sbin/ldirectord 日志 /var/log/ldirectord.log pid文件 /var/run/ldirectord.ldirectord.pid ldirectord配置文件 [root@localhost~]#cp /usr/share/doc/ldirectord-3.9.5/ldirectord.cf /etc/ha.d/ 选项 说明 checktimeout 判断RS出错的时间间隔 checkinterval 指定ldirectord在每次检查之间的间隔时间 fallback 当所有的RS不能工作时，web服务重定向的地址 autoreload 是否自动重载配置文件 logfile 指定ldirectord日志文件路径 quiescent（静态） 当选择no时，如果一个节点在checktimeout设置的时间周期内没有响应，ldirectord将会从LVS的路由表中移除RS，将终端现有的客户端连接，并是LVS丢掉所有的链接跟中记录和持续连接模板；如果选择yes，当某个RS失效时，ldirectord将失效节点的权值设置为0，新的链接不能到达，但是并不从LVS路由表清除此节点，同时连接跟踪记录和持久连接模板仍然保留在Director上。 virtual 指定虚拟的IP和端口号必须在行后面指定RS和端口号同时设置LVS工作模式 real 指定RS service 指定服务的类型 request ldirectord将根据指定的RS结合该选项给出的请求路径，发送访问请求，检查RS上的服务是否正常运行；确保这里给出的页面地址是可访问的，不然ldirectord会误从此节点已经失效，发生错误监控现象 receive 指定请求和应答字串 scheduler 指定调度算法 protocol 指定协议类型 checktype 指定ldirectord的检测类型，默认为negotiate checkport 指定监控的端口号 virtualhost 虚拟服务器的名称]]></content>
      <categories>
        <category>调度器</category>
        <category>LVS简单介绍二</category>
      </categories>
      <tags>
        <tag>lvs，firewall mark，持久连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MHA+Keepalived+MySQL主从]]></title>
    <url>%2F2017%2F11%2F28%2FMHA%2BKeepalived%2BMySQL%E4%B8%BB%E4%BB%8E%2F</url>
    <content type="text"><![CDATA[MHA+Keepalived+mysql主从 主机名 mysql keepalived MHA IP manager — — master-0.56 192.168.4.64 master mariadb-5.5.56 √ node-0.56 192.168.4.61 slave1 mariadb-5.5.56 √ node-0.56 192.168.4.62 slave2 mariadb-5.5.56 — node-0.56 192.168.4.63 各节点时间同步[root@manager~]#ntpdate 172.18.0.1 [root@manager~]#vim /etc/chrony.conf server 172.18.0.1 iburst [root@manager~]#systemctl start chronyd.service 各节点可通过主机名互相访问[root@manager~]#vim /etc/hosts 192.168.4.64 manager 192.168.4.61 master 192.168.4.62 slave1 192.168.4.63 slave2 各节点基于无密钥交叉通信（基于同一密钥认证）[root@manager~]#ssh-keygen -t rsa -P &#39;&#39; [root@manager~]#ssh-copy-id -i /root/.ssh/id_rsa.pub manager [root@manager~/.ssh]#scp authorized_keys id_rsa{,.pub} master:/root/.ssh [root@manager~/.ssh]#scp authorized_keys id_rsa{,.pub} slave1:/root/.ssh [root@manager~/.ssh]#scp authorized_keys id_rsa{,.pub} slave2:/root/.ssh 确保每个节点iptables和seline关闭配置主从复制master节点[root@master~]#vim /etc/my.cnf.d/server.cnf [server] innodb_file_per_table = ON skip_name_resolve = ON max_connections = 2000 server_id = 1 relay_log = relay-log log_bin = master-log [root@master~]#systemctl start mariadb 授权用户MariaDB [(none)]&gt; GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO joah@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39;; MariaDB [(none)]&gt; FLUSH PRIVILEGES; 查看二进制日志MariaDB [(none)]&gt; SHOW MASTER STATUS; +-------------------+----------+--------------+------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | +-------------------+----------+--------------+------------------+ | master-log.000003 | 414 | | | +-------------------+----------+--------------+------------------+ 1 row in set (0.00 sec) MariaDB [(none)]&gt; SHOW BINLOG EVENTS IN &apos;master-log.000003&apos;; +-------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------------------------------------+ | Log_name | Pos | Event_type | Server_id | End_log_pos | Info | +-------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------------------------------------+ | master-log.000003 | 4 | Format_desc | 1 | 245 | Server ver: 5.5.56-MariaDB, Binlog ver: 4 | | master-log.000003 | 245 | Query | 1 | 414 | GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO joah@&apos;192.168.4.%&apos; IDENTIFIED BY &apos;centos&apos; | +-------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------------------------------------+ slave节点[root@slave1~]#vim /etc/my.cnf.d/server.cnf [server] innodb_file_per_table = ON skip_name_resolve = ON max_connections = 2000 server_id = 2 relay_log = relay-log log_bin = master-log relay_log_purge = 0 read_only = ON [root@slave2~]#vim /etc/my.cnf.d/server.cnf [server] innodb_file_per_table = ON skip_name_resolve = ON max_connections = 2000 server_id = 3 #此处注意一定不能相同 relay_log = relay-log log_bin = master-log relay_log_purge = 0 read_only = ON 修改master为自己的主为了以后从升为主节点以后有授权，因此从二进制日志245开始 MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_USER=&#39;joah&#39;,MASTER_HOST=&#39;192.168.4.61&#39;,MASTER_PASSWORD=&#39;centos&#39;,MASTER_LOG_FILE=&#39;master-log.000003&#39;,MASTER_LOG_POS=245; MariaDB [(none)]&gt; SELECT User FROM mysql.user; 查看是否已经同步成功 MariaDB [(none)]&gt; FLUSH PRIVILEGES; 在mariadb所有节点授权用户此用户可在本地网络中又其他节点上远程访问。 MariaDB [(none)]&gt; GRANT ALL ON *.* TO mhaadmin@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39;; keepalived安装master上安装keepalived[root@master~]#yum install -y keepalived 修改配置[root@master/etc/keepalived]#cp keepalived.conf{,.bak} [root@master/etc/keepalived]#vim keepalived.conf global_defs { 4 notification_email { 5 root@localhost 6 } 7 notification_email_from keepalived@localhost 8 smtp_server 127.0.0.1 9 smtp_connect_timeout 30 10 router_id master 11 vrrp_mcast_group4 224.0.100.100 12 } 13 14 vrrp_script chk_mysql { 15 script &quot;killall -0 mysqld &amp;&amp; exit 0 ||exit 1&quot; 16 interval 1 17 weight -30 18 fall 2 19 rise 1 20 } 21 vrrp_instance VI_1 { 22 state MASTER 23 interface eth0 24 virtual_router_id 4 25 priority 100 26 advert_int 1 27 authentication { 28 auth_type PASS 29 auth_pass 152369 30 } 31 virtual_ipaddress { 32 192.168.4.55 33 } 34 track_script { 35 chk_mysql 36 } 37 } 添加IP地址[root@master/etc/keepalived]#ip addr add 192.168.4.55/24 dev eth0 启动服务[root@master/etc/keepalived]#systemctl start keepalived slave1上安装keepalived[root@slave1~]#yum install -y keepalived 3 global_defs { 4 notification_email { 5 root@localhost 6 } 7 notification_email_from keepalived@localhost 8 smtp_server 127.0.0.1 9 smtp_connect_timeout 30 10 router_id slave1 11 vrrp_mcast_group4 224.0.100.100 12 } 13 14 vrrp_script chk_mysql { 15 script &quot;killall -0 mysqld &amp;&amp; exit 0 ||exit 1&quot; 16 interval 1 17 weight -30 18 fall 2 19 rise 1 20 } 21 vrrp_instance VI_1 { 22 state SLAVE 23 interface eth0 24 virtual_router_id 4 25 priority 80 26 advert_int 1 27 authentication { 28 auth_type PASS 29 auth_pass 152369 30 } 31 virtual_ipaddress { 32 chk_mysql 33 } 34 } 添加IP地址[root@slave1/etc/keepalived]#ip addr add 192.168.4.55/24 dev eth0 启动服务MHA搭建Manager主机上安装[root@manager~]#yum install mha4mysql-manager-0.55-0.el6.noarch.rpm mha4mysql-node-0.56-0.el6.noarch.rpm mysql各节点上都安装[root@master~]#yum install mha4mysql-node-0.56-0.el6.noarch.rpm 注意：CentOS7可以直接使用适用于el6的程序包；MHA manger和MHA node程序包的版本不强制要求一样。 初始化MHAmanager节点需要为每个监控的master/slave集群提供一个专用的配置文件，并可以共享全局配置/etc/masterha_default.cnf。如果仅监控一个application，也可以直接通过application的配置来提供个服务器的默认配置信息。每个application的配置文件路径为自定义。 [root@manager~]#mkdir /etc/masterha/ [root@manager/etc/masterha]#vim app1.cnf [server default] #全局配置 user=mhaadmin password=centos manager_workdir=/data/masterha/app1 #这些目录会自动创建 manager_log=/data/masterha/app1/manager.log remote_workdir=/data/masterha/app1 ssh_user=root #基于密钥的用户 repl_user=joah #授权主从复制用户 repl_password=centos ping_interval=1 #间隔时长 [server1] hostname=192.168.4.61 ssh_port=22 candidate_master=1 [server2] hostname=192.168.4.62 ssh_port=22 candidate_master=1 [server3] hostname=192.168.4.63 ssh_port=22 no_master=1 检测各节点ssh互相配置是否成功[root@manager/etc/masterha]#masterha_check_ssh app1.cnf --conf=app1.cnf 检查管理的mysql复制集群的连接配置参数是否成功[root@manager/etc/masterha]#masterha_check_repl --conf=app1.conf 启动MHA[root@manager/etc/masterha]#masterha_manager --conf=app1.cnf 启动成功后，查看master状态[root@manager~]#masterha_check_status --conf=/etc/masterha/app1.cnf app1 (pid:38704) is running(0:PING_OK), master:192.168.4.61]]></content>
      <categories>
        <category>数据库</category>
        <category>MHA+Keepalived+MySQL主从</category>
      </categories>
      <tags>
        <tag>keepalived，mha，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bind包安装]]></title>
    <url>%2F2017%2F11%2F28%2FBind%E5%8C%85%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[实现管理DNS1、bind安装包bind-libs.x86_64 #库包 bind-libs-lite.x86_64 # bind-license.noarch #认证包 bind-utils.x86_64 #提供对dns服务器的测试工具程序 bind-chroot #为bind提供一个伪装的根目录以增强安全性 2、Bind配置文件服务脚本 /etc/rc.d/init.d/named和/usr/lib/systemcd/system/named.service 主配置文件/etc/named.conf /etc/named/rfc1912.zones 存放根服务器地址 /var/named/name.ca 解析库文件 /var/named/ZONE_NAME_ZONE 注意： （1）一台物理服务器可同时为多个区域提供解析。 （2）必须要有根文件：name.ca。 （3）应该有两个实现localhost和本地回环的解析库。 主配置文件/etc/namd.conf // named.conf // // Provided by Red Hat bind package to configure the ISC BIND named(8) DNS // server as a caching only nameserver (as a localhost DNS resolver only). // // See /usr/share/doc/bind*/sample/ for example named configuration files. #这个文件是一个参考例子 // // See the BIND Administrator&apos;s Reference Manual (ARM) for details about the // configuration located in /usr/share/doc/bind-{version}/Bv9ARM.html options { #全局设置 listen-on port 53 { 127.0.0.1; }; #IPv4监听的端口和IP地址 listen-on-v6 port 53 { ::1; }; #IPv6监听的端口 directory &quot;/var/named&quot;; #zone配置文件存放目录 dump-file &quot;/var/named/data/cache_dump.db&quot;; #下载缓存数据库 statistics-file &quot;/var/named/data/named_stats.txt&quot;; #静态文件 memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;; allow-query { localhost; }; #允许询问 /* - If you are building an AUTHORITATIVE DNS server, do NOT enable recursion. - If you are building a RECURSIVE (caching) DNS server, you need to enable recursion. control to limit queries to your legitimate users. Failing to do so will cause your server to become part of large scale DNS amplification attacks. Implementing BCP38 within your network would greatly reduce such attack surface */ recursion yes; #是否递归查询 dnssec-enable yes; #是否支持DNSSEC开关 dnssec-validation yes; #是否进行DNSSEC确认开关 /* Path to ISC DLV key */ bindkeys-file &quot;/etc/named.iscdlv.key&quot;; managed-keys-directory &quot;/var/named/dynamic&quot;; pid-file &quot;/run/named/named.pid&quot;; session-keyfile &quot;/run/named/session.key&quot;; }; logging { #日志信息 channel default_debug { file &quot;data/named.run&quot;; #存放的文件位置 severity dynamic; #工作模式 }; }; zone &quot;.&quot; IN { #根域 type hint; #zone类型 file &quot;named.ca&quot;; #文件名称 }; include &quot;/etc/named.rfc1912.zones&quot;; include &quot;/etc/named.root.key&quot;; 建议一般不要在这个文件中配置zone，可以在/etc/named.rfc1912.zones文件下进行配置。 /var/named/named.localhost 文件 $TTL 1D @ IN SOA @ rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS @ A 127.0.0.1 AAAA ::1 一般这个文件作为一个模板文件进行zone的配置。 3、DNS转发服务器 （1）全局转发：对非本机所负责区域的请求，全转发给指定的服务器。 options{ forward first|only； forwarders { IP; }; }； （2）特定区域转发：仅转发对特定区域的请求，比全局转发优先级高。 zone &quot;ZONE_NAME&quot; IN { tyep forward; forward first|only; forwarders { IP; } }; 4、从DNS服务器（1）应该为一台独立的名称服务器 （2）主服务器区域解析文件中必须有一条NS记录指向从DNS服务器 （3）从服务器只需要定义区域，而无须提供解析库；解析库文件应该放置于/var/named/slaves目录下。 （4）主服务器得允许从服务器区域传送 （5）主从服务器的时间应该保持一致 （6）Bind程序版本应该保持一致；如果不一致，建议主服务器低，从服务器高。 （7）修改网卡配置文件/etc/sysconfig/network-scripts-ifcfg-INTERFACE,添加DNS记录。 5、允许动态更新如果想启用此功能，可以在/etc/named.rfc1912.zones文件中定义之。]]></content>
      <categories>
        <category>服务</category>
        <category>DNS</category>
        <category>Bind包安装</category>
      </categories>
      <tags>
        <tag>dns，bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MHA]]></title>
    <url>%2F2017%2F11%2F28%2FMHA%2F</url>
    <content type="text"><![CDATA[MHA-MHA（Master HA）是一款开源的mysql的高可用程序，为mysql主从复制架构提供了automating master failover功能。MHA在监控到master节点故障时，会提升其中拥有最新数据的slave节点成为新的master节点，在此期间，MHA会通过与其他从节点获取额外信息来避免一致性方面的问题。MHA还提供了master节点在线切换功能。 MHA服务角色： MHA manager：通常单独部署在一台独立机器上管理多个master/slave集群，每个master/slave称为一个application MHA node：运行在每台mysql服务器，通过监控具备解析和清理logs功能的脚本来加快故障转移。 mysql复制集群中的master故障时，MHA转移 MHA组件 Manager节点 masterha_check_ssh：MHA依赖的SSH环境监测工具 masterha_check_repl：mysql复制环境监测工具 masterha_manager：MHA服务主程序 masterha_check_status：MHA运行状态探测工具 masterha_master_monitor：mysql master节点可用性探测工具 masterha_master_switch：master节点切换工具 masterha_conf_host：添加或删除配置的节点 masterha_stop：关闭MHA服务的工具 Node节点 save_binary_logs：保存和复制master的二进制日志 apply_diff_relay_logs：识别差异的中继日志并应用于其他slave purge——relay_logs：清除中继日志（不会阻塞SQL线程） 自定义扩展 secondary_check_script：通过多条网络路由检测master的可用性 master_ip_failover_script：更新application使用的masterip shutdown_script：强制关闭master节点 report_script：发送报告 init_conf_load_script：加载初始配置参数 master_ip_online_change_script：更新master节点ip地址 注意：MHA对mysql复制环境有特殊要求，各节点都要开启二进制日志及中继日志；各从节点必须显示启用其read-only属性；关闭relay_log_purege功能。 MHA实现- 各节点时间同步[root@manager~]#ntpdate 172.18.0.1 [root@manager~]#vim /etc/chrony.conf server 172.18.0.1 iburst [root@manager~]#systemctl start chronyd.service 各节点可通过主机名互相访问[root@manager~]#vim /etc/hosts 192.168.4.64 manager 192.168.4.61 master 192.168.4.62 slave1 192.168.4.63 slave2 各节点基于无密钥交叉通信（基于同一密钥认证）[root@manager~]#ssh-keygen -t rsa -P &#39;&#39; [root@manager~]#ssh-copy-id -i /root/.ssh/id_rsa.pub manager [root@manager~/.ssh]#scp authorized_keys id_rsa{,.pub} master:/root/.ssh [root@manager~/.ssh]#scp authorized_keys id_rsa{,.pub} slave1:/root/.ssh [root@manager~/.ssh]#scp authorized_keys id_rsa{,.pub} slave2:/root/.ssh 确保每个节点iptables和seline关闭配置主从复制master节点[root@master~]#vim /etc/my.cnf.d/server.cnf [server] innodb_file_per_table = ON skip_name_resolve = ON max_connections = 2000 server_id = 1 relay_log = relay-log log_bin = master-log [root@master~]#systemctl start mariadb 授权用户MariaDB [(none)]&gt; GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO joah@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39;; MariaDB [(none)]&gt; FLUSH PRIVILEGES; 查看二进制日志MariaDB [(none)]&gt; SHOW MASTER STATUS; +-------------------+----------+--------------+------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | +-------------------+----------+--------------+------------------+ | master-log.000003 | 414 | | | +-------------------+----------+--------------+------------------+ 1 row in set (0.00 sec) MariaDB [(none)]&gt; SHOW BINLOG EVENTS IN &apos;master-log.000003&apos;; +-------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------------------------------------+ | Log_name | Pos | Event_type | Server_id | End_log_pos | Info | +-------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------------------------------------+ | master-log.000003 | 4 | Format_desc | 1 | 245 | Server ver: 5.5.56-MariaDB, Binlog ver: 4 | | master-log.000003 | 245 | Query | 1 | 414 | GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO joah@&apos;192.168.4.%&apos; IDENTIFIED BY &apos;centos&apos; | +-------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------------------------------------+ slave节点[root@slave1~]#vim /etc/my.cnf.d/server.cnf [server] innodb_file_per_table = ON skip_name_resolve = ON max_connections = 2000 server_id = 2 relay_log = relay-log log_bin = master-log relay_log_purge = 0 read_only = ON [root@slave2~]#vim /etc/my.cnf.d/server.cnf [server] innodb_file_per_table = ON skip_name_resolve = ON max_connections = 2000 server_id = 3 #此处注意一定不能相同 relay_log = relay-log log_bin = master-log relay_log_purge = 0 read_only = ON 修改master为自己的主为了以后从升为主节点以后有授权，因此从二进制日志245开始 MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_USER=&#39;joah&#39;,MASTER_HOST=&#39;192.168.4.61&#39;,MASTER_PASSWORD=&#39;centos&#39;,MASTER_LOG_FILE=&#39;master-log.000003&#39;,MASTER_LOG_POS=245; MariaDB [(none)]&gt; SELECT User FROM mysql.user; 查看是否已经同步成功 MariaDB [(none)]&gt; FLUSH PRIVILEGES; 在mariadb所有节点授权用户此用户可在本地网络中又其他节点上远程访问。 MariaDB [(none)]&gt; GRANT ALL ON *.* TO mhaadmin@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;centos&#39;; MHA搭建Manager主机上安装[root@manager~]#yum install mha4mysql-manager-0.55-0.el6.noarch.rpm mha4mysql-node-0.56-0.el6.noarch.rpm mysql各节点上都安装[root@master~]#yum install mha4mysql-node-0.56-0.el6.noarch.rpm 注意：CentOS7可以直接使用适用于el6的程序包；MHA manger和MHA node程序包的版本不强制要求一样。 初始化MHAmanager节点需要为每个监控的master/slave集群提供一个专用的配置文件，并可以共享全局配置/etc/masterha_default.cnf。如果仅监控一个application，也可以直接通过application的配置来提供个服务器的默认配置信息。每个application的配置文件路径为自定义。 [root@manager~]#mkdir /etc/masterha/ [root@manager/etc/masterha]#vim app1.cnf [server default] #全局配置 user=mhaadmin password=centos manager_workdir=/data/masterha/app1 #这些目录会自动创建 manager_log=/data/masterha/app1/manager.log remote_workdir=/data/masterha/app1 ssh_user=root #基于密钥的用户 repl_user=joah #授权主从复制用户 repl_password=centos ping_interval=1 #间隔时长 [server1] hostname=192.168.4.61 ssh_port=22 candidate_master=1 [server2] hostname=192.168.4.62 ssh_port=22 candidate_master=1 [server3] hostname=192.168.4.63 ssh_port=22 no_master=1 检测各节点ssh互相配置是否成功[root@manager/etc/masterha]#masterha_check_ssh app1.cnf --conf=app1.cnf 检查管理的mysql复制集群的连接配置参数是否成功[root@manager/etc/masterha]#masterha_check_repl --conf=app1.conf 启动MHA[root@manager/etc/masterha]#masterha_manager --conf=app1.cnf 启动成功后，查看master状态[root@manager~]#masterha_check_status --conf=/etc/masterha/app1.cnf app1 (pid:38704) is running(0:PING_OK), master:192.168.4.61 测试故障转移假设master宕机 [root@master~]#systemctl stop mariadb.service 此时会检测到master down，但是此时的MHA也会停止工作，如果要使其正常工作需要将master重新上线。 查看日志[root@manager/etc/masterha]#cat /data/masterha/app1/manager.log 通过查看日志，已经顺利转移到slave1节点上了。 查看此时的状态[root@manager/etc/masterha]#masterha_check_status --conf=app1.cnf app1 is stopped(2:NOT_RUNNING). 故障恢复此时只能做从节点，需要加入从节点的配置信息 [root@master~]#vim /etc/my.cnf.d/server.cnf relay_log_purge = OFF read_only = ON [root@master~]#systemctl start mariadb.service MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_USER=&#39;joah&#39;,MASTER_HOST=&#39;192.168.4.62&#39;,MASTER_PASSWORD=&#39;centos&#39;,MASTER_LOG_FILE=&#39;master-log.000003&#39;,MASTER_LOG_POS=395; MariaDB [(none)]&gt; START SLAVE; manager再次检测[root@manager~]#nohup masterha_manager --conf=/etc/masterha/app1.cnf &amp;&gt; /data/masterha/app1/manager.log &amp; #后台运行 [root@manager~]#jobs [1]+ Running nohup masterha_manager --conf=/etc/masterha/app1.cnf &amp;&gt;/data/masterha/app1/manager.log &amp; 注意：如果主节点down必须进行重新设置。 问题：（1）提供额外的检测机制，以明对master的监控作出误判 （2）在master节点上提供虚拟ip地址向外提供服务，以名master节点转换时，客户端的请求无法正确送达。 （3）进行故障转移时对原有master节点执行STONITH操作以避免脑裂；可通过制定的shutdwon_script实现。 （4）必要时，进行在线master节点转换。]]></content>
      <categories>
        <category>数据库</category>
        <category>MHA</category>
      </categories>
      <tags>
        <tag>mha，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL主从复制]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[实战：实现主从复制 node1为主，node2为从 在node1操作[root@node1~]#vim /etc/my.cnf.d/server.cnf [root@node1~]#systemctl start mariadb 在node2操作[root@node2~]#vim /etc/my.cnf.d/server.cnf [root@node2~]#systemctl start mariadb 在node1进行授权 MariaDB [(none)]&gt; GRANT REPLICATION CLIENT,REPLICATION SLAVE ON *.* TO &apos;joah&apos;@&apos;192.168.4.62&apos; IDENTIFIED BY &apos;123456&apos;; 在node2 MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_HOST=&apos;192.168.4.61&apos;,MASTER_USER=&apos;joah&apos;,MASTER_PASSWORD=&apos;123456&apos;,MASTER_LOG_FILE=&apos;master-log.000004&apos;,MASTER_LOG_POS=417; MariaDB [(none)]&gt; START SLAVE; #启动从服务器 MariaDB [(none)]&gt; SHOW SLAVE STATUS\G; #查看从服务器状态 测试[root@node1~]#mysql &lt; hellodb.sql 在node1中查看 在node2中查看]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL主从复制</category>
      </categories>
      <tags>
        <tag>主从复制，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL主从复制读写分离]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[mysql主从复制读写分离 master和slave时间同步[root@master~]#ntpdate 172.18.0.1 [root@master~]#vim /etc/chrony.conf [root@master~]#systemctl start chronyd.service slave步骤同上 确保关闭了iptables和selinux功能 ##配置主从复制 master 配置： 修改配置文件 [root@master~]#vim /etc/my.cnf.d/server.cnf 授权用户 MariaDB [(none)]&gt; GRANT REPLICATION SLAVE,REPLICATION CLIENT ON . TO ‘joah’@’192.168.4.%’ IDENTIFIED BY ‘123456’; MariaDB [(none)]&gt; FLUSH PRIVILEGES; 查看二进制日志 MariaDB [(none)]&gt; SHOW MASTER STATUS; MariaDB [(none)]&gt; SHOW BINLOG EVENTS IN ‘log-bin.000001’; slave配置 修改配置文件[root@slave1~]#vim /etc/my.cnf.d/server.cnf slave1和slave2配置相同，不过需要修改下server_id 修改主节点 MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_USER=’joah’,MASTER_HOST=’192.168.4.61’,MASTER_PASSWORD=’123456’,MASTER_LOG_FILE=’log-bin.000001’,MASTER_LOG_POS=245; MariaDB [(none)]&gt; START SLAVE; MariaDB [(none)]&gt; SHOW SLAVE STATUS\G; 实现半同步复制master节点配置 安装semisync插件 MariaDB [(none)]&gt; INSTALL PLUGIN rpl_semi_sync_master SONAME ‘semisync_master’; 查看变量 MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES LIKE ‘rpl_semi%’;+————————————+——-+| Variable_name | Value |+————————————+——-+| rpl_semi_sync_master_enabled | OFF || rpl_semi_sync_master_timeout | 10000 || rpl_semi_sync_master_trace_level | 32 || rpl_semi_sync_master_wait_no_slave | ON |+————————————+——-+ 启动此插件功能 MariaDB [(none)]&gt; SET GLOBAL rpl_semi_sync_master_enabled=ON; 显示状态 MariaDB [(none)]&gt; SHOW GLOBAL STATUS LIKE ‘%rpl%’; Slave1 配置 安装插件 MariaDB [(none)]&gt; INSTALL PLUGIN rpl_semi_sync_slave SONAME ‘semisync_slave’; 查看semi变量 MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES LIKE ‘%rpl_semi%’;+———————————+——-+| Variable_name | Value |+———————————+——-+| rpl_semi_sync_slave_enabled | OFF || rpl_semi_sync_slave_trace_level | 32 |+———————————+——-+ 启动semi功能 MariaDB [(none)]&gt; SET @@global.rpl_semi_sync_slave_enabled=ON;重启IO线程，如果不重启当执行时会超时MariaDB [(none)]&gt; STOP SLAVE IO_THREAD; MariaDB [(none)]&gt; START SLAVE IO_THREAD; proxysqlhttp://www.proxysql.com/ 下载地址 ###安装proxysql [root@proxysql~]#yum install proxysql-1.4.3-1-centos7.x86_64.rpm ###修改配置文件/etc/proxysql.cnf[root@proxysql~]#cp /etc/proxysql.cnf{,.bak} [root@proxysql~]#vim /etc/proxysql.cnf datadir=&quot;/var/lib/proxysql&quot; #存放数据地址 10 11 admin_variables= 12 { 13 admin_credentials=&quot;admin:123456&quot; 14 mysql_ifaces=&quot;127.0.0.1:6032;/tmp/proxysql_admin.sock&quot; #为了安全可见仅在本地使用 15 } 16 17 mysql_variables= 18 { 19 threads=4 20 max_connections=2048 21 default_query_delay=0 22 default_query_timeout=36000000 23 have_compress=true 24 poll_timeout=2000 25 interfaces=&quot;0.0.0.0:3306;/tmp/proxysql.sock&quot; 26 # interfaces=&quot;0.0.0.0:6033&quot; 27 default_schema=&quot;information_schema&quot; 28 stacksize=1048576 29 server_version=&quot;5.5.30&quot; 30 connect_timeout_server=3000 31 monitor_username=&quot;joah&quot; 32 monitor_password=&quot;joah&quot; 33 monitor_history=600000 34 monitor_connect_interval=60000 35 monitor_ping_interval=10000 36 monitor_read_only_interval=1500 37 monitor_read_only_timeout=500 38 ping_interval_server_msec=120000 39 ping_timeout_server=500 40 commands_stats=true 41 sessions_sort=true 42 connect_retries_on_failure=10 43 } 44 45 46 # defines all the MySQL servers 47 mysql_servers = 48 ( 49 { 50 address = &quot;192.168.4.61&quot; 51 port = 3306 52 hostgroup = 0 53 status = &quot;ONLINE&quot; 54 weight = 1 55 compression = 0 56 }, 57 { 58 address = &quot;192.168.4.62&quot; 59 port = 3306 60 hostgroup = 1 61 status = &quot;ONLINE&quot; 62 weight = 1 63 compression = 0 64 }, 65 { 66 address = &quot;192.168.4.63&quot; 67 port = 3306 68 hostgroup = 1 69 status = &quot;ONLINE&quot; 70 weight = 1 71 compression = 0 72 } 73 ) 74 75 # defines all the MySQL users 76 mysql_users: 77 ( 78 { 79 username = &quot;joah&quot; 80 password = &quot;123456&quot; 81 default_hostgroup = 0 82 max_connections=1000 83 default_schema=&quot;hellodb&quot; 84 active = 1 85 } 86 ) 87 88 #defines MySQL Query Rules 89 mysql_query_rules: 90 ( 91 ) 92 93 scheduler= 94 ( 95 ) 96 97 98 mysql_replication_hostgroups= 99 ( 100 { 101 writer_hostgroup=0 102 reader_hostgroup=1 103 comment=&quot;joah mysql&quot; 104 } 105 ) 注意：配置文件中{}如果没有后续内容没有逗号。 本地管理[root@proxysql~]#mysql -S /tmp/proxysql_admin.sock -uadmin -p123456 测试是否能支持读写分离授权在上述文件中设定的mysql_user MariaDB [hellodb]&gt; GRANT ALL ON . TO ‘joah’@’192.168.4.%’ IDENTIFIED BY ‘123456’; [root@proxysql~]#mysql -ujoah -p -h192.168.4.64]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL主从复制读写分离</category>
      </categories>
      <tags>
        <tag>读写分离，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL双主模式]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E5%8F%8C%E4%B8%BB%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[双主模式互为主从：两个节点各自都要开启binlog和relay log （1）数据不一致 （2）自动增长ID 定义一个节点使用奇数ID auto_increment_offset=1 auto_increment_increment=2 另外一个节点使用偶数ID auto_increment_offset=2 auto_increment_increment=2 前提： （1）server_id必须要使用不同值 （2）均启用binlog和relay log （3）存在自动增长ID的表，为了使得ID不相冲突，需要定义其自动增长方式 （4）都授权复制权限的用户账号 （5）各把对方指定为主节点 复制时应该注意的问题： 1、从服务器设定为“只读” 在从服务器启动read_only，但仅对非SUPER权限用户有效 组织所有用户： FLUSH TABLES WITH READ LOCK; 2、尽量确保复制时的事物安全 在master节点启用参数 sync_binlog = ON 如果用到的是InnoDB存储引擎： innodb_flush_logs_at_trx_commit=ON innodb_support_xa=ON 3、从服务器意外终止时尽量避免自动复制线程 4、从节点：设置参数 sync_master_info = ON sync_relay_log_info = ON 实战： 在node1进行如下配置 [root@node1~]#vim /etc/my.cnf.d/server.cnf 在node2节点进行如下配置 [root@node2~]#vim /etc/my.cnf.d/server.cnf [root@node1~]#systemctl start mariadb [root@node2~]#systemctl start mariadb 在node1和node2相互授权 GRANT REPLICATION CLIENT,REPLICATION SLAVE ON *.* TO &apos;joah&apos;@&apos;192.168.4.62&apos; IDENTIFIED BY &apos;123456&apos;; GRANT REPLICATION CLIENT,REPLICATION SLAVE ON *.* TO &apos;joah&apos;@&apos;192.168.4.61&apos; IDENTIFIED BY &apos;123456&apos;; 在node1和node2指定master MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_HOST=&apos;192.168.4.62&apos;,MASTER_USER=&apos;joah&apos;,MASTER_PASSWORD=&apos;123456&apos;,MASTER_LOG_FILE=&apos;master-log.000003&apos;,MASTER_LOG_POS=422; MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_HOST=&apos;192.168.4.61&apos;,MASTER_USER=&apos;joah&apos;,MASTER_PASSWORD=&apos;123456&apos;,MASTER_LOG_FILE=&apos;master-log.000003&apos;,MASTER_LOG_POS=245; 在node1和node2启动从服务器 MariaDB [(none)]&gt; SHOW SLAVE STATUS\G; MariaDB [(none)]&gt; START SLAVE IO_THREAD,SQL_THREAD; 测试 MariaDB [(none)]&gt; SHOW SLAVE STATUS\G; 如果出现上述红框中yes字样就成功]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL双主模式</category>
      </categories>
      <tags>
        <tag>Xtrabackup，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL半同步复制]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[mysql半同步复制- 半同步复制是基于异步复制基础之上进行的。从Slave节点中选取一个节点进行半同步复制，当master节点提交一个事物将受到阻塞，直到得知一个已开启半同步复制功能的Slave同步完成之后返回ack包，master才会向用户返回事物提交。 1、半同步流程图： 2、半同步潜在的问题当master down时，有可能半同步复制没有完成，并没有提交给客户；切换到Slave时，数据有可能和master的数据不一致，此时需要使用binlog恢复 3、半同步复制概念（1）当slave节点连接到master时，能够查看是否处于半连接同步复制的机制；如果只有开启一侧，它依然为异步复制。 （2）当master节点开启半同步复制的功能时，至少有一个Slave节点开启此功能。 ###4、mysql插件 ####查询插件存放的位置： MariaDB [(none)]&gt; SHOW VARIABLES LIKE ‘plugin_dir’;+—————+————————–+| Variable_name | Value |+—————+————————–+| plugin_dir | /usr/lib64/mysql/plugin/ |+—————+————————–+ 安装插件：格式： INSTALL PLUGIN plugin_name SONAME &apos;shared_library_name&apos;； 卸载插件格式： UNINSTALL PLUGIN plg_name； 查看当前已经安装的插件格式： SHOW PLUGINS; 查看插件的详细信息格式： SELECT * FROM information_schema.plugins WHERE PLUGIN_NAME=&apos;plg-name&apos;; 半同步复制实现 前提： master和slave时间同步 [root@master~]#ntpdate 172.18.0.1 [root@master~]#vim /etc/chrony.conf [root@master~]#systemctl start chronyd.service slave步骤同上 确保关闭了iptables和selinux功能 配置主从复制master 配置： 修改配置文件 [root@master~]#vim /etc/my.cnf.d/server.cnf 授权用户 MariaDB [(none)]&gt; GRANT REPLICATION SLAVE,REPLICATION CLIENT ON . TO ‘joah’@’192.168.4.%’ IDENTIFIED BY ‘123456’; MariaDB [(none)]&gt; FLUSH PRIVILEGES; 查看二进制日志 MariaDB [(none)]&gt; SHOW MASTER STATUS; MariaDB [(none)]&gt; SHOW BINLOG EVENTS IN ‘log-bin.000001’; slave配置 修改配置文件[root@slave1~]#vim /etc/my.cnf.d/server.cnf slave1和slave2配置相同，不过需要修改下server_id 修改主节点 MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_USER=’joah’,MASTER_HOST=’192.168.4.61’,MASTER_PASSWORD=’123456’,MASTER_LOG_FILE=’log-bin.000001’,MASTER_LOG_POS=245; MariaDB [(none)]&gt; START SLAVE; MariaDB [(none)]&gt; SHOW SLAVE STATUS\G; 实现半同步复制master节点配置 安装semisync插件 MariaDB [(none)]&gt; INSTALL PLUGIN rpl_semi_sync_master SONAME ‘semisync_master’; 查看变量 MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES LIKE ‘rpl_semi%’;+————————————+——-+| Variable_name | Value |+————————————+——-+| rpl_semi_sync_master_enabled | OFF || rpl_semi_sync_master_timeout | 10000 || rpl_semi_sync_master_trace_level | 32 || rpl_semi_sync_master_wait_no_slave | ON |+————————————+——-+ 启动此插件功能 MariaDB [(none)]&gt; SET GLOBAL rpl_semi_sync_master_enabled=ON; 显示状态 MariaDB [(none)]&gt; SHOW GLOBAL STATUS LIKE ‘%rpl%’; Slave1 配置 安装插件 MariaDB [(none)]&gt; INSTALL PLUGIN rpl_semi_sync_slave SONAME ‘semisync_slave’; 查看semi变量 MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES LIKE ‘%rpl_semi%’;+———————————+——-+| Variable_name | Value |+———————————+——-+| rpl_semi_sync_slave_enabled | OFF || rpl_semi_sync_slave_trace_level | 32 |+———————————+——-+ 启动semi功能 MariaDB [(none)]&gt; SET @@global.rpl_semi_sync_slave_enabled=ON;重启IO线程，如果不重启当执行时会超时MariaDB [(none)]&gt; STOP SLAVE IO_THREAD; MariaDB [(none)]&gt; START SLAVE IO_THREAD; 查看master上的状态 选项介绍rpl_semi_sync_master_enabled 是否开启半同步 rpl_semi_sync_master_timeout 超时时长 rpl_semi_sync_slave_enable slave是否开启半同步 rpl_semi_sync_master_clients 查看有多少个slave开启半同步 rpl_semi_sync_master_status 查看master是否正在运行 rpl_semi_sync_master_no_tx 查看有多少事物没有用半同步复制的机制进行复制 rpl_semi_sync_master_yes_tx 查看有多少事物是通过半同步复制机制成功复制 rpl_semi_sync_slave_status 查看slave是否正常运行]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL半同步复制</category>
      </categories>
      <tags>
        <tag>半同步复制，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基于SSL实现主从复制]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E5%9F%BA%E4%BA%8ESSL%E5%AE%9E%E7%8E%B0%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[mysql数据库基于SSL实现主从复制实验环境： node1:192.168.4.61 node2:192.168.4.62 CA：192.168.4.63 node1和node2时间同步[root@node1~]#ntpdate 172.18.0.1 [root@node2~]#ntpdate 172.18.0.1 [root@node1~]#vim /etc/chrony.conf #node1和node2操作一样 [root@node1~]#systemctl start chronyd.service #启动服务 node1和node2基于key连接[root@node1~]#ssh-keygen [root@node1~]#ssh-copy-id -i /root/.ssh/id_rsa.pub 192.168.4.62 #将公钥复制到node2上 node2操作和node1操作相同。 修改hosts文件node1和node2配置相同 [root@node1~]#vim /etc/hosts 3 192.168.4.61 node1 4 192.168.4.62 node2 确保关闭iptables和selinuxnode1和node2安装mariadb数据库[root@node1~]#yum install -y mariadb-server [root@node2~]#yum install -y mariadb-server 配置node1为主服务器[root@node1~]#vim /etc/my.cnf.d/server.cnf [root@node1~]#systemctl start mariadb #启动mariadb服务 MariaDB [(none)]&gt; GRANT REPLICATION CLIENT,REPLICATION SLAVE ON *.* TO &apos;joah&apos;@&apos;192.168.4.62&apos; IDENTIFIED BY &apos;123456&apos;; #对用户授权 查看是否开启二进制日志MariaDB [(none)]&gt; SHOW VARIABLES LIKE &apos;%log%bin%&apos;; 在node1上二进制日志状态信息MariaDB [(none)]&gt; SHOW MASTER STATUS; 配置node2从服务器[root@node2~]#vim /etc/my.cnf.d/server.cnf [root@node2~]#systemctl start mariadb #启动mariadb服务 MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_HOST=&apos;192.168.4.61&apos;,MASTER_USER=&apos;joah&apos;,MASTER_PASSWORD=&apos;123456&apos;,MASTER_LOG_FILE=&apos;master-log.000003&apos;,MASTER_LOG_POS=417; #设置连接主服务器 启动从服务器MariaDB [(none)]&gt; START SLAVE; 启动IO线程和SQL线程MariaDB [(none)]&gt; START SLAVE IO_THREAD,SQL_THREAD; 查看从服务器状态MariaDB [(none)]&gt; START SLAVE IO_THREAD,SQL_THREAD; ######如果出现图中红框中的信息说明已经启动成功。 #####测试是否已经实现主从复制 实现SSL功能搭建CA服务器[root@CA/etc/pki/CA]#touch index.txt [root@CA/etc/pki/CA]#echo 01 &gt; serial 生成key文件[root@CA/etc/pki/CA]#(umask 077;openssl genrsa -out private/cakey.pem 2048) 生成自签证书[root@CA/etc/pki/CA]#openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days 3650 node1生成证书[root@node1~]#mkdir /etc/mysql/ssl -pv [root@node1~]#chown mysql.mysql /etc/mysql/ssl/ -R [root@node1/etc/mysql/ssl]#(umask 077;openssl genrsa -out master.key 2048)[root@node1/etc/mysql/ssl]#openssl req -new -key master.key -out master.csr [root@node1/etc/mysql/ssl]#scp master.csr 192.168.4.63:/etc/pki/CA/newcerts/ [root@CA/etc/pki/CA/newcerts]#openssl ca -in master.csr -out master.crt -days 365 [root@CA/etc/pki/CA/newcerts]#scp master.crt ../cacert.pem 192.168.4.61:/etc/mysql/ssl [root@node1~]#vim /etc/my.cnf.d/server.cnf [root@node1~]#systemctl restart mariadb 查看是否开启SSL功能 node2生成证书[root@node2~]#mkdir /etc/mysql/ssl -pv [root@node2~]#chown mysql.mysql /etc/mysql/ssl/ -R [root@node2/etc/mysql/ssl]#(umask 077;openssl genrsa -out slave.key 2048) [root@node2/etc/mysql/ssl]#openssl req -new -key slave.key -out slave.csr [root@node2/etc/mysql/ssl]#scp slave.csr 192.168.4.63:/etc/pki/CA/newcerts [root@CA/etc/pki/CA/newcerts]#openssl ca -in slave.csr -out slave.crt -days 365 [root@CA/etc/pki/CA/newcerts]#scp slave.crt ../cacert.pem 192.168.4.62:/etc/mysql/ssl [root@node2/etc/mysql/ssl]#vim /etc/my.cnf.d/server.cnf 重启服务[root@node2/etc/mysql/ssl]#systemctl restart mariadb 基于SSL连接node1授权MariaDB [(none)]&gt; GRANT REPLICATION CLIENT,REPLICATION SLAVE ON *.* TO &apos;joah&apos;@&apos;192.168.4.62&apos; IDENTIFIED BY &apos;123456&apos; REQUIRE SSL; 测试[root@node2~]#mysql -ujoah -p123456 -h192.168.4.61 --ssl node2连接主服务器以ssl复制MariaDB [(none)]&gt; CHANGE MASTER TO MASTER_HOST=&apos;192.168.4.61&apos;,MASTER_USER=&apos;joah&apos;,MASTER_PASSWORD=&apos;123456&apos;,MASTER_LOG_FILE=&apos;master-log.000008&apos;,MASTER_LOG_POS=429,MASTER_SSL=1,MASTER_SSL_CA=&apos;/etc/mysql/ssl/cacert.pem&apos;,MASTER_SSL_CERT=&apos;/etc/mysql/ssl/slave.crt&apos;,MASTER_SSL_KEY=&apos;/etc/mysql/ssl/slave.key&apos;; MariaDB [(none)]&gt; START SLAVE; #启动从服务器 MariaDB [(none)]&gt; SHOW SLAVE STATUS\G; 小结（1）如果你已经正确的添加了证书，但是启动以后还是没有启动SSL功能，有可能没有权限 [root@node2~]#chown mysql.mysql -R /etc/mysql/ssl （2）如果出现图片中的问题，停止slave即可 （3）每一个过程中都需要验证是否成功然后进行下面的操作。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL基于SSL实现主从复制</category>
      </categories>
      <tags>
        <tag>Xtrabackup，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基于证书连接]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E5%9F%BA%E4%BA%8E%E8%AF%81%E4%B9%A6%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[基于证书连接 搭建私有CA [root@CA/etc/pki/CA]#echo 01 &gt; serial [root@CA/etc/pki/CA]#touch index.txt [root@CA/etc/pki/CA]#(umask 077;openssl genrsa -out private/cakey.pem 2048) #创建key文件 [root@CA/etc/pki/CA]#openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days 3650 #创建自签证书 mysql创建证书文件 [root@mysql~]#yum insatll -y mariadb-server 查看是否支持ssl MariaDB [(none)]&gt; SHOW VARIABLES LIKE &apos;%ssl%&apos;; +---------------+----------+ | Variable_name | Value | +---------------+----------+ | have_openssl | DISABLED | #这里是支持ssl的没有启动而已 | have_ssl | DISABLED | | ssl_ca | | | ssl_capath | | | ssl_cert | | | ssl_cipher | | | ssl_key | | +---------------+----------+ [root@mysql/etc/my.cnf.d]#mkdir ssl [root@mysql/etc/my.cnf.d/ssl]#(umask 077;openssl genrsa -out mysqlsrv.key 2048) #生成key文件 [root@mysql/etc/my.cnf.d/ssl]#openssl req -new -key mysqlsrv.key -out mysqlsrv.csr #生成证书请求文件 You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter &apos;.&apos;, the field will be left blank. ----- Country Name (2 letter code) [XX]:CN State or Province Name (full name) []:zhengzhou Locality Name (eg, city) [Default City]:henan Organization Name (eg, company) [Default Company Ltd]:test Organizational Unit Name (eg, section) []:ops Common Name (eg, your name or your server&apos;s hostname) []:www.test.com Email Address []: Please enter the following &apos;extra&apos; attributes to be sent with your certificate request A challenge password []: An optional company name []: 注意：这里填写的内容需和CA认证中心对应 [root@mysql/etc/my.cnf.d/ssl]#scp mysqlsrv.csr 192.168.4.63:/etc/pki/CA/newcerts/ #将请求认证证书发送给认证中心 认证中心对请求证书签署 [root@CA/etc/pki/CA]#openssl ca -in newcerts/mysqlsrv.csr -out newcerts/mysqlsrv.crt -days 365 将ca证书和认证证书发送到myql客户端 [root@CA/etc/pki/CA/newcerts]#scp mysqlsrv.crt ../cacert.pem 192.168.4.62:/etc/my.cnf.d/ssl 修改刚刚生成文件的权限（因为mysql是以mysql用户运行的，如果您是别的用户修改别的用户即可） [root@mysql/etc/my.cnf.d/ssl]#chown mysql.mysql * 修改my.cnf配置文件 [root@mysql~]#vim /etc/my.cnf 重启服务测试 [root@mysql~]#systemctl restart mariadb MariaDB [(none)]&gt; SHOW VARIABLES LIKE &apos;%ssl%&apos;; +---------------+--------------------------------+ | Variable_name | Value | +---------------+--------------------------------+ | have_openssl | YES | #此时支持ssl功能了 | have_ssl | YES | | ssl_ca | /etc/my.cnf.d/ssl/cacert.pem | | ssl_capath | | | ssl_cert | /etc/my.cnf.d/ssl/mysqlsrv.crt | | ssl_cipher | | | ssl_key | /etc/my.cnf.d/ssl/mysqlsrv.key | +---------------+--------------------------------+ 7 rows in set (0.00 sec) 客户端配置 [root@client~]#mkdir .mysql/ssl -pv #基于安全考虑使用隐藏目录 [root@client~/.mysql/ssl]#(umask 077;openssl genrsa -out mysqlcli.key 2048) [root@client~/.mysql/ssl]#openssl req -new -key mysqlcli.key -out mysqlcli.csr 将请求认证文件发送到CA认证中心 [root@client~/.mysql/ssl]#scp mysqlcli.csr 192.168.4.63:/etc/pki/CA/newcerts/ 认证中心对此请求证书签署 [root@CA/etc/pki/CA/newcerts]#openssl ca -in mysqlcli.csr -out mysqlcli.crt -days 365 [root@CA/etc/pki/CA/newcerts]#scp mysqlcli.crt ../cacert.pem 192.168.4.61:/root/.mysql/ssl #将签署证书和ca证书发送给客户端 修改配置文件 [root@client~]#vim /etc/my.cnf 11 ssl-ca=/data/ssl/cacert.pem 12 ssl-key=/data/ssl/s.key 13 ssl-cert=/data/ssl/s.crt 测试 MariaDB [(none)]&gt; GRANT ALL ON *.* to &apos;joah&apos;@&apos;192.168.4.61&apos; IDENTIFIED BY &apos;123456&apos; REQUIRE ssl; #授权某个用户 [root@client~]#mysql -ujoah -p -h192.168.4.62 --ssl]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL基于证书连接</category>
      </categories>
      <tags>
        <tag>证书，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL备份与恢复]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[mysql备份和恢复（数据）：备份存储的数据副本；原始数据：持续改变。 备份原因：灾难恢复：硬件故障（冗余）、软件故障（bug）、自然灾害、黑客攻击、误操作等等。 备份时应注意事项 能容忍最多丢失多少数据 恢复数据需要在多长时间内完成 需要恢复哪些数据 备份类型 备份的数据集的范围： 完全备份：整个数据集 部分备份：数据集的一部分，比如部分表等 全量备份、增量备份、差异备份： 完成备份：整个数据集、文件等 增量备份：仅备份自上一次完全备份或增量备份以来变量的那部分数据 差异备份：仅备份自上一次完成备份以来的那部分数据 物理备份、逻辑备份： 物理备份：复制数据文件进行的备份 逻辑备份：从数据库导出数据另存在一个或多个文件 根据数据服务是否在线： 热备：读写操作均可进行的状态下所做的备份 温备：可读但不可写状态下进行的备份 冷备：读写操作不可进行的状态下所做的备份 备份需要考虑因素：锁定资源多长时间？ 备份过程的时长？ 备份时的服务器负载？ 恢复过程的时长？ 备份策略： 全量+差异+binlogs 全量+增量+binlogs 备份内容： 数据 二进制日志、InnoDB的事物日志 代码（存储过程、存储函数、触发器、时间调度器） 服务器的配置文件 备份工具： mysqldump mysql服务自带的备份工具；逻辑备份工具 InnoDB:支持热备、温备、冷备 MyISAM：支持温备、冷备；备份时要锁定表 mysqldump命令使用格式： mysqldump [OPTIONS] database [tables] 备份单库，可以只备份其中一部分表（部分备份） OR mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...] 备份多库 OR mysqldump [OPTIONS] --all-databases [OPTIONS] 备份所有库 选项： -x，--lock-all-tables：锁定所有库的所有表，读锁 -l，--lock-talbes：锁定指定库所有表 --single-transaction：创建一个事物，基于快照执行备份 -R，--routines：备份指定库的存储过程和存储函数 --triggers：备份指定库的触发器 -E，--events：备份事务 --master-data[=#] 1 ：记录为CHANGE MASTER TO语句，此语句不被注释 2：记录为CHANGE MASTER TO 语句，此语句被注释 --flush-logs：锁定表完成后，即进行日志刷新操作 示例： 只备份某个库某张表 [root@client~]#mysqldump -uroot -h 192.168.4.62 -p --databases hellodb --tables classes 只备份某个库的多张表 [root@client~]#mysqldump -uroot -h 192.168.4.62 -p --databases hellodb --tables classes coc 备份多个库 [root@client~]#mysqldump -uroot -h 192.168.4.62 -p --databases hellodb mysql 备份所有库 [root@client~]#mysqldump -uroot -p -h192.168.4.62 --all-databases 备份时锁定指定库的所有表 [root@client~]#mysqldump -uroot -p -h192.168.4.62 --databases hellodb -l 备份创建一个事物并锁定指定库所有表 [root@client~]#mysqldump -uroot -p -h192.168.4.62 --databases hellodb -l --single-transaction 如果锁定某个时间点如何做？ [root@client~]#mysqldump -uroot -p -h192.168.4.62 --databases hellodb --tables classes -l --single-transaction --master-data=2 --triggers -E &gt;test.sqll 这样我们就可以支持从哪个binlog日志中回复并从那个点回复 实战： 将一个数据库复制然后恢复，如何操作？ （1）在远程主机上dump [root@client~]#mysqldump -uroot -p -h192.168.4.62 --all-databases --master-data=2 --triggers -E --single-transaction -R --flush-logs &gt;test.sql 如果有远程存储服务器可以存储到此服务器上。 （2）模拟数据库奔溃 [root@mysql~]#systemctl stop mariadb [root@mysql~]#rm -rf /var/lib/mysql/ （3）恢复数据库 [root@client~]#scp test.sql 192.168.4.62:root #将备份文件拷贝到mysql服务器上 创建数据库存放位置 [root@mysql~]#mkdir /var/lib/mysql [root@mysql~]#chown mysql.mysql /var/lib/mysql #修改所有者所属组 先关闭此会话binlog日志功能 MariaDB [(none)]&gt; SET @@session.sql_log_bin=OFF； MariaDB [(none)]&gt; SELECT @@session.sql_log_bin #查询是否关闭 导入文件 [root@mysql~]#mysql &lt; test.sql 查看此时时从哪个时间点记录的 使用binlog日志恢复此后的内容 [root@mysql/app/data/binlog]#mysqlbinlog master-log.000001 -j 245 &gt; /tmp/testbin.sql 这里防止到tmp目录下，对所用用户都可以访问，如果您想放到别的目录下，如果使用下面操作需对mysql用户授权 MariaDB [(none)]&gt; \. /tmp/testbin.sql 导入数据库 MariaDB [hellodb]&gt; SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | hellodb | | mysql | | performance_schema | | test | +--------------------+ 5 rows in set (0.01 sec) 至此已经完成恢复 开启binlog日志功能 MariaDB [hellodb]&gt; SET @@session.sql_log_bin=ON; cp/tar 基于lvm，快照（请求一个全局锁），之后立即释放锁，达到几乎热备的效果，物理备份 注意：不能仅备份数据；同时备份事物日志；并且要求数据文件和事物日志位于同一个逻辑卷。 实战： 创建逻辑卷 [root@localhost~]#fdisk /dev/sdb 同步磁盘 [root@localhost~]#partprobe /dev/sdb 创建物理卷 [root@localhost~]#pvcreate /dev/sdb{1,2} [root@localhost~]#pvdisplay 创建卷组 [root@localhost~]#vgcreate mysqldisk /dev/sdb{1,2} [root@localhost~]#vgdisplay 创建逻辑卷 [root@localhost~]#lvcreate -L 15 -n mysqlv mysqldisk /dev/sdb{1,2} [root@localhost~]#lvdisplay 格式化 [root@localhost~]#mke2fs -t ext4 /dev/mysqldisk/mysqlv 挂载 [root@localhost~]#mkdir /data/mysql [root@localhost~]#mount /dev/mysqldisk/mysqlv /data/mysql/ 修改mysql数据和日志存放位置 [root@localhost~]#chown mysql.mysql /data/mysql/ [root@localhost~]#vim /etc/my.cnf [root@localhost~]#vim /etc/my.cnf.d/server.cnf 请求锁定所有表 MariaDB [hellodb]&gt; FLUSH TABLES WITH READ LOCK; 查看二进制日志 MariaDB [hellodb]&gt; FLUSH LOGS; MariaDB [hellodb]&gt; SHOW MASTER STATUS; 创建快照卷 [root@localhost~]#lvcreate -L 2G -s -p r -n mysql /dev/mysqldisk/mysqlv 释放锁 MariaDB [hellodb]&gt; UNLOCK TABLES; 挂载快照，并执行备份，备份完后删除快照卷 创建临时挂载点并挂载快照 [root@localhost~]#mkdir /test [root@localhost~]#mount /dev/mysqldisk/mysnap /test/ 如果有远程存储可以将内容存储到远程服务器上 [root@localhost~]#mkdir /backup/mysql -pv #创建一个备份目录 [root@localhost~]#cp -a /test/* /backup/mysql 卸载挂载点并删除快照 [root@localhost~]#umount /test/ [root@localhost~]#lvremove /dev/mysqldisk/mysnap 周期性备份二进制日志并将文件放置到远程存储服务器上 [root@localhost/data/mysql]#mysqlbinlog master-log.000003 &gt; test.sql 如果库被删除如何恢复？ [root@localhost~]#rm -rf /data/mysql/* [root@localhost~]#cp /backup/mysql/* /data/mysql/ -a [root@localhost~]#mysql &lt; test.sql 至此数据库就恢复完成了。 如果需要将文件压缩打包传送到远程服务器，可以使用如下命令： [root@localhost~]#tar cvf mysql.tar /backup/mysql/*]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL备份与恢复</category>
      </categories>
      <tags>
        <tag>备份与恢复，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础一]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E5%9F%BA%E7%A1%80%E4%B8%80%2F</url>
    <content type="text"><![CDATA[mysql1、概念MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。 2、mariadbMariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。在存储引擎方面，使用XtraDB（英语：XtraDB）来代替MySQL的InnoDB。 MariaDB由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入Oracle的手中。MariaDB名称来自Michael Widenius的女儿Maria的名字。 3、如何使用二进制安装mariadb呢？之前我们讲过使用源码编译安装DNS，其实编译安装的过程都是大同小异的，但是源码编译安装会耗费我们很多的时间，是不是如果有人把源码编译好我们直接使用该如何呢？但是这种方式有一个缺点不能自己定制自己的需求，如果你想只针对自己的需求安装那就只能使用源码编译安装了。下面我们就来看看二进制如何安装mariadb 先从官网下载二进制包 https://downloads.mariadb.org/mariadb/10.2.8/ 创建mysql用户 [root@localhost mysql]# useradd -r -m -d /app/testdata -s /sbin/nologin mysql 解压指定目录并创建软连接 [root@localhost ~]# tar xvf mariadb-10.2.8-linux-x86_64.tar.gz -C /usr/local [root@localhost local]# ln -sv mariadb-10.2.8-linux-x86_64/ mysql #创建软连接 准备配置文件 [root@localhost mysql]# mkdir /etc/mysql #创建目录 [root@localhost mysql]# cp support-files/my-large.cnf /etc/mysql/my.cnf #复制模板文件 [root@localhost mysql]# cd /etc/mysql/ [root@localhost mysql]# vim my.cnf #修改配置文件 [mysqld] datadir = /app/testdata innodb_file_per_table = on skip-name_resolve = on port = 3306 socket = /tmp/mysql.sock skip-external-locking key_buffer_size = 256M max_allowed_packet = 1M table_open_cache = 256 sort_buffer_size = 1M read_buffer_size = 1M read_rnd_buffer_size = 4M myisam_sort_buffer_size = 64M thread_cache_size = 8 query_cache_size= 16M 现在我们已经把主配置文件创建好了，但是如果现在启动的话，会出现下面情况 [root@localhost~]#service mysqld start Redirecting to /bin/systemctl start mysqld.service Failed to start mysqld.service: Unit not found. 我们还没有创建启动脚本呢！！！ [root@localhost mysql]# cp support-files/mysql.server /etc/rc.d/init.d/mysqld #将启动脚本复制到启动脚本目录下 [root@localhost mysql]# chkconfig --add mysqld #添加服务 创建数据库文件 [root@localhost/usr/local/mysql]#./scripts/mysql_install_db --datadir=/app/testdata --user=mysql #初始化数据库，但是这里需要注意的是这个执行文件必须在文件父目录上执行。 这是我们尝试去启动mysqld，看看是否可以启动 [root@localhost/usr/local/mysql]#service mysqld start 出错啦，出错啦，是什么原因呢？使我们的日志文件没有创建导致，现在我们去解决这个问题。 [root@localhost/usr/local/mysql]#journalctl -xe #查看日志 Sep 25 15:07:28 localhost.localdomain mysqld[3756]: Starting MySQL.170925 15:07:28 mysqld_safe Logging to &apos;/var/log/mariadb/mariadb.log&apos;. 如何解决这个问题呢？ [root@localhost/usr/local/mysql]#mkdir /var/log/mariadb [root@localhost/usr/local/mysql]#touch /var/log/mariadb/mariadb.log #创建日志文件 [root@localhost/usr/local/mysql]#setfacl -R -m u:mysql:rwx /var/log/mariadb/ #设置权限 现在我们来再尝试启动，看看能不能成功呢？ [root@localhost/usr/local/mysql]#service mysqld start Starting mysqld (via systemctl): [ OK ] 高兴，终于启动了，那让我们来尽情的享用吧？ 初始化数据库 [root@localhost/usr/local/mysql]#/usr/local/mysql/bin/mysql_secure_installation NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY! In order to log into MariaDB to secure it, we&apos;ll need the current password for the root user. If you&apos;ve just installed MariaDB, and you haven&apos;t set the root password yet, the password will be blank, so you should just press enter here. Enter current password for root (enter for none): #输入现在的密码，新创建的密码为空，直接回车 OK, successfully used password, moving on... Setting the root password ensures that nobody can log into the MariaDB root user without the proper authorisation. Set root password? [Y/n] Y #询问是否为root创建密码 New password: #输入密码 Re-enter new password: Password updated successfully! Reloading privilege tables.. ... Success! By default, a MariaDB installation has an anonymous user, allowing anyone to log into MariaDB without having to have a user account created for them. This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment. Remove anonymous users? [Y/n] Y #是否移除匿名用户 ... Success! Normally, root should only be allowed to connect from &apos;localhost&apos;. This ensures that someone cannot guess at the root password from the network. Disallow root login remotely? [Y/n] Y #是否远程root 登录 ... Success! By default, MariaDB comes with a database named &apos;test&apos; that anyone can access. This is also intended only for testing, and should be removed before moving into a production environment. Remove test database and access to it? [Y/n] N #是否移除test数据库 ... skipping. Reloading the privilege tables will ensure that all changes made so far will take effect immediately. Reload privilege tables now? [Y/n] Y #是否立即生效 ... Success! Cleaning up... All done! If you&apos;ve completed all of the above steps, your MariaDB installation should now be secure. Thanks for using MariaDB! 咦，有出错了，先哭会，再解决；这个原因是我们没有设置mysql路径，那么我们来设置下喽。 [root@localhost/usr/local/mysql]#vim /etc/profile.d/mysql.sh #写路径 export PATH=/usr/local/mysql/bin:$PATH [root@localhost/usr/local/mysql]#source /etc/profile.d/mysql.sh #使其生效。 如果您出现上图所示内容，说明你已经成功，来给自己鼓个掌。 安装过程中有没有注意到，为什么我们要创建/etc/mysql/目录来创建配置文件呢？ 在mysql中配置文件查找次序：后面的会覆盖前面的配置文件 /etc/my.cnf–&gt;/etc/mysql/my.cnf–&gt;–default-extra-file=/PATH/TO/CONF_FILE–&gt;/.my.cnf 示例创建两张表一个学生基本信息如ID、姓名、性别、年龄。另一张表为学生的成绩ID、姓名、成绩 MariaDB [student]&gt; CREATE TABLE information(ID TINYINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,name VARCHAR(20) NOT NULL,age TINYINT UNSIGNED) MariaDB [student]&gt; CREATE TABLE score (ID TINYINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,name VARCHAR(20) NOT NULL , scores INT NOT NULL); 授权用户MariaDB [mysql]&gt; SELECT user,host,password FROM user; 如何给创建用户并添加密码呢？ MariaDB [(none)]&gt; CREATE USER &#39;li&#39;@&#39;192.168.4.%&#39; IDENTIFIED BY &#39;123456&#39;; MariaDB [(none)]&gt; CREATE USER &#39;wang&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;; 如何更改口令呢？ MariaDB [(none)]&gt; UPDATE mysql.user SET PASSWORD = PASSWORD(&#39;123456&#39;) WHERE USER = &#39;li&#39;; MariaDB [(none)]&gt; SET PASSWORD FOR &#39;li&#39;@&#39;192.168.4.%&#39; = PASSWORD(&#39;123456&#39;); 在一台主机上远程登录，可以登了，但是看不到数据库 那么如何才可以使其使用呢？那必须授权此用户操作。 MariaDB [(none)]&gt; GRANT SELECT,DELETE ON student.* TO &#39;li&#39;@&#39;192.168.4.%&#39;; MariaDB [(none)]&gt; REVOKE ALL ON student.* FROM &#39;li&#39;@&#39;192.168.4.%&#39;; #当有一天这个人离职了，需要收回特权。 **注意：mariadb服务进程启动时会读取mysql库中的所有授权表至内存中。 (1)GRANT或REVOKE等执行权限操作会保存于系统表汇总，mariadb的服务进程通常自动重读授权表，使其生效。（2）对于不能够或不能及时重读授权表的命令，可手动让mariadb的服务进行重复授权表。FLUSH PRIVILEGES]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL基础一</category>
      </categories>
      <tags>
        <tag>数据库，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL工作方式]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[##1、mysql读取配置文件次序 ###my_print_defaultsdisplay options from option files 使用方法： my_print_defaults [options] option_group ... 选项： --defaults-file=file_name #修改默认读取的配置文件 --defaults-extra-file=path #在读取的默认配置文件之外再加载一个文件 [root@localhost~]#my_print_defaults --version #打印出信息 Default options are read from the following files in the given order 读取多出的多个配置文件，而且以指定的次序进行: /etc/mysql/my.cnf /etc/my.cnf ~/.my.cnf 不同的配置文件中出现同一个参数且拥有不同值时，后读取配置文件中的参数将为最终生效值。- ##2、mysqld服务器程序工作特性 ###服务器变量类型 全局（global）：对所有会话生效；所有的会话在建立时都从全局继承，但继承完成后每个会话独立维护自己会话级变量；修改时需要管理权限。 会话（session）：仅对当前会话有效；修改此变量即可生效并且不需要有管理权限。 ####修改变量的方法： 动态修改：会话级别，并且立即生效；全局级别，新建立的会话有效，对此前已经连接的会话无效。 静态修改：修改配置文件，或修改传递给mysqld的选项的值，重启后生效。 #####上述的修改访问不能永久保存，如果需要永久保存需要写入配置文件中；并且重启服务才能生效。 注意：并非所有的变量都支持动态修改。- ####查看服务器变量的方法 （1）方法一 mysql&gt; SHOW [GLOBAL | SESSION] VARIABLES [LIKE &apos;pattern&apos; | WHERE expr] （2）方法二 mysql&gt; SELECT@@{GLOBAL|SESSION}.VARIABLE_NAME 示例： MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES\G; #显示所有全局变量 MariaDB [(none)]&gt; SHOW SESSION VARIABLES\G; #显示所有会话变量 MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES LIKE &apos;innodb_file_per_table&apos;; #显示某个全局变量的信息 +-----------------------+-------+ | Variable_name | Value | +-----------------------+-------+ | innodb_file_per_table | OFF | +-----------------------+-------+ MariaDB [(none)]&gt; SHOW SESSION VARIABLES LIKE &apos;wait_timeout&apos;; #查看某个会话变量信息 +---------------+-------+ | Variable_name | Value | +---------------+-------+ | wait_timeout | 28800 | +---------------+-------+ MariaDB [(none)]&gt; SELECT @@SESSION.tx_isolation; #查看会话隔离级别 +------------------------+ | @@SESSION.tx_isolation | +------------------------+ | REPEATABLE-READ | +------------------------+ MariaDB [(none)]&gt; SELECT @@GLOBAL.tx_isolation; #查看全局隔离级别 +-----------------------+ | @@GLOBAL.tx_isolation | +-----------------------+ | REPEATABLE-READ | +-----------------------+ ###运行时修改变量值操作方法 使用格式： SET variable_assignment [, variable_assignment] ... variable_assignment: user_var_name = expr | [GLOBAL | SESSION] system_var_name = expr | [@@global. | @@session. | @@]system_var_name = expr 示例： MariaDB [(none)]&gt; SET @@SESSION.autocommit=0; #设置会话变量 MariaDB [(none)]&gt; SET SESSION autocommit=0 ; MariaDB [(none)]&gt; SELECT @@SESSION.autocommit; +----------------------+ | @@SESSION.autocommit | +----------------------+ | 0 | +----------------------+ 注意：GOLBAL值的修改要求用户拥有管理权限。- ####参看数据库服务器状态信息 mysql&gt; SHOW GLOBA|[SESSION] STATUS [LIKE clause]; 示例： MariaDB [(none)]&gt; SHOW GLOBAL STATUS; #显示全局状态信息 MariaDB [(none)]&gt; SHOW SESSION STATUS; #显示当前会话状态信息 MariaDB [(none)]&gt; SHOW SESSION STATUS LIKE &apos;Uptime&apos;; #显示当前会话某个状态信息 数据库实现并发控制- ####类类型：读锁：共享锁，可被多个读操作共享 写锁：排他锁，独占锁 ####锁粒度：表锁：在表级别施加的锁，并发性降低 行锁：在行级别施加锁，并发性较高；维持所状态的成本较大 ####锁类别： 显示锁：用户手动请求的锁 隐式锁：存储引擎自行根据需要施加的锁 示例：显示所使用 如图所示，如果设置为read，不能进行写操作 撤销所以后写进入了 将表设置为write测试 小结： 如果将表设置为read状态，可以在另外一个终端读，但是写不进去；如果将表设置为write状态，在另外一个终端读不行，写也不行。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL工作方式</category>
      </categories>
      <tags>
        <tag>mysql工作方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL日志]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[##mysql日志 mysql日志分类 查询日志：general_log 慢查询日志：log_slow_queries 错误日志：log_error，log_warnings 二进制日志：binlog 中继日志：relay_log 事物日志：innodb_log 查询日志记录查询语句日志存储位置： 文件：file 表：table（mysql.general_log） 选项： general_log={ON|OFF}：是否开启日志查询功能 general_log_file=HOSTNAME.log：如果日志以文件存储，此时指定存放日志的文件；并且日志文件名称以主机名.log命名 log_output={FILE|TABLE|NONE}：指定日志输出的格式 注意：查询日志一般不建议开启。 示例： 基于file存储 查看mysql是否开启日志存储功能MariaDB [(none)]&gt; SHOW VARIABLES LIKE &apos;general_log%&apos;; 开启日志存储功能并以file存储MariaDB [(none)]&gt; SHOW VARIABLES LIKE &apos;log_output&apos;; #查看以日志存储以什么形式存储 如果没有以file格式存储则通过如下方式开启即可 MariaDB [hellodb]&gt; SET @@global.log_output=FILE; MariaDB [(none)]&gt; SET @@global.general_log=ON; #开启查询日志存储功能 测试是否我们执行操作时记录日志中 MariaDB [hellodb]&gt; INSERT INTO students (StuID,Name,Age,Gender,ClassID,TeacherID) VALUES (26,&quot;xiao li&quot;,25,&quot;F&quot;,5,24); 基于table存储查询日志 设置为以table存储MariaDB [hellodb]&gt; SET @@global.log_output=&quot;TABLE&quot;; MariaDB [hellodb]&gt; SHOW VARIABLES LIKE &apos;log_output&apos;; #查询是否设置成功 +---------------+-------+ | Variable_name | Value | +---------------+-------+ | log_output | TABLE | +---------------+-------+ 测试是否已经启动table记录查询日志 event_time：时间发生时间 user_host：用户和主机 thread_id：线程ID server_id：服务ID command_type：命令类型 argument：参数 慢查询日志慢查询：运行时间超出指定时长的查询 选项： long_query_time：慢查询等待时长 log_slow_queries={ON|OFF}：日志是否开启慢查询功能 slow_query_log={ON|OFF}：是否开启慢查询功能 slow_query_log_file：慢查询文件 log_output={FILE|TABLE|NONE}：慢查询类型 log_slow_filter=admin,filesort,filesort_on_disk,full_join,full_scan,query_cache,query_cache_miss,tmp_table,tmp_table_on_disk 慢查询过滤 log_slow_rate_limit：慢查询速率限制 log_slow_verbosity 查看默认值 MariaDB [mysql]&gt; SHOW VARIABLES LIKE &apos;long_query_time&apos;; +-----------------+-----------+ | Variable_name | Value | +-----------------+-----------+ | long_query_time | 10.000000 | +-----------------+-----------+ 存储位置 文件：FILE 表：TABLE,mysql.slog_log 错误日志错误日志记录如下几类信息： （1）mysqld启动和关闭过程中输出的信息 （2）mysqld运行中产生的错误信息 （3）event scheduler运行时产生的信息，相当于周期性计划 （4）主从复制架构中，从服务器复制线程启动时产生的日志 选项： log_error=/var/log/mariadb/mariadb.log|log #是否开启错误日志 log_warnings={ON|OFF}：是否开启警告日志 示例： 建议：开启错误日志功能，方便以后排错 二进制日志用于记录引起数据改变或存在引起数据改变的潜在可能性的语句（STATEMENT）或改变后的结果（ROW）,也可能是二者混合。 作用：实现重放，恢复到某个时间点。 选项： binlog_format={STATEMENT|ROW|MIXED} #二进制日志格式 log_bin=/PATH/TO/BIN_LOG_FILE 定义二进制日志存放位置 session.sql_log_bin={ON|OFF}：控制某回话中的”写“操作语句是否会被记录于日志文件中 max_binlog_size 二进制文件最大容量 sync_binlog={1|0}：是否同步到磁盘中，binlogs先缓冲在内存中，不会立即写入磁盘中，开启此选项是否直接写入磁盘中。 查看二进制日志文件中的事件语法： SHOW BINLOG EVENTS [IN &apos;log_name&apos;] [FROM pos] [LIMIT [offset,] row_count] 示例： 创建二进制日志存放位置 [root@mysql~]#mkdir /app/data/binlog -pv [root@mysql~]#chown -R mysql.mysql /app/data/binlog/ #对mysql用户赋予权限 修改服务端配置文件启动二进制日志功能 [root@mysql~]#vim /etc/my.cnf.d/server.cnf 注意：二进制文件自动会加后缀 重启mysql服务 [root@mysql~]#systemctl restart mariadb 查看是否启动二进制功能 测试是否已经可以使用二进制日志功能 执行一些语句 MariaDB [hellodb]&gt; SELECT * FROM courses; 查看是否生成二进制文件 [root@mysql/app/data/binlog]#ls master-log.000001 master-log.index 查看二进制内容方法 [root@mysql/app/data/binlog]#mysqlbinlog master-log.000001 事件的起始位置：# at NUMBER 事件发生的日期时间：#171110 21:07:44 事件发生的服务器ID：server id 1 事件的结束位置： end_log_pos 427 事件的类型：Query 事件发生时所在服务器执行此时间的线程ID：thread_id=2 语句的时间戳与将其写入二进制日志文件中的时间差：exec_time=0 错误代码：error_code=0 设定时间发生的时间戳：SET TIMESTAMP=1510320590/*!*/; 事件内容 中继日志：从服务器上记录下来从主服务器的二进制日志文件同步过来的事件 事物日志：事物型存储引擎innodb用于保证事物特性的日志文件 注意：如果我们使用二进制日志回放，建议关闭此时会话记录二进制日志。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL日志</category>
      </categories>
      <tags>
        <tag>日志，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL引擎]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[ACID测试 A：AUTOMICITY ，原子性；整个事物中的所有操作要么全部成功执行，要么全部失败后回滚 C：CONSISTENY,一致性；数据库总是应该从一个一致性状态转为另一个一致性状态 I：ISOLATION：隔离性；一个数据所作出的操作在提交之前，是否能为其它事物可见；出于保证并发操作之目的，隔离有多种级别 D：DURABILITY 持久性；事物一旦提交，其所作出的修改会永久保存 事物隔离级别 READ-UNCOMMITTED：读未提交–&gt;脏读 READ-COMMITTED：读提交–&gt;不可重复读 REPEATABLE-READ：可重复读–&gt;幻读 SERIALIZABLE：串行化 手动控制事物启动：START TRANSACTION 提交：COMMIT 回滚：ROLLBACK 事物支持savepoints： SAVEPOINT identifier ROLLBACK [work] TO [SAVEPOINT] identifier RELEASE SAVEPOINT identifier 查看InnoDB存储引擎的状态信息 MariaDB [class]&gt; SHOW ENGINE innodb STATUS\G; mysql服务器引擎- 存储引擎：也称为“表类型”，表级别概念，不建议咋同一个库中的表上使用不同的ENGINE。 查看数据库服务器支持的引擎 MariaDB [(none)]&gt; SHOW ENGINES\G; MariaDB [(none)]&gt; SHOW ENGINE INNODB STATUS\G; #显示INNODB引擎状态 常见的引擎 MyISAM, Aria, InnoDB, MRG_MYISAM, CSV, BLACKHOLE, MEMORY, PERFORMANCE_SCHEMA, ARCHIVE, FEDERATED InnoDB和MyISAM引擎的区别- InnoDB Percon-XtraDB，支持事物，支持级别锁，支持外键 数据存储在“表空间（tables space）”中： （1）所有数据库中所有类型为InnoDB的表的数据和索引存储于同一个表空间中； 表空间文件：datadir定义的目录中 文件：ibdata1，ibdata2... （2）innodb_file_per_table=ON这个选项添加到配置文件中意味着每张表使用单独的表空间文件；每张表的数据文件（数据和索引，存储于数据库目录）存储在自己专用的表空间文件中，并存储于数据库目录下：tb1_name.ibd 表结构定义：在数据库目录，tb1——name.frm [root@localhost~]#vim /etc/my.cnf [root@localhost~]#systemctl start mariadb.service #重启服务 MariaDB [students]&gt; CREATE TABLE student (ID INT,NAME VARCHAR(30)); #创建一张表 [root@localhost/var/lib/mysql/students]#ls db.opt student.frm student.ibd 事务性存储引擎，适合对事物要求较高的场景中；但较适用于处理大量短期事物 基于MVCC（Mutli Version Concurrency Control） 支持高并发； 支持四个隔离级别，默认级别为REPEATALBE-READ;间隙锁以防止幻读 MariaDB [students]&gt; SHOW SESSION VARIABLES LIKE ‘tx_isolation’; +—————+—————–+ | Variable_name | Value | +—————+—————–+ | tx_isolation | REPEATABLE-READ | +—————+—————–+ MariaDB [students]&gt; SELECT @@GLOBAL.tx_isolation; +———————–+ | @@GLOBAL.tx_isolation | +———————–+ | REPEATABLE-READ | +———————–+ 使用聚集所以（主键索引） 支持“自适应Hash索引” 锁粒度：行级锁，间隙锁 小结： 数据存储：表空间 并发：MVCC，间隙锁，行级锁 索引：聚集索引、辅助索引 性能：预读操作、内存数据缓冲、自适应Hash索引、插入操作缓存区 备份：支持热备 MyISAM 支持全文索引、压缩、空间函数（GIS） 不支持事物 锁粒度：表级锁 崩溃无法保证表安全恢复 使用场景：只读或读多写少的场景、较小的表（以保证崩溃后恢复的时间较短） 文件：每个表有三个文件，存储于数据库目录中 tb1_name.frm：表格式定义 tb1_name.MYD：数据文件 tb1_name.MYI：索引文件 示例： MariaDB [students]&gt; CREATE DATABASE class; MariaDB [class]&gt; CREATE TABLE classes (ID INT ,number INT) ENGINE MyISAM; #创建表并指定引擎 [root@localhost/var/lib/mysql/class]#ls classes.frm classes.MYD classes.MYI class.frm class.ibd db.opt 特性： 加锁和并发：表级锁 修复：手动或自动修复、但可能会丢失数据 索引：非聚集索引 延迟索引更新 表压缩 其他的存储引擎CSV：将CSV文件（以逗号分隔字段的文本文件）作为mysql表文件 MRG_MYISAM：将多个MyISAM表合并成虚拟表 BLANCKHOLE：类似于/dev/null，不真正存储数据 MEMORY：内存存储引擎，支持hash索引，表级锁，常用于临时表 FEDERATED：用于访问其他远程mysql服务器上表的存储引擎接口 mariadb额外支持很多中引擎：OQGraph、SphinxSE、TokuDB、Cassandra、CONNECT、SQUENCE、..]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL引擎</category>
      </categories>
      <tags>
        <tag>引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL用户管理]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[用户管理1、新建普通用户（1）使用CREATE USER语句创建新用户 使用格式： CREATE USER &apos;user&apos;@&apos;host&apos; [IDENTIFIED BY [PASSWORD] &apos;password&apos;] [,&apos;user&apos;@&apos;host&apos; [IDENTIFIED BY [PASSWORD] &apos;password&apos;]...] user：新建用户 host：主机名 IDENTIFIED BY 设置用户密码 示例： MariaDB [(none)]&gt; CREATE USER test@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;; 在mysql.user表中会插入一行记录 MariaDB [(none)]&gt; SELECT user,host,password FROM mysql.user; +------+-----------------------+-------------------------------------------+ | user | host | password | +------+-----------------------+-------------------------------------------+ | root | localhost | | | root | localhost.localdomain | | | root | 127.0.0.1 | | | root | ::1 | | | | localhost | | | | localhost.localdomain | | | test | localhost | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 | +------+-----------------------+-------------------------------------------+ （2）在musql.user表中INSERT用户 MariaDB [(none)]&gt; INSERT INTO mysql.user (user,host,password) VALUES (&quot;testA&quot;,&quot;192.168.4.60&quot;,PASSWORD(&apos;123456&apos;)); 执行完INSERT之后，要使用如下命令生效。 MariaDB [(none)]&gt; FLUSH PRIVILEGES; （3）使用GRANT创建用户 使用格式： GRANT priv_type ON database.table TO user[IDENTIFIED BY [PASSWORD] &apos;password&apos;] [,user [IDENTIFIED BY [PASSWORD] &apos;password&apos;]...] priv_type：授予的权限 database.table：权限的范围 user：新建用户 IDENTIFIED BY 设置密码 示例： MariaDB [(none)]&gt; GRANT SELECT ON *.* TO testB@&apos;192.168.4.60&apos; IDENTIFIED BY &apos;123456&apos;; 2、重命名使用格式： RENAME USER old_user TO new_user[, old_user TO new_user] ... 示例： MariaDB [(none)]&gt; RENAME USER testA@&apos;192.168.4.60&apos; TO testC@&apos;192.168.4.60&apos;; 3、删除用户使用格式： DROP USER &apos;user&apos;@&apos;host&apos; [, &apos;user&apos;@&apos;host&apos;] ... 示例： MariaDB [class]&gt; DROP USER testC@&apos;192.168.4.60&apos;; 4、修改用户密码（1）使用mysqladmin命令修改密码 使用格式： mysqladmin -uUSERNAME -hHOST -p password &apos;NEW_PASS&apos; 示例： [root@localhost~]#mysqladmin -uroot -p password Enter password: New password: Confirm new password: [root@localhost~]#mysqladmin -utest -p password &#39;testabd&#39; Enter password: mysqladmin: Can&apos;t turn off logging; error: &apos;Access denied; you need (at least one of) the SUPER privilege(s) for this operation&apos; 修改普通用户需要超级管理权限 （2）修改mysql.user表 使用格式： UPDATE mysql.user SET Password=PASSWORD(&apos;cleartext password&apos;) WHERE User=&apos;USERNAME&apos; AND Host=&apos;HOST&apos;; 示例： MariaDB [(none)]&gt; UPDATE mysql.user SET PASSWORD=PASSWORD(&apos;testabcd&apos;) WHERE User=&apos;test&apos;; （3）使用SET语句修改密码 使用格式： SET PASSWORD [FOR &apos;user&apos;@&apos;host&apos;] = PASSWORD(&apos;cleartext password&apos;); 示例： MariaDB [(none)]&gt; SET PASSWORD FOR test@&apos;localhost&apos;=PASSWORD(&apos;testabcd&apos;); （4）GRANT语句修改普通用户密码 示例： MariaDB [(none)]&gt; GRANT SELECT ON *.* TO &apos;test&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;; 5、忘记管理员密码如何解决？（1）先确保mysql服务停止 [root@localhost~]#systemctl stop mariadb.service （2）确保其他用户连接不到mysql服务 （3）修改启动配置文件 [root@localhost~]#vim /usr/lib/systemd/system/mariadb.service （4）启动服务并修改密码 [root@localhost~]#systemctl restart mariadb.service MariaDB [(none)]&gt; UPDATE mysql.user SET PASSWORD=PASSWORD(&apos;123456&apos;) WHERE user=&apos;root&apos;; （5）修改更改文件 [root@localhost~]#systemctl stop mariadb.service [root@localhost~]#vim /usr/lib/systemd/system/mariadb.service 删除刚添加的参数 （6）重启服务测试 [root@localhost~]#systemctl restart mariadb.service [root@localhost~]#mysql -uroot -p Enter password: Welcome to the MariaDB monitor. Commands end with ; or \g. Your MariaDB connection id is 3 Server version: 5.5.56-MariaDB MariaDB Server 授权使用格式： GRANT priv_type [(column_list)] [, priv_type [(column_list)]] ... ON [object_type] priv_level TO user_specification [, user_specification] ... [REQUIRE {NONE | ssl_option [[AND] ssl_option] ...}] [WITH with_option ...] priv_type：表示权限类型 column_list：设置列 user：设置用户 password：用户密码 WITH关键字后面带有一个或多个with_option参数 GRANT OPTION：被授权用户可以使用的参数 MAX_QUERIES_PER_HOUR count：设置每小时允许执行的count查询 MAX_UPDATES_PER_HOUR count：设置每小时count更新 MAX_CONNECTIONS_PER_HOUR count：设置每小时可以建立count连接 MAX_USER_CONNECTIONS count：设置单个用户可以同时具有count连接数 示例： MariaDB [class]&gt; GRANT SELECT(number) ON class.class TO &apos;test&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;; 查看授权使用格式： SHOW GRANTS [FOR &apos;user&apos;@&apos;host&apos;] 示例： MariaDB [class]&gt; SHOW GRANTS FOR test@&apos;localhost&apos;\G; *************************** 1. row *************************** Grants for test@localhost: GRANT SELECT ON *.* TO &apos;test&apos;@&apos;localhost&apos; IDENTIFIED BY PASSWORD &apos;*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9&apos; *************************** 2. row *************************** Grants for test@localhost: GRANT SELECT (number) ON `class`.`class` TO &apos;test&apos;@&apos;localhost&apos; MariaDB [class]&gt; SHOW GRANTS ; #默认查询root的权限 取消授权使用格式 REVOKE priv_type [(column_list)][, priv_type [(column_list)]] ... ON [object_type] priv_level FROM &apos;user&apos;@&apos;host&apos; [, &apos;user&apos;@&apos;host&apos;] ... 示例： MariaDB [class]&gt; REVOKE SELECT(number) ON class.class FROM test@&apos;localhost&apos;;]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL用户管理</category>
      </categories>
      <tags>
        <tag>用户管理，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL索引]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[mysql索引提取索引的创建在的表上字段中的数据，构建出一个独特的数据结构。 索引的作用加速查询操作；副作用：降低些操作性能 表中数据子集：把表中某个或某些字段的数据提取出来另存为一个特定数据结构组织的数据。 某个字段或某些字段：WHERE子句中用到的字段 索引类型B+ TREE顺序存储，每一个叶子节点到根节点的距离相同；左前缀索引，适用于范围类型的数据查询 使用域B+ TREE索引查询类型：全键值、键值范围或键前缀全值匹配：精确匹配某个值 WHERE COLUMN = &apos;VALUE&apos;; 匹配左前缀：只精确匹配开头的部分 WHERE COLUMN LIKE &apos;PREFIX%&apos; 匹配范围值： 精确匹配某一列，范围匹配另一列 只用访问索引的查询：覆盖索引 index（NAME） SELECT NAME FROM students WHERE NAME LIKE &apos;L%&apos;; 不使用B+ TREE索引如果查询条件不是从最左侧开始，索引无效 index（age，fname） WHERE fname=‘jerry’; WHERE age &gt;30 AND fname=’smith&apos;; 不能跳过索引中的某列 index（name，age，gender） WHERE name=&apos;block&apos; and age &gt;30; WHERE name=&apos;block&apos; and gender=&apos;F&apos;; 如果查询中的某个列时为范围查询，那么其右侧的列都无法再使用索引优化查询。 WHERE age&gt;30 AND fname=&apos;smith&apos;; hash索引基于哈希表实现，特别适用于值的精确匹配查询。 使用场景：只支持等值比较实现，例如=、IN(),&lt;=&gt; 不使用场景所有非精确值查询，mysql仅对memory存储引擎支持显示的hash索引 索引优点降低需要扫描的数据量，减少IO次数； 可以帮助避免排序操作，避免使用临时表 帮助将随机IO转为顺序IO 高性能索引策略： 在WHERE中独立使用列，尽量避免其参与运算 WHERE age+2 &gt; 23 左前缀索引：索引构建于字段的最左侧的多少个字符，要通过索引选择性来评估 索引选择性：不重复的索引值和数据表的记录总数的比值 多列索引 AND连接的多个查询条件更适合使用多列索引，而非多个单间索引 选择合适的索引列次序：选择性更高的放左侧 示例： MariaDB [student]&gt; CREATE INDEX age ON students(age); #创建索引 MariaDB [student]&gt; SHOW INDEX FROM students; #查看索引 MariaDB [student]&gt; CREATE INDEX age_and_name ON students(age,name); #创建组合索引 MariaDB [student]&gt; EXPLAIN SELECT name,age FROM students WHERE age &gt; (SELECT avg(age) FROM students); +------+-------------+----------+-------+------------------+--------------+---------+------+------+--------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +------+-------------+----------+-------+------------------+--------------+---------+------+------+--------------------------+ | 1 | PRIMARY | students | index | age,age_and_name | age_and_name | 38 | NULL | 2897 | Using where; Using index | | 2 | SUBQUERY | students | index | NULL | age | 5 | NULL | 2897 | Using index | +------+-------------+----------+-------+------------------+--------------+---------+------+------+--------------------------+ 从上述可以看出通过使用index查询 EXPLAIN来分析索引有效性使用格式： EXPLAIN [explain_type] SELECT select_options 输出格式信息分析： id：当前查询语句中，第个SELECT 语句的编号 注意：联合查询的分析结果会出现一个额外的匿名临时表 select_type：查询类型 简单查询：SIMPLE 复杂查询： 简单子查询：SUBQUERY 用于FROM中的子查询：DERIVED 联合查询中的第一个查询：PRIMARY 联合查询中的第一个查询之后的其他查询：UNION 联合查询生成的临时表：UNION RESULT table：查询针对的表 type：关联类型，或称为访问类型，即mysql如何取查询表中的行 ALL ：全表扫描 index：根据索引的顺序进行的全表扫描；但同时如果EXTRA列出现了“Using index”表示使用了覆盖索引 range：有范围限制地根据索引实现范围扫描；扫描位置始于索引中的某一项，结束语另一项 ref：根据索引返回的表中匹配到某单个值的所有行（匹配给定值的行不止一个） eq_ref：根据索引返回的表中匹配到某单个值的单一行，仅返回一个行，但需要与某个额外的参考值比较，而不是常熟 const，systemc：与某个常数比较，且只返回一行 possible_keys：查询中可能会用到的索引 key：查询中使用的索引 key_len：查询中用到的索引长度 ref：在利用key字段所显示的索引完成查询操作时所引用的列或常量值 rows：mysql估计出的为找到所有的目标而需要读取的行数 Extra：额外信息 Using index：使用了覆盖索引进行的查询 Using where：拿到数据后还要再次进行过滤 Using temporary：使用了临时表以完成查询 Using filesort：对结果使用了一个外部索引排序]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL索引</category>
      </categories>
      <tags>
        <tag>索引，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAM]]></title>
    <url>%2F2017%2F11%2F28%2FPAM%2F</url>
    <content type="text"><![CDATA[PAM认证1、概念 PAM （Pluggable Authentication Modules）可插入认证模块是一套共享库,使本地系统管理员可以随意选择程序的认证方式.。提供了对所有服务进行认证的中央机制，适用于login，远程登录（telnet，rlogin,fsh,ftp，点对点协议（ppp）），su等应用程序中。系统管理员通过PAM配置文件来指定不同应用程序的不同认证策略；应用程序开发者通过在服务程序中使用PAM API来实现对认证方法的调用；而PAM服务模块的开发者则利用PAM SPI来编写模块，主要调用一些函数，将不同的认证机制加入到系统中；PAM接口库则读取配置文件，将应用和相应PAM服务模块联系起来。 2、配置文件模块存放位置/lib64/security/ 环境相关的配置/etc/security/ 模块通过读取配置文件完成用户对系统资源的使用控制 主配置文件/etc/pam.conf 默认不存在 文档 /usr/share/doc/pam-*;man -k pam_ 查看所有pam的说明 注意：如果/etc/pam.d/和/etc/pam.conf两个文件同时存在，则只有/etc/pam.d/*下的文件起效。 3、认证原理PAM一般遵循的顺序：server–&gt;PAM（配置文件）–&gt;pam.*so；PAM认证首先要确定哪一项服务，然后加载相应PAM的配置文件（/etc/pam.d）,最后调用认证文件（/lib64/security/）进行认证。 4、passwd程序PAM认证机制过程（1）用户执行/usr/bin/passwd程序，并输入密码； （2）passwd开始呼叫PAM模块，PAM模块会搜寻passwd程序的PAM相关设定文件，这个设定文件在/etc/pam.d/目录下与之程序同名的文件。即PAM会搜寻/etc/pam.d/passwd （3）经由/etc/pam.d/passwd设定的文件数据取用PAM所提供的相关模块来进行验证； （4）将验证结果回传给passwd程序，而passwd这个程序会根据PAM回传的结果决定下一个动作。 5、/etc/pam.d/目录下文件格式||type|control|module-path|argument| （1）type类型 type 解释 Auth 账号的认证和授权 Account 与账号管理相关的非认证类的功能 Password 用户修改密码复杂度检查机制等功能 Session 用户获取之前或使用服务完成之后需要进行的一些附加操作，如打开或关闭数据的信息，监视目录等 -type 表示因为缺失而不能加载的模块将不记录在系统日志，对于不总是安装在系统上的模块有用 （2）control PAM库如何处理与该服务相关的PAM模块成功或失败情况 control 解释 required 一票否决，表示本模块必须返回成功才能通过认证，但是如果该模块返回失败，失败结果也不会立即通知用户，而是要等到同一type类型全部执行完毕再将放回给应用程序。即为必要条件 requisite 一票否决，该模块必须返回成功才能通过认证，但是一旦该模块返回失败，将不再执行同一type内的任何模块，而是直接将控制权返回给应用程序。即一个必要条件 sufficient 一票通过权，表明本模块返回成功则通过身份认证的要求，不必再执行同一type内的其他模块，但是如果本模块返回失败可忽略，即充分条件 optional 表明本模块为可选的，它的成功与否不会对身份认证起关键作用，其返回值一般被忽略 include 调用其他的配置文件中定义的配置信息 还有另外一种方式：使用一个或多个“status=action” status：检查结果的返回值 action：采取行为ok，done，die，bad，ignore，reset action 解释 ok 模块通过，继续检查 done 模块通过，返回最后检查给应用 bad 结果失败，继续检查 die 结果失败，返回失败结果给应用 ingore 结果忽略，不影响最后结果 reset 忽略已经得到的结果 （3）modules-path 相对路径:/lib64/security目录下的模块可使用的相对路径；如pam_shells.so绝对路径：如果编译安装以后模块存放的位置 建议：将来修改PAM文件时，备用一个ssh连接窗口，以免我们误操作。 （4）argument 用来给该模块传递参数 6、常用pam模块1、pam_shells：检查有效shell 会调用文件/etc/shells 示例 （a）先创建用户指定其bash为/bin/csh [root@centos6~]#useradd -s /bin/bash wang （b）在CentOS6上修改/etc/shells和/etc/pam.d/su文件 在认证前添加 auth required pam_shells.so （c）在CnetOS6使用wang账户登录 [root@localhostsecurity]#su - wang Password: su: incorrect password 但是此时使用ssh还可以连接 [root@localhostpam.d]#ssh wang@192.168.4.131 wang@192.168.4.131&apos;s password: Last login: Thu Sep 14 13:42:35 2017 from 192.168.4.131 如果我们想彻底禁止wang登录把/etc/pam.d/su 和/etc/pam.d/sshd两个文件在auth前天添加如下一行： auth required pam_shells.so （d）如果让wang登录删除上述设置即可。 2、pam_securetty.so：只允许root用户在/etc/securetty列出的安全终端上登录 示例 允许telnet使用root登录 方法一： 修改配置文件/etc/pam.d/remote配置文件 #auth required pam_securetty.so 方法二： 直接修改/etc/securetty添加所需要登录的终端；如果连接的终端使用完毕后，后续的连接将不会执行。 3、pam_nologin.so：如果/etc/nologin文件存在，将导致非root用户不能登录 作用机理：如果用户shell是/etc/nologin时，当该用户登录时，会显示/etc/nologin.txt文件内容，并拒绝登录。 file=/PATH/TO/SOMEFILE 示例 修改配置文件login文件添加入下面一行： auth required pam_nologin.so 在CentOS7使用wang登录 [root@centos7~]#ssh wang@192.168.4.131 wang@192.168.4.131&apos;s password: Connection closed by 192.168.4.131 如果想给非root用户提示信息可以编辑文件/etc/pam.d/nologin account required pam_nologin.so file=/etc/nologin.txt 4、pam_limits.so：在用户级别对其可使用的资源的限制 （1）配置文件 /etc/security/limits.conf /etc/security/limits.d/*.conf （2）格式 ||domain|type|item|value| （a）domain 应用于哪些对象 username 单个用户 @group 组内所有用户 （b）type类型 soft软限制，普通用户可以自己修改；如果出现会有警告信息 hard硬限制，只有root能设定，且通过kernel强制生效 -：两者同时设定 （c）item 限制资源 选项 说明 core limits the core file size (KB) data max data size (KB) fsize maximum filesize (KB) memlock max locked-in-memory address space (KB) nofile max number of open file descriptors rss max resident set size (KB) stack max stack size (KB) cpu max CPU time (MIN) nproc max number of processes as address space limit (KB) maxlogins max number of logins for this user maxsyslogins max number of logins on the system priority the priority to run user process with locks max number of file locks the user can hold sigpending max number of pending signals msgqueue max memory used by POSIX message queues (bytes) nice max nice priority allowed to raise to values: [-20, 19] rtprio max realtime priority （4）value 指定具体值 ulimit命令的使用 选项 解释 -a 列出所有设定值 -n 最多打开的文件描述符个数 -u 最大用户进程数 -S 使用’SOFT’资源限制 -H 使用‘HARD’资源限制 5、pam_time.so （1）格式： services; ttys ；users； times （2）services 服务程序名称 （3）ttys 登录的终端 可是使用* （4）users 用户 （5）times 格式：day/time-range Mo Tu We Th Fr Sa Su Wk Wd Al MoMo = no day MoWk = all weekdays bar Monday 所有的工作日但是除了星期一 AllFr 所有添但是除了星期五 time-range： 格式：HHMM 如果开始时间小于结束时间，系统假设到了第二天。 可是使用模式 “&amp;” “ |”“ ！” 示例 禁止用户上班时间使用ssh服务 编辑/etc/security/time.conf添加如下一行： sshd;*;centos;Wk 编辑/etc/pam.d/sshd添加如下一行： auth required pam_time_so 了解pam_group.so模块]]></content>
      <categories>
        <category>安全</category>
        <category>PAM</category>
      </categories>
      <tags>
        <tag>PAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL表分区]]></title>
    <url>%2F2017%2F11%2F28%2FMySQL%E8%A1%A8%E5%88%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[MySQL表分区MySQL表分区有两种切分方法： 垂直切分：切库，把一个库中的多个表分组后放置于不同的物理服务器上。 水平切分：切表，分散其行至多个表中存放（table partitions）。 partition_options:PARTITION BY { [LINEAR] HASH(expr) | [LINEAR] KEY(column_list) | RANGE{(expr) | COLUMNS(column_list)} | LIST{(expr) | COLUMNS(column_list)} } [PARTITIONS num] [SUBPARTITION BY { [LINEAR] HASH(expr) | [LINEAR] KEY(column_list) } [SUBPARTITIONS num] ] [(partition_definition [, partition_definition] ...)] partition_definition:PARTITION partition_name [VALUES {LESS THAN {(expr | value_list) | MAXVALUE} | IN (value_list)}] [[STORAGE] ENGINE [=] engine_name] [COMMENT [=] &apos;comment_text&apos; ] [DATA DIRECTORY [=] &apos;data_dir&apos;] [INDEX DIRECTORY [=] &apos;index_dir&apos;] [MAX_ROWS [=] max_number_of_rows] [MIN_ROWS [=] min_number_of_rows] [TABLESPACE [=] tablespace_name] [NODEGROUP [=] node_group_id] [(subpartition_definition [, subpartition_definition] ...)] 分区类型： range：通过将数据划分为不同的范围 hash ：通过对表的一个或多个列hash key 计算，最后通过这个hash码不同的数值对应的数据区域进行分区 列:根据列进行划分]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL表分区</category>
      </categories>
      <tags>
        <tag>分表，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP工作方式]]></title>
    <url>%2F2017%2F11%2F28%2FPHP%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[CGI和FastCGI1、CGICGI（Common Gateway Interface，通用网关接口），HTTP服务器与你的货其他机器上的程序进行交谈的工具，其程序一般运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。 2、FastCGIFastCGI像是一个常驻型的CGI，它可以一直执行，只要激活后，不会每次都要花费时间去fork一次。 工作原理 （1）Web Server启动时载入FastCGI进程管理器（IIS ISAPI或Apache Module) （2）FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web Server的连接。 （3）当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。 Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。 （4）FastCGI 子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时， 请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。 3、php-fpm和FastCGI（1）两者之间有何联系php的解析器是php-cgi，只能解析请求，返回结果，不会对进程管理；为了能调用php-cgi进程程序，php-fpm就诞生了。 #####在CentOS 6 中： PHP-5.3.2之前，默认不支持fpm机制，需要自行打补丁并编译安装； httpd-2.2：默认不支持fcgi协议，需要自行编译此模块； 为了能在CentOS 6 中支持此功能，编译安装http和php即可。 在CentOS 7中：httpd-2.4：rpm包默认编译支持了fcgi模块 php-fpm包：专用于将php运行于fpm模式 （2）配置文件这里在CentOS7中对php-fpm配置文件进行讲解 [root@localhost~]#yum install -y php-fpm #直接使用yum源安装即可 主配置文件： /etc/php-fpm.conf 和 /etc/php-fpm.d/*.conf 选项介绍： pm = static(固定数量的子进程)|dynamic（以动态模式管理） pm.max_children 最大子进程 pm.start_servers 初始化时开启的子进程 pm.min_spare_servers 最小空闲子进程 pm.max_spare_servers 最大空闲子进程 pm.max_requests 每个子进程最大请求数量 php_value[session.save_handler] 设置类型 php_value[session.save_path] 文件的存储位置 为了确保运行php-fpm进程的用户对session目录有读写权限 mkdir /var/lib/php/session chown apache.apache /var/lib/php/session 如果想支持远程主机：修改配置文件/etc/php-fpm.d/www.conf listen 格式： ip.add.re.ss:port port listen.allowed_clients 允许远程who连接，默认any listen.backlog 等待队列的长度，-1表示无限制 （3）使http支持php-fpm确认httpd程序是否已经加载了proxy_fcgi_module [root@localhost/etc/php-fpm.d]#httpd -M |grep fcgi #必须加载了这个模块才能支持php-fpm 进行配置[root@localhost/etc/httpd/conf.d]#vim fastcgi.conf DirectoryIndex index.php #设置默认索引文件 ProxyRequests off #是否开启正向代理 ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/var/www/html/$1 #路径匹配 [root@localhost/etc/httpd/conf.d]#ss -tnl #查看端口是否开启 下面我们来测试下性能如何？ [root@localhost/etc/httpd/conf.d]#ab -c 10 -n 100 http://192.168.4.60/wordpress/ #测试我们在CentOS 7 搭建的博客 独立运行的php跟模块方式运行的php的性能略有提升。]]></content>
      <categories>
        <category>服务</category>
        <category>LAMP</category>
        <category>PHP工作方式</category>
      </categories>
      <tags>
        <tag>lphp，工作模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis主从复制]]></title>
    <url>%2F2017%2F11%2F28%2FRedis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[redis主从复制一个master可以有多个slave主机，支持链式复制；master以非阻塞方式同步数据值slave主机。 修改方式： redis-cli&gt; SLAVEOF &lt;MASTER_IP&gt; &lt;MASTER_PORT&gt; redis-cli&gt; CONFIG SET masterauth &lt;PASSWORD&gt; 节点 IP 角色 node1 192.168.4.61 master node2 192.168.4.62 slave node3 192.168.4.63 slave 同步时间基于主机名访问确保firewalld和selinux是否关闭三个节点上都安装redis[root@node1~]#yum install -y redis[root@node1~]#systemctl start redis.service node1进行配置[root@node1~]#vim /etc/redis.conf bind 0.0.0.0 requirepass centos node2和node3配置node2以第一种方式配置-[root@node2~]#vim /etc/redis.conf bind 0.0.0.0 requirepass centos slaveof 192.168.4.61 6379 masterauth centos slave-priority 90 [root@node2~]#systemctl start redis node3以第二种方式配置- 127.0.0.1:6379&gt; CONFIG GET slaveof #查看salveof的值 1) &quot;slaveof&quot; 2) &quot;&quot; 127.0.0.1:6379&gt; SLAVEOF 192.168.4.61 6379 #设定slaveof的值 OK 127.0.0.1:6379&gt; CONFIG GET slaveof 1) &quot;slaveof&quot; 2) &quot;192.168.4.61 6379&quot; 127.0.0.1:6379&gt; CONFIG SET masterauth centos OK 127.0.0.1:6379&gt; CONFIG SET requirepass centos OK 127.0.0.1:6379&gt; CONFIG GET slave-read-only (error) NOAUTH Authentication required. 127.0.0.1:6379&gt; AUTH centos OK 127.0.0.1:6379&gt; CONFIG GET slave-read-only 1) &quot;slave-read-only&quot; 2) &quot;yes&quot; 127.0.0.1:6379&gt; CONFIG REWRITE OK 在node1上查看 测试 sentinel主要完成三个功能：监控、通知、自动故障转移 配置项port 指定端口 sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; 设定监控 &lt;quorum&gt; 表示sentinel集群的quorum机制，即至少quorum个sentinel节点同时判定主节点故障，才认为其真的故障 s_down：subjectively down o_down：objectively down sentinel auth-pass &lt;master-name&gt; &lt;password&gt; 连接主节点的密码 sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; 指定failover过程中，能够被sentinel并行配置的从节点的数量 sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt; sentinel必须在此指定的时长内完成故障转移操作，否则，将视为故障转移操作失败 sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; 通知脚本，此脚本被自动传递多个参数 命令： redis-cli -h SENTINEL_HOST -p SENTINEL_PORT redis-cli &gt; SENTINEL masters SENTINEL slaves &lt;MASTER_NAME&gt; SENTINEL failover &lt;MASTER_NAME&gt; SENTINEL get-master-addr-by-name &lt;MASTER_NAME&gt; 注意：在集群中每个节点都要配置并启动sentinel服务。 ### 在刚刚三个集群中配置 [root@node1~]#vim /etc/redis-sentinel.conf bind 0.0.0.0 sentinel monitor mymaster 192.168.4.61 6379 2 sentinel auth-pass mymaster centos systemctl start redis-sentinel.service 查看此时的主节点 [root@node1~]#systemctl stop redis.service down掉主节点 如果故障点修改成功需要上线，进行如下操作： [root@node1~]#vim /etc/redis.conf slaveof 192.168.4.62 6379 masterauth centos slave-priority 70 [root@node1~]#systemctl start redis.service]]></content>
      <categories>
        <category>缓存服务</category>
        <category>Redis</category>
        <category>Redis主从复制</category>
      </categories>
      <tags>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis简单介绍]]></title>
    <url>%2F2017%2F11%2F28%2FRedis%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、Redis1、Redis简介Redis是一个开源的内存数据结构存储，用作数据库，缓存和消息代理。支持数据结构：字符串、列表（数组）、hahses（关联数据）、集合、有序集合、位图、hyperloglogs、空间索引。支持内建的复制，Lua 脚本，LRU算法、事物、持久存储、高可用。基于内存的高性能key-value数据库。 2、Redis优势 性能极高 丰富的数据类型 原子性 丰富的特性 3、Redis安装[root@node1~]#yum install -y redis 安装时会安装jemalloc（支持并存存储） （1）程序文件配置文件：/etc/redis.conf 主程序：/usr/bin/redis-server Unit File ：/usr/lib/systemd/system/redis.service 数据目录：/var/lib/redis 监控配置文件：/etc/redis-sentinel.conf （2）/etc/redis.conf文件详解[root@node1~]#grep &#39;###&#39; /etc/redis.conf INCLUDES 包括其他文件配置 NETWORK 网络配置项 bind IP 监听地址，一般为本地对外通信的地址，多个地址使用空格分隔。0.0.0.0表示监听所有地址 port PORT 监听的端口 protected-mode 是否启用受保护模式 如果bind和port其中一个没有设定就启用保护模式 tcp-backlog tcp级的后援队列长度 unixsocket unix套接字 tcp-keepalived 保持连接时长 timeout 连接的超时时长 GENERAL 基本配置项 daemonize 是否启用守护进程 supervised loglevel 日志级别 pidfile pid文件 logfile 日志文件 databases 设定数据库数量，默认为16个，每个数据库的名字均为正数，从0开始标号，默认操作的数据库为0 SNAPSHOTTING 快照配置项 按事先定制的策略，周期性地将数据从内存同步至磁盘；数据文件默认为dump.rdb 客户端显示使用SAVE或BGSAVE命令手动自动快照保存机制 SAVE：同步，即在主线程中保存快照，此时会阻塞所有客户端请求 BGSAVE：异步，backgroud（后台）进行 save 定义保存策略 表示三个策略满足其中任意一个均会触发SNAPSHOTTING操作；900s内至少有一个key变化，300s内至少有10个key变化；60s内至少有1w个key变化 stop-writes-on-bgsave-error dump操作出现错误时，是否禁止新的写入操作请求 rdbcompression 是否启用压缩功能 rdbchecksum 是否检验 dbfilename 文件名称 dir 定义保存文件的路径，通常不再默认位置下存放 REPLICATION 复制相关的配置项 slave-serve-stale-data 是否使用过期数据响应用户 slave-read-only 设置从为只读 repl-diskless-sync 复制是否无磁盘的复制 新的从节点或某较长时间未能与主节点进行同步的从节点重新与主节点通信，需要做“full synchronization”，此时其同步方式： （1）Disk-backend：主节点新创建快照文件与磁盘中，而后将其发送给从节点 （2）Diskless：主节点新创建快照后直接通过网络套接字文件发送给从节点；为了实现并行复制，通常需要在复制启动前延迟一个时间段。 repl-diskless-sync-delay 启用无磁盘延迟时间 repl-ping-slave-eriod 探测冲节点是否存活 repl-timeout 超时时长 repl-disable-tcp-nodelay 延迟tcp连接，通常关闭此功能 repl-backlog-size 队列的长度 slave-priority 从的优先级 复制集群中，主节点故障时，sentinel应用场景中的主节点选举时使用的优先；数字越小优先级越高，但0表示不参与选举 min-slaves-to-rewrite 主节点仅允许其能够通信的从节点数量大于等于此处的值时接受些操作 min-slaves-max-log 从节点延迟时长超出此处指定的时长时，主节点会拒绝写入操作。 SECURITY 安全相关的配置项 requirepass 设定密码 rename-command 主从复制不建议修改；在AOD或Replication环境中，不推荐使用 LIMITS limit相关的配置项 maxclients 最大并发连接数 maxmemory 最大的内存空间 maxmemory-policy noeviction 定义淘汰机制 volatile-lru 对设定过期期限的key淘汰 allkey-lru 有无过期都在淘汰序列中 volatile-random 对设定过期期限自由淘汰 allkeys-random 对有无过期期限的都自由淘汰 volatile-ttl 移除最接近淘汰期限的key noevication 不过期任何key，只返回错误 maxmemory-samples 淘汰算法运行时的采样本书 APPEND ONLY MODE 记录每次写操作至指定的文件尾部实现的持久化；当redis重启时，可通过重新执行文件中的命令在内存中重建出数据库 BGREWRITEAOD：AOF文件重写 不会读取正在使用AOF文件，而是通过将内存中的数据以命令的方式保存至临时文件中，完成之后替换原来的AOF文件 appendonly 是否开启追加文件 appendfilename 定义名称 appendfsync 定义同步时间 no redis不执行主动同步操作，而是OS内核进行 always 只要发生写就同步 everysec 每秒同步 no-appendfsync-on-rewrite 是否在后台执行aof重写期间不调用fsync，默认为no，表示调用 auto-aof-rewrite-percentage 自动重写的百分比 auto-aof-rewrite-min-size 自动重写的最小大小 上述两个条件同时满足时，方会触发重写AOF，与上次AOF文件大小相比，其增长量超过100%，且大小不少于64MB auto-load-truncated 自动加载截断 注意： RDB与AOF同时启用： （1）BGSAVE和BGREWRITEAOF不会同时进行 （2）Redis服务器启动时用持久化的数据文件恢复数据，会优先使用AOF LUA SCRIPTING Lua脚本 REDIS CLUSTER 集群相关的配置项 cluster-enabled 是否开启集群功能 cluster-config-file 集群节点集群信息配置文件，每个节点都有一个，由redis生成和更新，配置时避免名称冲突 cluster-node-timeout 集群节点互联超时的预支，单位毫秒 cluster-slave-validity-factor 进行故障转移时，slave会申请成为master，有时slave会和master失联很久数据较旧，这样的slave不应该成为master。这个配置用来判断slave是否和master失联时间过后长。 SLOW LOG SlowLog相关的配置项 slowlog-log-slower-than slowlog-max-len slowlog记录的日志最大条目 LATENCY MONITOR EVENT NOTIFICATION ADVANCED CONFIG 高级配置项 hash-max-ziplist-entries hash-max-ziplist-value 设置ziplist的键数量最大值，每个值的最大空间 client-output-buffer-limit normal client-output-buffer-limit slave client-output-buffer-limit pubsub &lt;hard-limit&gt; &lt;soft-limit&gt; &lt;soft-limit seconds&gt; ##注意：持久机制本身不能取代备份；应该制定备份策略，对redis库定期备份。##]]></content>
      <categories>
        <category>缓存服务</category>
        <category>Redis</category>
        <category>Redis简单介绍</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis集群]]></title>
    <url>%2F2017%2F11%2F28%2FRedis%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[redis集群同步时间主机名互相解析确保firewalld和iptables关闭1、配置三个节点[root@node3~]#yum install -y redis 2、修改配置文件 node1配置： [root@node1~]#vim /etc/redis.conf bind 192.168.4.61 requirepass centos cluster-enabled yes cluster-config node1.conf #集群节点信息配置文件，存放在/var/lib/redis目录下 cluster-node-timeout 15000 clusert-migration-barrier 1 #这个选项设置如果master宕机，是否从节点全部迁移到新的master上 [root@node1~]#systemctl start redis.service node2配置： [root@node2~]#vim /etc/redis.conf bind 192.168.4.62 requirepass centos cluster-enabled yes cluster-config node2.conf #集群节点信息配置文件，存放在/var/lib/redis目录下 cluster-node-timeout 15000 clusert-migration-barrier 1 #这个选项设置如果master宕机，是否从节点全部迁移到新的master上 [root@node1~]#systemctl start redis.service node3配置： [root@node3~]#vim /etc/redis.conf bind 192.168.4.63 requirepass centos cluster-enabled yes cluster-config node3.conf #集群节点信息配置文件，存放在/var/lib/redis目录下 cluster-node-timeout 15000 clusert-migration-barrier 1 #这个选项设置如果master宕机，是否从节点全部迁移到新的master上 [root@node1~]#systemctl start redis.service [root@node1~]#redis-cli -h 192.168.4.61 -a centos -p 6379 CLUSTER INFO 查看集群信息 此时看集群状态为fail，因为还没有进行分slot和建立集群关系。3、为每个redis建立slot[root@node1~]#redis-cli -h 192.168.4.61 -a centos -p 6379 CLUSTER ADDSLOTS {0..5461} [root@node1~]#redis-cli -h 192.168.4.62 -a centos -p 6379 CLUSTER ADDSLOTS {5462..10923} [root@node1~]#redis-cli -h 192.168.4.63 -a centos -p 6379 CLUSTER ADDSLOTS {10924..16383} 注意：如果有4个节点，需要自动计算除每个节点有多少个slots，然后进行分配。slot总共有16384个 4、设置集群关系[root@node1~]#redis-cli -h 192.168.4.61 -a centos -p 6379 CLUSTER MEET 192.168.4.62 6379 [root@node1~]#redis-cli -h 192.168.4.61 -a centos -p 6379 CLUSTER MEET 192.168.4.63 6379 #####查看集群信息时集群的状态已经为”ok“。 5、测试，查看效果[root@node1~]#redis-cli -h 192.168.4.61 -a centos -p 6379 #####通过从图中可以看出，在192.168.4.61这台主机不能创建testkeys hi 这个值，需要移到到192.168.4.62:6379主机上创建。 [root@node2~]#redis-cli -h 192.168.4.62 -a centos -p 6379 小结： 客户单向redis发送任何key指令，须先对key计算一个词hash作为其槽位编号，将指令发送给对应槽位的持有节点。就像我们刚刚操作的，如果发送到了错误的节点，会报错；而是返回表示MOVE的错误信息。]]></content>
      <categories>
        <category>缓存服务</category>
        <category>Redis</category>
        <category>Redis集群</category>
      </categories>
      <tags>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL语法]]></title>
    <url>%2F2017%2F11%2F28%2FSQL%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[SQL1、概念结构化查询语言(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。 2、RDBMS术语 数据库：数据库是一些关联表的集合。 数据表：表示数据的矩阵。在一个数据库中的表开起来像一个简单的电子表格。 列（column）：一列包含了相同的数据，又称为属性，字段。 行（row）：是一组相关的数据，又称为一条记录record。 域（domain）：属性的取值范围。 主键（Primary Key）：一个或多个字段的组合，填入的数据必须能在本表中唯一表示本行；必须提供数据，即NOT NULL。一个表中有且只有一个主键。 唯一键：一个或多个字段的组合，填入的数据必须能在本表中唯一表示本行；允许为NULL。一个表中可以存在多个。 外键（foreign key）：一个表中的某字段可填入的数据取决于另一个表中的主键或唯一键已有的数据。即用于关联两个表。 检查（check）：字段在一定范围内。 索引：将表中的一个或多个字段中的数据复制一份另存，并且这些需要按特定次序排序存储。相当于我们一个书前面的目录作用。 复合件：两个或多个字段组成，相当于主键的作用。 SQL处理过程 3数据表类型数值型 类型 大小(字节) 范围（有符号） 范围（UNSIGNED） 用途 TINYINT 1 -128,127 0,255 小整数值 SMALLINT 2 -32768,32767 大整数值 MEDINUMINT 3 -8388608,8388607 0,16777215 大整数值 INT或INTEGER 4 -2^4,2^4-1 0,2^4*2 大整数值 BIGINT 8 -2^8,2^8-1 0,2^8*2 极大整数值 FLOAT（m,d） 4 单精度，浮点数值 DOUBLE(m,d) 8 多精度浮点数值 DECIMAL 小数值 DECIMAL的解释：Decimal(n,m)表示数值中共有n位数，其中整数n-m位，小数m位。例：decimal(10,6)，数值中共有10位数，其中整数占4位，小数占6位。 日期和时间类型 类型 大小（字节） 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 -838:59:59/838:59:59 HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份 DATETIME 8 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2037年某时 YYYYMMDDHHMMSS 时间戳 若一个字段定义为timestamp，这个字段的时间数据随其他字段修改的时候自动更新，这个数据的字段可以存放这条记录最后被修改的时间。 字符串类型 类型 大小(字节) 用途 CHAR 0-255 定长字符串 VARCHAR 0-65535 变长字符串 TINYBLOB 0-255 不超过255个字符的二进制字符串 TINYTEXT 0-255 短文本字符串，可变长度 BLOB(binary large object 0-65535 二进制形式的长文本数据，可变长度 TEXT 0-65535 场文本数据可变长度 MEDIUMBLOB 0,2^24-1 二进制中等长度文本数据，可变长度 BINARY（M） 0，M 固定长度，可存二进制或字符， VARBINARY(M) 0，M 可变长度，可存二进制或字符 char和varchar区别 char(n)若存入字符数小于n，则以空格补充其后，查询之时再将空格去掉。所以char类型存储的字符末尾不能有空格。 char（n）固定长度，不管存入几个字符，都将占用n个字节；varchar（n）是存入的实际字符数+1个字节。真正存入的数据位实际字节-1。会使用1-2个字节来存储值长度。-char类型的字符串检索速度比varchar速度快 varchar和text区别 varchar可指定n，text不能指定n；内部存储varchar是存入的实际字节数+1个字节，text是实际字节数+2的字节。 text类型不能有默认值 varchar可直接创建索引；text创建索引要指定前多少个字符。varchar查询速度比text快。 BOLB与TEXT区别 TEXT以文本方式存储，英文存储区分大小写；而BLOB是以二进制方式存储，不分大小写。 BLOB存储的数据只能整体读出。 TEXT可以指定字符集;BLOB不用指定字符集。 如何正确的数据类型？ ①尽量使用可正确存储数据的最小数据类型 ②简单数据类型的操作通常需要更少的CPU周期 ③尽量避免NULL，包含NULL的列对MySQL更难优化 修饰符类型 类型 解释 NULL 空 NOT NULL 确保不能有NULL值 DEFAULT 提供未指定时为列的默认值 PRIMARY KEY 唯一表示数据库表中的每一行 FOREIGN KEY 唯一表示热河其他数据库表中的行 UNIQUE KEY 确保在一列中所有的值是唯一的 CHARACTER SET name 指定一个字符集 ATUO_INCREMENT 自动递增，适用于整数类型 UNSIGNED 无符号 CHECK 确保列中的所有值满足一定的条件 删除约束的方法ALTER TABLE column_name DROP CONSTRAINT PK; ###4 SQL通配符 通配符 描述 % 替代一个或多个字符 _ 仅替代一个字符 [] 中括号中任意单一字符 [^]或[!] 除中括号中任意单一字符 注意：SQL通配符必须跟LIKE运算符一起使用 ###5、 SQL算数运算符 运算符 描述 + 加法 - 减法 * 乘法 / 除法 % 取模，相当于取余数 ###6、SQL比较运算符 =、!=、 &lt;&gt;、 &gt;、 &lt;、 &gt;=、 &lt;=、 !&lt;、 !&gt; ###7、SQL逻辑运算符 操作符 描述 ALL 用来在另一个值设定比较值的所有值 AND 运行多个条件在SQL语句中，存在WHERE子句中 ANY 用于根据条件在列表中的值进行标胶的任何应用值 BETWEEN…AND 用于搜索是在一组的那个值，给定最小值和最大值 EXISTS 用于搜索中指定的表，以满足某些标准的存在 IN 用于一个值进行比较，以已被指定的文字值的列表 LIKE 用来标胶使用通配符运算符相似的值 NOT 取反 OR 用来多个条件子句结合起来的SQL语句 IS NULL 用来比较一个NULL的值 UNIQUE 搜索指定表的每一行的唯一性 ###8、SQL Alias格式：SELECT column_names FROM table_name AS alias_name ###9、SQL表达式 SQL 布尔表达式 语法：SELECT column_name1 column_name2 column_name3 FROM table_name WHERER SINGLE VALUE MATCHTING EXPRESSION; SQL 数字表达式 语法：SELECT numerical_expression as OPERATION_NAME [FROM table_name WHERE CONDITION]; SQL 日期表达式 SELECT CURRENT_TIMESTAMP; #显示当前系统的时间值 SELECT GETDATE(); #显示时间 ###10、SQL 索引索引是数据库的搜索引擎使用，以加快数据检索特定的查找表，是一个指向表中的数据。相当于一本书的目录，便于快速查找，对数据没有影响。缺点：如果UPDATE和INSERT会减慢数据的输入。 注意：索引是唯一的，索引防止在列或者有一个索引重复条目。 语法：CREATE INDEX index_name ON table_name; 单列索引：是一个基于只有创建表列。 语法：CREATE INDEX index_name ON table_name （colum_name）; 唯一索引:不仅用于性能，而且要求数据的完整性。 语法：CREATE UNIQUE INDEX index_name ON table_name （column_name）; 组合索引：两个或多个索引 语法：CREATE INDEX index_name ON table_name （column_name1，column_name2..）; ###11、SQL视图SQL视图（View）是SQL语句结果集的可视化表。视图中的字段是来自一个或多个数据库中真实表中的字段。 注意：数据库的设计不会受到视图中的函数、where或join语句的影响。 语法：CREATE VIEW view_name AS SELECT column_name（s） FROM table_name WHERE [CONDITION]; WHIT CHECK OPTION 是CREATE VIEW 语句选项。目的是为了确保所有更新和插入满足视图定义的条件。 示例：CREATE VIEW testView AS SELECT name，age FROM testtable WHERE age IS NOT NULL WITH CHECK OPTION; #WITH CHECK OPTION 拒绝任何age为NULL值的行。 那么是不是这样我们就可以随便更新视图了呢？那可不一定哦，更新视图是有一定条件的： SELECT子句不包含关键字DISTINCT. SELECT子句不包含汇总函数。 SELECT子句不包含集合函数。 SELECT子句不能包含集合运算符 SELECT子句不能包含一个ORDER BY 子句。 FROM子句中不能包含多个表。 WHERE子句中不能包含子查询。 查询不包含GROUP BY 或HAVING. 计算列无法更新 从基表中的所有NOT NULL 列必须包含在视图。 看看是不是不是随便能更新视图能。好忧伤。。。 示例：UPDATE testView SET age = 20 WHERE name ‘xiaomian’ ; ###12、SQL排序语法：SELECT column-list FROM table_name [WHERE CONDITION] [ORDER BY column1,column2..][ASC|DESC]; ###13SQL约束事物就是对数据库执行的工作单元。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！ 事物的特性事务是必须满足4个条件（ACID）： Atomicity（原子性）、Consistency（稳定性）、Isolation（隔离性）、Durability（可靠性） 事务的原子性：确保工作单元中的所有操作都成功完成。否则，该事物被终止的故障点，操作回滚到操作之前的状态。 一致性：确保数据库正确后成功提交事物更改状态。 隔离性：事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。 可靠性：软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候把事务保存到日志里。 控制事物使用的命令： COMMIT :保存修改 ROLLBACK:回滚更改 SAVEPOINT:回滚事物组创建点 SET TRANSACTION:用来设置事物的隔离级别 ##14、 SQL命令分类DDL（Data Define Language） 命令 描述 CREATE 创建一个表、数据库、表的视图 ALTER 修改现有数据库对象 DROP 删除整个表、数据库中的表或其他对象或视图 DML（Data Manager Language） 命令 描述 INSERT 插入记录 UPDATE 修改记录 DELETE 删除记录 DCL（Date Control Language） 命令 描述 GRANT 授予用户权限 REVOKE 撤销授予用户的权限 DQL（Date Query Language） 命令 描述 SELECT 从一张表或多张表中检索特定的记录 ###、15、SQL语言规范 在数据库系统中，SQL语句不区分大小写（建议使用大写），但在字符串中常量区分大小写。 SQL语句中可以单行书写，并以“；”结尾。 在SQL中关键词不能跨多行或简写。 子句通常独立运行，便于管理，提高可读性。 SQL注释标准：/需要注释的内容/ 或 –需要注释的内容]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL语法</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP_wrappers]]></title>
    <url>%2F2017%2F11%2F28%2FTCP_wrappers%2F</url>
    <content type="text"><![CDATA[tcp_wrappers1、概念Transmission Control Protocol (TCP) Wrappers 为由 inetd 生成的服务提供了增强的安全性。TCP Wrappers 是一种对使用 /etc/inetd.sec 的替换方法。TCP Wrappers 提供防止主机名和主机地址欺骗的保护。欺骗是一种伪装成有效用户或主机以获得对系统进行未经授权的访问的方法。 2、工作机制（1）工作在第四层的TCP协议（2）对有状态的特定服务进行安全检测并实现访问控制（3）以库文件形式实现（4）其进程是否接受libwrap的控制取决于发起此进程的程序在编译时是否针对libwrap进行编译的。 3、如何查看服务程序是否支持libwrap访问控制（1）先使用命令查看执行程序文件是哪个 which COMMAND （2）使用命令ldd 对上述文件查找 lddwhich COMMAND|grep libwrap 4、配置文件1、配置文件 /etc/hosts.allow和/etc/hosts.deny 2、检查顺序 在tcp_wrappers中检查顺序并不像前面的服务一样，前面的成功后面的就不再执行。而tcp_wrappers的检查顺序为/etc/hosts.allow–&gt;/etc/hosts.deny 前面的规则一旦匹配成功，直接生效，将不再继续后面的执行；如果前面的没有成功，则继续向后执行。 3、基本语法damon_list@host：client_list [:option:option…] damon_list格式： （1）单个应用程序的二进制文件名，而非服务名 （2）以逗号或空格分隔的应用程序文件名列表 （3）ALL 表示所有接受tcp_wrappers控制的服务程序 （4）主机有多个IP ，可用@hostIP来实现 如：in.telnetd@192.168.159.131 client_host格式： （1）以逗号或空格分隔的客户端列表 （2）基于IP地址 （3）基于主机名 （4）基于网络/掩码 192.168.159.0/255.255.255.0 （5）基于CIDR格式 192.168.159.0/24 （6）基于网络组 @munetwork （7）内置ACL：ALL,LOCAL,KNOWN,UNKNOWN,PARANOID EXPECT用法 示例： sshd:192.168.159.0/24 EXPECT 192.168.159.151 [:OPTIONS]选项 (1)deny 主要用在/etc/host.allow文件中，定义“拒绝”规则。如：vsftpd:192.168.159.159:deny 先定义了这个IP可以访问但是又否定。 (2)allow 主要用在/etc/hosts.deny 定义“允许”规则如：vsftpd:192.168.159.159:allow 先定义192.168.159.159不允许然后否定允许使用 (3)spawn 启动一个外部进程完成执行的操作 选项： %c：客户端信息 %s：服务器端信息 %d：服务名 %p：守护进程的PID注意：如果在配置文件中想使用“%”需要使用两个“%”；如果使用“：”则需要使用“\”进行转义。 示例：在CentOS6主机上编辑/etc/hosts.allow文件[root@localhost~]#vim /etc/hosts.allowsshd:192.168.4.135:spaw echo &quot;date%c to %s %d %p &quot; &gt;&gt; /var/log/sshd.log 在CentOS7主机上连接[root@centos7/var/log]#ssh 192.168.4.131 在CentOS6上查看是否生成sshd.log文件并且有内容[root@localhost~]#cat /var/log/sshd.logThu Sep 14 09:33:18 CST 2017 192.168.4.135 to sshd@192.168.4.131 sshd 29705 (4)twist 实际动作是拒绝访问，使用指定的操作替换当前服务，标准I/O和ERROR发送到客户端，默认输出至/dev/null 示例：在CentOS6上配置/etc/hosts.allow文件[root@localhost~]#vim /etc/hosts.allow vsftpd:192.168.4.135:twist /bin/echo &quot;Do not login&quot; 在CentOS7上连接[root@centos7~]#ftp 192.168.4.131 Connected to 192.168.4.131 (192.168.4.131). Do not login ftp&gt; 测试工具： tcpdmatch [-d] daemon[@host] client -d 测试当前目录下的host.allow和hosts.deny文件 [root@localhost~]#tcpdmatch -d /etc/hosts.deny 192.168.4.135 client: address 192.168.4.135 server: process hosts.deny access: granted [root@localhost~]#tcpdmatch -d /etc/hosts.allow 192.168.4.135 client: address 192.168.4.135 server: process hosts.allow access: granted]]></content>
      <categories>
        <category>安全</category>
        <category>TCP_wrappers</category>
      </categories>
      <tags>
        <tag>tcp_wrappers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VRRP协议]]></title>
    <url>%2F2017%2F11%2F28%2FVRRP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[一、VRRP协议虚拟路由冗余协议（VRRP，Virtual Router Redundancy Protocol）通过把几台路由设备联合组成一台虚拟的路由设备，使用一定的机制保证当主机的下一跳路由机出现故障时，及时将业务切换到备份路由器，从而保持业务的持续性和可靠性。 基本概念 虚拟路由器（Virutal Router）：又陈VRRP备份组，由一个master设备和多个backup设备组成，被当做一个共享局域网内主机的缺省网关 Master设备（Virtual Router Master）：承担转发报文任务的VRRP设备 Backup设备（Virtual Router Backup）：一组没有承担转发任务的VRRP设备，当Master设备出现故障时，他们将通过优先级成为新的Master设备 VRID：虚拟路由器的表示 虚拟IP地址（Virtual IP Address）：虚拟路由器IP地址，一个虚拟路由器可以有一个或多个IP地址 IP地址拥有者（IP Address Owner）：如果一个VRRP设备将虚拟路由器IP地址作为真实的接口地址，则该设备称为IP地址拥有者，如果IP地址拥有者是可用的，通常称为Master 虚拟MAC地址（Virtual MAC Address）：虚拟路由器根据虚拟路由器ID生成的MAC地址 主IP地址（Primary IP Address）：从接口的真实IP地址中选出来的一个主用IP地址，通常选择配置的第一个IP地址。VRRP广播报文使用主IP地址作为IP报文的源地址。 优先级（Priority）：虚拟路由器中VRRP设备的优先级。虚拟路由器根据优先级选举出Master设备和Backup设备 抢占模式：如果Backup设备的优先级比当前Master设备的优先级高，则主动将自己切换成Master 非抢占模式：只要Master设备没有出现故障，Backup设备即使随后被配置了更高的优先级也不会成为Master设备 VRRP工作原理（1）VRRP备份组中的交换机根据优先级选举出Master。Master交换机通过发送免费ARP报文，将虚拟MAC地址通知给与它连接的设备或主机，从而承担报文转发任务。 （2）Master交换机周期性向备份组内的Backup交换机发送VRRP通告报文，以公布其配置信息和工作状态。 （3）如果Master交换机出现故障，VRRP备份组中的Backup交换机将根据优先级重新选举新的Master。 （4）VRRP备份组状态切换时，Master交换机由一台设备切换为另外一台设备，新的Master交换机立即发送携带虚拟路由器的虚拟MAC地址和虚拟IP地址信息的免费ARP报文，刷新与它连接的主机或者设备中的MAC表项。 （5）如果原来的Master恢复时，若优先级高时，将直接切换为Master状态。 VRRP主备备份示例- VRRP主主示例]]></content>
      <categories>
        <category>服务</category>
        <category>Keepalived</category>
        <category>VRRP协议</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cobbler]]></title>
    <url>%2F2017%2F11%2F28%2FCobbler%2F</url>
    <content type="text"><![CDATA[一、cobbler1、cobbler概念Cobbler是一个Linux服务器快速网络安装的服务，而且在经过调整也可以支持网络安装windows。该工具使用python开发，小巧轻便（才15k行python代码），可以通过网络启动(PXE)的方式来快速安装、重装物理服务器和虚拟机，同时还可以管理DHCP，DNS，TFTP、RSYNC以及yum仓库、构造系统ISO镜像。Cobbler可以使用命令行方式管理，也提供了基于Web的界面管理工具(cobbler-web)，还提供了API接口，可以方便二次开发使用。Cobbler是较早前的kickstart的升级版，优点是比较容易配置，还自带web界面比较易于管理。Cobbler内置了一个轻量级配置管理系统，但它也支持和其它配置管理系统集成，如Puppet，暂时不支持SaltStack。Cobbler客户端Koan支持虚拟机安装和操作系统重新安装，使重装系统更便捷。 2、工作流程 （a）client裸机配置了从网络启动后，开机后会广播包请求DHCP服务器（cobbler server）发送其分配好的一个IP （b）DHCP服务器（cobbler server）收到请求后发送responese，包括其ip地址 （c）client裸机拿到ip后再向cobbler server发送请求OS引导文件的请求 （d）cobbler server告诉裸机OS引导文件的名字和TFTP server的ip和 port （e）client裸机通过上面告知的TFTP server地址通信，下载引导文件 （f）client裸机执行执行该引导文件，确定加载信息，选择要安装的os， （g）期间会再向cobbler server请求kickstart文件和os image （h）cobbler server发送请求的kickstart和os iamgeclient裸机加载kickstart文件 （i）client裸机接收os image，安装该os image 3、cobbler包介绍cobbler包集成了dhcp，pxe服务，rsync，http，dns，kiskstart，IPMI电源管理。 cobbler命令格式：cobbler command [subcommand] [–arg1=value1] [–arg2=value2] cobbler check 核对当前设置是否有问题cobbler list 列出所有的cobbler元素cobbler repo 列出元素的详细信息 cobbler sync 同步配置到数据目录，更改配置 cobbler reposync 同步yum仓库 cobbler distro 查看导入的发行版系统信息 cobbler distro add cobbler distro copy cobbler distro edit cobbler distro find cobbler distro list cobbler distro remove cobbler distro rename cobbler distro report cobbler system 查看添加的系统信息 cobbler profile 查看配置信息 cobbler profile add --name=NAME --distro=DISTRO --kickstart=KICKSTART cobbler profile list #列出配置文件信息 cobbler profile remove cobbler profile rename 修改配置文件名称 cobbler profile report #列出某个配置文件的报告 --name=NAME cobbler improt | | –arch=ARCH | OS architecture being imported | –breed=BREED | the breed being imported | –os-version=OS_VERSION |the version being imported | –path=PATH | local path or rsync location | –name=NAME | name, ex ‘RHEL-5’ | –available-as=AVAILABLE_AS | tree is here, don’t mirror | –kickstart=KICKSTART_FILE | assign this kickstart file | –rsync-flags=RSYNC_FLAGS | pass additional flags to rsync 3、cobbler目录介绍/etc/cobbler/settings : cobbler 主配置文件 /etc/cobbler/iso/: iso模板配置文件 /etc/cobbler/pxe: pxe模板文件 /etc/cobbler/power: 电源配置文件 /etc/cobbler/user.conf: web服务授权配置文件 /etc/cobbler/users.digest: web访问的用户名密码配置文件 /etc/cobbler/dhcp.template : dhcp服务器的的配置模板 /etc/cobbler/dnsmasq.template : dns服务器的配置模板 /etc/cobbler/tftpd.template : tftp服务的配置模板 /etc/cobbler/modules.conf : 模块的配置文件 数据目录 /var/lib/cobbler/config/: 用于存放distros，system，profiles 等信息配置文件 /var/lib/cobbler/triggers/: 用于存放用户定义的cobbler命令 /var/lib/cobbler/kickstart/: 默认存放kickstart文件 /var/lib/cobbler/loaders/: 存放各种引导程序 镜像目录 /var/www/cobbler/ks_mirror/: 导入的发行版系统的所有数据 /var/www/cobbler/images/ : 导入发行版的kernel和initrd镜像用于远程网络启动 /var/www/cobbler/repo_mirror/: yum 仓库存储目录 日志目录 /var/log/cobbler/installing: 客户端安装日志 /var/log/cobbler/cobbler.log : cobbler日志 4、相关术语发行版：表示一个操作系统。它承载了内核和initrd信息，以及内核参数等其他数据。 配置文件：包含一个发行版、一个kickstart文件以及可能的存储库，还包含更多特定的内核参数等其他数据。 系统：表示要配给的机器。它包含一个配置文件或一个镜像，还包含IP和MAC地址、电源管理以及更专业的数据信息。 存储库：保存一个yum或rsync存储库的镜像信息。镜像：可替换一个包含不属于此类别的文件的发行版对象。（例如，无法分为内核和initrd对象） 二、cobbler实战（1）安装cobbler安装包和dhcp[root@localhost ~]# yum install -y cobbler [root@localhost ~]# yum install -y dhcp （2）将服务设为开机启动并启动服务[root@localhost ~]# systemctl enable tftp #将tftp服务设为开机启动，并启动它 [root@localhost ~]# systemctl start tftp [root@localhost ~]# systemctl enabel httpd #将http服务设为开机启动并启动 [root@localhost ~]# systemctl enable httpd [root@localhost ~]# systemctl start httpd [root@localhost ~]# systemctl enable cobblerd #将cobbler设为开机启动并启动 [root@localhost ~]# systemctl start cobblerd （3）运行cobbler check命令解决问题为了确保出现不必要的问题，禁用iptables和setenforce [root@localhost ~]# iptables -F#清空防火墙规则[root@localhost ~]# setenforce 0 #将selinux设为permissiving [root@localhost ~]# cobbler check #检查cobbler环境是否配置正确 当运行cobbler check命令时出现上述的问题，我们通过一个一个解决就可以慢慢的实现cobbler自动化安装CentOS 系统。下面我们一个一个的解决这些文件 （a）修改cobbler服务端地址选项server [root@localhost ~]# vim /etc/cobbler/settings [root@localhost ~]# cobbler sync #将修改过的文件同步 （b）修改next_server 此选项是修改tftp的地址[root@localhost ~]# vim /etc/cobbler/settings [root@localhost ~]# cobbler sync （c）修改mange_dhcp 此选项是要cobbler管理dhcp[root@localhost ~]# vim /etc/cobbler/settings [root@localhost ~]# cobbler sync （d）获取启动菜单方法一：如果有网络的话使用如下方式 [root@localhost ~]# cobbler get-loaders方法二： 如果没有网络/var/lib/tftpboot/目录下的pxelinux.0和menu.c32文件复制到/var/lib/cobbler/loaders [root@localhost ~]# cp /var/lib/tftpboot/{pxelinux.0,menu.c32} /var/lib/cobbler/loaders/[root@localhost ~]# cobbler sync （e）修改用户口令 [root@localhost ~]# openssl passwd -1 #生成加密口令 Password: Verifying - Password: $1$gMx01QUD$eo5dQGlEDGh9o0fY8dgnr. [root@localhost ~]# cobbler sync （f）配置dhcp服务 [root@localhost ~]# vim /etc/cobbler/dhcp.template [root@localhost tftpboot]# cobbler sync #将修改后内容太同步到/etc/dhcp/dhcpd.conf文件中 （4）导入yum源 [root@localhost ~]# cobbler import --path=/media/cdrom --name=centos7.3 --arch=x86_64 --path：指明yum源的路径 --name：指明复制到`/var/www/cobbler`目录下 --arhc：指明架构类型 （5）编辑ks文件并导入 默认的ks位置/var/lib/cobbler/kickstarts/sample.ks 首先将ks文件复制到/var/lib/cobbler/kickstarts目录下，然后将ks文件导入 [root@localhost kickstarts]# cobbler profile edit/add --name=centos7.3-x86_64 --distro=centos7.3-x86_64 --kickstart=/var/lib/cobbler/kickstarts/ks7.cfg #编辑原有的ks文件 [root@localhost tftpboot]# cobbler sync （6）编辑菜单文件 默认的菜单文件/etc/cobbler/pxe/pxedefault.template #默认菜单模板 启动菜单存放位置/var/lib/tftpboot/pxelinux.cfg/default [root@localhost tftpboot]# cobbler sync （7）新建一台虚拟机测试 另外cobbler也提供web管理。Cobbler web界面是一个很好的前端，非常容易管理Cobbler。可以添加和删除system、distro、profile，可以查看、编辑distros、profiles、subprofiles、systems、repos、kickstart文件cobbler认证方式有两种： 方式一： （1）修在认证方式 （2）创建管理用户[root@localhost ~]# htdigest -c /etc/cobbler/users.digest &quot;Cobbler&quot; admin 注意：第一创建是需要加选项“-c”意味着创建文件/etc/cobbler/users.digest文件。 htdigest命令的使用格式： htdigest [ -c ] passwdfile realm username 如何修改管理用户的密码呢？[root@localhost ~]# htdigest /etc/cobbler/users.digest &quot;Cobbler&quot; admin方式二：（a）修改认证方式 （b）创建管理用户 [root@localhost ~]# useradd cobbler[root@localhost ~]# passwd cobbler （c）修改文件/etc/cobbler/user.conf （3）在浏览器地址输入地址 https://192.168.4.128/cobbler_web并管理用户和密码即可]]></content>
      <categories>
        <category>自动化运维</category>
        <category>Cobbler</category>
      </categories>
      <tags>
        <tag>cobbler，自动化安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xtrabackup]]></title>
    <url>%2F2017%2F11%2F28%2FXtrabackup%2F</url>
    <content type="text"><![CDATA[xtrabackup由percona提供、开源工具，支持对InnoDB做热备，物理备份工具。 特点： 物理备份；速率快、可靠； 备份完成后自动校验备份结果是否可用 还原速度快 使用格式[innobackupex [--defaults-file=#] --backup | innobackupex [--defaults-file=#] --prepare] [OPTIONS] https://www.percona.com/software/mysql-database/percona-server innobackupex命令 使用innobackupex备份时，其会调用xtrabackup备份所有的InnoDB表，复制所有关于表结构定义相关文件（.frm）、以及MyISAM、MERGE、CSV和ARCHIVE表相关文件，同时还会备份触发器和数据库配置信息相关文件。这些文件会被保存至一个以时间命名的目录中。 在备份的同时，innobackupex还会备份目录中创建如下文件： xtrabackup_checkpoints 备份类型（如完全或增量）、备份状态（如是否已经为prepared状态）和LSN（日志序列号）范围信息 每个InnoDB页（通常为16k大小）都会包含一个日志序列号（LSN）。LSN是整个数据库系统的系统版本号，每个页面相关的LSN能够表明此页面时如何发生改变的。 xtrabackup_binlog_info mysql服务器当前正在使用的二进制日志文件及至备份这一刻为止二进制日志事件的位置 xtrabackup_binlog_pos_innodb 二进制日志文件及用于InnoDB或XtraDB表的二进制日志文件的当前position xtrabackup_binary 备份中用到的xtrabackup的可执行文件 backup-my.cnf 备份命令用到的配置选项信息 在使用innobackupes进行备份时，还可以使用–no-timestamp选项来阻止命令自动创建一个以时间命名的目录；如此一来，innobackupex命令将会创建一个BCAKUP-DIR目录来存储备份数据。 准备一个完全备份 一般情况下，在备份完成后，数据尚且不能用于恢复操作，因为备份的数据中可能会包含尚未提交的事务或已经提交单尚未同步至数据文件中的事务。因此，此时数据文件仍处理不一致状态。“准备”的主要作用是通过回滚为提交的事务及同步已经提交的事务至数据文件也使得数据文件处于一致性状态。 --apply-log选项可用于实现上述功能。 使用格式： innobackupex --apply-log /PATH/TO/BACKUP-DIR 在实现“准备”过程中，innobackupex通常还可以使用–use-memory选项来指定其可以使用的内存大小，默认为100M。如果有足够的内存使用，可以多划分一些内存给prepare的过程，以提高其完成速度。 从一个完全备份中恢复数据 注意：恢复时不用启动mysql服务 innobackupex命令的–copy-back选项用于执行恢复操作，其通过复制所有数据相关的文件至mysql服务器的DATADIR目录中来执行恢复过程。innobackupex通过backup-my.cnf来获取DATADIR目录的相关信息。 使用格式： innobackupex --copy-back /PATH/TO/BACKUP-DIR 当数据恢复之DATADIR目录中，需要确保所有数据文件的所属主和所属组均为mysql用户。否则，在启动mysql服务器前事先修改数据文件的所有者和所属组。 使用innobackupex进行增量备份 每个InnoDB的页面都会包含一个LSN信息，每当相关数据发生改变，相关的页面的LSN就会自动增长。这正式InnoDB表可以进行增量备份的基础，即innobackupex通过备份上次完全备份之后发生改变的页面来实现。 使用格式： innobackupex --incremental /BACKUP --incremental-basedir=/BASEDIR 其中BASEDIR指的是完全备份所在的目录，此命令执行结束后，innobackupex命令会在/BACKUP目录中创建一个新的以时间命名的目录以存放所有的增量备份的数据。另外，在执行过增量备份之后再一次进行增量备份时，其–incremental-basedir应该指向上一次的增量备份所在的目录。 增量备份仅能应用于InnoDB或XtraDB表，对弈MyISAM表而言，执行增量备份时其实进行的完全备份。 “准备“增量备份与整理备份不同： （1）需要在每个备份（包括完全和增量备份）上，将已经提交的事物进行“回放”。所有的备份数据将合并到完全备份上 （2）基于所有的备份将未提交的事物进行“回滚” 操作步骤 innobackupex --apply-log --redo-log BASE-DIR innobackupex --apply-log --redo-log BASE-DIR --incremental-dir=INCREMENTAL-DIR-1 innobackupex --apply-log --redo-log BASE-DIR --incremental-dir=INCREMENTAL-DIR-2 其中BASE-DIR指的是完全备份所在的目录，而INCREMENTAL-DIR-1指的是第一次增量备份的目录，INCREMENTAL-DIR-2指的是第二次增量备份目录，其他依次类推，即如果有多次增量备份，每一次都要执行如上操作。 Xtrabackup的“流”及“备份压缩”功能 Xtrabackup对备份的数据文件支持“流”功能，即可以将备份的数据通过STDOUT传输给tar程序进行归档，而不是默认的直接保存至某备份目录中。要使用此功能仅需要使用–stream选项即可。 使用格式： innbackupex --stream=tar /BACKUP |gzip &gt; /BACKUP/`date +F_$H-$M_%M_%S`.tar.gz 也可是使用如下命令将数据备份至某服务器上： innobackupex --stream=tar /BACKUP |ssh user@IP &quot;cat - &gt; /backups/`date +%F_%H-%M-%S`.tar&quot; 在执行本地备份时，还可以使用–parallel选项对多个文件进行并行复制。此选项用于指定在复制时启动的线程数目。在实际进行备份时要利用此功能的便利性，也需要启动inndb_file_per_table选项或共享表空间通过innodb_data_file_path选项存储在多个ibdata文件中。对某一数据库的多个文件的复制无法利用此功能。 使用格式： innobackupex --parallel /path/to/backup 同时innobackupex备份数据文件也可以存储值远程主机，使用–remote-host选项 使用格式： innobackupex --remote-host=user@IP /PATH/IN/REMOTE/HOST/TO/BACKUP 导入或导出单张表 默认情况下，InnoDB表不能通过直接复制文件的方式在mysql服务器之间进行移植，即便使用了innodb_file_per_table选型。而使用Xtreabackup工具可以实现此种功能，不过此时需要“导出”表的mysql服务器启动innodb_file_per_table选项（严格来说，是要“导出”的表在其创建之前，msyql服务器就启用了innodb_file_per_table选项），并且“导入”表的服务器同时启用了innodb_file_per_table和innodb_expand_import选项。 （1）导出表 导出表示在备份的prepare阶段进行的，因此一旦完成备份，就可以在prepare过程中通过–export选项将某表导出了 使用格式： innobackupex --apply-log --export /path/to/bacup 此命令会为每个innodb表的表空间创建一个以.exp结尾的文件，这些以.exp结尾的文件则可以用于导入至其它服务器。 （2）导入表 要在mysql 服务器上导入来自于其他服务器的某个innodb表，需要先在当前服务器上创建一个跟原表结构一致的表，而后才能实现将表导入： CREATE TABLE mytable ENGING=InnoDB; 然后将此表的表空间删除 ALTER TABLE mydatabase.mytable DISCARD TABLESPACE; 接下来，将来自于导出表的服务器的mytable表的mytable.ibd和mysqtalbe.exp文件复制到当前服务器的数据目录： ALTER TABLE mydatabase.mytable IMPORT TABLESPACE; 使用Xtrabackup对数据库进行部分备份 Xtrabackup也可以实现部分备份，即只备份某个或某些指定的数据库或某数据库中的某个或某些表。但要使用此功能，必须启用innodb_file_per_table选项，即每张表保存为一个独立的文件。同时其也不支持–stream选项，即不支持将数据通过管道传输给其他程序进行处理。 此外，还原部分备份跟还原全部数据备份也有所不同，即不能通过简单地将prepared的部分备份使用–copy-back选项直接复制回数据目录，而是要通过导入表的防线来实现还原。当前，有些情况下，部分备份也可以直接通过–copy-back进行还原，但这种范式还原而来的数据多数会产生数据不一致的文件。 （1）创建部分备份 创建部分备份的方式： 正则表达式（–include） 要求为其制定要备份的表的完整名称，即如databasesname.tablename innobackupex --include ‘^student[.]tb1’ /path/to/backup 枚举表文件（–tables-file） 此选项的参数需要一个文件名，此文件中每行包含一个要备份的表的完整名称 echo -e &apos;test.tb1\ntest.tb2&apos; &gt; /tmp/tables.txt innobackupex --tables-file=/tmp/tables.txt /path/to/backup 列出要备份的数据库（–databases） 此选项接受参数参数为数据名，如果要指定多个数据库，彼此间需要以空格隔开；同时，在指定某数据库时，也可以只指定其中的某张表。此外，此选项也可以接受一个文件为参数，文件中每一行为一个要备份的对象。 innobackupex --databases=“test testb” /path/to/backup （2）整理（preparing）部分备份 prepare部分备份的过程类似于导出表的过程，要使用–export选项进行 innobackupex --apply-log --export /PATH/TO/PARTIAL/BACKUP 此命令执行过程中，innobackupex会调用xtrabackup命令从数据字典中移除缺失的表，因此，会显示出许多关于“表不存在”类的警告信息。同时，也会显示出为备份文件中存在的表创建.exp文件的相关信息。 （3）还原部分备份 还原部分备份的过程跟导入表的过程相同。当然，也可以通过直接复制prepared状态的备份直接至数据目录中实现还原，不过此时要求数据目录处于一致状态。 实战： 准备两台虚拟器node1和node2 同步时间 [root@node1~]#ntpdate 172.18.0.1 [root@node2~]#ntpdate 172.18.0.1 [root@node1~]#vim /etc/chrony.conf #node1和node2操作一样 [root@node1~]#systemctl start chronyd.service #启动服务 基于root密钥认证 node1和node2配置一样 [root@node2~]#ssh-keygen [root@node2~]#ssh-copy-id -i /root/.ssh/id_rsa.pub 192.168.4.61 修改hosts文件node1和node2配置相同 [root@node1~]#vim /etc/hosts 3 192.168.4.61 node1 4 192.168.4.62 node2 安装数据库和extabackup [root@node1~]#yum install -y mariadb-server [root@node1~]#yum install -y percona-xtrabackup-24-2.4.7-2.el7.x86_64.rpm 导入一个数据库并备份 [root@node1~]#vim /etc/my.cnf.d/server.cnf 9 [server] 10 log_bin = /data/mysql/master-log [root@node1~]#vim /etc/my.cnf 10 innodb_file_per_table [root@node1~]#systemctl start mariadb.service 创建目录并修改权限 [root@node1~]#mkdir /data/mysql -pv [root@node1~]#chown -R mysql.mysql /data/mysql 查看是否真正开启二进制日志功能 MariaDB [(none)]&gt; SELECT @@global.log_bin; +------------------+ | @@global.log_bin | +------------------+ | 1 | +------------------+ 关闭当前会话二进制功能，并导入数据库 MariaDB [(none)]&gt; SET @@session.sql_log_bin=OFF; [root@node1~]#mysql &lt; hellodb.sql 使用xtrabackup备份数据库 MariaDB [(none)]&gt; GRANT ALL ON *.* TO &apos;root&apos;@&apos;192.168.4.63&apos; IDENTIFIED BY &apos;123456&apos;; #授权远程用户权限 [root@node1~]#innobackupex --user=root --host=localhost /data/mysql/ #使用命令进行备份 [root@node1~]#scp -r /data/mysql/* node2:/data/mysql #将备份数据复制到node2中 在node1中添加一些数据 MariaDB [hellodb]&gt; INSERT INTO scores (ID,StuID,CourseID,Score) VALUES (16,9,3,95); 在node2进行如下操作： [root@node2~]#innobackupex --apply-log /data/mysql/2017-11-11_19-45-11/ #将数据进行回滚 [root@node2~]#innobackupex --copy-back /data/mysql/2017-11-11_19-45-11/ #恢复 [root@node2~]#chown -R mysql.mysql /var/lib/mysql/ #修改权限 此时只是复制了某个时间点的数据，时间点之后的数据没有如何解决？ 查看时间点是的二进制日志在哪个地方 [root@node2/data/mysql/2017-11-11_19-45-11]#cat xtrabackup_binlog_info 在node1节点上查看并导出 [root@node1~]#mysqlbinlog -j 8203 /data/mysql/master-log.000001 &gt; change.sql [root@node1~]#scp change.sql node2:/tmp 在node2节点上导入 MariaDB [hellodb]&gt; SET @@session.sql_log_bin=OFF； 先关闭二进制日志功能 MariaDB [hellodb]&gt; \. /tmp/change.sql #导入 ####如何实现全量和增量？ #####在node1节点操作： [root@node1~]#innobackupex --user=root --host=localhost /data/mysql/ MariaDB [hellodb]&gt; INSERT INTO scores (ID,StuID,CourseID,Score) VALUES (17,10,3,95); #添加一行记录 [root@node1~]#innobackupex --user=root --host=localhost /data/mysql/ --incremental --incremental-basedir=/data/mysql/2017-11-11_20-19-31 #增量备份 MariaDB [hellodb]&gt; INSERT INTO scores (ID,StuID,CourseID,Score) VALUES (18,11,4,95); #再次添加一条记录 [root@node1~]#innobackupex --user=root --host=localhost /data/mysql/ --incremental --incremental-basedir=/data/mysql/2017-11-11_20-22-16 #再次进行增量备份 进行准备操作： [root@node1/data/mysql]#innobackupex --apply-log --redo-only 2017-11-11_20-19-31/ [root@node1/data/mysql]#innobackupex --apply-log --redo-only 2017-11-11_20-19-31/ --incremental-dir=/data/mysql/2017-11-11_20-22-16 #第一次增量准备 [root@node1/data/mysql]#innobackupex --apply-log --redo-only 2017-11-11_20-19-31/ --incremental-dir=/data/mysql/2017-11-11_20-24-32 #第二次增量准备 [root@node1/data/mysql]#innobackupex --apply-log /data/mysql/2017-11-11_20-19-31/ [root@node1/data/mysql]#mysqlbinlog -j 8203 master-log.000002 &gt; /root/mysql.sql [root@node1/data/mysql]#scp -r /root/mysql.sql node2:/tmp 将准备好的备份文件复制到node2节点中 [root@node1/data/mysql]#scp -r /data/mysql/2017-11-11_20-19-31/ node2:/data/mysql 在node2节点上操作[root@node1/data/mysql]#innobackupex --copy-back /data/mysql/2017-11-11_20-19-31/ #恢复数据库 [root@node1/data/mysql]#chown -R mysql.mysql /var/lib/mysql/ #修改权限 MariaDB [hellodb]&gt; \. /tmp/mysql.sql]]></content>
      <categories>
        <category>数据库</category>
        <category>Xtrabackup</category>
      </categories>
      <tags>
        <tag>Xtrabackup，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables命令]]></title>
    <url>%2F2017%2F11%2F28%2Fiptables%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[iptables命令格式： iptables [-t table] SUBCOMMAND chain [-m ] matchname [per-match-options]] -j targetname [per-target-options] 链管理||-F flush|清空规则链；|-N new|创建新的自定义规则链|-X drop|删除用户自定义空的规则链|-Z zero|清零，置零规则计数器|-P policy|为指定链设定默认策略，对于filter表，默认策略通常有ACCEPT、DROP、REJECT|-E rEname|重命名自定义链，注意：引用计数不为0自定义链无法改名，也无法删除|-A append|将新规则追加于指定链的尾部|-I insert|将新规则追加于指定链的位置|-D delete|删除指定链上的指定规则，指明规则序号；指明规则本身|-R replace|替换指定链上的指定规则 查看链规则||-L list|列出指定链上的所有规则|-n |以数字格式显示地址和端口号|-v|显示详细信息|–line-number|显示规则编号|-x exactly|显示计数器计数结果的精确值 匹配条件基本匹配[!]-s,–src,–source address[/mask]:检查报文中的源IP地址是否符合此处指定的地址范围 [!]-d,–dst,–destination address[/mask]:检查报文中源IP地址是否符合此处指定的地址范围 -p，–protocol {tcp|udp|icmp} ：检查报文中的的协议，即IP首部中的protocol所表示的协议 -i，–in-interface INFACE：数据报文的流入接口；仅能用于PREROUTING INPUT FORWARD链上 -o，–out-interface INFACE：数据报文的流出接口；仅能用于FORWARD OUTPUT POSTROUTING链上 扩展匹配使用扩展匹配需加载模块 隐式扩展在使用-p选项指明了特定的协议时，无需再使用-m选项指明扩展模块的扩展机制，不需要手动加载扩展模块 tcp协议扩展选项[!] –source-port,–sport port[:port] ：匹配报文源端口 [!] –destination-port ,–dport port[:port]：匹配报文目标端口 [!] –tcp-flags LIST1 LIST2 ：检查LIST1所指明的所有标志位，且LIST2所表示标记位必须为1，而余下的必须为0,；没有LIST1中指明的不做检查 --syn：用于匹配检查第一次三次握手 与--tcp-flags SYN,ACK,FIN,RST SYN作用相同 udp协议扩展选项[!] –source-port,–sport port[:port] ：匹配报文源端口 [!] –destination-port ,–dport port[:port]：匹配报文目标端口 icmp协议扩展选项[!] –icmp-type {type[/mode]|typename} type/code 0/0 echo-replay :icmp应答 8/0 echo-reques :icmp请求 显示扩展显示扩展必须使用选项-m指定，必须显示指明使用的模块 [root@localhost ~]# rpm -ql iptables |grep \.so$ mulitport扩展，以离散方式定义多端口匹配，最多指定15个端口 [!] –source-ports,–sports port[,port|port:port]指明多个源端口 [!] –destination-ports,–dports port[,port|:port] :指明多个目标端口 [!] –ports port[,port|,port:port] :指明多个源或目标端口 示例：[root@localhost ~]# iptables -A INPUT -s 192.168.4.61 -d 192.168.4.55 -p tcp -m multiport --sports 20:23 -j ACCEPT iprange扩展，指明连续ip地址范围使用；但一般是不能扩展整个网络 [!] –src-range from [-to]:指明连续的源ip地址范围[!] –dst-range from [-to]：指明连续的目标ip地址范围 示例：[root@localhost ~]# iptables -A INPUT -m iprange --src-range 192.168.4.61-192.168.4.65 -p tcp -j ACCEPT string 检查报文中出现的字符串 –algo {bm|kmp}：字符串匹配检测算法 –from offset ：开始偏移 –to offset ：结束偏移 [!] –string PATTERN ：要检查的字符串模式 [!] –hex-string PATTERN：要检测字符串模式 示例：[root@localhost html]# iptables -A OUTPUT -s 192.168.4.61 -d 0/0 -p tcp --sport 80 -m string --algo bm --string &quot;www.google.com&quot; -j REJECT time根据报文到达时间与指定的时间范围进行匹配 –datestart YYYY[-MM[-DD[Thh[:mm[:ss]]]]] –datestop YYYY[-MM[-DD[Thh[:mm[:ss]]]]] –timestart hh:mm[:ss] –timestop hh:mm[:ss] [!] –monthdays day[,day…] [!] –weekdays day[,day…] Mon, Tue, Wed, Thu, Fri, Sat, Sun, or values from 1 to 7, respectively. –kerneltz:内核时区，不建议使用；CentOS 7系统默认使用UTC；CentOS 6 不支持kerneltz，–localtz指定本地时区（默认） 示例：[root@localhost html]# iptables -A INPUT -s 192.168.4.61 -d 192.168.4.55 -p tcp --dport 80 -m time --timestart 15:00 --timestop 16:00 --weekdays 5 -j DROP connlimit 根据每客户端IP 做并发数量限制；通常分别于默认的拒绝或允许策略配合使用 –connlimit-upto N ：连接的数量小于等于N时匹配 –connlimit-above N：连接的数量大于N时匹配 示例：[root@localhost html]# iptables -A INPUT -d 192.168.4.61 -p tcp --dport 22 -m connlimit --connlimit-above 2 -j REJECT limit扩展，基于收发报文的速率做匹配 –limit rate[/second|/minute|/hour|/day] 限制速率 –limit-burst number 限制浏览 默认为5 示例：[root@localhost ~]# iptables -A INPUT -d 192.168.4.55 -p icmp --icmp-type 8 -m limit --limit 3/minute --limit-burst 5 -j ACCEPT state扩展，根据“连接追踪机制”去检查连接的状态，此扩展比较消耗资源 state 注释 NEW 新发出的请求，连接追踪模板中不存在此连接相关的信息条目，因此，将其识别为第一次发出的请求。 ESTABLISHED NEW状态之后，连接追踪模板中为建立的条目失效之前期间所进行的通信的状态。这个状态不管这个数据包是发往防火墙还是由防火墙转发的。ICMP的错误和重定向等信息包也被看做是ESTABLISHED，只要他们是我们所发出的信息应答。 RELATED 相关的连接，如ftp协议的命令连接和数据之间的关系。 INVALID 无法识别的连接 [!] –state STATE conntrack机制：追踪本机上的请求和响应之间的关系 文件 说明 /proc/net/nf_conntrack 已经追踪到的并记录下来的连接信息库 /proc/sys/net/nf_conntrack_max 调整连接追踪所能够容纳的最大连接数量 /proc/sys/net/netfilter 不同的协议连接追踪时长 注意：CentOS 7中需要加载模块：modprobe nf_conntrack iptablesde 连接追踪表最大容量为/proc/sys/net/nf_conntrack_max,各种状态超时连接会从表中删除，当模板满载时，后续连接可能会超时；那么我们如何解决此问题呢？ 方法一： 加大nf_conntrack_max的值 [root@localhost ~]# vim /etc/sysctl.conf net.nf_conntrack_max = 393216 net.netfilter.nf_conntrack_max = 393216 方法二 降低nf_conntrack timeout 时间 [root@localhost ~]# vim /etc/sysctl.conf net.netfilter.nf_conntrack_tcp_timeout_established = 300 net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120 net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60 net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120 示例：[root@localhost ~]# iptables -A OUTPUT -s 192.168.4.55 -p tcp -m multiport --dports 22,80 -m state --state ESTABLISHED -j ACCEPT [root@localhost ~]# iptables -A INPUT -d 192.168.4.55 -p tcp -m multiport --dports 22,80 -m state --state NEW -j ACCEPT mac扩展 指明源MAC地址；适用于PREROUTING、FORWARD、INPUT [!] –mac-source MAC 示例：[root@localhost ~]# iptables -A INPUT -s 192.168.4.61 -p icmp --icmp-type 8 -m mac --mac-source 00:0c:29:40:d6:de -j DROP 目标 target-j TARGET：jump值指定的target 选项 说明 ACCEPT 允许数据包通过 DROP 丢弃数据包 REJECT 丢弃数据包，并且将拒绝信息发送给发送方 SNAT 源地址转换 DNAT 目标地址转换 REDIRECT 目标端口转换 MASQUERADE 地址伪装 LOG：非中断target，本身不拒绝和允许，放在拒绝和允许规则之前，并将日志记录在/var/log/messages系统日志中 –log-level LEVEL 指定日志级别 –log-prefix PREFIX：日志前缀，用于区别不同的日志，最多29个字符 示例：[root@localhost ~]# iptables -A INPUT -s 192.168.4.61 -p tcp -m multiport --dports 21:23,80 -m state --state NEW -j LOG --log-level info --log-prefix &quot;new connections:&quot; 小结 任何不允许的访问，应该在请求到达时给予拒绝。规则在表中的次序为其检查时的生效次序 基于上述，规则优化建议： （1）安全放行所有入站和出站的状态为ESTABLISHED状态连接 （2）谨慎放行入站的新请求 （3）有特殊目的的限制访问功能，要在放行规则之前加以拒绝 （4）同类规则，匹配范围小的放在前面，用于特殊处理 （5）不同类规则，匹配范围大的放在前面 （6）应该将那些可由一条规则能够描述的多个规则合并为一条 （7）设置默认策略，建议白名单（只放心特定连接） iptables -P 不建议使用 建议在规则的最后定义规则作为默认策略 iptables -A INPUT -j DROP 规则的保存和恢复service iptables save 将规则覆盖保存至/etc/sysconfig/iptables文件中 iptables-save /PATH/TO/SOMEFILE 保存至指定文件中 iptables -S /PATH/TO/SOMEFILE 保存至指定文件中 service iptables restart 会从/etc/sysconfig/iptables文件中重新载入规则 iptables-restore &lt; /PATH/TO/SOMEFILE 从指定文件中加载规则 -n，--noflush：不清楚原有规则 -t，--test：仅分析生成规则集，但不提交 如果需要开启自动加载自己配置的规则，如何实现？ 方法一： 将iptables命令写至/etc/rc.d/rc.local，让此脚本开机后自动运行 方法二： 将iptables命令写入一个专门放置/PATH/TO/SOMEFILE文件中，然后将此脚本文件放置/etc/rc.d/rc.local文件中 iptables-restore &lt; /PATH/TO/SOMEFILE 方法三： 在CentOS 7 中可以自定义Unit File ，进行iptables-restore 注意：由于CentOS 7 中/etc/rc.d/rc.local文件没有执行权限，需要赋予执行权限才能实现 如果要实现不同场景中实现不同规则，可以将规则集放入到不同的文件中，在不同场景中使用 iptables-restore &lt; /PATH/TO/SOMEFILE即可。但是只能有且只用一个规则集生效。]]></content>
      <categories>
        <category>防火墙</category>
        <category>iptables命令</category>
      </categories>
      <tags>
        <tag>iptables命令，四表五链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables简单介绍]]></title>
    <url>%2F2017%2F11%2F28%2Fiptables%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、iptables1、iptables历史iptables的前身叫ipfirewall （内核1.x时代）,这是一个作者从freeBSD上移植过来的，能够工作在内核当中的，对数据包进行检测的一款简易访问控制工具。但是ipfirewall工作功能极其有限(它需要将所有的规则都放进内核当中，这样规则才能够运行起来，而放进内核，这个做法一般是极其困难的)。当内核发展到2.x系列的时候，软件更名为ipchains，它可以定义多条规则，将他们串起来，共同发挥作用，而现在，它叫做iptables，可以将规则组成一个列表，实现绝对详细的访问控制功能。 2、iptables概念iptables包含两部分，一部分是netfilter组件，是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤处理的规则集；另一部分是iptables，工作在用户空间中，定义规则的工具，本身并不算是防火墙。它们定义的规则可以让在内核空间当中的netfilter来读取，并且实现让防火墙工作。而放入内核的地方必须要是特定的位置，必须是tcp/ip的协议栈经过的地方；而这个tcp/ip协议栈必须经过的地方，可以实现读取规则的地方就叫做 netfilter.(网络过滤器) 3、防火墙的分类 主机防火墙：服务范围为当前主机网络防火墙，防火墙一侧的局域网 硬件防火墙：专用硬件级别实现部分功能的防火墙 软件防火墙：运行于通用硬件平台上的防火墙的应用软件 网络层防火墙：OSI下面第三层应用层防火墙 （1）网络层防火墙（包过滤防火墙） 工作机理 网络层对数据包进行选择（依据是系统内设置的过滤逻辑，被称为访问控制列表（ACL）），通过检查数据流中每个数据的源地址、目标地址、所用端口和协议状态等因素，或者他们的组合确定是否允许此数据包通过。 优点 对于用户来说是透明的，处理速度快且易于维护 缺点 无法检查应用层数据，如病毒等。 （2）应用层防火墙（代理服务器型防火墙） 工作机理 将所有跨越防火墙的网络通信链路分为两段，内外网用户的访问都是通过代理服务器上的链接来实现的 优点 应用层对数据进行检查，比较安全 缺点 增加防火墙的负载 在现实生产环境中所使用的防火墙一般都是上述两者结合一起发挥功用；即先进行网络数据检查，如果通过之后再送到应用层检查。 4、Netfilter组件netfilter工作在内核空间中，集成于linux内核中，提供一整套hook函数管理机制，使得数据包过滤、网络地址转换和基于协议类型的链接跟中成为了可能。内核中选取五个位置放五个hook function,INPUT、OUTPUNT、PREROUTING、POSTROUTING、FORWARD。由信息过滤表组成，包含控制IP 包处理的规则集，规则被分组放在chain上。 三种报文流向 流入本机：PREROUTING–&gt;INPUT–&gt;用户进程 流出本机：用户进程–&gt;OUTPUT–&gt;POSTROUTING 转发：PREROUTING–&gt;FORWARD–&gt;POSTROUTING 5、iptables组成防火墙的管理工具，工作在用户进程空间中。在用户进程空间中编写好规则之后，被发送给netfilter，告诉内核如何去处理信息包。 iptables由四张表和五个链以及一些规则组成。 四张表 filter ：过滤规则表，根据预先定义的规则过滤符合条件的数据表 nat（network addresss translation）表：地址转换表 mangle表：修改数据标记位规则表 raw表：关闭nat表上启动的链接追踪机制，加快封包速率 四张表的优先级 raw &gt; mangle &gt; nat &gt;filter netfilter表盒链对应关系 防火墙是iptabls和netfilter的组合，可以让规则进行生效，本身不是一种服务。 数据包过滤匹配流程如下 6、内核中数据包传输过程 （1）当一个数据包进入网卡时，数据包首先进入PREROUTING链，内核根据数据包目的IP 判断是否需要转发出去 如果上述判断数据包是进入本机，数据沿着②到达INPUT。数据包进入INPUT链后，任何进程都会接收到它。本机运行的程序可以发送数据包，这些数据包经过OUTPUT链然后到达POSTROUTING链输出 如果数据包要转发出去，且内核开启转发功能，数据包会沿着⑤到达FORWARD链，然后沿着⑥到达POSTROUTING链输出 7、iptables组成根据规则的匹配条件尝试匹配报文，对匹配成功的报文根据规则定义的处理动作做出处理。 规则和链是有计数器： pkgs：由规则和链所匹配到的报文的个数 bytes：由规则或链匹配到的所有报文大小之和 匹配条件 基本匹配：IP 、端口、TCP的标记位 扩展匹配：通过复杂高级功能匹配 处理动作 内置处理动作：ACCEPT DROP REJECT SNAT DNAT MASQUERADE MARK LOG 自定义处理动作：自定义chain，利用分类管理复杂情形 链 内置链：每个内置链对应一个hook函数 自定义链：用于对内置链进行扩展或补充，可以实现更灵活的规则管理机制；只有hook调用自定义链才能生效。 报文不会经过自定义链，只能在内置链上通过规则进行引用后生效。 8、添加规则的考量点（1）实现哪种功能：判断添加在哪张表上合适 （2）报文流经的路径：判断添加在哪个链上 链上的规则次序，即检查次序 同类规则（控制同一种应用访问），匹配范围小的放在上面 不同类规则（访问不同应用），匹配到报文频率较大的放在上面 将那些可有一条规则描述的多个规则合并为一个规则 设置默认策略]]></content>
      <categories>
        <category>防火墙</category>
        <category>iptables简单介绍</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keepalived实战]]></title>
    <url>%2F2017%2F11%2F28%2Fkeepalived%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[实战keepalived单实例，高可用性IPVS集群，IPVS集群提供apache；NAT模式topology （1）node1和node2环境前提 时间同步：[root@node1 ~]# ntpdate 172.18.0.1 [root@node1 ~]# vim /etc/ntp.conf [root@node1 ~]# service ntpd start #重启服务 [root@node1 ~]# chkconfig ntpd on #设置为开机启动 另外一个节点也是这样操作 如果是CentOS 7 操作如下[root@node2~]#vim /etc/chrony.conf[root@node2~]#systemctl start chronyd.service [root@node2~]#systemctl enable chronyd （2）关闭iptables和selinux node1： [root@node1 ~]# iptables -F [root@node1 ~]# service iptables stop [root@node1 ~]# chkconfig iptables off [root@node1 ~]# vim /etc/selinux/config SELINUX=disabled [root@node1 ~]# setenforce 0 node2： [root@node2~]#systemctl disable firewalld [root@node2 ~]# vim /etc/selinux/config SELINUX=disabled [root@node1 ~]# setenforce 0 （3）修改/etc/hosts文件 node1 [root@node1 ~]# vim /etc/hosts 192.168.4.61 node2 192.168.4.56 node1 node2 [root@node2 ~]# vim /etc/hosts 192.168.4.56 node1 192.168.4.61 node2 测试ping能否ping通 [root@node1 ~]# ping node2 PING node2 (192.168.4.61) 56(84) bytes of data. 64 bytes from node2 (192.168.4.61): icmp_seq=1 ttl=64 time=0.392 ms [root@node2~]#ping node1 PING node1 (192.168.4.56) 56(84) bytes of data. 64 bytes from node1 (192.168.4.56): icmp_seq=1 ttl=64 time=0.247 ms （4）node1和node2之间root用户可以基于密钥认证ssh服务完成互相通信 node1： [root@node1 ~]# ssh-keygen -t rsa [root@node1 ~]# ssh-copy-id -i /root/.ssh/id_rsa.pub node2 node2： [root@node2 ~]# ssh-keygen -t rsa [root@node2~]#ssh-copy-id -i /root/.ssh/id_rsa.pub node1 （5）node1和node2安装keepalived服务并配置 [root@node1 ~]# yum install -y keepalived ! Configuration File for keepalived global_defs { notification_email { client@mail.com } notification_email_from node1@mail.com smtp_server 192.168.4.132 smtp_connect_timeout 30 router_id node1 #node2为node2 vrrp_mcast_group4 224.100.100.4 } vrrp_instance VI_1 { state MASTER interface eth0 virtual_router_id 4 priority 12 #此处node1和node2优先级不一样 advert_int 1 authentication { auth_type PASS auth_pass e60f4024 } virtual_ipaddress { 172.18.4.60/16 } delay_loop 3 lb_algo wrr lb_kind NAT persistence_timeout 50 protocol TCP sorry_server 172.18.4.60 80 real_server 192.168.4.62 80 { weight 3 HTTP_GET { url { path /app/website status_code 200 } connect_timeout 1 nb_get_retry 3 delay_before_retry 1 } } real_server 192.168.4.63 80 { weight 1 HTTP_GET { url { path /app/website status_code 200 } connect_timeout 1 nb_get_retry 3 delay_before_retry 1 } } } node2和node1配置类似这里不再累述 测试是否VRRP实现 如果关闭node1服务，会出现图中情况。 （6）实现lvs调度 node1：开启路由转发功能 [root@node1 keepalived]# vim /etc/sysctl.conf net.ipv4.ip_forward = 1 [root@node1 keepalived]# sysctl -p node2：开启路由转发功能 [root@node2 keepalived]# vim /etc/sysctl.conf net.ipv4.ip_forward = 1 [root@node1 keepalived]# sysctl -p]]></content>
      <categories>
        <category>服务</category>
        <category>Keepalived</category>
        <category>keepalived实战</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memcached]]></title>
    <url>%2F2017%2F11%2F28%2Fmemcached%2F</url>
    <content type="text"><![CDATA[memcached是是一款开源、高性能、分布式存储内存对象缓存系统。主要目的是通过降低对Database的访问来加速web应用程序。一个基于内存的”键值对”存储用于存储数据库调用、API调用或页面引用结果的直接数据，如字符串、对象等。 一、memcached1、memcached特点（1）简单key/value存储，服务器不关心数据本身的意义及结构，只要是可序列化数据即可。 （2）功能的实现一般依赖于客户端，一般基于服务器端，客户端负责发送存储箱至服务器端，从服务器端获取数据以及无法连接至服务器时采用响应的动作；服务器端负责接收、存储数据，并负责数据项的超时过期 （3）各服务器彼此无视，不再服务器间进行数据同步 （4）o（1）的执行效率 （5）清理超期数据，默认情况下，memcached是一个LRU缓存，它按事先预设的时长清理超期数据，但是，memcached不会删除任何已缓存数据，只是在其过期之后不再为客户所见；也不会真正按期限清理缓存，而仅是当get命令到达时检查其时长 2、yum安装memcached[root@memcache~]#yum install -y memcached 配置文件主程序： /usr/bin/memcached 配置文件： /etc/sysconfig/memcached 1 PORT=&quot;11211&quot; 2 USER=&quot;memcached&quot; 3 MAXCONN=&quot;1024&quot; 4 CACHESIZE=&quot;64&quot; 5 OPTIONS=&quot;&quot; unit file memcached.service 3、命令memcached程序常用选项-l &lt;ip_addr&gt;：指定进程监听的地址 -d：以服务模式运行 -u &lt;username&gt;：以指定的用户身份运行memcached进程 -m &lt;num&gt;：用于缓存数据最大内存空间，单位为MB，默认为64MB -c &lt;num&gt;：最大支持的并发连接数，默认为1024 -p&lt;num&gt;：指定监听的TCP端口，默认为11211 -U&lt;num&gt;：指定监听的UDP端口，默认为11211,0表示关闭UDP端口 -M：内存耗尽时，不执行LRU清理缓存，而是拒绝存入新的缓存项，直到有多余的空间可用时为止 -f &lt;factor&gt;：增长因子，默认是1.25 -t &lt;threads&gt;：启动的用于响应用户请求的线程数 memcached-toolstats and management tool for memcached 使用格式： memcached-tool &lt;host[:port] | /path/to/socket&gt; [mode] display：打印分类信息。默认模式 [root@tomcatB~]#memcached-tool 127.0.0.1:11211 # Item_Size Max_age Pages Count Full? Evicted Evict_Time OOM # Number of the slab class. Item_Size The amount of space each chunk uses. One item uses one chunk of the appropri‐ ate size. Max_age Age of the oldest item in the LRU. Pages Total number of pages allocated to the slab class. Count Number of items presently stored in this class. Expired items are not auto‐ matically excluded. Full? Yes if there are no free chunks at the end of the last allocated page. Evicted Number of times an item had to be evicted from the LRU before it expired. Evict_Time Seconds since the last access for the most recent item evicted from this class. OOM Number of times the underlying slab class was unable to store a new item. stats：显示状态信息 dump：使部分缓存写 远程命令[root@memcache~]#telnet 127.0.0.1 11211 Trying 127.0.0.1... Connected to 127.0.0.1. Escape character is &apos;^]&apos;. 格式： &lt;command name&gt; &lt;key&gt; &lt;flags&gt; &lt;exptime&gt; &lt;bytes&gt; &lt;cas unique&gt; 统计类： stats stats items ,stats slabs ,stats sizes 存储类： set，add，replace，append，prepend 检索类： get ，delete，incr/decr 清空： flush_all]]></content>
      <categories>
        <category>缓存服务</category>
        <category>memcached</category>
      </categories>
      <tags>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keepalived简单介绍]]></title>
    <url>%2F2017%2F11%2F28%2Fkeepalived%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[keepalived介绍keepalived是linux下一个轻量级高可用的解决方案，主要通过VRRP实现高可用功能，作用域网络层、传输层和应用层；主要用作RealServer的健康性检查以及LoadBalance主机和Bcakup主机之间failover的实现。原生设计目的为了高可用的ipvs服务。（常见的前段高可用组合有LVS+Keepalived、Nginx+Keepalvied、HAproxy+Keepalived） 1、keepalived功能 （1）VRRP协议完成地质流动 （2）为VIP地质所在的节点生成ipvs规则 （3）为ipvs集群的各RS做健康状态检测 （4）基于脚本调用接口通过执行脚本完成脚本中定义的功能，进而影响集群事物，以支持nginx、haproxy等服务 2、keepalived组成 keepalived主要有三个模块，分别是core、check和vrrp。 core模块为keepalived的核心，负责主进程启动、维护以及全局配置文件的加载和解析 check模块负责健康检查，包括常见的各种检查方式 vrrp模块来实现VRRP协议 3、Keepalived工作原理 （1）在网络层，运行着四个重要的协议：互联网协议IP、互联网控制报文协议ICMP、地址转换协议以及反向地址转换协议RARP。keepalived在网络层采用的最常见的工作方式通过ICMP协议向服务器集群中的每个节点发送一个ICMP数据包，如果某个及诶单没有返回响应数据包，那么就认为此节点发生了故障，keepalived将报告此节点失效，并从服务器集群中剔除故障节点。 （2）在传输层，提供了主要的协议：传输控制协议TCP和用户数据协议UDP。keepalived在传输层利用TCP协议的端口连接和扫描技术来判断集群点是否工作正常。例如：web服务端口默认为80，如果keepalived在传输层探测到这些端口没有响应数据返回，就认为这些端口发生异常，然后强制将此端口对应的节点从服务器集群中移除。 （3）在应用层，运行着ftp、telnet、smtp、dns等各种不同类型的协议，用户可以编写脚本运行keepalived，keepalived根据用户设定检测各种程序或服务是否运行正常，如果keepalived的检测结果与用户设定不一致时，将对应的服务器从集群中移除。 4、keepalived配置文件安装方式一：- [root@localhost~]#yum install -y keepalived #安装keepalived [root@localhost~]#rpm -ql keepalived /etc/keepalived/keepalived.conf #主配置文件 /etc/sysconfig/keepalived #unit file环境配置文件 /usr/lib/systemd/system/keepalived.service #unit文件 安装方式二：-[root@localhost/usr/local/src]#tar xf keepalived-1.3.9.tar.gz [root@localhost/usr/local/src]#cd keepalived-1.3.9/ [root@localhost/usr/local/src/keepalived-1.3.9]#./configure [root@localhost/usr/local/src/keepalived-1.3.9]#make &amp;&amp; make install /etc/keepalived/keepalived.conf文件详解 Global definitions synopsis global_defs{ #全局定义 notification_email { #指定keepalived在发生切换时需要发送email到的对象，格式：一行一个。 email } notification_email_from email #指定发件人 smtp_server host #smtp服务器地址 smtp_connect_timeout num #smtp服务器连接超时时间 lvs_id string #表示本节点的字符串，通常为hostname } Virtual server definitions synopsis virtual_server (@IP PORT)|(fwmark num) { #设置一个VS ：VIP:PORT delay_loop num #服务轮询的时间间隔 lb_algo rr|wrr|lc|wlc|sh|dh|lblc #LVS调度算法 lb_kind NAT|DR|TUN # LVS集群模式 persistence_timeout num #会话保持时间 persistence_granularity @IP #LVS会话保持粒度，ipvsadm中的-M参数，即每个客户端都做会话保持 virtualhost string #检查web服务器的虚拟主机 protocol TCP|UDP #健康检查使用协议 sorry_server @IP PORT #备用服务器，当后端所有RS节点不可用时，就用此设置，把请求临时请求到这里 real_server @IP PORT { #后端真实节点服务器IP:PORT weight num #权重；0表示失效 TCP_CHECK { connect_ip &lt;IP ADDRESS&gt; #向当前RS的哪个IP地址发起健康状态检测请求 connect_port num #健康检查的端口 connect_timeout num #连接超时时间 bindto &lt;IP ADDRESS&gt; #发出健康状态检测请求时使用的源地址 bind_port &lt;PORT&gt; #发出健康状态检测请求时使用的源端口 } } real_server @IP PORT { weight num MISC_CHECK { misc_path /path_to_script/script.sh (or misc_path &quot;/path_to_script/script.sh &lt;arg_list&gt;&quot;) #外部脚本或程序 misc_timeout num #脚本或程序超时时间 } } real_server @IP PORT { weight num HTTP_GET|SSL_GET { 健康检查方式 url { #要检查的URL path alphanum #具体路径 status_code &lt;INT&gt; #判断上述检测机制为健康状态的响应码 digect alphanum #摘要 } connect_port num #监控检查端口 connect_timeout num #连接超时时长 nb(nat_mask)_get_retry num #重连次数 delay_before_retry num #重连间隔 bindto &lt;IP ADDRESS&gt;：发出健康状态检测请求时使用的源地址 bind_port &lt;PORT&gt; #发出健康状态检测请求时使用的源端口 connect_ip #向当前RS哪个IP地址发起健康状态检测请求 } } } VRRP intance definitions synopsis vrrp_sync_group string { #同步vrrp组 group { string string } notify_master /path_to_script/script_master.sh （or notify_master “/path_to_script/script_master.sh &lt;arg_list&gt;”） notify_backup /path_to_script/script_backup.sh (or notify_backup &quot;/path_to_script/script_backup.sh &lt;arg_list&gt;&quot;) notify_fault /path_to_script/script_backup.sh (or notify_fault &quot;/path_to_script/script_fault.sh &lt;arg_list&gt;&quot;) } vrrp_instance string { #示例名称 state MASTER|BACKUP #当前节点在此虚拟路由器上的初始状态；只能有一个MASTER，其余的为BACKUP interface string #绑定为当前虚拟路由器使用的物理接口 mcast_src_ip @IP #组播IP lvs_sync_daemon_interface string virtual_router_id num #虚拟路由ID，用来区别多个instance的VRRP组播 priority num #优先级 advert_int num #检查间隔 smtp_alert authentication { #认证区域 auth_type PASS（最长8位）|AH #认证类型，默认是PASS认证 auth_pass string #PASS认证密码 } virtual_ipaddress { 不能超过20个 @IP #虚拟VIP地址 @IP } virtual_ipaddress_excluded { @IP @IP } notify_master /path_to_script/script_master.sh （or notify_master “/path_to_script/script_master.sh &lt;arg_list&gt;”） #当前节点成为主节点时触发的脚本 notify_backup /path_to_script/script_backup.sh (or notify_backup &quot;/path_to_script/script_backup.sh &lt;arg_list&gt;&quot;) #当前节点转为备节点时触发的脚本 notify_fault /path_to_script/script_backup.sh (or notify_fault &quot;/path_to_script/script_fault.sh &lt;arg_list&gt;&quot;) #当前节点转为“失败”状态时触发的脚本 notify &lt;STRING&gt;|&lt;QUOTED-STRING&gt; 一个脚本可完成以上上中状态转换时的通知 } vrrp_script chk_http { script &quot;/path_to_script/script.sh&quot; http服务检测脚本 interval num #检查间隔 weight num #权重 fall #如果连接失败次数达到此值，则认为服务器已经down rise #如果连接次数达到此值，则认为服务器已UP，但不修改优先级 weight -NUM #检测失败则优先级-NUM } track_interface { #定义额外的监听网卡，只要其中一个网卡出现故障就会发生准备切换 eth0 eth1 ... } track_script { chk_http #引用VRRP脚本，即在vrrp_script部分指定的名字 } 小结 （1）优先级不会不断的提高或降低 （2）可以编写多个检测脚本为每个检测脚本设置不同的weight （3）不管提高优先级还是降低优先级，范围为1-254 （4）在MASTER节点的vrrp_instance中配置nopreempt，当它异常恢复后，即时它的优先级更高也不会抢占 keepalived调用脚本进行资源监控keepalived调用外部辅助脚本进行资源监控，并根据监控结果状态能实现优先动态太正。 vrrp_script：自定义资源监控脚本，vrrp示例根据脚本返回值，公共定义，可对悲多个示例调用，定义在vrrp示例之外 track_script：调用vrrp_script定义的脚本去监控资源，定义在示例之外，调用事先定义的vrrp_script 定义keepalived日志[root@localhost~]#vim /etc/sysconfig/keepalived 14 KEEPALIVED_OPTIONS=&quot;-D -S 2&quot; [root@localhost~]#vim /etc/rsyslog.conf 74 local2.* /var/log/keepalived.log 重启服务 [root@localhost~]#systemctl restart rsyslog.service [root@localhost~]#systemctl restart keepalived.service]]></content>
      <categories>
        <category>服务</category>
        <category>Keepalived</category>
        <category>keepalived简单介绍</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sudo]]></title>
    <url>%2F2017%2F11%2F28%2Fsudo%2F</url>
    <content type="text"><![CDATA[sudo在生产环境中，一个人的力量总是不够的，我们可以把一些任务分配别的人员协同操作，这样办事效率也提高了。但是我们又不想把所有的权限都分给小伙伴，所以sudo就解决了这样一个问题。sudo能够授权指定用户在指定主机上运行某些命令；如果未授权用户使用sudo尝试登录，会提示管理员。这样方便了我们的管理。 1、含义sudo是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的一个工具，如halt，reboot，su等等。&lt;摘自：百度&gt; 2、sudo的优点（1）提供日志，记录每个用户使用sudo操作 （2）为系统管理员提供配置文件，允许系统管理员集中地管理用户的使用权限和使用的主机。 （3）sudo提供用户一个使用时长，相当于“入场券”，如果超时，重新登录。默认为5分钟（如果想修改，只能自己编译安装时候修改）。 （4）sudo提供专门的修改文件工具visudo，默认是vi界面，如果想使用vim功能，可以自定环境变量“export EDORIT=vim”。 （5）自己创建文件的权限为440，如果你忘记修改权限，visudo命令可以自动修改完成。 （6）修改配置文件是同时打开一个，不能打开多个。并且配置文件不建议直接去修改。 3、配置文件/etc/sudoers/和/etc/sudoers.d/*（1）配置文件支持使用通配符 通配符 说明 ？ 任意单个字符 * 匹配任意长度 [] 匹配单个字符 [!] 除了的任意字符 \ 支持转义 （2）授权规则格式 用户 登入主机=（代表用户） 命令 选项 说明 user 运行命令着的身份 host 通过哪些主机 （runas） 以哪个用户身份运行 command 运行哪些命令 user和runas格式 username #uid %group_name %#group_name User_Alias Runas_Alias host ip或hostname network network/prefix(只有CentOS7支持) Host_Alias command commandName directory sudoedit 可以对文件`/etc/sudoers`修改 CMD_Alias 注意：这里的命令一定要与执行的命令精确匹配，否则不成功。别名定义一定要大写字母开头，构成只能有字母和数字。 （3）别名 格式：Alias_Type NAME1 = item1, item2, item3 : NAME2 = item4, item5注意：不同的别名之间需要使用冒号隔开。%wheel是一个组，权限和root一样，使用时一定要小心。如果在添加NOPASSWD不提供口令直接登录。sudo使用时登录需要认证，但是此时认证时运行者的口令。 时间戳文件/var/db/sudo/日志文件/var/log/secure （4）设定默认值defaults 示例：Defaults：laowang runas_default=tom 4、sudo命令格式：sudo [-u user] COMMAND 选项 解释 -u 指定用户，默认root -l 列出用户在主机上可用的和被禁止的命令 -v 再延长有效期5分钟，更新时间戳 -k 清除时间戳（197–01-01），西祠需要重新输入密码 -K 与-k类似，但还要删除时间戳文件 -b 在后台执行 -p 改变询问密码的提示符号 %p代表用户 -V 显示版本信息等配置信息 注意：在sudoers文件中，如果定义文件后面添加“*”表示所有，即这个文件后面可以添加任意字符 ，言外之意，就是可以看到别的文件。]]></content>
      <categories>
        <category>安全</category>
        <category>sudo</category>
      </categories>
      <tags>
        <tag>sudo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[varnish]]></title>
    <url>%2F2017%2F11%2F28%2Fvarnish%2F</url>
    <content type="text"><![CDATA[Varnish是一款高性能且开源的反向代理服务器和HTTP极速器，其采用全新的软件体系机构和现在的硬件体积紧密配合。 一、Varnish1、varnish系统结构 varnish主要运行两个进程：Manager进程和Cacher 进程 Manager进程功能： 实现应用新的配置 编译VCL（Varnish Configure Language） 监控varnish 初始化varnish 提供一个命令行接口 Manager进程每个几秒会探测cache进程是否正常运行，如果在指定的时间内未得到cache进程响应，Manager进程将重启此Cache进程 Cache进程包含多种类型的线程 Acceptor进程：接受新的链接请求并响应 Worker进程：cache进程会为每个会话启动一个worker线程，因此在高并发场景中可能会出现数百个worker进程或者更多 Expiry进程：从缓存中清理过期内容 varnish日志为了与系统的其他部分进行交互，Cache进程使用了可以通过文件系统接口进行访问的共享内存日志（shared memory log），如果某线程需要记录日志信息，其仅需要持有一个锁，而后向共享内存中的某内存区域写入数据，再释放持有的所即可。 共享内存日志大小一般为90M，其分为两部分，前一部分为计数器，另一部分为客户端请求的数据。varnish提供了多个不同管理日志工具：varnishlog、varnishncsa、varnishstat等来分析共享内存日志中的信息并能够以指定的方式进行显示 2、VCL（Varnish Configuration Language）varnish配置缓存策略工具，是一种基于“域（domain specific）”的简单编程语言。支持有限的算术运算和逻辑运算操作、允许使用正则表达式进行字符串匹配、允许用户使用set自定义变量、支持if判断语句、内置函数和变量等。使用VCL编写的缓存策略通常保存至.VCL文件中，其需要变异成二进制格式后才能由varnish调用。不过整个缓存策略由几个特定的子例程如vcl_recv、vcl_fetch等组成，它们分别在不同的位置执行，如果没有实现为某个位置自定义子例程，varnish将会执行默认定义。 编译过程VCL策略在启用之前，会由manager进程将其转换为C代码，然后再由gcc编译器将C代码编译成二进制程序；编译完成后，manager进程负责将其连接至varnish示例，即Cache进程。 优点： 由于编译工作在Cache进程之外完成，避免了装载错误格式VCL风险。因此varnish修改配置的开销非常小，其可以同时保存尚在引用的旧版本配置，也能够让新的配置即刻生效。编译后的旧版本配置通常在varnish重启时才会被丢弃，如果需要手动请求，则可以使用varnishadm中的vcl.discard命令完成。 3、varnish后端存储varnish支持多种不同类型的后端存储，可以在varnishd启动时使用-s选项指定。 后端存储类型 基于磁盘存储 file：使用特定的文件存储全部的缓存数据，并通过操作系统的mmap()系统调用将整个缓存文件映射至内存区域（如果条件允许） persistent：与file功能相同，但可以持久存储数据（即重启varnish数据时不会被清除），处于测试期基于内存存储 malloc：使用malloc()库调用在varnish启动时向操作系统申请指定大小的内存空间以存储缓存对象；串行存储模式 jemalloc：并行存储模式 选择使用合适的存储方式有助于提升系统性，从经验的角度看，建议在内存空间足以存储所有的缓存对象时使用malloc方法，反之，file存储将有着更好的性能表现。不过varnish实际上使用的空间比使用-s选项指定的缓存空间更大，一般来说，其需要为每个缓存对象多使用差不多1k左右的存储空间。 二、varnish状态引擎（Varnish Finite State Machine） 1、VCL状态引擎在VCL状态引擎中，状态之间具有相关性，但彼此间互相隔离，每个引擎使用return（action）来退出当前状态并指示varnish进入下一个状态。 处理过程varnish开始处理一个请求时，首先需要分析HTTP请求本身，如从首部获取请求方法、验证其是否为一个合法的HTTP请求等；当这些基本分析结束后就需要作出第一个决策，即varnish是否从缓存中查找请求的资源（需要由vcl_recv方法完成；如果没有自定义的vcl_recv函数指定其终止操作，其扔将执行默认的vcl_recv函数。）。 2、VCL语法基本语法： （1）//、#或/comment/用于注释 （2）sub $name 定义函数 （3）不支持循环，有内置变量 （4）使用终止语句，没有返回值 （5）域专用 （6）操作符：=、==、~、！、&amp;&amp;、|| 为什么VCL只有终止语句而没有返回值呢？ VCL函数不接受参数并没有返回值，并非真正意义上的函数，这也限定了VCL内部的数据传递只能隐藏在HTTP首部内部进行。VCL的return语句用于将控制权从VCL状态引擎返回给varnish，而非默认函数。 3、VCL内置函数VCL提供了几个函数来实现字符串修改，添加bans、重启VCL状态引擎以及将控制权转回varnish等 regsub（str，regex，sub）和regsuball（str，regex，sub）：这两个用于基于正则表达式搜索指定的字符串并替换为指定的字符串；只替换第一次匹配到的，而regsuball全部替换 ban（expression）： ban_url（regex）：bans所有其URL能够有regex匹配的缓存对象 purge：从缓存中挑选出某对象以及其相关变种一并删除，这可以通过HTTP协议的PURGE方法完成 hash_data（str）：指明哈希计算的数据；减少差异，以提升命中率 return（restart）：重新运行整个VCL，即重新从vcl_recv开始进行处理；每一次重启都会增加req-restarts变量中的值，而max_restarts参数则用于限定最大重启次数 4、vcl_recv在varnish完成对请求报文的解码为基础数据结构后的第一个要执行的子例程 主要用途（1）修改客户端数据已减少缓存对象差异性，如删除URL中的www.等字符 （2）基于客户端数据选用缓存策略，日入仅缓存特定的URL请求，不缓存POST请求等 （3）位某web应用程序执行URL重写规则 （4）挑选合适的后端web服务器 可以使用下面的终止语句，即通过return（）向varnish返回的指示操作： pass：绕过缓存，即不从缓存中查询内容或不将内容存储至缓存中 pipe：不对客户端进行检查或作出任何操作，而是在客户端与后端服务器之间建立专用“管道”，并直接将数据在二者之间进行传送；此时，keep-alived连接中后续传送的数据也都将通过此管道进行直接传送，并不会出现在任何日志中 lookup：在缓存中查找用户请求的对象，如果缓存中没有其请求的对象，后续操作很可能会将其请求的对象进行缓存 error：由varnish自己合成一个相应报文，一般是响应一个错误类信息、重定向类信息或负载均衡器返回的后端web服务器健康状态检查类信息 可以通过精巧的策略完成一定意义上的安全功能，以将某些特定的攻击扼杀于摇篮中，同时，它也可以检查出一些拼写错误并将其进行修修正 varnish默认的vcl_recv专门设计用来实现安全的缓存策略，主要完成两种功能：（1）仅处理可以识别的HTTP方法，并且只缓存GET和HEAD方法 （2）不缓存任何用户特有的数据 安全起见，一般在自定义的vcl_recv中不要使用return()终止语句，而是再由默认vcl_recv进行处理，并由其作出相应的处理决策。 5、vcl_fetch根据服务器的响应作出缓存决策；在任何VCL状态引擎中返回的pass操作都将由vcl_fetch进行后续处理。vcl_fetch中有许多可用的内置变量，比如最常用的用于定义某对象缓存时长的beresp.ttl变量 通过return()返回给varnish的操作指示有：（1）deliver：缓存此对象，并将其发送给客户端（vcl_deliver） （2）hit_for_pass：不缓存此对象，但可以导致后续对此对象的请求直接送达到vcl_pass进行处理 （3）restart：重启整个VCL，并增加重启计数；超过max_restarts限定的最大重启次数后将会返回错误信息 （4）error code [reason]：返回指定的错误代码给客户端并丢弃此请求 默认的vcl_fetch放弃了缓存任何使用了Set-Cookie首部的响应。 两个特殊引擎- vcl_init：在处理任何请求之前要执行的vcl代码：主要用于初始化VMODs； vcl_fini：所有的请求都已经结束，在vcl配置被丢弃时调用；主要用于倾全力VMODs； 三、修改缓存对象1、缓存内容修剪提高缓存命中率的最有效途径之一时增加缓存对象的生存时间（TTL），但是这也可能会带来副作用，比如缓存的内容再到达为其制定的有效期之间已经失效。因此，手动检验缓存对象的有效性或者刷新时缓存很有可能成为服务器管理员的日常工作之一；varnish完成这类的任务提供了三种途径：HTTP修剪(HTTP purging)、禁用某类缓存对象（banning）和强制缓存未命中（forced cache misses） 2、移除单个缓存对象purge用于清理缓存中的某特定对象及其变种，因此在有着明确要修剪的缓存对象时可以使用此中方式。HTTP协议的PURGE方法可以实现purge功能，不过其仅能用于vcl_hit和vcl_miss中，它会释放内存工作并移除指定缓存对象的所有vary（变种），并等待下一个针对此内容客户端请求到达时刷新此内容。起一般要与return（restart）一起使用。 3、强制缓存未命中在vcl_recv中使用return（pass）能够强制到上游服务器取得请求的内容，但这也会导致无法将其缓存。使用purge会移除就的缓存对象，但如果上游服务器宕机而无法取得新版本的内容时，此内容将无法再响应给客户端。使用req.has_always_miss=true，可以让varnish在缓存中搜寻响应的内容但却总是回应“未命中”，于是vcl_miss将后续地负责启动vcl_fetch从上游服务器取得新内容，并以新内容缓存覆盖就内容；此时，如果上游服务器宕机或未响应，旧的内容将保持原状，并能够继续服务器那些为使用req.has_always_miss=true的客户端，直到其过期失效或者由其他方法移除。 4、banningban（）是一种已缓存对象中过滤出某此特定的对象并将其移除的缓存内容刷新机制，不过它并不足之处新的内容进入缓存或响应于请求。在varnish中，ban的实现是指将一个ban添加至ban列表中，这可以通过命令行接口或VCL实现，他们的使用语法时相同的。ban本身就是一个或多个VCL风格的语句，它会在varnish从缓存哈希（cache hash）中查找某缓存对象时对搜寻的对象进行比较测试，因此，一个ban语句就是类似匹配所有以/downloads开头的URL，或者响应首部中包含nginx的对象。 示例： ban req.http.host == “test。com” &amp;&amp; req.url ~ “\.gif$” 定义好的ban语句会生成一个ban列表（ban-list），新添加的ban语句会被放置在列表中的首部。缓存中的所有对象在响应给客户端之前都会被ban列表检查至少一次，检查完成将会为每个缓存创建一个指向与其匹配的ban语句的指针。varnish在从缓存中获取对象时，总是会检查此缓存对象的指针是否指向了ban列表的首部；如果没有指向ban列表的首部，其将对使用所有的新添加的ban语句对此缓存对象进行测试，如果没有任何ban语句能够匹配则更新ban列表。 四、varnish检测后端主机的健康状态varnish可以检测后端主机的健康状态，在判定后端主机失效时能够给自动将其从可用后端主机列表中移除，而一旦其重新变得可用还可以自动将其设定为可用。为了避免误判，varnish在探测后端主机的健康状态发生转变时，通常需要连续执行几次探测均为新状态才将其标记为转换后的状态。 每个后端服务器当前探测的健康状态探测可以使用.probe进行设定，其结果可有req.backend.healthy变量获取；也可以通过varnishlog中的backend_health查看或varnishadm的debug.health查看 ####### .probe的探测常用的指令： （1）.url：探测后端主机健康状态时请求的URL，默认为”/“ （2）.request：探测后端主机健康状态时请求内容的详细格式，定义后，它会替换.url指定的探测方法 （3）.window：设定在判定后端主机健康状态时基于最近多少次的探测进行，默认为8 （4）.threshold：在.window中指定的次数中，至少有多少次时成功的才能判定后端主机健康运行，默认为3 （5）.initial：varnish启动时对后端主机至少需要多少次的成功探测，默认同.threshold （6）.expected_response：期望后端主机响应的状态码，默认为200 （7）.interval：探测请求的发送周期，默认为5s （8）.timeout：每次探测请求的过期时长，默认为2s 如果varnish在某时刻没有任何可用的后端主机，它将尝试使用缓存对象的“宽容副本（graced copy）”，此时VCL中的各种规则亦然有效。因此更好的办法时在VCL规则中判断req.backend.health变量显示某后端主机不可用时，为此后端主机增大req.grace变量的值以设定使用的宽容期限长度。 五、varnish使用多台后端主机varnish中可以使用的director指令将一个或多个近似的后端主机定义为一个逻辑组，并可以指定的调度方式来轮流将请求发送至这些主机上。不同的director可以使用同一个后端主机，而某director也可以使用“匿名”后端主机（在direcotr中直接进行定义）。每个director都必须有专用名，且在定义后必须在VCL中进行调用，VCL中任何可以指定后端主机的位置均可以按需将其替换为调用已定义的director。 使用前需要导入directors模块 示例： import directors; backend server1 { .host = 192.168.4.60 .port = 80 } backend server2 { .host = 192.168.4.61 .port = 80 } sub vcl_init { new testgrp = direcotrs.round_robin(); testgrp.add_backend(server1); testgrp.add_backend(server2); } sub vcl_recv { set req.backend_hint = testgrp.backend(); } 六、varnish参数varnish有许多参数，但是在某些场合我们需要修改他们提高性能。可以在管理接口中使用param.show命令查看这些参数，而使用param.set则能修改这些参数的值。当时，在命令行接口进行的修改不会保存至任何位置，重启varnish后这些设定会消失。可以通过启动脚本使用-p选项在varnishd启动时为其设定参数的值。 1、线程模型 cache-worker线程：每连接一个用于处理请求， cache-main线程：全局只有一个，用于启动cache 2、线程相关的参数 thread_pools：工作线程池，最好小于或等于CPU核心数量 thread_pool_max：每线程池最大线程数 thread_pool_min：每线程池最小线程数，即最大空闲线程数 thread_pool_timeout：每线程的超时时长 thread_pool_add_delay：添加线程的延迟时间 thread_pool_destory_delay：每线程销毁时长 3、timer相关的参数 send_timeout：客户端连接超时时长 timeout_idle：Idle timeout for client connections. timeout_req：请求超时时长 cli_timeout：Timeout for the childs replies to CLI requests from the mgt_param. 七、varnish命令行工具1、varnishadm命令通过命令行的方式连接至varnishd进行管理操作的工具。 语法： varnishadm [-t timeout] [-S secret_file] [-T address:port] [-n name] [command [...]] 指定要连接的varnish示例的方法：-n name 连接至名称为“name”的示例 -T address:port 连接至指定套接字上的示例 配置文件相关： vcl.list： vcl.load：装载，加载并编译 vcl.use：激活 vcl.discard：删除 vcl.show [-V] &lt;configname&gt;：查看指定的配置文件的详细信息 运行时参数： param.show -1：显示列表 param.show &lt;PARAM&gt; param.set &lt;PARAM&gt; &lt;VALUE&gt; 缓存存储： storage.list 后端服务器： backend.list 2、varnish.param选项 -a address[:port][,address[:port]...]，默认为6081端口 -T address[:port]，默认为6082 -s [name=]type[,options]，定义缓存存储机制 -u user -g group -f config，VCL配置文件 -F 运行在前台 -p param=value：设定运行参数即数值，可重复使用多次 -r param[,param]：设定指定的参数为只读状态 3、varnishstatvarnish缓存统计信息 -l：列出 -f：指定字段名称列表 MAIN.cache_hit MAIN.cache_miss 4、varnishtopvarnish日志全部等级 -l -i taglist，可以同时使用多个-i选项，也可以一个选项跟上多个标签 -I &lt;[targlist:]regex&gt; -x taglist:排除列表 -X &lt;[taglist:]regex&gt; 八、varnish配置文件配置varnish服务进程的工作特性，例如监听的地址和端口，缓存机制 /etc/varnish/varnish.params 配置各Child/cache线程的缓存策略 /etc/varnish/default.vcl 主程序 /usr/sbin/varnishd share memory log交互工具 /usr/bin/varnishhist /usr/bin/varnishlog /usr/bin/varnishncsa /usr/bin/varnishstat /usr/bin/varnishtop 测试工具程序 /usr/bin/varnishtest VCL配置文件重载程序 /usr/sbin/varnish_reload_vcl systemd unit file /usr/lib/systemd/system/varnish.service /usr/lib/systemd/system/varishlog.service /usr/lib/systemd/system/varnishncsa.service]]></content>
      <categories>
        <category>缓存服务</category>
        <category>varnish</category>
      </categories>
      <tags>
        <tag>varnish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库类型]]></title>
    <url>%2F2017%2F11%2F28%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、数据库1、数据库的概念数据库(Database)是按照数据结构来组织、存储和管理数据的建立在计算机存储设备上的仓库；它以一定的组织形式存于存储介质上。 2、数据库管理系统(Database Management System)一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS。它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。用户通过DBMS访问数据库中的数据，数据库管理员也通过dbms进行数据库的维护工作。它可使多个应用程序和用户用不同的方法在同时或不同时刻去建立，修改和询问数据库。大部分DBMS提供数据定义语言DDL（Data Definition Language）和数据操作语言DML（Data Manipulation Language），供用户定义数据库的模式结构与权限约束，实现对数据的追加、删除等操作。 &lt;摘自：百度&gt; 3、数据库管理系统与文件管理系统对比||编写应用程序不方便|编写应用程序方便，好管理|数据冗余不可避免|较少的数据冗余|应用程序依赖性|程序与数据相互独立|不支持对文件并发访问|数据可以被并发访问；并保证一致性|数据之间联系弱|相互关联的数据集合|难以按用户要求使用视图表示|可以按用户的需求使用视图表示|无安全控制功能|可以保证数据的安全性、可靠性 4、数据库的种类（1）非关系型数据库（2）关系型数据库（RDBM）创建在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。标准数据查询语言SQL就是一种基于关系数据库的语言。这种语言执行对关系数据中数据的检索和操作。关系模型由关系数据结构、关系操作集合和关系完整性约束三部分组成。 数据结构 包括两类：一类是与数据类型、内容和性质有关的对象，比如关系型中的域、属性和关系等；另一类是与数据之间有关的对象，它从数据组织层表达数据记录于字段的结构。 数据的操作集合 数据提取，在数据集合中提取感兴趣的内容。（SELECT）；数据更新，更改数据库中的数据（INSERT、DELETE和UPDATE）。 数据完整性约束 是一组完整性规则的集合。如实体完整性（Entity Integrity）、域完整性（Doamin Integrity）和参考完整性（Referential Integrity）。 （a）关系实体模型（Entity-Relationship Model，E-R Model） 注： 矩形代表实体 椭圆代表关系 菱形代表关系 实体表示一个离散对象。客观存在并可以相互区分的客观事物或抽象时间被称为实体（Entity）；每个实体必须有一个唯一表示的最小化集合。这个集合叫实体的主键。 关系 描述了两个或多个实体之间是如何关联。如有关两个实体 （b）构建数据库步骤①收集数据，得到字段 ②字段分类，归入表并建立表的关联 ③规范化数据库 （c）关系型数据库正规化设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为范式。各种范式呈递次规范，越高的范式数据库冗余越小。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、Boyce-Codd范式（BCNF）、第四范式（4NF）和第五范式（5NF） 1NF：无重复的列，每一列都是不可分割的基本数据项；同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。除去同类型的字段，简言之：无重复的列。 2NF：要求实体的属性完全依赖于关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。如果存在这个属性和主关键字的这一部分应该分离出来形成一个新的实体。新实体与原来实体之间是一对多关系。为实现区分通常需要为表加上一个列，以存储各个实体的唯一标识（primary key）。简言之，非主属性分非部分依赖于主关键字。 3NF：属性不依赖于其他非主属性。简言之，要求一个数据库不包含已在其他表中已包含的非主关键字信息。非PK（primary key）的字段不能有从属关系。 注意：不过这个不是必要遵守的，有时候在生产中，为了提升效能，刻意而为之。]]></content>
      <categories>
        <category>数据库</category>
        <category>数据库类型</category>
      </categories>
      <tags>
        <tag>数据库类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集群介绍]]></title>
    <url>%2F2017%2F11%2F28%2F%E9%9B%86%E7%BE%A4%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[参考： http://www.linuxvirtualserver.org/zh/lvs1.html 一、服务器集群系统1、对称多处理对称多处理（symmctric multi-processor，SMP）是由多个对称的处理器和通过总线共享的内存和I/O不见所组成的计算机系统。由于SMP的可扩展能力有限，SMP服务器显然不能满足高可伸缩、高可用网络服务器的负载处理能力不断增长需求。 SMP的缺点（1）升级过程繁琐，机器切换会使服务中断并造成原有计算资源的浪费。 （2）高端的服务器所花费的代价大 （3）SMP服务器是单一故障点（Single Point of Failure），一旦该服务器或应用软件失效，会导致整个服务的中断。 2、集群服务器集群，英文名称为Cluster，通俗地说，集群是一种技术：它将多个系统连接到一起，使多台服务器能够像一台机器那样工作或者看起来好像一台机器。采用集群系统通常是为了提高系统的稳定性和网络中心的数据处理能力及服务能力。 3、linux cluster类型1.LB Load Balancing（负载均衡集群），为了提高服务的并发能力 2.HA High Availability（高可用性集群），为了提供7*24小时服务的能力，通过冗余服务器，来防止宕机造成服务器终端 3.HPC High Performance Computing（高性能集群），为了在短期内解决大量复杂的计算 4、Cluster分类LB Cluster实现方法硬件 F5 Big-IP Citrix Netscaler A10 软件 lvs：Linux Virtual Server Nginx：支持四层调度 Haproxy：支持四层调度 ats：apache traffic server，是一个高性能的、模块化的HTTP代理和缓存服务器 Cluster分类基于工作的协议层划分 传输层：DPORT应用层：针对特定协议，自定义的请求模型分类5、会话保持：负载均衡（1）session sticky：同一用户调度固定服务器 （2）session replication ：每台服务器拥有全部内容 （3）session server：专门的session服务器memcached，redis等]]></content>
      <categories>
        <category>集群</category>
        <category>集群介绍</category>
      </categories>
      <tags>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络防火墙]]></title>
    <url>%2F2017%2F11%2F28%2F%E7%BD%91%E7%BB%9C%E9%98%B2%E7%81%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[网络防火墙网络防火墙可以充当网关；使用filter表中的FORWARD链。如果要启用conntrack机制，建议将双方向的状态为ESTABLISHED的报文直接放行。 如图所示：现在我们的需求是内网可以ping外网但是外网ping不了内网如何实现？ 环境： CentOS 6 192.168.4.55 CentOS 6 172.18.4.61 充当路由器（两块网卡） CentOS 7 172.18.4.56 （1）在CentOS 6 (192.168.4.56)可以路由转发功能并添加规则 [root@localhost ~]# vim /etc/sysctl.conf net.ipv4.ip_forward = 1 [root@localhost ~]# sysctl -p 使其生效 （2）将两台主机的网关指定路由器 [root@localhost ~]# route add default gw 192.168.4.61 [root@localhost ~]# route add default gw 172.18.4.61 （3）测试没有假规则之前是否可以ping通 （4）在路由上添加规则 方式一： [root@localhost~]#iptables -A FORWARD -s 192.168.4.0/24 -d 172.18.4.0/24 -p icmp --icmp-type 8 -j ACCEPT [root@localhost~]#iptables -A FORWARD -s 172.18.4.0/24 -d 192.168.4.0/24 -p icmp --icmp-type 0 -j ACCEPT [root@localhost~]#iptables -A FORWARD -j REJECT 方式二： [root@localhost~]#iptables -A FORWARD -m state --state ESTABLISHED -j ACCEPT [root@localhost~]#iptables -A FORWARD -s 192.168.4.0/24 -d 172.18.4.0/24 -p icmp --icmp-type 8 -j ACCEPT [root@localhost~]#iptables -A FORWARD -j REJECT 方式三： [root@localhost~]#iptables -A FORWARD -m state --state ESTABLISHED -j ACCEPT [root@localhost~]#iptables -A FORWARD -s 192.168.4.0/24 -d 172.18.4.0/24 -m state --state NEW -j ACCEPT [root@localhost~]#iptables -A FORWARD -j REJECT （5）测试是否成功 问题：如何开放被动模式的ftp模式？ （1）需要查看是否已经加载了ftp追踪的模块 跟踪模块路径：/lib/modules/2.6.32-696.el6.x86_64/kernel/net/netfilter/ [root@localhost ~]# lsmod |grep ftp 如果没有记载此模块需要安装模块 [root@localhost ~]# modprobe nf_conntrack_ftp （2）放行请求报文 [root@localhost ~]# iptables -A INPUT -d 192.168.4.55 -p tcp --dport 21 -m state --state NEW -j ACCEPT[root@localhost ~]# iptables -A INPUT -d 192.168.4.55 -p tcp -m state --state RELATED,ESTABLISHED # （3）放行响应报文 [root@localhost ~]# iptables -A OUTPUT -s 192.168.4.55 -p tcp -m state --state ESTABLISHED -j ACCEPT #如果没有别的定义OUTPTU 可以不定义此规则 NAT：Network Address Translation（网络地址转换）NAT工作在PREROUTING、INPUT、OUTPUT、POSTROUTING SNAT :Source Network Address Translation 应用在PREROUTING、INPUT链上，让本地网络中的主机通过某一特定地址访问外部网络，实现地址伪装。 请求报文：修改源IP -J SNAT --to-source [ipaddr[-ipaddr]][:port[-port]] --random 如上图所示，就是SNAT。 实现此功能只需添加一条规则即可 [root@localhost~]#iptables -t nat -A POSTROUTING -s 192.168.4.0/24 -j SNAT --to-source 172.18.4.56 注意：地址转换不需要双方互指网关，只需本地网络指定内网网关即可 ###如果我们不知道外网IP地址或者范围如何实现SNAT呢？ MASQUERADE :伪装，动态IP ，如以前拨号网络 --to-ports[-port] --random [root@localhost~]#iptables -t nat -A POSTROUTING -s 192.168.4.0/24 -j MASQUERADE DNAT ：Destination Network Address Translation 应用在PREROUTING、OUTPUT链上。把本地网络中的主机上的某服务开放给外部网络访问，但可以隐藏真实IP 请求报文：修改目标IP [root@localhost~]#iptables -t nat -A PREROUTING -s 172.18.4.56 -p tcp --dport 80 -j DNAT --to-destination 192.168.4.55 PNAT：Port Network Address Translation 端口号和IP都进行修改。 注意：我们在工作环境中一般把本地网络设置为私网地址，如果设置为公网地址，假设某天您访问的某个网站的IP和你设置的一样可能导致您访问不了。 REDIRECT转发 可用于PREROUTING、 OUTPUT链上。通过改变目标IP和端口，将接受的包转发至不同地址 --to-ports port[-port] [root@localhost~]#iptables -t nat -A PREROUTING -d 192.168.4.55 -p tcp --dport 80 -j REDIRECT --to-ports 8000 实现多端口转发 [root@localhost~]#iptables -t nat -A PREROUTING -d 192.168.4.55 -p tcp -m multiport –dports 1234,9527,8000 -j REDIRECT –to-ports 80]]></content>
      <categories>
        <category>防火墙</category>
        <category>网络防火墙</category>
      </categories>
      <tags>
        <tag>网络防火墙，DNAT</tag>
        <tag>SNAT</tag>
      </tags>
  </entry>
</search>
