<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2017%2F11%2F28%2FCobbler%2F</url>
    <content type="text"><![CDATA[title: Cobblerdate: 2017-11-28tags: [cobbler，自动化安装]categories: - 自动化运维 - cobbler – 一、cobbler1、cobbler概念Cobbler是一个Linux服务器快速网络安装的服务，而且在经过调整也可以支持网络安装windows。该工具使用python开发，小巧轻便（才15k行python代码），可以通过网络启动(PXE)的方式来快速安装、重装物理服务器和虚拟机，同时还可以管理DHCP，DNS，TFTP、RSYNC以及yum仓库、构造系统ISO镜像。Cobbler可以使用命令行方式管理，也提供了基于Web的界面管理工具(cobbler-web)，还提供了API接口，可以方便二次开发使用。Cobbler是较早前的kickstart的升级版，优点是比较容易配置，还自带web界面比较易于管理。Cobbler内置了一个轻量级配置管理系统，但它也支持和其它配置管理系统集成，如Puppet，暂时不支持SaltStack。Cobbler客户端Koan支持虚拟机安装和操作系统重新安装，使重装系统更便捷。 2、工作流程 （a）client裸机配置了从网络启动后，开机后会广播包请求DHCP服务器（cobbler server）发送其分配好的一个IP （b）DHCP服务器（cobbler server）收到请求后发送responese，包括其ip地址 （c）client裸机拿到ip后再向cobbler server发送请求OS引导文件的请求 （d）cobbler server告诉裸机OS引导文件的名字和TFTP server的ip和 port （e）client裸机通过上面告知的TFTP server地址通信，下载引导文件 （f）client裸机执行执行该引导文件，确定加载信息，选择要安装的os， （g）期间会再向cobbler server请求kickstart文件和os image （h）cobbler server发送请求的kickstart和os iamgeclient裸机加载kickstart文件 （i）client裸机接收os image，安装该os image 3、cobbler包介绍cobbler包集成了dhcp，pxe服务，rsync，http，dns，kiskstart，IPMI电源管理。 cobbler命令格式：cobbler command [subcommand] [–arg1=value1] [–arg2=value2] cobbler check 核对当前设置是否有问题cobbler list 列出所有的cobbler元素cobbler repo 列出元素的详细信息 cobbler sync 同步配置到数据目录，更改配置 cobbler reposync 同步yum仓库 cobbler distro 查看导入的发行版系统信息 cobbler distro add cobbler distro copy cobbler distro edit cobbler distro find cobbler distro list cobbler distro remove cobbler distro rename cobbler distro report cobbler system 查看添加的系统信息 cobbler profile 查看配置信息 cobbler profile add --name=NAME --distro=DISTRO --kickstart=KICKSTART cobbler profile list #列出配置文件信息 cobbler profile remove cobbler profile rename 修改配置文件名称 cobbler profile report #列出某个配置文件的报告 --name=NAME cobbler improt | | –arch=ARCH | OS architecture being imported | –breed=BREED | the breed being imported | –os-version=OS_VERSION |the version being imported | –path=PATH | local path or rsync location | –name=NAME | name, ex ‘RHEL-5’ | –available-as=AVAILABLE_AS | tree is here, don’t mirror | –kickstart=KICKSTART_FILE | assign this kickstart file | –rsync-flags=RSYNC_FLAGS | pass additional flags to rsync 3、cobbler目录介绍/etc/cobbler/settings : cobbler 主配置文件 /etc/cobbler/iso/: iso模板配置文件 /etc/cobbler/pxe: pxe模板文件 /etc/cobbler/power: 电源配置文件 /etc/cobbler/user.conf: web服务授权配置文件 /etc/cobbler/users.digest: web访问的用户名密码配置文件 /etc/cobbler/dhcp.template : dhcp服务器的的配置模板 /etc/cobbler/dnsmasq.template : dns服务器的配置模板 /etc/cobbler/tftpd.template : tftp服务的配置模板 /etc/cobbler/modules.conf : 模块的配置文件 数据目录 /var/lib/cobbler/config/: 用于存放distros，system，profiles 等信息配置文件 /var/lib/cobbler/triggers/: 用于存放用户定义的cobbler命令 /var/lib/cobbler/kickstart/: 默认存放kickstart文件 /var/lib/cobbler/loaders/: 存放各种引导程序 镜像目录 /var/www/cobbler/ks_mirror/: 导入的发行版系统的所有数据 /var/www/cobbler/images/ : 导入发行版的kernel和initrd镜像用于远程网络启动 /var/www/cobbler/repo_mirror/: yum 仓库存储目录 日志目录 /var/log/cobbler/installing: 客户端安装日志 /var/log/cobbler/cobbler.log : cobbler日志 4、相关术语发行版：表示一个操作系统。它承载了内核和initrd信息，以及内核参数等其他数据。 配置文件：包含一个发行版、一个kickstart文件以及可能的存储库，还包含更多特定的内核参数等其他数据。 系统：表示要配给的机器。它包含一个配置文件或一个镜像，还包含IP和MAC地址、电源管理以及更专业的数据信息。 存储库：保存一个yum或rsync存储库的镜像信息。镜像：可替换一个包含不属于此类别的文件的发行版对象。（例如，无法分为内核和initrd对象） 二、cobbler实战（1）安装cobbler安装包和dhcp[root@localhost ~]# yum install -y cobbler [root@localhost ~]# yum install -y dhcp （2）将服务设为开机启动并启动服务[root@localhost ~]# systemctl enable tftp #将tftp服务设为开机启动，并启动它 [root@localhost ~]# systemctl start tftp [root@localhost ~]# systemctl enabel httpd #将http服务设为开机启动并启动 [root@localhost ~]# systemctl enable httpd [root@localhost ~]# systemctl start httpd [root@localhost ~]# systemctl enable cobblerd #将cobbler设为开机启动并启动 [root@localhost ~]# systemctl start cobblerd （3）运行cobbler check命令解决问题为了确保出现不必要的问题，禁用iptables和setenforce [root@localhost ~]# iptables -F#清空防火墙规则[root@localhost ~]# setenforce 0 #将selinux设为permissiving [root@localhost ~]# cobbler check #检查cobbler环境是否配置正确 当运行cobbler check命令时出现上述的问题，我们通过一个一个解决就可以慢慢的实现cobbler自动化安装CentOS 系统。下面我们一个一个的解决这些文件 （a）修改cobbler服务端地址选项server [root@localhost ~]# vim /etc/cobbler/settings [root@localhost ~]# cobbler sync #将修改过的文件同步 （b）修改next_server 此选项是修改tftp的地址[root@localhost ~]# vim /etc/cobbler/settings [root@localhost ~]# cobbler sync （c）修改mange_dhcp 此选项是要cobbler管理dhcp[root@localhost ~]# vim /etc/cobbler/settings [root@localhost ~]# cobbler sync （d）获取启动菜单方法一：如果有网络的话使用如下方式 [root@localhost ~]# cobbler get-loaders方法二： 如果没有网络/var/lib/tftpboot/目录下的pxelinux.0和menu.c32文件复制到/var/lib/cobbler/loaders [root@localhost ~]# cp /var/lib/tftpboot/{pxelinux.0,menu.c32} /var/lib/cobbler/loaders/[root@localhost ~]# cobbler sync （e）修改用户口令 [root@localhost ~]# openssl passwd -1 #生成加密口令 Password: Verifying - Password: $1$gMx01QUD$eo5dQGlEDGh9o0fY8dgnr. [root@localhost ~]# cobbler sync （f）配置dhcp服务 [root@localhost ~]# vim /etc/cobbler/dhcp.template [root@localhost tftpboot]# cobbler sync #将修改后内容太同步到/etc/dhcp/dhcpd.conf文件中 （4）导入yum源 [root@localhost ~]# cobbler import --path=/media/cdrom --name=centos7.3 --arch=x86_64 --path：指明yum源的路径 --name：指明复制到`/var/www/cobbler`目录下 --arhc：指明架构类型 （5）编辑ks文件并导入 默认的ks位置/var/lib/cobbler/kickstarts/sample.ks 首先将ks文件复制到/var/lib/cobbler/kickstarts目录下，然后将ks文件导入 [root@localhost kickstarts]# cobbler profile edit/add --name=centos7.3-x86_64 --distro=centos7.3-x86_64 --kickstart=/var/lib/cobbler/kickstarts/ks7.cfg #编辑原有的ks文件 [root@localhost tftpboot]# cobbler sync （6）编辑菜单文件 默认的菜单文件/etc/cobbler/pxe/pxedefault.template #默认菜单模板 启动菜单存放位置/var/lib/tftpboot/pxelinux.cfg/default [root@localhost tftpboot]# cobbler sync （7）新建一台虚拟机测试 另外cobbler也提供web管理。Cobbler web界面是一个很好的前端，非常容易管理Cobbler。可以添加和删除system、distro、profile，可以查看、编辑distros、profiles、subprofiles、systems、repos、kickstart文件cobbler认证方式有两种： 方式一： （1）修在认证方式 （2）创建管理用户[root@localhost ~]# htdigest -c /etc/cobbler/users.digest &quot;Cobbler&quot; admin 注意：第一创建是需要加选项“-c”意味着创建文件/etc/cobbler/users.digest文件。 htdigest命令的使用格式： htdigest [ -c ] passwdfile realm username 如何修改管理用户的密码呢？[root@localhost ~]# htdigest /etc/cobbler/users.digest &quot;Cobbler&quot; admin方式二：（a）修改认证方式 （b）创建管理用户 [root@localhost ~]# useradd cobbler[root@localhost ~]# passwd cobbler （c）修改文件/etc/cobbler/user.conf （3）在浏览器地址输入地址 https://192.168.4.128/cobbler_web并管理用户和密码即可]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP请求报文]]></title>
    <url>%2F2017%2F11%2F28%2FHTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%2F</url>
    <content type="text"><![CDATA[HTTP请求报文在之前我们介绍了Web请求的过程里面说了当Client向Serve发送建立请求时即发送请求报文。Server处理完成之后向Client发送响应报文，即响应报文。下面我们来具体说说这两个的结构。 请求报文语法格式： &lt;Method&gt;&lt;Request-URL&gt;&lt;VERSION&gt; &lt;Headers&gt; &lt;Entity-body&gt; 响应报文语法格式： &lt;Version&gt;&lt;Status-code&gt;&lt;Reson-phrase&gt; &lt;Headers&gt; &lt;Entity-body&gt; 具体解释说明 method方法类型： method方法类型 说明 GET 从服务器获取一个资源 HEAD 只从服务器获取文档的响应头部 POST 向服务器输入数据，通常会再由网关程序继续处理 PUT 将请求的主体部分存储在服务器上，如上传文件 DELETE 请求删除服务器上指定的文档 TRACE 追踪请求到达服务器中间经过的代理服务器 OPTIONS 请求服务器返回对指定资源支持使用的请求方法 VERSION构成： HTTP/&lt;major&gt;.&lt;minor&gt; Header 每个请求或响应报文可包含任意首部；每个首部都有首部名称，后面跟一个冒号，而后跟一个可选空格，接着一个值。 Entity-body 请求时附加的数据或响应时附加的数据 Reson-phrase 状态码所标记状态简要描述 状态码种类 HTTP状态码分类 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 状态码详解说明 状体码 描述 简要描述 200 成功，请求数据通过响应报文的Eentity-body部分发送 ok 301 请求的URL指向的资源已经删除；但在响应报文中通过首部Location指明了资源现有资源所处的新位置 Moved Permanently 302 响应报文Location指明资源临时位置 Moved Temporarily 304 客户端发出了条件式请求，但服务器上的资源未曾发生改变，则通过此响应状态码通知客户端 Not Modified 401 需要填入账号和密码认证才能访问资源 Unautorized 403 访问被禁止 Forbidden 404 服务器无法找到客户端请求资源 Not Found 500 服务器内部错误 Internal Server Error 502 代理服务器从后端服务器收到了一条伪响应，如无法连接网关 Bad Gateway 503 服务不可用，临时服务器维护或过载，服务器无法处理请求 Service Unavailable 504 网关超时 Gateway Timeout 505 服务器不支持请求的HTTP协议的版本，无法完成处理 HTTP Version Not Support 示例： [root@localhost ~]# curl -i www.360buy.com #响应报文示例 HTTP/1.1 301 Moved Permanently Age: 2822 Content-Type: text/html Date: Thu, 28 Sep 2017 13:23:54 GMT Location: http://www.jd.com/ Server: JDWS Via: BJ-H-NX-112(), http/1.1 LA-1-JCS-40 ( [cRs f ]) Content-Length: 272 &lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt; &lt;body bgcolor=&quot;white&quot;&gt; &lt;h1&gt;301 Moved Permanently&lt;/h1&gt; &lt;p&gt;The requested resource has been assigned a new permanent URI.&lt;/p&gt; &lt;hr/&gt;Server: JDWS&lt;/body&gt; &lt;/html&gt; http协议头部 通用首部 首部信息 说明 Date 报文的创建时间 Connnection 连接状态，如keep-alive，close Via 显示报文经过的中间节点 （代理、网关） Cache-Control 控制缓存，如缓存时长 MIME-Version 发送端使用的MIME版本 请求首部 请求首部信息 说明 Accept 通知服务器自己可接受的媒体类型 Accept-Charset 客户端可接受的字符集 Accept-Encoding 客户端可接受编码格式 Accept-Language 客户端可接受的语言 Client-IP 请求客户端IP Host 请求服务器名称和端口号 Referer 跳转至当前URL的前一个URL User-Agent 客户端代理，浏览器版本 条件式请求首部 条件请求首部信息 说明 Expect 允许客户端列出某请求所要求的服务器行为 If-Modified-Since 自从指定的时间之后，请求的资源是否发生过修改 If-Unmodified-Since 自从指定的时间之后，请求的资源是否没有发生过修改 If-None-Match 本地缓存中存储的文档的ETag标签是否与服务器文档的ETag不匹配 If-Match 本地缓存中的存储文档ETag标签是否与服务器文档的ETag匹配 安全请求首部 安全请求首部 说明 Authorization 向服务器发送认证信息，如账号和密码 Cookie 客户端向服务器发送cookie Cookie2 用于说明请求端支持的cookie版本 代理服务请求首部 Proxy-Authorization 向代理服务器认证 响应首部 响应首部信息 说明 Age 从最初创建开始响应持续时长 Server 服务器程序软件名称和版本 Accept-Ranges 服务器可接受的请求范围类型 Vary 服务器查看的其他首部列表 安全响应首部 安全首部信息 说明 Set-Cookie 向客户端设置cookie Set-Cookie 向客户端发送cookie2版本 WWW-Authenticate 来自服务器对客户端的质询列表 实体首部： 实体首部信息 说明 Allow 列出对此资源实体可使用的请求方法 Location 告诉客户端真正的实体位于何处 Content-Encoding 对主体执行的编码 Content-Language 文本使用的语言 Content-Location 实体真正所处的位置 Content-type 主体的对象类型 ETag 实体的扩展标签 Expires 实体的过期时间 Last-Modified 最后一次修改时间]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>HTTP请求报文</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bind包安装]]></title>
    <url>%2F2017%2F11%2F28%2FBind%E5%8C%85%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[实现管理DNS1、bind安装包bind-libs.x86_64 #库包 bind-libs-lite.x86_64 # bind-license.noarch #认证包 bind-utils.x86_64 #提供对dns服务器的测试工具程序 bind-chroot #为bind提供一个伪装的根目录以增强安全性 2、Bind配置文件服务脚本 /etc/rc.d/init.d/named和/usr/lib/systemcd/system/named.service 主配置文件/etc/named.conf /etc/named/rfc1912.zones 存放根服务器地址 /var/named/name.ca 解析库文件 /var/named/ZONE_NAME_ZONE 注意： （1）一台物理服务器可同时为多个区域提供解析。 （2）必须要有根文件：name.ca。 （3）应该有两个实现localhost和本地回环的解析库。 主配置文件/etc/namd.conf // named.conf // // Provided by Red Hat bind package to configure the ISC BIND named(8) DNS // server as a caching only nameserver (as a localhost DNS resolver only). // // See /usr/share/doc/bind*/sample/ for example named configuration files. #这个文件是一个参考例子 // // See the BIND Administrator&apos;s Reference Manual (ARM) for details about the // configuration located in /usr/share/doc/bind-{version}/Bv9ARM.html options { #全局设置 listen-on port 53 { 127.0.0.1; }; #IPv4监听的端口和IP地址 listen-on-v6 port 53 { ::1; }; #IPv6监听的端口 directory &quot;/var/named&quot;; #zone配置文件存放目录 dump-file &quot;/var/named/data/cache_dump.db&quot;; #下载缓存数据库 statistics-file &quot;/var/named/data/named_stats.txt&quot;; #静态文件 memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;; allow-query { localhost; }; #允许询问 /* - If you are building an AUTHORITATIVE DNS server, do NOT enable recursion. - If you are building a RECURSIVE (caching) DNS server, you need to enable recursion. control to limit queries to your legitimate users. Failing to do so will cause your server to become part of large scale DNS amplification attacks. Implementing BCP38 within your network would greatly reduce such attack surface */ recursion yes; #是否递归查询 dnssec-enable yes; #是否支持DNSSEC开关 dnssec-validation yes; #是否进行DNSSEC确认开关 /* Path to ISC DLV key */ bindkeys-file &quot;/etc/named.iscdlv.key&quot;; managed-keys-directory &quot;/var/named/dynamic&quot;; pid-file &quot;/run/named/named.pid&quot;; session-keyfile &quot;/run/named/session.key&quot;; }; logging { #日志信息 channel default_debug { file &quot;data/named.run&quot;; #存放的文件位置 severity dynamic; #工作模式 }; }; zone &quot;.&quot; IN { #根域 type hint; #zone类型 file &quot;named.ca&quot;; #文件名称 }; include &quot;/etc/named.rfc1912.zones&quot;; include &quot;/etc/named.root.key&quot;; 建议一般不要在这个文件中配置zone，可以在/etc/named.rfc1912.zones文件下进行配置。 /var/named/named.localhost 文件 $TTL 1D @ IN SOA @ rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS @ A 127.0.0.1 AAAA ::1 一般这个文件作为一个模板文件进行zone的配置。 3、DNS转发服务器 （1）全局转发：对非本机所负责区域的请求，全转发给指定的服务器。 options{ forward first|only； forwarders { IP; }; }； （2）特定区域转发：仅转发对特定区域的请求，比全局转发优先级高。 zone &quot;ZONE_NAME&quot; IN { tyep forward; forward first|only; forwarders { IP; } }; 4、从DNS服务器（1）应该为一台独立的名称服务器 （2）主服务器区域解析文件中必须有一条NS记录指向从DNS服务器 （3）从服务器只需要定义区域，而无须提供解析库；解析库文件应该放置于/var/named/slaves目录下。 （4）主服务器得允许从服务器区域传送 （5）主从服务器的时间应该保持一致 （6）Bind程序版本应该保持一致；如果不一致，建议主服务器低，从服务器高。 （7）修改网卡配置文件/etc/sysconfig/network-scripts-ifcfg-INTERFACE,添加DNS记录。 5、允许动态更新如果想启用此功能，可以在/etc/named.rfc1912.zones文件中定义之。]]></content>
      <categories>
        <category>服务</category>
        <category>DNS</category>
        <category>Bind包安装</category>
      </categories>
      <tags>
        <tag>dns，bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible初级认识]]></title>
    <url>%2F2017%2F11%2F28%2Fansible%E5%88%9D%E7%BA%A7%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[一、ansible介绍1、概念ansible是自动化运维工具，基于Python开发，集合了众多的运维工具的优先，实心了批量系统配置、批量程序部署、批量运行命令等功能。 2、特性 模块化：调用特定的模块完成特定的任务 基于Python语言实现，由Paramiko、PyYAML和Jinja2三个关闭模块 部署简单，agentless 支持自定义模块 支持playbook 3、ansible工作原理 由图中我们可以看出ansible的组成结构： Host Inventory ：主机库设置 Playbook：剧本，按照事先设定的顺序完成安排的任务 Core Modules：核心模块 Custom Modules：自定义模块 Connection Plugins：连接插件，一般基于ssh连接，加密传输，相对安全。 后面的Host1、Host2等都是在Host Inventory定义的主机。 用户通过命令执行，Ansible使用ssh等方式连接到Host Inventory定义的主机；执行事先好的Playbook，调用Core Modules或Custom Modules等完成任务。 4、ansible安装[root@localhost~]#yum install -y ansible 由于ansible是由Python开发，所以依赖于有关Python包，需要epel源环境。 配置文件 主配置文件：/etc/ansible/ansible.cfg 设置主机清单：/etc/ansible/hosts 定义格式： 定义单个主机： green.example.com blue.example.com 192.168.100.1 192.168.100.10 定义一组主机 [webservers] alpha.example.org beta.example.org 192.168.1.100 192.168.1.110 如果有一组主机格式相同可以使用如下格式： www[001:006].example.com 如果一个主机属于多个组可以写入不同的组中。 设置角色路径：/etc/ansible/roles 定义每个角色时，均需在此目录创建目录，在新创建的目录下创建目录： files/：存放由copy或script模块等调用的文件 templates/：template模块查找所需要的模板文件的目录，文件均需以“.j2”结尾 tasks/：定义任务的目录；至少应该包含一个名为main.yml的文件，其他的文件需要在此文件中通过include进行包含 handlers/：定义触发条件的目录；至少应该包含一个名为main.yml的文件，其他的文件需要通过include进行包含 vars/：定义变量的目录；至少应该包含一个名为main.yml文件，其他的文件需要在此文件中通过include进行包含 meta/：定义元数据目录；至少应该包含一个名为main.yml的文件，定义当前角色的特殊设定及其依赖关系；其他的文件需要在此文件中通过include进行包含。 default/：设定默认值变量时使用此目录的main.yml文件 命令介绍（1）ansible - run a task on a target host(s) 是一个额外简单的tool/framework/API管理远程主机。允许运行一个简单的任务剧本的adhoc命令。 使用格式: ansible &lt;host-pattern&gt; [-m module_name] [-a args] [options] # 选项 说明 -a ‘ARGUMENTS’, –args=’ARGUMENTS’ 设定参数 -C, –check 在远程不做任何修改，相当于干跑 -c CONNECTION, –connection=CONNECTION 指定使用的连接类型，如ssh、winrm和local，默认为ssh -e EXTRA_VARS, –extra-vars=’EXTRA_VARS 指定额外的变量插入到剧本中，变量需要使用“‘’”引起来，并且命令行的优先级大于剧本中变量的优先级 -f NUM, –forks=NUM 指定并行级别。默认为5 -i PATH, –inventory=PATH 指定主机库，默认为/etc/ansible/hosts –list-hosts 列出指定主机 -m NAME, –module-name=NAME 指定模块名称，默认为command模块 -M DIRECTORY, –module-path=DIRECTORY 指定模块路径，默认为/usr/share/ansible -o, –one-line 输出信息在一行 -u USERNAME, –user=USERNAME 设定连接主机的名称，默认为root （2） ansible-doc - show documentation on Ansible modules显示模块信息 使用格式： ansible-doc [-M module_path] [-l] [-s] [module...] # 选项 说明 -M DIRECTORY, –module-path=DIRECTORY 指定模块路径，默认为/usr/share/ansible -s, –snippet= 列出模块使用方法 -l, –list= 列出所有模块信息 （3）ansible-playbook - run an ansible playbook管理剧本 使用格式： ansible-playbook &lt;filename.yml&gt; ... [options] # 选项 说明 -C, –check 检查脚本是否正确 -c CONNECTION, –connection=CONNECTION 连接使用的方法 -e EXTRA_VARS, –extra-vars=EXTRA_VARS 设定变量 –list-tasks 列出任务 –list-tags 列出标签 –list-hosts 列出主机]]></content>
      <categories>
        <category>监控工具</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>playbook</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS实战]]></title>
    <url>%2F2017%2F11%2F28%2FDNS%E5%AE%9E%E6%88%98%E4%B8%80%2F</url>
    <content type="text"><![CDATA[实战（1）搭建主DNS服务器（a）[root@localhost ~]# yum install -y bind #安装包（b）[root@localhost ~]# vim /etc/named.conf #修改主配置文件 方式一： 方式二： （c）[root@localhost ~]# vim /etc/ named.rfc1912.zones #修改zone文件 zone &quot;test.com&quot; IN { type master; file &quot;test.com.zone&quot; #此地方可以写绝对路径和相对路径，如果写相对路径，默认为`/var/named/test.com.zone`，因此在`/var/named`目录下文件名一定要与这里的文件名一致。 }; （d）[root@localhost ~]# named-checkconf #使用命令对配置文件检查 /etc/named.rfc1912.zones:27: missing &apos;;&apos; before &apos;}&apos; #此时检查为27行处没有加&quot;;&quot;修改完再检查即可。 注意：修改rfc1912.zones文件时，要以“；”结尾；参数与选项之间必须有空格隔开。 （e）修改zone文件[root@localhost named]# cp named.localhost test.com.zone 但是这里有一个问题，bind程序是以who的身份运行呢？下面通过命令查询看下：[root@localhost named]# ps aux |grep named named 4002 0.2 1.2 161124 13028 ? Ssl 09:55 0:00 /usr/sbin/named -u named 通过命令查看我们看到是以name身份运行的，但是我们在复制文件时，文件名时root，如下图；所以在复制过来以后记得修改文件的权限。 方法一：修改文件的所属组 [root@localhost named]# chgrp named test.com.zone 方法二：复制模板文件时，直接加“-p” [root@localhost named]# cp -p named.localhost test.com.zone[root@localhost named]# vim test.com.zone #修改ZONE文件 $TTL 1D @ IN SOA dns1 mail.test.com. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 dns1 A 192.168.4.132 （f）加载zone文件 [root@localhost named]# rndc reload （g）查看是否可以解析 [root@localhost named]# dig-t ns test.com @192.168.4.132 #在本机测试 在另外一台机器上测试 修改这台机器上的DNS 测试 [root@localhost/etc/sysconfig/network-scripts]#dig -t ns test.com @192.168.4.132 （2）搭建从DNS服务器在主机IP地址为192.168.4.144搭建从服务器 （a）安装bind包 （b）编辑/etc/named.conf （c）编辑配置zone文件/etc/named.rfc1912zones zone &quot;test.com&quot; IN { type slave; #修改类型 masters { 192.168.4.132; }; #主DNS服务器的地址 file &quot;slaves/test.com.slave.zone&quot;; #从DNS服务文件存放的位置 }; （d）启动bind服务，使其生效 [root@localhost~]#systemctl restart named[root@localhost~]#ls /var/named/slaves/test.com.slave.zone （e）测试 [root@localhost~]#dig www.test.com @192.168.4.144 （3）实现转发功能假如一个公司有三台DNS服务器，A,B,C并且这三台主机不在同一个位置；A机器可以直接连接互联网，而B，C不可以直接连接互联网。用户使用电脑想访问www.qq.com，只能通过专线先到C再到A，然后才能访问www.qq.com，通过C转发到A。 方式一：全局转发 （1）分别在CentOS 6和CentOS 7 主机上设置，CentOS 7为转发 (A)在CentOS 6主机上配置 [root@localhost ~]# vim /etc/named.conf [root@localhost ~]# vim /etc/named.rfc1912.zones zone &quot;test.com&quot; IN { type master; file &quot;test.com.zone&quot;; }; 重启服务 [root@localhost ~]# service named restart (B)在CentOS 7主机上配置 [root@localhost~]#vim /etc/named.conf 切记，做这个实验室一定要关闭dnssec功能；dnssec-enable no; dnssec-validation no。 重启服务 [root@localhost~]#systemctl restart named (C)修改客户端机器的dns [root@localhost~]#vim /etc/sysconfig/network-scripts/ifcfg-ens33 (D)在客户端机器上测试 [root@localhost~]#dig www.test.com @192.168.4.148 在这里给大家提个醒：自己搞这个明明很简单的搞了一个多小时都没有成功，原因在于没有关闭dnssce功能。 方式二：特定区域转发 在CentOS 主机上配置 [root@localhost~]#vim /etc/named.rfc1912.zones zone &quot;test.com&quot; IN { type forward; forward first; forwarders {192.168.4.132;}; }; [root@localhost~]#systemctl restart named #重启服务 在客户端主机上测试 （4）实现父域与子域的关系在前面实验的基础上，执行如下操作： （A）在CentOS 7主机上 [root@localhost~]#vim /etc/named.rfc1912.zones 创建zone zone &quot;do.test.com&quot; IN { type master; file &quot;do.test.com.zone&quot;; }; [root@localhost/var/named]#vim do.test.com.zone #配置解析库 $TTL 1D @ IN SOA dns1 rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 dns1 A 192.168.4.148 webserver A 192.168.4.148 www CNAME webserver (B)[root@localhost named]# vim test.com.zone #在CentOS 6主机上修改解析库 [root@localhost named]# service named restart #重启服务 (C)重启服务测试 （5）主从服务器案例前提：准备4台虚拟机 （A）CentOS6主机作为主DNS服务器，同上面的配置类似，这里就不再阐述。 （B）在CentOS 7两台主机上做从DNS服务器，进行如下配置： [root@localhost ~]# vim /etc/named.conf [root@localhost~]#vim /etc/named.rfc1912.zones#创建zone zone &quot;test.com&quot; IN { type slave; masters {192.168.4.132;}; file &quot;slaves/test.com.slave.zone&quot;; }; 启动bind的服务即可以同步到/var/named/slaves目录下 [root@localhost~]#systemctl restart named[root@localhost~]#ll /var/named/slaves/test.com.slave1.zone -rw-r--r--. 1 named named 382 Sep 20 19:08 /var/named/slaves/test.com.slave1.zone 如果主从服务器想指定从DNS服务器，可以在/etc/named.conf配置文件中添加选项 allow-transfer {IP;}； 在从服务器上添加“allow-transfer {none;};”在主DNS服务器上“allow-transfer {IP;};”这样就限制了。 注意：通过以上几个实验总结出需要注意的一些地方 1、在做实验过程中一定要关闭dnssec功能； 2、复制文件/var/named/named.localhost做模板时，一定要加选项“-a”或“-p”选项。复制完成后一定看所有者、所属组和权限。]]></content>
      <categories>
        <category>服务</category>
        <category>DNS</category>
        <category>DNS实战一</category>
      </categories>
      <tags>
        <tag>主从，转发，子域和父域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS实战]]></title>
    <url>%2F2017%2F11%2F28%2FDNS%E5%AE%9E%E6%88%98%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[实战二 如何实现上述的拓扑图呢？先从底部网上一步一步的搭建 （1）实现主从DNS服务器 （a）修改主DNS服务器 [root@localhost~]#vim /etc/named.conf #修改主配置文件 [root@localhost~]#vim /etc/named.rfc1912.zones #创建zone zone &quot;test.com&quot; IN { type master; file &quot;test.com.zone&quot;; }; [root@localhost ~]# vim /var/named/test.com.zone #创建解析库文件 $TTL 1D @ IN SOA dns1 test.com. ( 2 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum IN NS dns1 dns1 A 192.168.4.132 webserver IN A 192.168.4.132 www IN CNAME webserver [root@localhost~]#vim /var/named/named.ca #修改根服务器文件 [root@localhost ~]# service named restart #重启bind服务 （b）配置从DNS服务器 主配置文件和配置从服务器一样，这里就不再阐述[root@localhost~]#vim /etc/named.rfc1912.zones zone &quot;localhost&quot; IN { type master; file &quot;named.localhost&quot;; allow-update { none; }; }; [root@localhost~]#systemctl restart named#重启服务[root@localhost~]#ll /var/named/slaves/test.com.slave.zone #查看是否成功 （2）配置子域 [root@localhost~]#vim /etc/named.rfc1912.zones #创建zone zone &quot;com&quot; { type master; file &quot;com.zone&quot;; }; [root@localhost~]#vim /var/named/com.zone #创建解析库 $TTL 1D @ IN SOA dns1 rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 test NS dns2 dns1 A 192.168.4.147 dns2 A 192.168.4.132 www A 192.168.4.66 [root@localhost~]#systemctl restart named #重启bind服务 （3）根 [root@localhost~]#vim /etc/named.rfc1912.zones zone &quot;.&quot; IN { type master; file &quot;root.zone&quot;; }; 删除配置文件中/etc/named.conf如下内容 [root@localhost/var/named]#vim root.zone #创建解析库 $TTL 1D @ IN SOA dns1 rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 com NS dns2 dns1 A 192.168.4.146 dns2 A 192.168.4.147 [root@localhost/var/named]#systemctl restart named重启服务 这样我们搭建完成了。是否是很有成就感呢？哈哈。当大家看到这里的时候是不是发现我们没有对从DNS服务器做设置呢？如果主DNS挂了，那么从DNS能工作么？下面我们就来说道说道。 假设主DNS服务器down（IP 192.168.4.132 ） [root@localhost ~]# ifconfig eth0 down #将主DNS服务器down掉 [root@localhost ~]# rndc flush #清除主DNS服务器的缓存 在Client客户机测试 （IP 192.168.4.149） [root@localhost~]#dig www.test.com @192.168.4.147 如图所示，没有解析成功，说明我们的从DNS服务器没有起作用，没有实现负载均衡作用。有没有想过为什么出现这种情况呢？因为我们没有在com域中没有添加这条域，下面我们在com域中添加此从DNS服务器的dns记录测试 在com域中添加如下记录 [root@localhost/var/named]#vim com.zone [root@localhost/var/named]#rndc flush #清除缓存 在client客户机上测试 [root@localhost~]#dig www.test.com @192.168.4.148 这样说明我们从DNS服务器起到了，达到了容错功能。是不是有点小小的成就感呢？]]></content>
      <categories>
        <category>服务</category>
        <category>DNS</category>
        <category>DNS实战二</category>
      </categories>
      <tags>
        <tag>主从，转发，子域和父域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CURL、elinks工具]]></title>
    <url>%2F2017%2F11%2F28%2FCURL%E3%80%81elinks%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[CURL工具curl是居于URL语法在命令行方式下工作的文件传输工具，它支持FTP,FTPS,HTTP,HTTPS,GOPHER,TELNET,DICT,FILE及LDAP等协议。curl支持HTTPS认证，并且支持HTTP的POST、PUT等方法，FTP上传，kerberos认证，HTTP上传，代理服务器，cookies，用户名/密码认证，下载文件断电续传，上传文件断电续传，httpd代理服务器通道，还支持IPv6，socket5代理服务器，通过http代理服务器上传文件到FTP服务器等。 格式： curl [OPTIONSS] [URL...] -A/--user-agent &lt;string&gt;:设置用户代理发送给服务器 -e/-referer &lt;URL&gt;:查看此网址从那个网址转发过来 --cacert &lt;file&gt;:CA证书 -k/--insecure:允许忽略证书进行SSL连接 --compressed:要求返回时压缩的格式 --H/--header &lt;line&gt;：自定义首部信息传递给服务器，构造请求首部 -i：显示页面内容，包括报文首部信息 -I/--head：只显示响应报文首部信息 -D/--dump-header &lt;file&gt;：将url的header信息存放在指定文件中 --limit-rate &lt;rate&gt;：设置传输速度，默认为k --basic：使用HTTP基本认证 -u/--user&lt;user[:passwd]&gt;:设置服务器的用户和密码 -L：如果有3XX响应吗，重新发请求到新位置 -o &lt;file&gt;：将网络文件保存为指定的文件中 -O：使用url中默认的文件名保存文件到本地 -0/--http1.0：使用http1.0协议 -C：选项可对文件使用断电续传功能 -c/--cookie-jar &lt;filename&gt; :将url中cookie存放在指定文件中 -x/--proxy&lt;proxyhost[:port]&gt;：指定代理服务器地址 -X/--request &lt;command&gt;：向服务器发送指定请求方法 -U/--proxy-user &lt;user:password&gt;：代理服务器用户和密码 -T：将指定本地文件上传到FTP服务器上 --date/-d:指定使用POST方式传递数据 elinks命令格式：elinks [option] [url]… -dump:非交互式模式，将URL的内容输出至标准输出 -source：打印源码]]></content>
      <categories>
        <category>命令</category>
        <category>网页工具</category>
      </categories>
      <tags>
        <tag>命令使用，curl，elinks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DHCP]]></title>
    <url>%2F2017%2F11%2F28%2FDHCP%2F</url>
    <content type="text"><![CDATA[一、DHCP服务1、DHCP概念DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一个局域网的网络协议，使用UDP协议工作， 主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段，。DHCP有3个端口，其中UDP67和UDP68为正常的DHCP服务端口，分别作为DHCP Server和DHCP Client的服务端口；546号端口用于DHCPv6 Client，而不用于DHCPv4，是为DHCP failover服务，这是需要特别开启的服务，DHCP failover是用来做“双机热备”的。 ###2、DHCP过程（1）DHCP Client以广播的方式发出DHCP Discover报文。 （2）所有的DHCP Server都能够接收到DHCP Client发送的DHCP Discover报文，所有的DHCP Server都会给出响应，向DHCP Client发送一个DHCP Offer报文。DHCP Offer报文中“Your(Client) IP Address”字段就是DHCP Server能够提供给DHCP Client使用的IP地址，且DHCP Server会将自己的IP地址放在“option”字段中以便DHCP Client区分不同的DHCP Server。DHCP Server在发出此报文后会存在一个已分配IP地址的纪录。 （3）DHCP Client只能处理其中的一个DHCP Offer报文，一般的原则是DHCP Client处理最先收到的DHCP Offer报文。DHCP Client会发出一个广播的DHCP Request报文，在选项字段中会加入选中的DHCP Server的IP地址和需要的IP地址。 （4）DHCP Server收到DHCP Request报文后，判断选项字段中的IP地址是否与自己的地址相同。如果不相同，DHCP Server不做任何处理只清除相应IP地址分配记录；如果相同，DHCP Server就会向DHCP Client响应一个DHCP ACK报文，并在选项字段中增加IP地址的使用租期信息。 （5）DHCP Client接收到DHCP ACK报文后，检查DHCP Server分配的IP地址是否能够使用。如果可以使用，则DHCP Client成功获得IP地址并根据IP地址使用租期自动启动续延过程；如果DHCP Client发现分配的IP地址已经被使用，则DHCP Client向DHCPServer发出DHCP Decline报文，通知DHCP Server禁用这个IP地址，然后DHCP Client开始新的地址申请过程。 （6）DHCP Client在成功获取IP地址后，随时可以通过发送DHCP Release报文释放自己的IP地址，DHCP Server收到DHCP Release报文后，会回收相应的IP地址并重新分配。 ###3、DHCP的状态||状态|解释||DHCP discover|客户端到服务器端||DHCP offer|服务器端到客户端||DHCP request|客户端到服务端||DHCP nack|服务器端到客户端指示客户端的网络地址是不正确的||DHCP ack|服务器端到客户端||DHCP decline|客户端到服务器端，指示地址已经被使用||DHCP release|客户端到服务器端，放弃网络地址和取消剩余的租约时间||DHCP inform|客户端到服务器端，只要求本地配置参数，客户端已经具有外部配置的网络地址| ###4、如何续租呢？当客户端向服务器端取得地址以后得到租期，当租期达到某个期限时，客户端主动向服务器端发起广播请求 %50：租赁时间达到50%时来续租，刚想DHCP服务器发现新的DHCP request请求。如果dhcp服务没有拒绝的理由，则回应DHCP ack信息。当DHCP客户端收到应答信息后，就重新开始新的租用期限。 87.5%：如果之前DHCP server没有回应，等到租约期的87.5%时，主动再发送一次广播请求。 ###5、DHCP的配置文件主配置文件 /etc/dhcp/dhcpd.conf /etc/dhcp/dhcpd6.conf启动配置文件 /etc/rc.d/init.d/dhcpd /etc/rc.d/init.d/dhcpd6中继器 /usr/sbin/dhcrelay /etc/rc.d/init.d/dhcrelay ###6、/etc/dhcp/dhcpd.conf配置文档详解 # option definitions common to all supported networks... option domain-name &quot;example.org&quot;; #searchname option domain-name-servers ns1.example.org, ns2.example.org; #设置DNS服务器地址 default-lease-time 600; #设置租约时长 max-lease-time 7200; #设置客户端最长租期 # Use this to enble / disable dynamic dns updates globally. #ddns-update-style none; #设置DHCP更新 # If this DHCP server is the official DHCP server for the local # network, the authoritative directive should be uncommented. #authoritative; # Use this to send dhcp log messages to a different log file (you also # have to hack syslog.conf to complete the redirection). log-facility local7; #设置日志级别 # No service will be given on this subnet, but declaring it helps the # DHCP server to understand the network topology. subnet 10.152.187.0 netmask 255.255.255.0 { } # This is a very basic subnet declaration. subnet 10.254.239.0 netmask 255.255.255.224 { range 10.254.239.10 10.254.239.20; #设置可分配IP的范围 option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org; #设置客户端默认网关 } filename #指明引导文件名称 next-server #提供引导文件的服务器IP地址 当我们配置完时候，不知道是否出现问题这时候就需要对配置文件尽心检查 service dhcp configtest 示例： （1）安装dhcp服务[root@localhost ~]# yum install -y dhcp（2）将配置文件复制到/etc/dhcp/目录下[root@localhost ~]# cp /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example /etc/dhcp/dhcpd.conf（3）编辑配置文件[root@localhost ~]# vim /etc/dhcp/dhcpd.conf（4）重启dhcp服务[root@localhost ~]# systemctl restart dhcpd（5）在另外一个机器上测试，是否可以拿到地址。[root@localhost ~]#service restart dhcpd 注意： 1、在进行编辑注意每行完成以后要以“；”结尾。 2、在配置DHCP服务时，有时获取到地址并不能ping，很有可能dhcp服务IP变化。]]></content>
      <categories>
        <category>服务</category>
        <category>DHCP</category>
      </categories>
      <tags>
        <tag>dhcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS访问控制和智能DNS]]></title>
    <url>%2F2017%2F11%2F28%2FDNS%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E6%99%BA%E8%83%BDDNS%2F</url>
    <content type="text"><![CDATA[DNS的管理功能你是不是有这样的想法，只想让某个IP或者某个IP端的地址进行访问，实现访问控制功能。DNS服务给我们提供了很好的解决方法。 1、选项||allow-query {}；| 允许查询的主机，相当于白名单|allow-transfer {}；|允许区域传送的主机|allow-recursion{};|允许递归的主机，这个选项建议在options中使用|allow-update{}；|允许更新区域数据库中的内容 2、acl acl：是把某个IP或IP端合并为一个集合，通过一个统一的名称调用；可以把这个理解为bash函数的功能。 （1）acl内置的选项 ||none|没有一个主机||any|任意主机||localhost|本机||localnet|本机的IP同掩码运算后得到的网络地址| 注意：acl只能先定义再使用；建议一般定义再options的前面。 （2）示例 [root@localhost ~]# vim /etc/named.conf 重新启动服务然后在本机测试[root@localhost ~]# dig www.test.com @127.0.0.1 由于我们设置了acl功能，所有本机也不能访问了。实现我们的预期效果。 view大家小时候去网吧的时候有没有遇到这样一个问题，如果你玩问道在电信1玩，而你的网络是联通的网络，这样开始玩游戏的过程中，我们的屏反应会迟钝，频很高；但是网络提供一个网络转换程序，如果你切换到电信网络，问道游戏运行流畅；这相当于我们这里view的功能。实现只能DNS解析，不过不需要我们手动切换网络。 （1）一个bind服务器可以定义多个view；每个view可以定义多个zone。每个view匹配一组客户端。 （2）如果多个view对同一个zone进行解析时，使用不同的zone解析库文件。 实战如果我们在北京和广州有两台DNS服务器，北京和广州用户通过访问www.test.com的时候，我希望北京访问直接在北京DNS解析并返回，广州与它相同，如何实现嗯？ 在一台由于我电脑有两个不同的IP段，在一台机器上实现这个功能 （a）修改/etc/named.conf文件 （b)创建/etc/named.rfc1912.zones.test和/etc/named.rfc1912.zones.app分别修改 （3）创建zone文件 /var/named/app.com.zone和/var/named/app.com.zone分别修改 （4）重启dns服务[root@localhost named]# service named restart 在Clinet客户机上测试（IP 192.168.4.148和172.18.253.86）]]></content>
      <categories>
        <category>服务</category>
        <category>DNS</category>
        <category>DNS访问控制和智能DNS</category>
      </categories>
      <tags>
        <tag>acl，view，智能DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS简单介绍]]></title>
    <url>%2F2017%2F11%2F28%2FDNS%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、DNS1、DNS概念DNS（Domain Name System，域名系统）是互联网的一项服务。它将域名和IP地址相互映射的一个分布式数据库，能够使人方便地访问互联网。 2、使用的端口（1）53/TCP 53/UDP （2）不同协议的端口作用是什么呢？ 53/UDP:提供客户端查询功能 53/TCP和53/UDP:实现dns主从复制功能 3、DNS域名开头我们述说DNS是分布式数据库，想必大家猜到了DNS是层级结构的。 从图中可以看出DNS的层级结构 （1）根域（Top Level Domain，tld） （2）顶级域 （a）组织域， com，org，gov，mil等 （b）国家域，cn，ca，hk，tw等 （c）反向域，arpa （3）二级域 … 4、DNS服务器类型（1）主DNS服务器 作用：管理和维护负责解析的域内解析库的服务器 。（2）从DNS服务器 作用：从主服务器或从服务器“复制”（区域间传输）解析库副本。 这里我们需要注意一下，区域传输分为两种 （a）完全传输（axfr）：传送整个解析库； （b）增量传输（ixfr）：传递解析库变化的内容； 是不是大家想，主从DNS服务器时如何工作的呢？ 有两种工作机制“PUSH”和“PULL”。当主DNS服务器配置文件中序列号发生递增，重新DNS服务；主DNS服务器会主动向从DNS服务器同步信息；这个过程称为&apos;PUSH&apos;。如果区域传输终端，没有同步成功，从服务器会根据配置文件中的”retry“指定的时间重新尝试同步信息，这个过程称为“PULL”。 5、DNS解析DNS解析分为两种 （a）正向解析：FQDN--&gt;IP （b）反向解析: IP--&gt;FQDN 注意：正向解析是两个不同的名称空间，是两个不同的解析树，如果为子域则写DNS服务IP。 DNS查询类型： （a）递归查询 （b）迭代查询 一次完整的DNS查询请求的过程：Client–&gt;host文件–&gt;DNS server Local Cache –&gt;DNS server（recursion）–&gt;Server Cache–&gt;Iteration（迭代）–&gt;Root–&gt;TLD–&gt;二级域名–&gt;… 6、DNS资源类型区域解析库由众多的RR（resource record）组成。存在不同的类型：A,AAAA,SOA,CNAME,MX,PTR,NS。 资源记录的格式： NAME [TTL] IN RR_TYPE VALUE 下面有几点需要注意的： （a）$TTL变量，全局继承此处的缓存周期，默认单位为秒。 （b）@代替/etc/named.rfc1912.zones配置的ZONE_NAME. （c）同一个名字可以通过多条记录定义多个不同的值，此时DNS服务器会以轮询方式进行相应。 （d）同一个值可能有多个不同定义的名字；通过多个不同的名字指向同一个值进行定义。此仅表示通过多个不同的名字可以找到同一个主机。 （1）SOA：Start Of Authority，起始授权记录。value的构成： （a）当前区域的主DNS服务器的 FQDN，也可以使用/etc/named.rfc1912.zones配置的ZONE_NAME。 （b）当前区域管理员的邮箱地址，但地址中不能使用”@“，一般使用“.”替代。因为在配置文件中“@”表示特殊含义。 （c）主从服务区域传输相关定义以及否定的答案的同一TTL。 @ IN SOA @ rname.invalid. ( 0 ; serial #解析库序列号，主服务器解析库变化时，递增，最长只能为十位数组成，一般为了方便管理这样管理“当前日期+版本号” 1D ; refresh #刷新时间，从服务器从主服务器请求同步解析库的时间 1H ; retry #重试时间，从服务器从主DNS服务器请求失败时，再次尝试的时间 1W ; expire #过期时长，从服务器联系不到主服务器时，多久后停止服务 3H ) ; minimum #错误解析存活时长 注意：一个区域解析库只能有且仅有一个SOA记录，必须位于解析库的第一条记录。 （2）NS，Name Server ，名称服务value：当前区域的某DNS服务器名称 注意： （a）相邻的两个资源记录的NAME相同时，后续可省略。 （b）任何一个NS记录后面的服务器名字，都应该在后续有一个A记录。 （3）MX，Mail eXchange，邮件转换value：当前区域的某邮件服务器的主机名 注意： （1）在一个区域内可以有多个MX记录,但是每个MX记录前应该有一个数字（0-99），表示服务器的优先级，数字越小优先级越高。 （2）任何一个MX记录后应该有一个A记录。 （4）A 记录value：主机名对应的IP地址 对于A记录有以下几种定义格式: (a)可以使用FQDN (b)可以使用泛域名 *.ZONE_NAME,这种方式的好处是避免用户写错名称时给错误答案，将错误答案指向某特性的地址。 (c)如果一个网段中地址不确定可以是使用 $GGENERATE #-# NAME$ 后面对应的地址也是，网段加$ 示例：$GENERATE 100-150 host$ IN A 192.168.4.$ (5)AAAA记录(6)PTR PoinTeR IP，反向域名解析格式：IP PTR FQDN 完整格式：135.4.168.192-in.adder.arpa IN PTR dns1 如果192.168.4为网络地址，可以这样写 135 IN PTR DNS1 注意:主机地址要反着写。 （7）CNAME 别名有时候我们访问一个网站是www主机不一定是真正的主机。有可能使用了这种别名机制 示例： www IN CNAME websrv 我们在访问一个网址时，有可能为如下地址www.test.server.com对整个地址来说真正的，test为server的子域。server为com的子域。n那么父域如何对子域进行授权呢？ 子域授权：每个域的名称服务器，都是通过父域服务器在解析库进行授权。 如图所述：想必大家多DNS的名称，过程有了一定的了解，下面通过看上面这张图，可以看出子域与父域的管理。通过观察图中，一个zone可有多个RR组成。可以粗略的看出DNS的容错功能，实现负载的作用。父域通过委派子域进行管理。 如图所示：DNS是工作在内核中的，用户是没有办法直接管理DNS服务，那要如何管理DNS服务呢？前人想出了Bind进行管理DNS服务。这样用户通过用户空间借助于Bind管理工具或配置文件就可以管理DNS服务了。]]></content>
      <categories>
        <category>服务</category>
        <category>DNS</category>
        <category>DNS简单介绍</category>
      </categories>
      <tags>
        <tag>dns，bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP安装及配置文件介绍]]></title>
    <url>%2F2017%2F11%2F28%2FHTTP%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Http安装及文件介绍1、文件类型 主配置文件 /etc/httpd/conf/httpd.conf /etc/httpd/conf.d/*.conf 服务脚本文件 /etc/rc.d/init.d/httpd /etc/sysconfig/httpd #脚本配置文件 站点网页文档默认目录 /var/www/html 模块文件路径 /etc/httpd/modules /usr/lib64/httpd/modules 主程序文件 /usr/sbin/httpd /usr/sbin/httpd.worker /usr/sbin/httpd.event 主进程文件 /etc/httpd/run /httpd.pid #如果这个文件之前存在，系统重启之后会覆盖此配置文件。如果没有会自动创建之。 日志文件目录 /var/log/httpd/access_log /var/log/httpd/err_log 帮助文档包 httpd-manual #如果需要使用可以安装，访问示例http:192.168.4.135/manual 2、/etc/httpd/conf/httpd.conf文件选项介绍 httpd.conf文件的主要分类 [root@localhost ~]# grep &#39;###&#39; /etc/httpd/conf/httpd.conf ### Section 1: Global Environment #全局配置 ### Section 2: &apos;Main&apos; server configuration #主机配置 ### Section 3: Virtual Hosts #虚拟主机配置 选项介绍 （1）ServerTokens 显示服务器版本信息 syntax：ServerTokens Major|Minor|Min[imal]|Prod[uctOnly]|OS|Full ServerTokens Prod[uctOnly] #仅显示类型 Server sends (e.g.): Server: Apache ServerTokens Major #显示版本及主版本号 Server sends (e.g.): Server: Apache/2 ServerTokens Minor #显示类型主板本号及此版本号 Server sends (e.g.): Server: Apache/2.0 ServerTokens Min[imal] Server sends (e.g.): Server: Apache/2.0.41 ServerTokens OS #显示类型版本号及系统类型 Server sends (e.g.): Server: Apache/2.0.41 (Unix) ServerTokens Full (or not specified) #全部显示 #系统默认# Server sends (e.g.): Server: Apache/2.0.41 (Unix) PHP/4.2.2 MyMod/1.2 建议使用ServerTokens prod，防止此版本有漏洞被入侵。建议一般不要显示版本号。 （2）Listen 修改监听的IP和Port Syntax: Listen [IP-address:]portnumber [protocol] 省略IP 表示为0.0.0.0 Listen指令至少一个，可重复出现多次 修改监听socket，重启或重新加载服务进程方可生效 示例： Listen 80 Listen 8080 Listen 192.168.4.150:80 （3）持久连接建立连接，每个资源获取完成后不断开连接，而好似继续等待其他的请求完成，默认关闭 KeepAlive Syntax: KeepAlive On|Off #默认为关闭 MaxKeepAliveRequests Synatax:MaxKeepAliveRequests number #默认最大连接请求100 KeepAliveTimeout Syntax：KeepAliveTimeout seconds #默认持久连接超时时间为5秒 缺点：对并发量较大的服务器，持久连接功能会使其它有些请求得不到回应。 解决方法：使用较短的持久时间设置。 （4）MPM（Multi-Processing Module） 多进程处理模块 MPM的类型在前面已经详细的介绍，这里来说说在配置文件中怎么配置 prefork配置 &lt;IfModule prefork.c&gt; StartServer number #初始化开启几个进程 MinSpareServers number #最小空闲进程 MaxSpareServers number #最大空闲进程 ServerLimit number #最大开启的进程数 ，最大为20000个 MaxClients number #最大并发量 MaxRequestsPerChild number #最多处理的请求数量 默认为10000。在子进程请求之后，子进程会被父进程终止，子进程占用的内容就会释放（为0是永远释放）。 &lt;/IfModule&gt; worker配置 &lt;IfModule worker.c&gt; StartServers number #初始化开启几个进程 MaxClients number #最大并发量 MinSpareThreads number #最小空闲线程 MaxSpareThreads number #最大空闲进程 ThreadsPerChild number #一个子进程最多开启几个线程 MaxRequestsPerChild number #一个子进程最多有多个访问请求 默认10000 &lt;/IfModule&gt; 配置文件默认内容 &lt;IfModule worker.c&gt; StartServers 4 MaxClients 300 MinSpareThreads 25 MaxSpareThreads 75 ThreadsPerChild25 MaxRequestsPerChild 0 &lt;/IfModule&gt; 这里需要注意: StartServers*ThreadsPerChild&gt;MaxSpareThreads 所以系统初始时会少开一个进程。 如何更改工作模式呢？ [root@localhost ~]# vim /etc/sysconfig/httpd 如何计算PV的值呢？ 假设每秒中开启256进程，持久连接，每个进程能处理5个资源；每个网页有100个资源，如何计算PV？ pv：256586400/100=1105920 带宽10245256/1024/1024*8=8M 网络中计算是以位为单位 （5）DSO：Dynamic Shared Object 动态加载模块 httpd -M #查看动态加载模块 httpd -l #查看静态加载模块 格式： LoadModule &lt;mod_name&gt; &lt;mod_path&gt; mod_path写路径时要写相对路径：相对于ServerRoot （6）DocumentRoot 定义Main server 中文档页面路径 Syntax: DocumentRoot directory-path 文档路径映射：DocumentRoot指向的路径为URL路径的起始位置。 示例： # http://HOST:PORT/test/index.html \|/ /app/data/test/index.html （7）DirectoryIndex 定义站点页面 Syntax: DirectoryIndex local-url [local-url] … /etc/httpd/conf.d/welcome.conf如果主站点出错可以跳转至此页面 （8）站点访问控制常见机制 可基于两种机制指明对哪些资源进行何种访问控制 文件系统路径： &lt;directory &quot;/PATH&quot;&gt; ... &lt;/directory&gt; &lt;File &quot;/PATH/FILE&quot;&gt; ... &lt;/File&gt; &lt;FileMatch&gt; ... &lt;/FileMatch&gt; URL路径： &lt;Location URL-path|URL&gt; ... &lt;/Location&gt; &lt;LocationMatch regex&gt; ... &lt;/LocationMatch&gt; 其上的路径都可以使用正则表达式和通配符 通配符： 通配符 说明 * 匹配任意长度字符 ? 匹配任意单个字符 [] 匹配中括号内的任意单个字符 [^] 除中括号里的都匹配 正则表达式： 符号 说明 . 匹配任意单个字符 * 匹配前一个字符任意长度，0次或多次 ？ 匹配前一个字符一次或0次 + 匹配前一个字符一次或多次 [] 匹配括号里的任意单个字符 … 示例： &lt;FilesMatch &quot;\.(gif|jpe?g|png)$&quot;&gt; &lt;Files “?at.*”&gt; &lt;Location /status&gt; &lt;LocationMatch &quot;/(extra|special)/data&quot;&gt; 注意：使用正则表达式比较耗费资源，会遍历整个路径去寻找，建议不要使用。 （9）中“基于源地址”实现访问控制 Options Syntax: Options [+|-]option [[+|-]option] … 常见选项： 选项 说明 Indexes 指明的URL路径下不存在于定义的主页面资源相符的资源文件时，返回索引列表给用户 FollowSymlinks 允许访问符号链接文件所指向的源文件，默认支持软连接。 None 全部禁用 All 全部允许，系统默认选项 MultiViews 允许使用多视图 注意：Options只对有效。 示例： （1）在/etc/httpd/conf.d/目录下创建custom.conf文件 [root@localhost conf.d]# vim custom.conf &lt;Directory &quot;/app/testweb&quot;&gt; Options None #全部禁用 &lt;/Directory&gt; （2）把welcome.conf文件删除或修改名字 [root@localhost conf.d]# mv welcome.conf welcome.conf.bak （3）重启服务测试 现在我们再修改配置文件修改为Options Indexes &lt;Directory &quot;/app/testweb&quot;&gt; Options Indexes &lt;/Directory&gt; 重启服务测试 AllowOverride 与访问控制相关的的指令可以放在指定目录下.htaccess文件中，覆盖之前配置指令。 常见选项： 选项 说明 AuthConfig 允许使用与认证授权相关的指令 FileInfo 允许使用控制文档类型的指令 Indexes 允许使用控制目录索引的指令 Limit 允许使用控制主机访问的指令 Options[=Option,…] 允许使用控制指定目录功能的指令 None .htaccess文件失效 示例 在上面的基础上我们再/app/testweb.htaccess此文件 [root@localhost testweb]# vim .htaccess Options Indexes 在custom.conf编辑 [root@localhost conf.d]# vim custom.conf &lt;Directory &quot;/app/testweb&quot;&gt; Options None AllowOverride All &lt;/Directory&gt; 由于我们在上面测试的时候如果Options为None时候网页出现如下情况 先我们再测试 这时你会不会想到放到站点目录下会不会被访问到呢？这样显然就不安全了，开发人员已经想到了这点如下： &lt;Files ~ &quot;^\.ht&quot;&gt; Order allow,deny Deny from all Satisfy All &lt;/Files&gt; 现在我们真正了解了AllowOverride选项作用了。使用这种方法我们控制一些内容。 Order 和allow 、deny 定义生效次序；写在后面的表示默认规则，优先级高。 匹配次序 条件 结果 Match Allow,Deny result Deny,Allow result Match Allow only Request allowed Request allowed Match Deny only Request denied Request denied No match Default to second directive: Denied Default to second directive: Allowed Match both Allow &amp; Deny Final match controls: Denied Final match controls: Allowed 格式： A (partial) domain-name Example: Allow from apache.org deny from .net example.edu A full IP address Example: Allow from 10.1.2.3 deny from 192.168.1.104 192.168.1.205 A partial IP address Example: Allow from 10.1 deny from 10 172.20 192.168.2 A network/netmask pair Example: Allow from 10.1.0.0/255.255.0.0 deny from 20.1.0.0/255.255.0.0 A network/nnn CIDR specification Example: Allow from 10.1.0.0/16 deny from 20.1.0.0/16 示例 编辑custom.conf文件 &lt;Directory &quot;/app/testweb&quot;&gt; Options Indexes Order allow,deny Deny from 192.168 &lt;/Directory&gt; 重启服务测试 如果修改为Allow &lt;Directory &quot;/app/testweb&quot;&gt; Options Indexes Order allow,deny Allow from 192.168 &lt;/Directory&gt; （10）日志设定 LogLevel 设定日志级别 LogFormat 定义日志格式 示例 LogFormat “%h %l %u %t \”%r\” %&gt;s %b \”%{Referer}i\” \”%{User-Agent}i\”” combined Syntax: CustomLog file|pipe format|nickname [env=[!]environment-variable 示例 CustomLog logs/access_log combined /var/log/error_log 错误日志存放位置 /var/log/access_log 访问成功日志存放位置 选项 说明 %h 客户端IP地址 %L 远程用户，启动mod_ident才有效，通常为“-” %u 验证远程用户，非登录访问时，为一个“-” %t 服务器收到请求时的时间 %r 表示请求报文的首行，记录了此次请求的方法、URL以及协议版本 %&gt;s 响应状态码 %b 响应报文的大小，单位为字节；不包括响应报文http首部 %{Referer}i 请求报文中首部“referer”的值，即从哪个页面中的超链接跳转至当前页面 %{User-Agent}i 请求报文中首部“User-Agent”的值，即发出请求的应用程序 示例： 192.168.4.1 - - [18/Sep/2017:17:14:09 +0800] “GET / HTTP/1.1” 403 281 “-“ “Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:56.0) Gecko/20100101 Firefox/56.0” （11）AddDefaultCharset 设定默认字符集 Syntax: AddCharset charset extension [extension] … 常用类型：UTF-8 GBK GB2312 GB18030 （12）定义路径别名 Syntax: Alias URL-path file-path|directory-path Syntax: AliasMatch regex file-path|directory-path #可以使用通配符和正则表达式 示例 修改custom.conf文件 Alias /test /app/testweb &lt;Directory &quot;/app/testweb&quot;&gt; Options Indexes &lt;/Directory&gt; 重启服务测试 [root@localhost testweb]# curl -I 192.168.4.132/test HTTP/1.1 301 Moved Permanently Date: Mon, 18 Sep 2017 09:38:50 GMT Server: Apache/2.2.15 (CentOS) Location: http://192.168.4.132/test/ Connection: close Content-Type: text/html; charset=iso-8859-1 （13）基于用户的访问控制 认证质询：WWW-Authenticate Authorization：客户端用户填入账号和密码后再次发送请求报文；认证通过时，服务器发送响应的资源。 认证方式类型： basic：明文 digest：消息摘要认证，兼容性查 安全域：需要用户认证后才能访问的路径；通过名称对齐进行标识，以便于告知用户认证原因。 虚拟账户：仅用于访问某服务时用到的认证标识。创建文件的位置在/etc/httpd/conf.d/目录下。 basic认证示例（1）定义安全域 &lt;Directory “/PATH”&gt; AuthType #认证类型 AuthName #提示信息 AuthUserFile #认证文件位置 Require user UserName1 UserName2 .. #从认证文件中挑选出的用户可以访问 Requie vaild-user #允许账户文件中的所有用户登录访问 AuthGroupFile 组文件存放的位置 Require group GrpName1 GrpName1.. #允许指定组用户登录访问 &lt;/Directory&gt; （2）提供账号和密码存储的位置，一般为隐藏文件 #####htpasswd命令 htpasswd ：Manage user files for basic authentication 选项： -c：自动创建文件，仅在文件不存在创建时使用 -m：使用md5加密 -s：使用sha格式加密 -D：删除指定用户 （3）创建组账号文件 组名称：user1 user2 ... 远程客户端和用户验证的控制Satisfy： Interaction between host-level access control and user authentication 主机访问控制和用户认证之间的交互 ||All|客户机IP和用户验证都需要通过才能访问|Any|客户机IP和用户验证有一个满足就可以访问 示例一 基于用户认证控制 （1）创建存放密码的配置文件 [root@localhost conf.d]# htpasswd -c .htusers wang[root@localhost conf.d]# htpasswd -s .htusers li[root@localhost conf.d]# htpasswd -s .htusers joah （2）修改custom.conf配置文件 Alias /test /app/testweb &lt;Directory &quot;/app/testweb&quot;&gt; Options Indexes AuthType basic AuthName &quot;welcom visit...&quot; AuthUserFile &quot;/etc/httpd/conf.d/.htusers&quot; Require user wang &lt;/Directory&gt; （3）重启服务测试 输入wang账户后 示例二 基于组账户认证 在上述基础之上进行如下操作 （1）将上述用户加入组中[root@localhost conf.d]# groupmems -a wang -g webtest [root@localhost conf.d]# groupmems -a li -g webtest [root@localhost conf.d]# groupmems -a joah -g webtest （2）创建组用户文件 [root@localhost conf.d]# vim .htgrps webtest:wang li （3）修改custom.conf文件Alias /test /app/testweb &lt;Directory &quot;/app/testweb&quot;&gt; Options Indexes AuthType basic AuthName &quot;welcom visit...&quot; AuthUserFile &quot;/etc/httpd/conf.d/.htusers&quot; AuthGroupFile &quot;/etc/httpd/conf.d/.htgrps&quot; Require group webtest &lt;/Directory&gt; （4）重启服务测试 输入li账户后 （14）虚拟主机 虚拟主机有三种实现方式： 基于IP，为每个虚拟主机准备至少一个IP地址 基于Port，为每个虚拟主机使用至少一个独立的Port 基于FQDN，为每个虚拟主机使用至少一个FQDN 注意：一般虚拟主机不要与Main主机混用；如果要使用虚拟主机，一般先禁用Main主机。如果要禁用Main主机，直接禁用DocumentRoot即可。 示例一：基于IP的虚拟主机 （1）编辑配置文件custom.conf &lt;VirtualHost 192.168.4.132:80&gt; DocumentRoot &quot;/app/a.com/htdocs&quot; &lt;/VirtualHost&gt; &lt;VirtualHost 192.168.4.133:80&gt; DocumentRoot &quot;/app/b.net/htdocs&quot; &lt;/VirtualHost&gt; &lt;VirtualHost 192.168.4.134:80&gt; DocumentRoot &quot;/app/c.org/htdocs&quot; &lt;/VirtualHost&gt; （2）创建所需文件 [root@localhost conf.d]# mkdir /app/a.com/htdocs -pv [root@localhost conf.d]# mkdir /app/b.net/htdocs -pv [root@localhost conf.d]# mkdir /app/c.org/htdocs -pv [root@localhost conf.d]# echo www.a.com &gt; /app/a.com/htdocs/index.html [root@localhost conf.d]# echo www.b.net&gt; /app/b.net/htdocs/index.html [root@localhost conf.d]# echo www.c.org&gt; /app/c.org/htdocs/index.html （3）添加IP地址 [root@localhost conf.d]# ip addr add 192.168.4.133/24 dev eth0 [root@localhost conf.d]# ip addr add 192.168.4.134/24 dev eth0 （4）重启服务测试 示例二：基于Port的虚拟主机 （1）编辑custom.com文件 Listen 192.168.4.132:81 Listen 192.168.4.132:82 Listen 192.168.4.132:83 &lt;VirtualHost 192.168.4.132:80&gt; DocumentRoot &quot;/app/a.com/htdocs&quot; &lt;/VirtualHost&gt; &lt;VirtualHost 192.168.4.132:81&gt; DocumentRoot &quot;/app/b.net/htdocs&quot; &lt;/VirtualHost&gt; &lt;VirtualHost 192.168.4.132:82&gt; DocumentRoot &quot;/app/c.org/htdocs&quot; &lt;/VirtualHost&gt; （2）重启服务器测试 示例三：基于FQDN的虚拟主机 我们准备三台虚拟主机，一台CentOS 6 配置3个FQDN，一台CentOS 7配置DNS，一台CentOS 7测试 第一步：在CentOS 6 上配置3个FQDN NameVirtualHost *:80 #注意这项配置在CentOS 6 中必须开启，切记！！！ NameVirtualHost *:80 &lt;VirtualHost *:80&gt; ServerName &quot;www.a.com&quot; DocumentRoot &quot;/app/a.com&quot; &lt;/VirtualHost&gt; &lt;VirtualHost *:80&gt; ServerName &quot;www.b.com&quot; DocumentRoot &quot;/app/b.com&quot; &lt;/VirtualHost&gt; &lt;VirtualHost *:80&gt; ServerName &quot;www.c.com&quot; DocumentRoot &quot;/app/c.com&quot; &lt;/VirtualHost&gt; 第二步：在CentOS 7上配置DNS服务器 [root@localhost~]#yum install -y bind [root@localhost/etc/named]#vim /etc/named.conf #修改图中方框内容 [root@localhost/etc/named]#vim /etc/named.rfc1912.zones [root@localhost/var/named]#vim a.com.zone #b.com.zone 和c.com.zone类似这里就不累述。 1 $TTL 1D 2 @ IN SOA dns1 mail.a.com. ( 3 0 ; serial 4 1D ; refresh 5 1H ; retry 6 1W ; expire 7 3H ) ; minimum 8 NS dns1 9 dns1 A 192.168.4.164 10 www A 192.168.4.132 重启服务 第三步：在另一台CentOS 7 主机上测试 [root@localhost~]#vim /etc/resolv.conf #修改DNS 1 # Generated by NetworkManager 2 search localdomain 3 nameserver 192.168.4.164 （15）status页面 要实现这个功能需要加载模块mod_status.so 格式： LoadModule status_module modules/mod_status.so &lt;Location /server-status&gt; SetHandler server-status Order allow,deny Allow 192.168.4 &lt;/Location&gt; ExtendedStatus On #开启此选项显示更多内容 建议：不要开启此选项，如果处于测试状态可以开启拍错。 （16）mod_deflate模块 压缩页面优化传输速度 适用场景： 节约带宽，额外消耗CPU； 压缩适于压缩的资源，如文本文件 如何启用压缩功能？ SetOutputFilter DEFLATE AddOutputFilterByType DEFLATE text/plain AddOutputFilterByType DEFLATE text/html AddOutputFilterByType DEFLATE application/xhtml+xml AddOutputFilterByType DEFLATE text/xml AddOutputFilterByType DEFLATE application/xml AddOutputFilterByTypeDEFLATE application/x-javascript AddOutputFilterByType DEFLATE text/javascript AddOutputFilterByType DEFLATE text/css Level of compression 指定压缩比 （1-9），默认为9 （17）mod_ssl模块 认证模块 http基于ssl认证过程： （1）客户端发送可供选择的加密方式，并向服务器请求证书 （2）服务器端发送证书以及选定的加密方式给客户端 （3）客户端取得证书并进行证书验证如果信任给其发证书的CA 验证证书的来源的合法性：用CA的公钥解密证书上数字签名 验证证书内容的合法性：完整性验证 验证证书有效期限 检查证书是否被吊销 （4）客户端生成临时会话密钥，并使用服务器端的公钥加密此数据发送给服务器，完成密钥交换 （5）服务用此密钥加密用户请求的资源，响应客户端。 注意：SSL是基于IP地址实现，单IP的主机仅可以使用一个HTTPS虚拟主机。 实现https的过程： （1）先建立私有CA；在CentOS 7上 [root@localhost~]#cd /etc/pki/CA/ [root@localhost/etc/pki/CA]#(umask 066；openssl genrsa -out private/cakey.pem 2048） [root@localhost/etc/pki/CA]#openssl req -new -x509 -key private/cakey.pem -out casert.pem -days 4650 [root@localhost/etc/pki/CA]#echo 01 &gt; serial [root@localhost/etc/pki/CA]#touch index.txt （2）在CentOS 6上创建请求认证证书 [root@localhost ssl]# (umask 066；openssl genrsa -out httpd.key 2048） [root@localhost ssl]# openssl req -new -key httpd.key -out httpd.csr [root@localhost ssl]# scp httpd.csr 192.168.4.163:/etc/pki/CA/certs/ （3）CentOS 7对收到的证书签证并返回 [root@localhost/etc/pki/CA/certs]#openssl ca -in httpd.csr -out httpd.crt -days 300 [root@localhost/etc/pki/CA/certs]#scp httpd.crt 192.168.4.132:/etc/httpd/conf/ssl （4）在CentOS 6上安装此 模块并修改配置文件 [root@localhost conf.d]# yum install -y mod_ssl [root@localhost conf.d]# vim ssl.conf （5）将证书拷贝到本地添加至浏览器中 当我们每次输入http://192.168.4.132时想要直接https://192.168.4.132访问网页怎么做呢？ 将http请求转发至https的URL，可以使用重定向 Redirect [status] URL-path URL status分类： Permanent:Returns a permanent redirect status(301) indicating that the resource has moved permanently Temp:Returns a temporary redirect status (302). This is the default 示例： Redirect temp / https://www.a.com/ Redirect permanent / https://www.a.com/ 注意：设置跳转时，根下的目录也会自动跳转。 [root@localhost conf.d]# vim custom.conf Redirect temp / https://192.168.4.132/ 测试 [root@localhost conf.d]# curl --cacert -L 192.168.4.132/ &lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt; &lt;html&gt;&lt;head&gt; &lt;title&gt;302 Found&lt;/title&gt; #由于之前我们已经介绍了状态码，所以看到302代表临时跳转。 &lt;/head&gt;&lt;body&gt; &lt;h1&gt;Found&lt;/h1&gt; &lt;p&gt;The document has moved &lt;a href=&quot;https://192.168.4.132/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;hr&gt; &lt;address&gt;Apache/2.2.15 (CentOS) Server at 192.168.4.132 Port 80&lt;/address&gt; &lt;/body&gt;&lt;/html&gt; （18）HSTS:HTTP Strict Transport Security 如果我们使用HTTPS 访问一个网站，我们大多数情况习惯按http://这样的方式去访问，在配置文件中添加Redirect temp / https:// 或Redirect permanent / https://这种方式解决；其工作方式如下 当浏览器第一次发出HTTP请求时是明文发送的，这种容易被攻击者拦截下来，攻击者作为代理，把当前请求转发至钓鱼网站，钓鱼网站返回假冒的网页内容，攻击者把假冒的网页返回给浏览器；如下图 为了解决这个文件就有人提出了HSTS方案：服务器端配置支持HSTS后，会在给浏览器返回的HTTP首部中携带HSTS字段。浏览器获取到该信息后，会将所有HTTP访问请求在内部做307跳转到HTTPS，而无需任何网络过程；从而使得中间人攻击失效。 如何设置HSTS呢？ Strict-Transport-Security: [; includeSubDomains][; preload] max-age：过期时间，默认单位为秒，你每次访问它都会在访问时间之后的值时间。 includeSubDomains：是可选参数，如果包含它意味着当前域名或子域均开启HSTS保护 preload：是可选参数，只有当你申请将自己的加入到浏览器内置列表的时候才需要使用到它。 重定向的另外一种方式：使用模块mod_rewrite 在使用这种方式之前我们先确认mod_rewrite是否被加载 格式： 示例 Header always set Strict-Transport-Security &quot;max-age=15768000&quot; RewriteEngine on #是否开启重启引擎 RewriteRule ^(/.*)$ https://%{HTTP_HOST}$1 [redirect=301] （19）httpd自带的工具程序 ab命令：压力测试工具 usage：ab [OPTIONS] URL -n：总请求数 -c：模拟的并行数 -k：以持久连接模式测试 htpasswd：基于认证basci时，用到的账户密码文件生成工具 usage： htpasswd [ -c ] [ -m ] [ -D ] passwdfile username -c：如果passwdfile文件不存在使用 -D：删除用户 -m：使用md5加密，默认 -s：使用SHA格式加密]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>HTTP安装及配置文件介绍</category>
      </categories>
      <tags>
        <tag>httpd，配置文件，认证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP的工作机制]]></title>
    <url>%2F2017%2F11%2F28%2FHTTP%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[HTTP的工作机制当我们去访问一个网站是一个网页并不是单单的一个资源，是由多个资源展示出来；每个资源都要单独的请求。 现在我们需要区分两个概念静态文件和动态文件 静态文件：无需服务端做出额外处理，说白了就是写死的，任何人访问此资源时，都显示同一个页面内容。文件后缀：.jpg .html .txt .js .css .mp3 .avi 动态文件：服务端执行程序之后，返回执行结果。说白了就是不同的人、不同时候访问此页面，显示的内容可能不同。文件后缀：.asp .php .jsp 非持久连接和持久连接 非持久连接：一个请求与服务器连接传输完成之后，端口。如果下一个请求过来，再建立连接。 缺点 (1)客户为每个待请求的对象建立并维护一个新得连接。对于每个这个的连接，TCP必须同时在客户端和服务器端分配TCP缓冲区，并维护TCP变量。对于有可能同时为来自数百个不同客户的请求提供服务的Web服务器来说，这会严重增加服务器的负担； (2)对每个对象请求都有2个RTT(Round-Trip Time 往返时延)的响应延迟：一个RTT用于建立TCP连接，另一个RTT用于请求和接收对象；http://blog.csdn.net/jackywangjia/article/details/27643379 (3)每个对象都要经历 TCP 缓启动，因为每个TCP连接都要起始于slow start 阶段。并行TCP连接的使用能够部分减轻RTT延迟和缓启动的影响。 持久连接：当完成一次请求之后，服务器在发出响应后让TCP连接继续打开着。同一对客户/服务器之间的后续请求和响应可以通过这个连接发送。 缺点：服务器送出一个对象后开始等待下一个请求，而这个新请求却不能马上到达。这段时间服务器资源便闲置了。 如何提高HTTP连接性能呢？ 并行连接：通过多条TCP连接发起并发的HTTP请求 持久连接：keep-alive,长连接，重用TCP连接，以消除连接和关闭的时延,以事务个数和时间来决定是否关闭连接 管道化连接：通过共享TCP连接发起并发的HTTP请求 复用的连接：交替传送请求和响应报文（实验阶段） Web响应模型介绍 单进程I/O模型：启动一个进程处理用户请求，而且一次只处理一个，当发出多个请求时，被串联响应。 多进程I/O模型：并行启动多个进程，每个进程响应一个连接请求。 复用I/O请求：启动一个进程，同时响应N个连接请求。 复用多进程I/O模型：启动M个进程，每个进程响应N个请求，同时接受M*N个请求。]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>HTTP的工作机制</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BIND编译安装]]></title>
    <url>%2F2017%2F11%2F28%2FBIND%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[编译安装bind （1）下载源码包 https://www.isc.org/downloads/ （2）解压缩源码包 [root@localhost~]#mv bind-9.10.6.tar.gz /usr/src/ [root@localhost~]#cd /usr/src/ [root@localhost/usr/src]#tar xvf bind-9.10.6.tar.gz （3）来我们先看看bind包原来有没有安装脚本呢？ [root@localhost ~]# rpm -q --scripts bind 从图中我们可以看出，安装前需要自己创建用户，那么我们来创建一个用户吧 [root@localhost/usr/src/bind-9.10.6]#useradd -r -d /var/named -s /sbin/nologin -m named #这里由于是系统用户，如果不加“-m”的话，是不能创建家目录的，切记！！！ （4）我们接下来看看如何安装bind [root@localhost/usr/src/bind-9.10.6]#cat README 如果直接向定制bind程序，显然这样做是不能满足我们的需求的，我们可以使用如下操作定制我们bind程序 [root@localhost/usr/src/bind-9.10.6]#./configure --help 如上图所示，这里只是截取部分图，这里可以选择我们要安装的包位置，启用或关闭某些功能，实现定制bind，相信很多第一次编译的像我这样的人来说认真研究一种程序源码安装过程，基本可以掌握别的源码包的安装。 [root@localhost/usr/src/bind-9.10.6]#./configure --prefix=/app/bind10 --sysconfdir=/etc/bind10 来来看看，我说什么了，当出现这是不是不知道如何操作，没有人家说的很清楚了，没有gcc，那该如何解决呢？那么我们来安装一个开发包来解决这个问题 [root@localhost/usr/src/bind-9.10.6]#yum groupinstall -y &quot;development tools&quot; 那我们再来尝试一次，看看这次会出现什么幺蛾子。 [root@localhost/usr/src/bind-9.10.6]#./configure --prefix=/app/bind10 --sysconfdir=/etc/bind10 看看我说什么来着，这次又出错啦，为什么呢？它提示我们说没有openssl程序，如果想依赖这个程序，可以安装openssl-devel；一般源码包遇到的情况，都安装相对的开发包即可。 那我们再来测试一次，看看还会出现什么情况呢？ 当当当，哈哈，竟然成功啦 ；不过这只是成功了一部分，如果想继续成功那就实行下面步骤吧 （5）进行编译安装 [root@localhost/usr/src/bind-9.10.6]#make ;make install make 的作用是开始进行源代码编译，以及一些功能的提供，这些功能由他的 Makefile 设置文件提供相关的功能； make install 一般表示进行安装，相当于创建软连接，创建目录等等一些操作。 （6）这样安装的话是没有命令PATH和man帮助的，那如何实现呢？ [root@localhost~]#vim /etc/profile.d/env.sh [root@localhost~]#source !$ source /etc/profile.d/env.sh export PATH=/app/bind10/bin:/app/bind10/sbin:$PATH [root@localhost~]#vim /etc/man_db.conf （7）刚刚在（2）比步骤是不是看看还有安装后脚本呀，对的你没有看错，那么我们来进行安装后脚本需要的操作。安装后脚本需要我们使用命令rndc-confgen创建相当于”暗号“，创建了暗号才能访问，那么我们就看看如何创建暗号呢？ [root@localhost~]#rndc-confgen -r /dev/urandom &gt; /etc/bind10/rndc.conf #如果不重定向只能在终端上显示，写不到文件中 不过我们现在还没有主配置文件named.conf文件，怎么办呢？那就手动创建一个喽 [root@localhost~]#vim /etc/bind10/named.conf 不过刚刚我们了解到bind程序运行者是named用户，但是我们来看看这个文件所有者和所属组是who [root@localhost~]#ll /etc/bind10/named.conf -rw-r--r--. 1 root root 200 Sep 22 10:19 /etc/bind10/named.conf [root@localhost~]#chgrp named /etc/bind10/named.conf #修改所属组 [root@localhost/etc/bind10]#chgrp named bind10/ -R #修改文件都为named所属组 （8）不过DNS中解析当然需要根啦那么我们就创建一个喽 [root@localhost named]# scp named.ca 192.168.4.152:/var/named/ #从远程主机上拷贝一个 [root@localhost/var]#chgrp named named/ -R #修改权限 [root@localhost~]#vim /etc/bind10/named.conf [root@localhost/var/named]#vim test.com.zone #编辑测试域 [root@localhost/var/named]#chgrp named test.com.zone #修改权限 （9）那我们接下来尝试着看看能不能起来服务 [root@localhost~]#named -u named -g -f -d 3 [root@localhost~]#ss -tnul 端口53/tcp 53/udp 953/tcp 已经处于监听状态，说明启动已经成功 （10）我们尝试看看可以解析么？ 那么接下来测测我们dns的性能如何喽 对压力测试工具编译安装 [root@localhost ~]# cd /usr/src/bind-9.10.6/contrib/queryperf #切换至源码包位置 [root@localhost/usr/src/bind-9.10.6/contrib/queryperf]#./configure #进行编译 [root@localhost/usr/src/bind-9.10.6/contrib/queryperf]#make [root@localhost/usr/src/bind-9.10.6/contrib/queryperf]#cp queryperf /app/bind10/bin/ #将程序复制到bind执行程序的目录下 创建一个测试文本 [root@localhost~]#vim test 测试 [root@localhost~]#queryperf -d test -s 127.0.0.1]]></content>
      <categories>
        <category>服务</category>
        <category>DNS</category>
        <category>BIND编译安装</category>
      </categories>
      <tags>
        <tag>BIND编译安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Httpd-2.4特性]]></title>
    <url>%2F2017%2F11%2F28%2FHttpd-2.4%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[新特性 MPM支持运行为DSO机制，以模块形式按需加载 event MPM生产环境可用 异步读写机制 支持每模块及每目录的单独自制级别定义 每请求相关的专用配置 增强版的表达式分析式 毫秒级持久连接时长定义 基于FQDN的虚拟主机不需要NameVirtualHost指令 新指令，AllowOverList 支持用户自定义变量 更低的内存消耗 不再支持使用Order，Deny,Allow来做基于IP的访问控制新模块 httpd-2.4文件介绍-配置文件 /etc/httpd/conf/httpd/conf /etc/httpd/conf.d/*.conf 模块相关的配置文件 /etc/httpd/conf.modules.d/*.conf 系统启动文件 /usr/lib/systemd/system/httpd/service 主程序文件 /usr/sbin/httpdd 日志文件 /var/log/httpd/access_log /var/log/httpd/error_log 站点文档 /var/www/html 模块文件路径 /usr/lib64/httpd/moudles /etc/httpd/modules 相关设置介绍（1）切换使用MPM [root@localhost/etc/httpd/conf.modules.d]#vim 00-mpm.conf 如上图所示，如果要使用其他MPM将注释取消重启即可。 （2）认证方式 无明确授权的记录，默认拒绝 允许所有主机访问：Require all granted 拒绝所有主机访问：Require all denied 控制特定的IP访问 Require ip IPADDR :授权指定来源的IP访问 Require not ip IPADDR：拒绝特定的IP访问 控制特定的主机访问 Require host HOSTNAME :授权特定主机访问 Require not host HOSTNAME：拒绝特定主机访问 HOSTNAME: FQDN:特定主机 domain.tld：指定域名下的所有主机 使用示例 &lt;RequireAll&gt; Require all granted Require not ip 192.168.4.150 &lt;/RequireAll&gt; 不能又失败，至少有一个成功匹配。 &lt;RequireAny&gt; Require all deny Require not ip 192.168.4.150 &lt;/RequireAny&gt; 多个语句有一个成功，即成功优先。 （3）虚拟主机 注意：基于FQDN的虚拟主机也不需要NameVirtualHost指令 示例 &lt;VirtualHost *:80&gt; ServerName www.x.com DocumentRoot &quot;/app/www/x.com&quot; &lt;Document &quot;/app/www/x.com&quot;&gt; Option None AllowOverride None Require all granted &lt;/Document&gt; &lt;/VirtualHost&gt; 注意：任意目录下的页面只有显示授权才能被访问。 （4）Sendfile机制 不使用Sendfile的过程 1、系统调用read()产生一个上下文切换：从user mode 切换到Kernel mode，然后DMA(Direct Memory Access，直接内存存取)执行拷贝，把文件数据从硬盘读到一个Kernel buffer里。 2、数据从Kernel buffer拷贝到user buffer，然后系统调用read()返回，这时又产生一个上下文切换：从kernel mode 切换到user mode 3、系统调用write()产生一个上下文切换：从user mode 切换到kernel mode，然后把步骤2读到user buffer的数据拷贝到kernel buffer，不过关这次是相关联的。 4、系统调用write()返回，产生一个上下文切换：从Kernel mode 切换到User mode，然后DMA从kernel buffer拷贝数据到协议栈。 使用Sendfile机制过程 1、系统调用sendfile()通过DMA把硬盘数据拷贝到Kernel buffer，然后数据被kernel直接拷贝到另一个与socket相关的kernel buffer。这里没有user mode和kernel mode 之间的切换。在kernel中直接完成了从一个buffer到另一个buffer的拷贝。 2、DMA把数据从kernel buffer直接拷贝给协议栈，没有切换也不需要把数据从user mode拷贝到kernel mode，以为数据就在Kernel 里。 （5）方向代理功能 ProxyPass “/” &quot;http://www.example.com/&quot; ProxyPassReverse &quot;/&quot; &quot;http://www.example.com/&quot; 特定URL反向代理 ProxyPass “/image” &quot;http://www.example.com/&quot; ProxyPassReverse &quot;/image&quot; &quot;http://www.example.com&quot; 示例 &lt;VirtualHost *:80&gt; ServerName www.x.com ProxyPass / http://localhost:8080 ProxyPassReserver / http://localhost:8080 &lt;/VirtualHost&gt; 准备三台虚拟注意，CentOS 7 做web服务器，CentOS 7做代理服务器，另一台CentOS 6 做客户端 （5）APR（Apache Portalbe Run-time Libararies，Apache 可移植运行库） 主要为上层的应用程序提供一个可以跨越多操作系统平台使用的底层支持接口库。在早起的Apache版本中，应用程序本身必须能够处理各种具体操作系统平台的细节，并针对不同的平台调用不同的处理函数。]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>Httpd-2.4特性</category>
      </categories>
      <tags>
        <tag>httpd，2.4版本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP介绍]]></title>
    <url>%2F2017%2F11%2F28%2FHttpd%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[HTTP概念及相关术语1、概念HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 2、HTTP协议介绍 http/0.9 1991，原型版本，功能简陋，只有一个命令GET。GET /index.html ,服务器只能回应HTML格式字符串，不能回应别的格式 http/1.0 1996年5月,支持cache, MIME, method每个TCP连接只能发送一个请求，发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。（1）引入了POST命令和HEAD命令头信息是 ASCII 码，后面数据可为任何格式。服务器回应时会告诉客户端，数据是什么格式，即Content-Type字段的作用。这些数据类型总称为MIME 多用途互联网邮件扩展，每个值包括一级类型和二级类型，预定义的类型，也可自定义类型。 http/1.1 1997年1月（1）引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。对于同一个域名，大多数浏览器允许同时建立6个持久连接。（2）引入了管道机制（pipelining），即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率。新增方法：PUT、PATCH、OPTIONS、DELETE。 同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只能顺序处理回应，前面的回应慢，会有许多请求排队，造成”队头堵塞”（Head-of-line blocking）。为避免这种问题出现：一是减少请求数，二是同时多开持久连接。 网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等。 HTTP 协议不带有状态，每次请求都必须附上所有信息。请求的很多字段都是重复的，浪费带宽，影响速度Spdy：2009年,谷歌研发,解决 HTTP/1.1 效率不高问题。 http/2.0 2015年头信息和数据体都是二进制，称为头信息帧和数据帧。（1）复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免了“队头堵塞“,此双向的实时通信称为多工（Multiplexing）。（2）引入头信息压缩机制（header compression）,头信息使用gzip或compress压缩后再发送；客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，不发送同样字段，只发送索引号，提高速度。（3）HTTP/2 允许服务器未经请求，主动向客户端发送资源，即服务器推送（server push）。 3、MIME（Multiprocess Internet Mail Extensions）1、概念多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。 2、MIME类型 魔法分类：Apache web服务器可以扫描每个资源的内容，并将其与一个已知模式表(被称为魔法文件)进行匹配，以决定每个文件的MIME类型。这样做可能比较慢，但很方便，尤其是文件没有标准扩展名的时候 显式分类：可以对Web服务器进行配置，使其不考虑文件的扩展名或内容，强制特定文件或目录内容拥有某个MIME类型 类型协商： 有些Web服务器经过配置，可以以多种文档格式来存储资源。在这种情况下，可以配置Web服务器，使其可以通过与用户的协商来决定使用哪种格式(及相关的MIME类型)”最好” 3、MIME格式Content-Type: [type]/[subtype]; parameter type类型 类型 说明 Text 用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的； Multipart 用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据； Application 用于传输应用程序数据或者二进制数据； Message 用于包装一个E-mail消息； Image 用于传输静态图片数据； Audio 用于传输音频或者音声数据； Video 用于传输动态影像数据，可以是与音频编辑在一起的视频数据格式 subtype类型 subtype是用于指定type详细形式。 子类型 说明 text/plain 纯文本，文件扩展名.txt text/html HTML文，文件扩展名.html 或.htm application/xhtml+xml XHTML文 image/gif GIF图像 image/jpeg JPEG图像 image/png PNG图像 video/mpeg MPEG动画 application/octet-stream 任意的二进制数据 application/pdf PDF文档 application/msword Microsoft Word文件 application/vnd.wap.xhtml+xml wap1.0+ application/xhtml+xml wap2.0+ message/rfc822 RFC 822形式 multipart/alternative HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示 application/x-www-form-urlencoded 使用HTTP的POST方法提交的表单 multipart/form-data 同上，但主要用于表单提交时伴随文件上传的场合 parameter 可用来指定附加的信息，更多情况下是用于指定text/plain和text/html等的文字编码方式的charset参数。 Content-Transfer-Encoding: [mechanism] 内容传输编码，指定ASCII意外的字符编码方式，用来对附件进行解码。 编码格式 说明 7bit 用在US ASCII字符集上 8bit和binary 一般不使用 quoted printable 可读的标准文本，如果传输要经过对格式有影响的网关时对其进行保护 base64 通用方法，通常在二进制中，非文本数据 如果想查看MIME的类型可以查看文件/etc/mime.types 4、URI统一资源标识符（Uniform Resource Identifier，或URI）是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对网络中（一般指万维网）的资源通过特定的协议进行交互操作。分为两种URL（Uniform Resource Location）和URN（Uniform Resource Name）。URL用于描述某服务器某特定资源位置。URN其目的是通过提供一种途径，用于在特定的命名空间资源的标识，以补充网址并不指定地址。说白了URL就是一个人的住址，URN是一个人的名字。URN定义某事物的身份，而URL提供查找该事物的方法。 URL组成 hierarchical part ┌───────────────────┴─────────────────────┐ authority path ┌───────────────┴───────────────┐┌───┴────┐ abc://username:password@example.com:123/path/data?key=value&amp;key2=value2#fragid1 └┬┘ └───────┬───────┘ └────┬────┘ └┬┘ └─────────┬─────────┘ └──┬──┘ scheme user information host port query fragment urn:example:mammal:monotreme:echidna └┬┘ └──────────────┬───────────────┘ scheme path 解释 种类 说明 scheme 方案，访问服务器以获取资源时要使用哪种协议 user 用户，某些方案访问资源时需要用户名 password 用户对应的密码；user:password host 资源宿主机主机名或IP地址 part 资源宿主机正在监听的端口号，很多方案都有默认的端口号 path 服务器资源的本地名，有一个/将其与前面的URL组件分割 params 指定输入的参数，参数为名/值对，用“；”分隔 query 查询，传递参数给程序，用”?”分隔，多个查询使用“&amp;”分隔 frag 片段，一小片或一部分资源的名字，此组件在客户端使用，用“#”分隔 示例： http://www.test.com:8080/images/logo.jpg ftp://xiaoming:password@192.168.4.150/pub/linux.ppt rtsp://videoserver/video_demo/Real Time Streaming Protocol http://wwwtest.com/bbs/hello;gender=f/send;type=title https://list.jd.com/list.html?cat=670,671,672&amp;ev=149 _2992&amp;sort=sort_totalsales15_desc&amp;trans=1 http://apache.org/index.html#projects-list]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>Httpd</category>
      </categories>
      <tags>
        <tag>HTTP，https，web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MPM工作模式]]></title>
    <url>%2F2017%2F11%2F28%2FMPM%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[MPM（MultiProcess Modules ）工作模式 prefork 多进程I/O模型，每个进程响应一个请求，默认模型一个主进程生成N个子进程，创建套接字，每个子进程响应一个请求；而主进程不响应请求，只负责管理接受请求。系统初始化时，预先生成多个空闲进程，等待请求，多大不超过1024个（由pam.limits.so控制，可使用ulimit -n # 设置） worker 复用多进程I/O模型，多进程多线程。一个主进程生成m个子进程，每个子进程负责生产n个线程，每个线程响应一个请求，并发响应请求为m*n。 event 一个主进程生成m个子进程，每个进程直接响应n个请求；并发响应请求为m*n。event中有专门的线程来管理这些Keep-Alive类型的线程，当有真实请求时，将请求传递给服务线程，执行完毕后，又允许释放，增强了高并发场景下的处理请求能力。]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>MPM（MultiProcess Modules ）工作模式</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible模块]]></title>
    <url>%2F2017%2F11%2F28%2Fansible%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[常用模块介绍ansible中执行命令时，必须考虑其幂等性；即返回的结果不是错误的。如果一个文件存在则不再创建等等情况。 （1）command模块：在远程节点执行命令，此模块为默认模块 action 说明 chdir 执行命令切换工作目录至指定位置 creates 如果此处给定的文件或目录存在，则不执行命令 remove 如果给定的文件后目录不存在，则不执行命令；即存在才执行此命令 示例： [root@localhost~]#ansible all -m command -a &quot;pwd chdir=/etc/&quot; [root@localhost~]#ansible all -m command -a &quot;pwd chdir=/etc/ansible creates&quot; （2）shell模块：执行命令在节点上。 这个模块解决了echo等情况的问题，如果给一个用户添加密码执行如下指令会报错： [root@localhost~]#ansible all -m command -a &quot;echo test | passwd --stdin test&quot; 因此shell解决了这个问题，支持管道传输命令。 action 说明 chdir 在执行命令前切换目录 creates 如果一个文件已经存在则不执行命令 removes 如果一个给定的文件不存在则不执行命令 excutable 指定运行命令使用的shell解释器 [root@localhost~]#ansible all -m command -a &quot;useradd joah &quot; [root@localhost~]#ansible all -m shell -a &quot;echo centos |passwd --stdin joah&quot; （3）copy模块：复制文件到远程主机 action 说明 dest 指定远程绝对路径 group 设置文件的所属组 mode 设置文件的权限 owner 设置文件的所有者 src 设定本地的文件路径，可以使用相对路径也可以使用绝对路径 content 指定复制的内容 [root@localhost~]#ansible all -m copy -a &quot;src=&#39;/etc/hosts&#39; dest=/root/hosts group=joah owner=joah mode=644 &quot; [root@localhost~]#ansible all -m copy -a &quot;context=&#39;hello ansible&#39; dest=/tmp owner=joah group=joah mode=666&quot; 这种使用方法需要在template中使用 （4）fetch模块：把远程文件复制到本地，此时只能点对点复制 action 说明 dest 目标地址 src 源文件路径或文件 [root@localhost~]#ansible 192.168.4.61 -m fetch -a &quot;src=&#39;/etc/fstab&#39; dest=&#39;/root/&#39;&quot; （5）file模块：设置文件属性 action 说明 group 设置所属组 mode 设置权限 owner 设置所有者 path 要修改文件的路径 src 原文件路径 state 如果为link设置软连接；如果是hard设置硬链接；如果是absent，如果存在则删除；如果为touch，如果要创建的文件不存在则创建一个空文件； 示例： [root@localhost~]#ansible all -m file -a &quot;path=/root/test1 state=directory&quot; 创建目录 [root@localhost~]#ansible all -m file -a &quot;path=/root/test1/hidb state=touch&quot; 创建空文件 [root@localhost~]#ansible all -m file -a &quot;path=/root/host src=/root/test1/hidb state=link&quot; 创建软连接 [root@localhost~]#ansible all -m file -a &quot;path=/root/host src=/root/test1/hidb state=absent&quot; 删除软连接 （6）user模块：管理用户账户 action 说明 name 用户名 password 设置用户的密码 createhome 是否创建家目录 local 设定时区 system 是否设置为系统用户 uid 指定uid shell 设置使用的shell类型 group 设置组 groups 设置附加组 comment 添加注释信息 home 指定家目录位置 注意：如果用户的属性修改可以直接执行命令修改 示例： [root@localhost~]#ansible all -m user -a &quot;name=hello password=centos createhome=yes system=no shell=/sbin/nologin &quot; （7）group模块：管理组 action 说明 gid 设置组ID name 设置组名 state 如果present，如果用户存在则不创建，如果absent，用户删除时需存在组 system 是否创建系统用户 示例： [root@localhost~]#ansible all -m group -a &quot;name=hi gid=1005 state=present&quot; 创建组 [root@localhost~]#ansible all -m group -a &quot;name=hi state=absent&quot; 删除用户 （8）get_url：下载文件从HTTP、HTTPS、或者FTP到节点上 action 说明 checksum 是否检查 dest 目标地址 force no，如果目标路径存在且为空则下载；yes如果目标不是目录则覆盖原来的文件 url 指定url url_password 如果下载链接需要使用密码则给定 url_username 如果下载链接需要使用用户则给定 use_proxy 如果为no则不使用代理 示例： [root@localhost~]#ansible all -m get_url -a &quot;url=https://www.percona.com/downloads/percona-toolkit/3.0.4/binary/redhat/7/x86_64/percona-toolkit-3.0.4-1.el7.x86_64.rpm dest=/root&quot; （9）hostname模块：管理主机名 action 说明 name 主机名称 示例： [root@localhost~]#ansible 192.168.4.61 -m hostname -a &quot;name=node6&quot; （10）pip模块：Manages Python library dependencies.管理Python库依赖关系 action 说明 chdir 切换目录 state forcereinstall是否强制重装 （11）yum模块：管理yum包 action 说明 name 包名 state 是否安装；present、installed和latest表示安装；remove、absent和remove表示卸载 list 列出 示例： [root@localhost~]#ansible all -m yum -a &quot;name=nginx state=latest&quot; （12）service模块：管理服务 action 说明 arguments 添加参数 enabled 是否设置为开启启动 name 服务名 state started启动；stopped停止；restarted重启； runlevel 设定运行级别 示例： [root@localhost~]#ansible all -m service -a &quot;name=nginx state=started enabled=yes&quot; （13）git模块：部署软件从git导出 action 说明 repo 仓库路径 dest 目标路径 version 版本 示例： [root@localhost~]#ansible all -m git -a &quot;repo=https://github.com/mbdavid/FileDB.git dest=/root/test1&quot; （14）haproxy模块：管理代理 action 说明 backend 代理后端池 host 修改后端主机名称 state 后端主机状态 weight 设置权重 （15）cron模块：管理计划任务 action 说明 minute 设定分钟，0-59, , /2, month 设定月份， 1-12, , /2, name 计划任务名称， hour 设定小时 day 设置天 job 设定任务 disabled 是否禁用任务 state 如果为present则创建，如果为absent删除 注意：若果name没有设置并且state=present，如果一个新的任务创建，将覆盖原来的任务 示例： [root@localhost~]#ansible all -m cron -a &quot;name=test job=&#39;ntpdate 172.18.0.1 &amp;&gt; /dev/null&#39; hour=*/2&quot; （16）setup模块：收集远程主机信息]]></content>
      <categories>
        <category>监控工具</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>自动化</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible中playbook]]></title>
    <url>%2F2017%2F11%2F28%2Fansible%E4%B8%ADplaybook%2F</url>
    <content type="text"><![CDATA[Playbook1、Playbook核心元素 Hosts：运行指定任务的目标主机 remote_user：在远程主机上执行任务的用户 sudo_user：切换用户 Tasks：任务列表 格式： （1）action：module argument （2）module：arguments 注意：shell和command模块后面直接跟命令，而不是key:value的参数列表 Variables：变量 （1）facts：可直接调用的变量 可以使用ansible HOSTS -m setup查看 （2）用户自定义的变量 （a）在命令行中指定使用 -e ARGS或--extra-vars=VARS （b）在playbook中定义变量的方法 vars： - var1：values1 - var2：values2 ... （3）通过roles传递变量 （4）Host Inventory （a）用户自定义变量 向不同主机传递不同的变量： IP/HOSTNAME variable=value var1=vaule1 向组中的主机传递相同的变量可以定义成一个组,可以引用多次 [groupname:vars] variable=value （b）invertory参数 用于定义ansible远程连接目标主机时使用的参数，而非传递给playbook的变量 ansible_ssh_host ansible_ssh_port ansible_ssh_user ansible_ssh_pass ansbile_sudo_pass 变量引用方法： Template：模板文件 注意文件名必须以“j2”结尾。 格式说明： 字符串：使用单引号或双引号 数字：整数、浮点数 列表：[item1,item2..] 元组：（item1，item2...） 字典：{key1:values1,key2:value2...} 布尔型：true/false 算数运算：+ - / *% ** 逻辑运算：and or not Handers：由特定触发的任务 当某个文件参数修改时，这样我们修改了但是并不会立即生效；有没有一个办法当我们修改以后如果某个参数只修改这个文件呢？ notify和tags就是帮我们解决这个问题的。notify通知给相应的handler被触发；tags指定某个服务重启。 条件测试有时我们管理的主机会使不同版本的服务器，每类型服务的执行的命令有些不同，这时就需要条件判断执行。 when语句：在task中使用，jinja2的语法格式 - hosts: websrvs remote_user: root tasks: - name: install conf file to centos7 template: src=/root/nginx.conf.j2 dest=/etc/nginx/nginx.conf when: ansible_distribution_major_version == &quot;7&quot; - name: install conf file to centos6 template: src=/root/nginx.conf2.j2 dest=/etc/nginx/nginx.conf when: ansible_distribution_majoe_version == &quot;6&quot; 循环迭代，需要重复执行的任务 对迭代项的引用，固定变量名为“item”，要在task中使用with_items给定要迭代的元素列表 方式一： name: install some packageyum: name= state=presentwith_items： nginx memcache php-fpm 方式二： name: add some usersuser: name= group= state=presentwith_items: { name: ‘user1’,group: ‘group1’ } { name: ‘user2’,group: ‘group2’ } 在playbook调用角色方法一： - hosts: websrvs remote_user: root roles: - mysql - memcached - nginx 在playbook调用角色方法二： hosts: websrsremote_user: rootroles: { role:nginx, username: nignx } 键role用于指定角色名称，后续的k/v用于传递变量给角色]]></content>
      <categories>
        <category>监控工具</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>playbook</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dig、nslookup等工具]]></title>
    <url>%2F2017%2F11%2F28%2Fdig%E3%80%81nslookup%E7%AD%89%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[管理命令1、dig命令作用：只能用于测试DNS系统，不会查询hosts文件进行解析。 格式： dig [@server] [-b address] [-c class] [-f filename] [-k filename] [-m] [-p port#] [-q name] [-t type] [-x addr] [-y [hmac:]name:key] [-4] [-6] [name] [type] [class] [queryopt...] simple usage： dig @server name type 选项： -b：绑定源IP -4：仅使用IPv4 -t：指定RR类型，默认为A记录，atfr（反向解析） -x：反向解析 +[no]trace:跟踪解析过程 +[no]recure：递归解析 2、host命令格式： host [-aCdlnrsTwv] [-c class] [-N ndots] [-R number] [-t type] [-W wait] [-m flag] [-4] [-6] {name} [server] 选项： -t：指定RR类型 3、nslookup格式：nslookup [-option] [name | -] [server] nslookup&gt; server IP: 指明使用哪个DNS server进行查询 set q=RR_TYPE: 指明查询的资源记录类型 NAME: 要查询的名称 4、rndc命令(953/tcp)格式： rndc [-b source-address] [-c config-file] [-k key-file] [-s server] [-p port] [-V] [-y key_id] {command} reload：重载主配置文件和区域解析库文件 retranfer：手动启动区域传送，而不管序列号是否增减； notify：重新对区域传送发通知； reconfig：重载主配置文件 querylog：开启或关闭查询日志文件`/var/log/message` trace：递增debug一个级别 trace LEVEL：指定使用的级别 notrace：将调试级别设置为0 flush：清空DNS服务器的所有缓存记录]]></content>
      <categories>
        <category>命令</category>
        <category>dig、nslookup等工具</category>
      </categories>
      <tags>
        <tag>命令使用，dig，nslookup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible示例]]></title>
    <url>%2F2017%2F11%2F28%2Fansible%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[完整示例-安装httpd并配置（1）方式一： 创建目录[root@localhost/etc/ansible/roles]#mkdir -pv http/{tasks,templates,files,handlers,vars,meta,default} 创建task文件[root@localhost/etc/ansible/roles/http]#vim tasks/main.yml 1 - name: install package httpd 2 yum: name=nginx state=latest 3 - name: create webdoc 4 file: path={{ http_doc_root }} state=directory 5 - name: service httpd service 6 service: name=nginx state=started 7 - name: configure httpd conf 8 template: src=httpd.conf.j2 dest=/etc/httpd/conf.d/ 9 tags: httpconf 10 notify: reload httpd 创建handler文件[root@localhost/etc/ansible/roles/http]#vim handlers/main.yml 1 - name: relad httpd 2 service: name=httpd state=reloaded 创建vars文件[root@localhost/etc/ansible/roles/http]#vim vars/main.yml 1 http_server_port: 8080 2 http_server_name: www.test.com 3 http_doc_root: /webdate 创建template文件[root@localhost/etc/ansible/roles/http]#vim templates/httpd.conf.j2 1 listen {{ http_server_port }} 2 ServerName {{ http_server_name }} 3 DocumentRoot {{ http_doc_root }} 4 &lt;Directory {{ http_doc_root }}&gt; 5 Require all granted 6 &lt;/Directory&gt; 创建剧本[root@localhost/etc/ansible]#vim http.yml 1 - hosts: websrvs 2 remote_user: root 3 roles: 4 - http 测试[root@localhost~]#ansible-playbook /etc/ansible/http.yml 实战：基于msm的tomcat集群- 实验环境 主机名 IP 安装的包 node1 192.168.4.61 nginx、keepalived node2 192.168.4.62 nginx、keepalived node3 192.168.4.63 tomcat、tomcat-docs-webapp、tomcat-webapps、tomcat-adim-webapps、java-1.8.0-openjdk、memcached-session-manager-2.1.1.jar 、memcached-session-manager-tc7-2.1.1.jar、spymemcached-2.12.3.jar 、msm-javolution-serializer-2.1.1.jar 、javolution-5.4.3.1 node4 192.168.4.64 tomcat、tomcat-docs-webapp、tomcat-webapps、tomcat-adim-webapps、java-1.8.0-openjdk、memcached-session-manager-2.1.1.jar 、memcached-session-manager-tc7-2.1.1.jar、spymemcached-2.12.3.jar 、msm-javolution-serializer-2.1.1.jar 、javolution-5.4.3.1 node5 192.168.4.65 ansible、memcached 基于ssh密钥认证[root@node5~]#vim ssh.sh 1 #!/bin/bash 2 [ ! -f /root/.ssh/id_rsa.pub ] &amp;&amp; ssh-keygen -t rsa -P &apos;&apos; &amp;&gt; /dev/null 3 while read line;do 4 expect &lt;&lt; EOF 5 spawn ssh-copy-id -i /root/.ssh/id_rsa.pub root@$line 6 expect { 7 &quot;yes/no&quot; { send &quot;yes\n&quot;;exp_continue } 8 &quot;password&quot; { send &quot;magedu\n&quot; } 9 } 10 expect eof 11 EOF 12 13 done &lt; /root/ip.txt [root@node5~]#vim ip.txt 1 192.168.4.61 2 192.168.4.62 3 192.168.4.63 4 192.168.4.64 5 192.168.4.65 [root@node5~]#chmod +x ssh.sh ansible中修改主机库文件[root@node5~]#vim /etc/ansible/hosts 25 [nginx-keep] 26 192.168.4.61 27 192.168.4.62 28 [tomcat-cluster] 29 192.168.4.63 30 192.168.4.64 31 [memcached] 32 192.168.4.65 同步时间[root@node5/etc/ansible]#vim ntp.yml 1 - hosts: all 2 remote_user: root 3 tasks: 4 - name: sync time 5 command: ntpdate 172.18.0.1 6 - name: chrony conf 7 file: src=/etc/chrony.conf dest=/etc/chrony.conf 8 tags: chrony 9 notify: restart chronyd.service 10 - name: start chrony 11 service: name=chronyd state=started 12 handlers: 13 - name: restart chronyd.service 14 service: name=chronyd state=restarted [root@node5~]#vim /etc/chrony.conf 7 server 172.18.0.1 iburst [root@node5/etc/ansible]#ansible-playbook --syntax-check ntp.yml #检测语法是否正确 注意：由于yaml格式对于初学者来说有一定的坑，需要严格按照格式写。[root@node5/etc/ansible]#ansible-playbook ntp.yml #语法检测没有问题后，执行剧本 温馨提示：为了以后不必要的错误，建议没此执行完以后，都要确认是否执行正确后再进行下一步基于主机名解析[root@node5/etc/ansible]#ansible all -m copy -a &quot;src=/etc/hosts dest=/etc/hosts&quot; 挂载光盘[root@node5~]#ansible all -m mount -a &quot;name=/media/cdrom src=/dev/sr0 state=mounted fstype=iso9660&quot; 配置nginx角色 创建所需要的目录 [root@node5/etc/ansible/roles]#mkdir haproxy/{tasks,handler,files,templates,vars,default,meta} -pv 创建任务文件 [root@node5/etc/ansible/roles/haproxy]#vim tasks/main.yml 1 - name: install haproxy package 2 yum: name=haproxy state=latest 3 - name: modify haproxy conf 4 template: src=haproxy.cfg.j2 dest=/etc/haproxy/haproxy.cfg 5 tags: haproxy 6 notify: haproxy restart 7 - name: start haproxy service 8 service: name=haproxy state=started 9 handlers: 10 - name: haproxy restart 11 service: name=haproxy state=restarted 创建模板文件 [root@node5/etc/ansible/roles/haproxy]#cp /etc/haproxy/haproxy.cfg templates/haproxy.cfg.j2 42 defaults 43 mode http 44 log global 45 option httplog 46 option dontlognull 47 option http-server-close 48 option forwardfor except 127.0.0.0/8 43 mode http 44 log global 45 option httplog 46 option dontlognull 47 option http-server-close 48 option forwardfor except 127.0.0.0/8 49 option redispatch 50 retries 3 51 timeout http-request 10s 52 timeout queue 1m 53 timeout connect 10s 54 timeout client 1m 55 timeout server 1m 56 timeout http-keep-alive 10s 57 timeout check 10s 58 maxconn 3000 59 60 frontend tomcat #定义前段并指定名称 61 bind 172.18.4.60:{{ tomcat_server_port }} #绑定地址和端口 62 63 backend tomcat-cluster #定义后端服务 64 balance roundrobin 65 server node3 192.168.4.63 check 66 server node4 192.168.4.64 check 67 listen #定义管理界面 68 bind 127.0.0.1:9000 69 stats enable 70 stats uri /stats 71 stats auth joah:centos 72 stats relam &quot;tomcat&quot; 73 stats hide-version 74 stats refresh 10s 75 stats admin if TRUE 注意：模板文件必须以“j2”结尾。 创建变量文件 [root@node5/etc/ansible/roles/haproxy]#vim vars/main.yml 1 tomcat_server_port: 80 创建触发文件 [root@node5/etc/ansible/roles/haproxy]#vim handlers/main.yml 1 - name: haproxy restart 2 service: name=haproxy state=restarted 注意：创建tasks、templates、vars文件时必须以main.yml文件为入口，如果定义别的文件使用include指定即可。 添加IP[root@node5/etc/ansible/roles/haproxy]#ansible tomcat-cluster -m shell -a &quot;ip addr add 192.168.4.60/24 dev eth0 &quot; 创建keepalived角色 创建所需目录 [root@node5/etc/ansible/roles]#mkdir keepalived/{tasks,handler,files,templates,vars,default,meta} -pv 创建任务文件 [root@node5/etc/ansible/roles/keepalived]#vim tasks/main.yml 1 - name: install keepalived package 2 yum: name=keepalived state=latest 3 - name: modify keepalived conf 4 template: src=keepalived.conf.j2 dest=/etc/keepalived/keepalived.conf 5 when: ansible_hostname == &quot;node1&quot; 6 notify: keepalived reloaded 7 tags: keepalived 8 - name: modify keepalived conf 9 template: src=keepalived.conf.j2 dest=/etc/keepalived/keepalived.conf 10 when: ansible_hostname == &quot;node2&quot; 11 notify: keepalived reloaded 12 tags: keepalived 13 - name: start keepalived 14 service: name=keepalived state=started 创建触发文件 [root@node5/etc/ansible/roles/keepalived]#vim handlers/main.yml 1 - name: keepalived reloaded 2 service: name=keepalived state=reloaded 创建模板文件 [root@node5/etc/ansible/roles/keepalived]#vim templates/keepalived.conf.j2 #创建master 1 ! Configuration File for keepalived 2 3 global_defs { 4 notification_email { 5 locahost@qq.com 6 } 7 notification_email_from haproxy@qq.com 8 smtp_server 127.0.0.1 9 smtp_connect_timeout 30 10 router_id node3 11 route_mcast_group4 224.0.100.4 12 vrrp_strict chk_haproxy { 13 script &quot;killall -0 haporxy&quot; 14 interval 3 15 weight -15 16 } 17 } 18 19 vrrp_instance VI_1 { 20 state MASTER 21 interface eth0 22 virtual_router_id 4 23 priority 100 24 advert_int 1 25 authentication { 26 auth_type PASS 27 auth_pass 152369 28 } 29 virtual_ipaddress { 172.18.4.60/16 32 } 33 track_script { 34 chk_haproxy 35 } 36 } [root@node5/etc/ansible/roles/keepalived]#cp templates/keepalived.conf.j2 templates/keepalived.conf2.j2 创建backup 1 ! Configuration File for keepalived 2 3 global_defs { 4 notification_email { 5 locahost@qq.com 6 } 7 notification_email_from haproxy@qq.com 8 smtp_server 127.0.0.1 9 smtp_connect_timeout 30 10 router_id node2 11 route_mcast_group4 224.0.100.4 12 vrrp_strict chk_haproxy { 13 script &quot;killall -0 haporxy&quot; 14 interval 3 15 weight -15 16 } 17 } 18 19 vrrp_instance VI_1 { 20 state BACKUP 21 interface eth0 22 virtual_router_id 4 23 priority 90 24 advert_int 1 25 authentication { 26 auth_type PASS 27 auth_pass 152369 28 } 29 virtual_ipaddress { 172.18.4.60/16 32 } 33 track_script { 34 chk_haproxy 35 } 36 } 注意： （1）master和backup中priority、state需要修改，其他的配置不需要修改。 （2）如果使用auth_type认证，需要双方auth_pass必须相同 （3）如果你想使用脚本检测，vrrp_script可以指定脚本位置/PATH/TO/SCRIPT.sh 创建tomcat角色 创建所需要的目录 [root@node5/etc/ansible/roles]#mkdir tomcat/{tasks,handlers,files,templates,vars,default,meta} -pv 创建tomcat任务 [root@node5/etc/ansible/roles/tomcat]#vim tasks/main.yml 1 - name: install tomcat package 2 yum: name={{ item }} state=latest 3 with_items: 4 - java-1.8.0-openjdk 5 - tomcat 6 - tomcat-docs-webapp 7 - tomcat-admin-webapps 8 - tomcat-webapps 9 - memcached 10 - name: modify tomcat conf 11 template: src=server.xml.j2 dest=/etc/tomcat/server.xml 12 notify: tomcat reload 13 tags: tomcat 14 - name: kryo jar 15 copy: src=/root/{{ item }}.jar dest=/usr/share/tomcat/lib/ 16 with_items: 17 - asm-6.0 18 - kryo-4.0.1 19 - kryo-serializers-0.42 20 - memcached-session-manager-2.1.1 21 - memcached-session-manager-tc7-2.1.1 22 - minlog-1.3.0 23 - msm-kryo-serializer-2.1.1 24 - objenesis-2.6 25 - reflectasm-1.11.3 26 - spymemcached-2.12.3 27 - name: start tomcat 28 service: name=tomcat state=started 29 - name: mkdir directory 30 file: path=/usr/share/tomcat/webapps/test state=directory 31 - name: touch file 32 file: path=/usr/share/tomcat/webapps/test/{{ item }} state=touch 33 with_items: 34 - WEB-INF 35 - classes 36 - lib 37 - name: copy index.jsp 38 copy: src=index.jsp.j2 dest=/usr/share/tomcat/webapps/index.jsp 39 when: ansible_hostname == &quot;node3&quot; 40 notify: tomcat reload 41 tags: tomcat 42 - name: copy index.jsp 43 copy: src=index2.jsp.j2 dest=/usr/share/tomcat/webapps/index.jsp 44 when: ansible_hostname == &quot;node4&quot; 45 notify: tomcat reload 46 tags: tomcat 创建模板文件 [root@node5/etc/ansible/roles/tomcat/templates]#vim server.xml.j2 126 &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; 127 unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt; 128 &lt;Context path=&quot;&quot; docBase=&quot;test&quot; reloadable=&quot;&quot; /&gt; 129 &lt;Context&gt; 130 &lt;Manager className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot; 131 memcachedNodes=&quot;n1:192.168.4.63:11211,n2:192.168.4.64:11211&quot; #指定位置 132 failoverNodes=&quot;n1&quot; 133 requestUriIgnorePattern=&quot;.*\.(ico|png|gif|jpg|css|js)$&quot; 134 transcoderFactoryClass=&quot;de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory&quot; 135 /&gt; 136 &lt;/Context&gt; [root@node5/etc/ansible/roles/tomcat/templates]#vim index.jsp.j2 1 &lt;%@ page language=&quot;java&quot; %&gt; 2 &lt;html&gt; 3 &lt;head&gt;&lt;title&gt;TomcatA&lt;/title&gt;&lt;/head&gt; 4 &lt;body&gt; 5 &lt;h1&gt;&lt;font color=&quot;red&quot;&gt;TomcatA.test.com&lt;/font&gt;&lt;/h1&gt; 6 &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt; 7 &lt;tr&gt; 8 &lt;td&gt;Session ID&lt;/td&gt; 9 &lt;% session.setAttribute(&quot;test.com&quot;,&quot;test.com&quot;); %&gt; 10 &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt; 11 &lt;/tr&gt; 12 &lt;tr&gt; 13 &lt;td&gt;Created on&lt;/td&gt; 14 &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt; 15 &lt;/tr&gt; 16 &lt;/table&gt; 17 &lt;/body&gt; 18 &lt;/html&gt; [root@node5/etc/ansible/roles/tomcat/templates]#vim index2.jsp.j2 1 &lt;%@ page language=&quot;java&quot; %&gt; 2 &lt;html&gt; 3 &lt;head&gt;&lt;title&gt;TomcatB&lt;/title&gt;&lt;/head&gt; 4 &lt;body&gt; 5 &lt;h1&gt;&lt;font color=&quot;blue&quot;&gt;TomcatB.test.com&lt;/font&gt;&lt;/h1&gt; 6 &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt; 7 &lt;tr&gt; 8 &lt;td&gt;Session ID&lt;/td&gt; 9 &lt;% session.setAttribute(&quot;test.com&quot;,&quot;test.com&quot;); %&gt; 10 &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt; 11 &lt;/tr&gt; 12 &lt;tr&gt; 13 &lt;td&gt;Created on&lt;/td&gt; 14 &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt; 15 &lt;/tr&gt; 16 &lt;/table&gt; 17 &lt;/body&gt; 18 &lt;/html&gt; 编辑触发文件 [root@node5/etc/ansible/roles/tomcat]#vim handlers/main.yml 1 - name: tomcat reload 2 service: name=tomcat state=reloaded 编辑剧本 [root@node5/etc/ansible]#vim tomcat.yml 1 - hosts: nginx-keep 2 remote_user: root 3 roles: 4 - keepalived 5 - haproxy 6 - hosts: tomcat-cluster 7 remote_user: root 8 roles: 9 - tomcat]]></content>
      <categories>
        <category>监控工具</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>自动化</tag>
        <tag>示例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译安装httpd-2.4]]></title>
    <url>%2F2017%2F11%2F28%2F%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85httpd-2.4%2F</url>
    <content type="text"><![CDATA[编译安装httpd-2.4（1）准备安装前环境 [root@localhost ~]# yum groupinstall -y &quot;development tools&quot; （2）编译安装apr [root@localhost src]# tar xf apr-1.6.2.tar.gz[root@localhost apr-1.6.2]# ./configure --prefix=/app/apr[root@localhost apr-1.6.2]# make &amp;&amp; make install （3）编译安装apr-util [root@localhost src]# tar xf apr-util-1.6.0.tar.gz[root@localhost apr-util-1.6.0]# ./configure --prefix=/app/apr-util --with-apr=/app/apr[root@localhost apr-util-1.6.0]# yum install -y expat-devel #编译依赖与这个包（Expat是一个用C语言开发的、用来解析XML文档的开发库）[root@localhost apr-util-1.6.0]# make &amp;&amp; make install （4）编译安装httpd-2.4[root@localhost src]# useradd -r -m -d /app/website -s /sbin/nologin apache [root@localhost src]# tar xf httpd-2.4.27.tar.bz2 [root@localhost httpd-2.4.27]# yum install -y pcre-devel openssl-devel [root@localhost httpd-2.4.27]# ./configure --prefix=/app/httpd24 --enable-so --enable-ssl --enable-cgi --enable-rewrite --with-zlib --with-pcre --with-apr=/app/apr/ --with-apr-util=/app/apr-util/ --enable-modules=most --enable-mpms-shared=all --with-mpm=prefork [root@localhost bin]# make &amp;&amp; make install 修改PATH路径 [root@localhost bin]# vim /etc/profile.d/http24.sh export PATH=/app/httpd24/bin:$PATH [root@localhost bin]# source /etc/profile.d/http24.sh #使其生效[root@localhost bin]# echo $PATH /app/httpd24/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin 修改配置文件 [root@localhost conf]# vim httpd.conf 配置启动脚本 方法一： [root@localhost conf]# scp 192.168.4.132:/etc/init.d/httpd /etc/init.d/httpd24 #如果其他主机上有可以拷贝一份 [root@localhost httpd-2.4.27]# vim /etc/init.d/httpd24 apachectl=/app/httpd24/apachectl httpd=${HTTPD-/app/httpd24/httpd} prog=httpd pidfile=${PIDFILE-/app/httpd24/logs/httpd.pid} lockfile=${LOCKFILE-/var/lock/subsys/httpd} RETVAL=0 STOP_TIMEOUT=${STOP_TIMEOUT-10} [root@localhost conf]# chkconfig --add httpd24 #将此服务加到服务中心[root@localhost conf]# chkconfig httpd24 on设为开机启动 方法二：由于CentOS 6中支持rc.local脚本所有我们可以把命令写到脚本中，设为开机启动 [root@localhost conf]# vim /etc/rc.d/rc.local /app/httpd24/apachectl start [root@localhost conf]# chmod +x /etc/rc.d/rc.local 测试 [root@localhost website]# echo index.html &gt; index.html [root@localhost website]# apachectl start 安装方式二 （1）准备安装前环境 [root@localhost ~]# yum groupinstall -y &quot;development tools&quot; （2）解压apr包 [root@localhost src]# tar xf apr-1.6.2.tar.gz （3）解压apr-util包 [root@localhost src]# tar xf apr-util-1.6.0.tar.gz （4）编译安装httpd-2.4[root@localhost src]# useradd -r -m -d /app/website -s /sbin/nologin apache [root@localhost src]# tar xf httpd-2.4.27.tar.bz2 [root@localhost httpd-2.4.27]# yum install -y pcre-devel openssl-devel 将解压包移动到srclib目录下[root@localhost src]# mv apr-1.6.2 httpd-2.4.27/srclib/apr [root@localhost src]# mv apr-util-1.6.0 httpd-2.4.27/srclib/apr-util [root@localhost httpd-2.4.27]# ./configure --prefix=/app/httpd24 --enable-so --enable-ssl --enable-cgi --enable-rewrite --with-zlib --with-pcre --with-included-apr --enable-modules=most --enable-mpms-shared=all --with-mpm=prefork [root@localhost httpd-2.4.27]# make &amp;&amp; make install 修改配置文件 [root@localhost conf]# vim httpd.conf 配置启动脚本 方法一： [root@localhost conf]# scp 192.168.4.132:/etc/init.d/httpd /etc/init.d/httpd24 #如果其他主机上有可以拷贝一份 [root@localhost httpd-2.4.27]# vim /etc/init.d/httpd24 apachectl=/app/httpd24/apachectl httpd=${HTTPD-/app/httpd24/httpd} prog=httpd pidfile=${PIDFILE-/app/httpd24/logs/httpd.pid} lockfile=${LOCKFILE-/var/lock/subsys/httpd} RETVAL=0 STOP_TIMEOUT=${STOP_TIMEOUT-10} [root@localhost conf]# chkconfig --add httpd24 #将此服务加到服务中心[root@localhost conf]# chkconfig httpd24 on设为开机启动 方法二：由于CentOS 6中支持rc.local脚本所有我们可以把命令写到脚本中，设为开机启动 [root@localhost conf]# vim /etc/rc.d/rc.local /app/httpd24/apachectl start [root@localhost conf]# chmod +x /etc/rc.d/rc.local 方法三：将/app/httpd24/bin/apachectl文件拷贝至/etc/init.d/httpd [root@localhost httpd24]# cp /app/httpd24/bin/apachectl /etc/init.d/httpd24 测试 [root@localhost website]# echo index.html &gt; index.html [root@localhost website]# apachectl start]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>编译安装httpd-2.4</category>
      </categories>
      <tags>
        <tag>源码编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站访问量计算方式]]></title>
    <url>%2F2017%2F11%2F28%2F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E9%87%8F%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[网站访问量计算方式 IP(独立IP)：即Internet Protocol,指独立IP数。一天内来自相同客户机IP地址只计算一次，记录远程客户机IP地址的计算机访问网站的次数，是衡量网站流量的重要指标。 PV(访问量)： 即Page View, 页面浏览量或点击量，用户每次刷新即被计算一次，PV反映的是浏览某网站的页面数，PV与来访者的数量成正比，PV并不是页面的来访者数量，而是网站被访问的页面数量。 UV(独立访客)：即Unique Visitor,访问网站的一台电脑为一个访客。一天内相同的客户端只被计算一次。可以理解成访问某网站的电脑的数量。网站判断来访电脑的身份是通过来访电脑的cookies实现的。如果更换了IP后但不清除cookies，再访问相同网站，该网站的统计中UV数是不变的 http://www.alexa.cn/rank/可以查看全球网站的统计量 示例： 小明在家用ADSL拨号上网，早上8点访问了www.baidu.com下的2个页面，下午2点又拨号访问了www.baidu.com3个页面。那么，对于www.baidu.com来讲，今天的PV、UV、VV、IP各项指标该如何计算呢 ？ IP 2 PV 5 UV 1]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>网站访问量计算</category>
      </categories>
      <tags>
        <tag>访问量计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP四次挥手]]></title>
    <url>%2F2017%2F11%2F28%2FTCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[TCP四次挥手的过程 第一步 Client和Server相互传送完包以后，Client主动向Server发送关闭连接的信息：FIN=1，seq=u；此时进入FIN_WAIT状态 第二步 Server接收到Client请求之后，假如他们过程中还有一些包传输没有完成，这就Server向Client发送：ACK=1，seq=y（自己的序列号），ack=u+1（确认Client发送过程的请求号），此时进入CLOSE_WAIT。 第三步 当数据包全部传送完成之后，Server主动向Client发送回应：FIN=1，ACK=1，seq=w（此时完成传送的序列号），ack=u+1（这是这个确认好还是确认那序列号），此时进入LASET_ACK状态 第四步 Client接受到Server指令，并向Server发送：ACK=1，seq=u+1，ack=w+1，此时进入`TIME_WAIT状态，而不是直接关闭，原因是如果网络不通畅，重新发送包，相当于防止zombie状态。 Client调用close()主动关闭连接，TCP发送一个FIN 1,seq=u Server接收到FIN 1,seq=u之后，执行被动关闭，对这个seq=u进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；这是并不能立即关闭连接，如果有数据传送ACK=1，seq=y,ack=u+1，但没有发送FIN信号。 一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。ServerTCP也发送一个FIN 1，ACK=1，seq=w,ack=u+1 Client接收到这个FIN它进行确认,并向Server发送ACK=1，seq=u+1，ack=w+1。此时进入TIME_WAIT 1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？ 因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 2．为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？ 因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态但是网络并不能保证通畅，无法确保发送的ACK报文会Server能接受到；因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。]]></content>
      <categories>
        <category>服务</category>
        <category>TCP</category>
        <category>四次挥手</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP三次握手]]></title>
    <url>%2F2017%2F11%2F28%2FTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%2F</url>
    <content type="text"><![CDATA[一、Socket1、概念 socket是“孔”和“插座”之意。在linux中显然是插座的意思，相当于我们家中插头和插座之意，它们连接才能通电。在Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。实现进程间通信，允许位于不同主机（或同一主机）上不同进程之间进行通信和数据交换。Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。 2、Socket的类型（1）Socket DomainAF_INET：Address Family IPv4 AF_INET6：Address Family IPv6 AF_UNIX：同一台主机不同进程之间通信使用。 （2）Socket TypeSOCK_STREAM：流套接字，TCP套接字；可靠传输，面向对象传输。 SOCK_DGRAM：数据报，UDP套接字；不可靠传输，无直接连接。 SOCK_RAW：裸套接字，无须TCP或UDP，应用程序直接通过IP 包通信。 （3）Socket Protocol指定实际使用的传输协议。常见IPPROTO_TCP、IPPROTO_UDP等。 3、Socket函数 socket（） 为通讯创建一个端点，为套接字返回一个文件描述符。 注意：当调用socket（）创建一个socket时，只赋予其所使用的协议，没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind（），否则就当调用connect（）、listen（）时系统会自动随机分配一个端口。 bind() 为一个套接字分配地址。对应的Socket protocol把一个IPv4 或IPv6地址和端口组合赋给socket。 通常服务器在启动时会绑定IP地址和端口，用于提供服务；而客户端就不用指定，系统自动分配一个端口和自身的IP 地址。这就是为什么通常服务器端在listen之前要bind（），而客户端不会调用，而是在connect（）时由系统自动生成一个。 listen（） 当socket和一个地址（IP和端口）绑定之后，listen（）函数就开始监听可能的链接请求。socket（）函数创建的socket默认是一个主动类型，listen函数将socket变为被动类型，等待客户的连接请求。一旦连接被接受，返回0表示成功，-1表示错误。 accept（） 当应用程序监听来自其他主机的面对数据流的连接时，通过时间通知它。必须用accept（）函数初始化连接，TCP服务器监听到这个请求之后，就会调用accept（）函数接受请求。这样就连接就建立好了。之后就可以进行I/O操作了。 accept默认会阻塞进程，直到有一个客户连接建立后返回，返回一个新可用的套接字，这个套接字是连接套接字。 监听套接字：在调用函数listen函数之后，是服务器开始调用socket（）生成的；存在于服务器整个生命周期。 连接套接字：一个套接字会从主动连接变为一个监听套接字；accept函数返回值是已经连接socket描述符，它代表着一个网络已经存在的点点连接；利用I/O可以实现不同进程间的通信。 connect() 系统调用为一个套接字设置连接，参数有文件描述符和主机地址。 某些类型的套接字是无连接的，如DUP协议，连接时默认发送和接受数据的主机由给定的地址确定，可以使用send（）和recv（）。 read()、write() 服务器与客户已经建立连接。就可以使用不同进程之间的通信了。 close（） 在服务器与客户建立连接之后，会进行一些读写操作，完成之后就要关闭响应的socket描述子。 注意：close只是在相应的socket描述字的引用计数-1，只有当计数为0时，才会触发TCP客户端向服务器发送终止请求。 4、Socket工作 二、TCP三次握手和TCP四次挥手我们先来举一个示例想必大家就懂了它的工作流程了。 小明：您好，请问您是小红么？ 小红：是的，您是谁？ 小明：我是小明。 小红：有什么事情呢？ 然后他们就开始友好的聊天了 。这个过程和我们TCP三次握手一样，TCP三次握手也是分为三步，然后建立连接实现通信。 第一步 Client主动向和Server发送请求；发送SYN=1，seq=x(Synchronize Sequence Numbers)，此时Client由状态CLOSED进入SYS_SENT状态。 第二步 Server接受到Client请求时，此时状态由LISTEN进入SYN_RECV状态。并向Client发送自己的SYN=1，ACK=1，seq=y，并确定Client同步序列号seq+1并返回，即ack=x+1。 第三步 Client接受到Server请求时,并向Server发送ACK=1，seq=x+1代表要进行通信的序列号，发送希望Server下次通信的数据包的ack=y+1。这里需要注意只有Server接受到ack=y+1时才代表通讯成功。此时就可以愉快的通信了；此时状态进入ESTABLISHED。 TCP和Socket怎么结合工作呢？如下表。 Server Server服务器端调用socket()，生成socket 调用bind()绑定，为socket分配一个地址（IP和端口） 调用listen()进行监听；默认socket为主动连接状态，变为被动监听状态 调用accept()阻塞，等待客户端连接。 Clinet Client调用socket()生成socket 调用connect()阻塞，等待服务端的回应 接下来就是TCP三次握手的过程： 第一步 Client主动向和Server发送请求；发送SYN=1，seq=x(Synchronize Sequence Numbers)，此时Client由状态CLOSED进入SYS_SENT状态。 第二步 Server接受到Client请求时，此时状态由LISTEN进入SYN_RECV状态。并向Client发送自己的SYN=1，ACK=1，seq=y，并确定Client同步序列号seq+1并返回，即ack=x+1。 第三步 Client接受到Server请求时,并向Server发送ACK=1，seq=x+1代表要进行通信的序列号，发送希望Server下次通信的数据包的ack=y+1。这里需要注意只有Server接受到ack=y+1时才代表通讯成功。此时就可以愉快的通信了；此时状态进入ESTABLISHED。 那么Client想和Server分手怎么办呢？ 假如小明和小红在一起久了，觉得双方在一起不合适，这是就会发生如下事情 小明：我发现我们在这么久了，不太适合，我们分手吧！ 假如这时候小明和小红有一些经济的往来，借了一些钱 小红：为什么呢？我还没有还你那些钱呢，等我换一阵子我们了清了就分手！！！ 过了一段时间小红把小明的钱还了之后，并和小明说 小红：我们分手吧 小明：这时小明收到小红的分手信，好的，那就分手吧，从此一段姻缘就这样结束了。]]></content>
      <categories>
        <category>服务</category>
        <category>TCP</category>
        <category>三次握手</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB工作过程]]></title>
    <url>%2F2017%2F11%2F28%2FWEB%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Web服务请求处理过程 此图为经过的OSI模型 （1）Client需要和Server通信，这时需要发出建立连接请求 （2）Client与Server进行传输数据包时，需要经应用层–&gt;传输层–&gt;网络层–&gt;链路层:层层打包然后传输至Server，Server对此包进行 链路层–&gt;网络层–&gt;传输层–&gt;应用层：层层解封装。http协议工作在应用层，TCP/IP协议工作在网络层，这时就要经过三次握手进行连接（具体想看上述过程） （3）Server接受Client发过的请求 （4）Server接受请求之后需要对处理请求，对请求报文进行解析，获取Client请求的资源及请求资源使用的方法等相关信息；Server根据解析到的结果进行处理 （5）Server这时获取报文中需要请求的资源Web服务器，即存放了Web资源的服务器，此服务器存Client请求的静态文静或运行后生成的资源（6）存放Web资源的服务器识别了请求的资源，执行Client要求的动作并将返回响应报文。响应报文中包括：响应状态码、响应头部、如果生成了响应主体并返回响应主体。 （7）构建完报文之后需要就此报文发送给Client，但是这时Server需要面对一个严重的问题：Server到Client有很多连接，有些是空闲的，有些是正向Server发送数据，还有一些在向客户端回送响应数据。在连接中存在非长连接（服务器应该在发送了整条报文之后关闭自己这条连接）和长连接（在传输完成之后可能还扔保持打开状态）。这时Server就需要精确计算除Content-Length首部，目的是为了知道传送什么时候才能结束。（8）当传输完成之后，理应是把这个通道关闭，这时就要出发TCP四次挥手过程（详细过程请查看上述过程），这种情况是对非长连接说的。如果是长连接，此通道会保持此状态。直到KeepAliveTimeout时间到之后触发TCP四次挥手，结束连接。 （9）如果你有一个好习惯的话，做完一件事情之后要对这件事请求有一个总结，不能做完之后什么都得不到把。Server跟这个性质一样。当完成传输之后在日志文件中记录这条信息。方便以后出现什么情况好解决。]]></content>
      <categories>
        <category>服务</category>
        <category>Apache</category>
        <category>WEB工作过程</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
</search>
